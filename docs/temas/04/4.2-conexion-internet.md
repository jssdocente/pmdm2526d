# **4.2 Conexi贸n a internet**

??? info "Corrutinas en Android"

    Las corutinas en Android son una forma de escribir c贸digo as铆ncrono de forma m谩s sencilla y concisa. Las corutinas te permiten ejecutar tareas en segundo plano de forma eficiente y reactiva, sin bloquear el hilo principal de la aplicaci贸n. Las corutinas en Android se basan en el concepto de suspensi贸n, que te permite pausar la ejecuci贸n de una tarea hasta que se complete una operaci贸n as铆ncrona, como una petici贸n HTTP o una consulta a la base de datos.

    Las corutinas en Android se utilizan principalmente para realizar operaciones as铆ncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Las corutinas te permiten escribir c贸digo as铆ncrono de forma m谩s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas en Android se basan en el concepto de suspensi贸n, que te permite pausar la ejecuci贸n de una tarea hasta que se complete una operaci贸n as铆ncrona.

    Para implementar una clase que se ejecute en segundo plano debe crearse una suspend function, que es una funci贸n que puede pausar su ejecuci贸n. Para ello, se utiliza la palabra clave `suspend` antes de la declaraci贸n de la funci贸n.

    Por ejemplo, el siguiente c贸digo muestra un objeto que comienza un conteo en segundo plano y lo actualiza cada segundo:

    ```kotlin
    object Timer {
        suspend fun start(callback: (Int) -> Unit) {
            var count = 0
            while (true) {
                delay(1000)
                count++
                callback(count)
            }
        }
    }
    ```

    En este ejemplo, la funci贸n `start` es una suspend function que inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.

    La funci贸n `delay` se utiliza para pausar la ejecuci贸n de la tarea durante un segundo.

    Para llamar a una suspend function desde una funci贸n principal, se utiliza la funci贸n `runBlocking`, que crea un bloque de c贸digo que ejecuta la tarea de forma s铆ncrona. Por ejemplo, el siguiente c贸digo muestra c贸mo llamar a la funci贸n `start` desde una funci贸n principal:

    ```kotlin
    fun main() {
        runBlocking {
            Timer.start { count ->
                println("Count: $count")
            }
        }
    }
    ```

    En este ejemplo, la funci贸n `main` llama a la funci贸n `start` de forma s铆ncrona utilizando `runBlocking`. La funci贸n `start` inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.

    Las corutinas en Android te permiten escribir c贸digo as铆ncrono de forma m谩s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas se basan en el concepto de suspensi贸n, que te permite pausar la ejecuci贸n de una tarea hasta que se complete una operaci贸n as铆ncrona.

    ![Corroutine Scope](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-coroutines-android-studio/img/a3c314fb082a9626_960.png?hl=es-419)

    > **La palabra clave suspend**<br>
    > La palabra clave suspend en kotlin se utiliza para marcar una funci贸n que puede pausar su ejecuci贸n y reanudarla m谩s tarde. Las funciones suspendidas se utilizan en las corutinas para realizar operaciones as铆ncronas de forma reactiva y eficiente.

    ### LaunchedEffect para ejecutar tareas en segundo plano en Jetpack Compose

    LaunchedEffect es una funci贸n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu铆a de composici贸n.

    Por ejemplo, el siguiente c贸digo muestra un composable que muestra un contador que se actualiza cada segundo:

    ```kotlin
    @Composable
    fun Timer() {
        var count by remember { mutableStateOf(0) }

        LaunchedEffect(Unit) {
            while (true) {
                delay(1000)
                count++
            }
        }

        Text(text = "Count: $count")
    }
    ```

    En este ejemplo, el composable `Timer` muestra un contador que se actualiza cada segundo. La funci贸n `LaunchedEffect` se utiliza para iniciar un bucle infinito que actualiza el contador cada segundo. La funci贸n `delay` se utiliza para pausar la ejecuci贸n del bucle durante un segundo.

    ### Alcance de las corutinas en Jetpack Compose

    En Jetpack Compose, las corutinas se ejecutan en el alcance de un composable, lo que significa que una corutina se cancela autom谩ticamente cuando el composable se elimina de la jerarqu铆a de composici贸n. Esto garantiza que las corutinas se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento.

    Por ejemplo, el siguiente c贸digo muestra un composable que inicia una corutina cuando se coloca en la jerarqu铆a de composici贸n y la cancela cuando se elimina:

    ```kotlin
    @Composable
    fun Timer() {
        var count by remember { mutableStateOf(0) }

        LaunchedEffect(Unit) {
            while (true) {
                delay(1000)
                count++
            }
        }

        DisposableEffect(Unit) {
            onDispose {
                // Cancela la corutina cuando el composable se elimina
                coroutineContext.cancel()
            }
        }

        Text(text = "Count: $count")
    }
    ```

    En este ejemplo, el composable `Timer` inicia una corutina cuando se coloca en la jerarqu铆a de composici贸n utilizando `LaunchedEffect` y la cancela cuando se elimina utilizando `DisposableEffect`. La funci贸n `onDispose` se utiliza para realizar tareas de limpieza cuando el composable se elimina, como cancelar la corutina.

    ### CoroutineScope en Jetpack Compose

    En Jetpack Compose, puedes utilizar `coroutineScope` para crear un alcance de corutina que se cancela autom谩ticamente cuando el composable se elimina de la jerarqu铆a de composici贸n. `coroutineScope` es una funci贸n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom谩ticamente cuando el composable se elimina.

    Por ejemplo, el siguiente c贸digo muestra un composable que inicia una corutina utilizando `coroutineScope` y la cancela cuando se elimina:

    ```kotlin
    @Composable
    fun Timer() {
        var count by remember { mutableStateOf(0) }

        coroutineScope {
            launch {
                while (true) {
                    delay(1000)
                    count++
                }
            }
        }

        Text(text = "Count: $count")
    }
    ```

    En este ejemplo, el composable `Timer` inicia una corutina utilizando `coroutineScope` y la cancela autom谩ticamente cuando el composable se elimina. La funci贸n `launch` se utiliza para iniciar una corutina en el alcance de `coroutineScope` que actualiza el contador cada segundo.

    `coroutineScope` es una funci贸n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom谩ticamente cuando el composable se elimina. `coroutineScope` es 煤til para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.

    ### CoroutineScope en un LaunchedEffect

    En Jetpack Compose, puedes utilizar `coroutineScope` en un `LaunchedEffect` para crear un alcance de corutina local que se cancela autom谩ticamente cuando el composable se elimina de la jerarqu铆a de composici贸n. `coroutineScope` es una funci贸n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom谩ticamente cuando el composable se elimina.

    Por ejemplo, el siguiente c贸digo muestra un composable que inicia una corutina utilizando `coroutineScope` en un `LaunchedEffect` y la cancela cuando se elimina:

    ```kotlin
    @Composable
    fun Timer() {
        var count by remember { mutableStateOf(0) }

        LaunchedEffect(Unit) {
            coroutineScope {
                launch {
                    while (true) {
                        delay(1000)
                        count++
                    }
                }
            }
        }

        Text(text = "Count: $count")
    }
    ```

    En este ejemplo, el composable `Timer` inicia una corutina utilizando `coroutineScope` en un `LaunchedEffect` y la cancela autom谩ticamente cuando el composable se elimina. La funci贸n `launch` se utiliza para iniciar una corutina en el alcance de `coroutineScope` que actualiza el contador cada segundo.

    `coroutineScope` es una funci贸n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom谩ticamente cuando el composable se elimina. `coroutineScope` es 煤til para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.

    Un ejemplo de uso podemos encontrarlo en el siguiente Codelab en el que se implemmenta una carrera ficticia entre dos jugadores:

    [Codelab: Carrera de coches ficticia](https://developer.android.com/codelabs/basic-android-kotlin-compose-coroutines-android-studio?hl=es-419&continue=https%3A%2F%2Fdeveloper.android.com%2Fcourses%2Fpathways%2Fandroid-basics-compose-unit-5-pathway-1%3Fhl%3Des-419%23codelab-https%3A%2F%2Fdeveloper.android.com%2Fcodelabs%2Fbasic-android-kotlin-compose-coroutines-android-studio)

    > 癸 **CoroutineContext**<br>
    > El contexto de la corrutina es un objeto que proporciona informaci贸n sobre la corutina, como su alcance, su trabajo y su estado. El contexto de la corutina se utiliza para gestionar la ejecuci贸n de la corutina y proporcionar informaci贸n sobre su estado y progreso.

    > **LaunchedEffect**<br>
    > LaunchedEffect es una funci贸n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu铆a de composici贸n. LaunchedEffect es 煤til para realizar operaciones as铆ncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S.<br><br>
    > Una de las principales ventajas del uso de LaunchedEffect es que se ejecuta en el alcance de un composable, lo que significa que se cancela autom谩ticamente cuando el composable se elimina de la jerarqu铆a de composici贸n. Esto garantiza que las tareas en segundo plano se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento. Esto hace que no sea necesario preocuparse por la cancelaci贸n manual de las tareas en segundo plano, ya que Jetpack Compose se encarga de ello de forma autom谩tica. Tampoco debemos preocuparnos de proporcionar un componente Dispatcher de forma expl铆cita, ya que LaunchedEffect utiliza el Dispatcher predeterminado de la corrutina para ejecutar la tarea en segundo plano.


## Formas de conectarse a internet desde una app

Para conectarse a internet en una aplicaci贸n Android con Jetpack Compose, puedes utilizar las siguientes opciones (existen m谩s opciones, pero estas son las m谩s comunes):

- **Retrofit**: Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi贸n a servicios web RESTful. Puedes utilizar Retrofit para realizar peticiones HTTP a un servidor y obtener los datos necesarios para tu aplicaci贸n.
    
- **Ktor**: Ktor es un framework de cliente y servidor web en Kotlin que te permite crear aplicaciones web
    
- **Volley**: Volley es una biblioteca de red que facilita la conexi贸n a servicios web en Android. Puedes utilizar Volley para realizar peticiones HTTP y gestionar las respuestas de forma sencilla.
    

Vamos a centrarnos en la primera opci贸n, Retrofit, que es una de las bibliotecas m谩s utilizadas para conectarse a servicios web en Android.

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/76551dbe9fc943aa_960.png?hl=es-419" width="50%" alt="DataLayer">

## **驴Qu茅 es Retrofit?**

Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi贸n a servicios web RESTful. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio, como las peticiones GET, POST, PUT y DELETE. Retrofit se encarga de convertir las respuestas del servidor en objetos Java/Kotlin y de gestionar la comunicaci贸n con el servidor de forma eficiente.

**Tipos de peticiones habituales HTTP**

- **GET**: Se utiliza para obtener datos del servidor. Por ejemplo, puedes utilizar una petici贸n GET para obtener una lista de usuarios de un servidor.
- **POST**: Se utiliza para enviar datos al servidor. Por ejemplo, puedes utilizar una petici贸n POST para enviar un formulario con los datos de un nuevo usuario al servidor.
- **PUT**: Se utiliza para actualizar datos en el servidor. Por ejemplo, puedes utilizar una petici贸n PUT para actualizar los datos de un usuario existente en el servidor.
- **DELETE**: Se utiliza para eliminar datos del servidor. Por ejemplo, puedes utilizar una petici贸n DELETE para eliminar un usuario del servidor.

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/301162f0dca12fcf_960.png" width="50%" alt="Ejemplo de Petici贸n http">
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/7ced9b4ca9c65af3_960.png" width="50%" alt="Ejemplo de respuesta http">


## **Implementaci贸n de Retrofit en Jetpack Compose**

Para implementar Retrofit en una aplicaci贸n Android con Jetpack Compose, puedes seguir los siguientes pasos:

1. **Definir la interfaz de servicio web**: Define una interfaz que contenga las operaciones disponibles en el servicio web y an贸tala con las anotaciones de Retrofit, como `@GET`, `@POST`, `@PUT` y `@DELETE`. Por ejemplo, puedes definir una interfaz `ApiService` que contenga m茅todos para obtener y enviar datos al servidor.
    
2. **Crear una instancia de Retrofit**: Crea una instancia de Retrofit utilizando el constructor de `Retrofit.Builder` y configura la URL base del servicio web y el convertidor de JSON. Por ejemplo, puedes crear una instancia de Retrofit que se conecte a un servidor en `https://api.example.com` y utilice el convertidor de JSON de Gson.
    
3. **Crear una instancia del servicio web**: Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit. Por ejemplo, puedes crear una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit.
    
4. **Realizar peticiones HTTP**: Utiliza la instancia del servicio web para realizar peticiones HTTP al servidor y obtener los datos necesarios para tu aplicaci贸n. Por ejemplo, puedes utilizar el m茅todo `getUsers()` de la interfaz `ApiService` para obtener una lista de usuarios del servidor.

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-compose-getting-data-internet/img/26043df178401c6a_960.png" width="50%" alt="Funcionamiento Retrofit">    

## **Ejemplo sencillo de implementaci贸n**

A continuaci贸n, se muestra un ejemplo de implementaci贸n de Retrofit en una aplicaci贸n Android con Jetpack Compose:

```kotlin
// Define la interfaz de servicio web con las operaciones disponibles
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}

// Crea una instancia de Retrofit con la URL base y el convertidor de JSON
val retrofit = Retrofit.Builder()
    .baseUrl("https://api.example.com")
    .addConverterFactory(GsonConverterFactory.create())
    .build()

// Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit
val apiService = retrofit.create(ApiService::class.java)

// Realiza una petici贸n HTTP al servidor para obtener una lista de usuarios
val users = apiService.getUsers()
```

En este ejemplo, se define una interfaz `ApiService` con el m茅todo `getUsers()` que realiza una petici贸n GET al servidor para obtener una lista de usuarios. Se crea una instancia de Retrofit con la URL base `https://api.example.com` y el convertidor de JSON de Gson. A continuaci贸n, se crea una instancia del servicio web a partir de la interfaz `ApiService` y la instancia de Retrofit. Por 煤ltimo, se utiliza la instancia del servicio web para realizar una petici贸n HTTP al servidor y obtener una lista de usuarios.

Con Retrofit, puedes conectarte a servicios web RESTful de forma sencilla y eficiente en una aplicaci贸n Android con Jetpack Compose. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio y gestionar la comunicaci贸n con el servidor de forma autom谩tica.

Todo este c贸digo suele ordenarse y distribuirse en diferentes archivos y paquetes para mantener una estructura limpia y organizada. A continuaci贸n veremos cada uno de estos pasos en detalle.

## Implementaci贸n de Retrofit en Android[](https://resuacode.es/pmdm-ds/docs/Android/conexion-internet#implementaci%C3%B3n-de-retrofit-en-android "Enlace directo al Implementaci贸n de Retrofit en Android")

### Permiso de Internet

Para conectarse a internet en una aplicaci贸n Android, debes a帽adir el permiso de internet al archivo `AndroidManifest.xml` de la aplicaci贸n. Puedes hacerlo a帽adiendo la siguiente l铆nea al archivo `AndroidManifest.xml`:

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

Este permiso permite que la aplicaci贸n se conecte a internet y realice peticiones HTTP al servidor. Sin este permiso, la aplicaci贸n no podr谩 conectarse a internet y no podr谩 realizar peticiones HTTP al servidor.

### Importar las dependencias de Retrofit

Para utilizar Retrofit en una aplicaci贸n Android, primero debes importar las dependencias de Retrofit en el archivo `build.gradle` del m贸dulo de la aplicaci贸n. Puedes hacerlo a帽adiendo las siguientes l铆neas al archivo `build.gradle`:

```gradle
dependencies {
    // Retrofit
    implementation("com.squareup.retrofit2:retrofit:2.9.0")
    // Retrofit with Scalar Converter
    implementation("com.squareup.retrofit2:converter-scalars:2.9.0")
}
```

Estas l铆neas importan las dependencias de Retrofit y el convertidor de escalares en la aplicaci贸n. El convertidor de escalares se utiliza para convertir las respuestas del servidor en cadenas de texto.

### Definir la interfaz de servicio web

A continuaci贸n, debes definir una interfaz de servicio web que contenga las operaciones disponibles en el servicio. Puedes hacerlo creando una interfaz en un archivo Kotlin y anot谩ndola con las anotaciones de Retrofit, como `@GET`, `@POST`, `@PUT` y `@DELETE`. Por ejemplo, puedes definir una interfaz `ApiService` que contenga m茅todos para obtener y enviar datos al servidor:

```kotlin
import retrofit2.http.GET

interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}
```

En este ejemplo, la interfaz ApiService contiene un m茅todo getUsers() que realiza una petici贸n GET al servidor para obtener una lista de usuarios.

> **Ubicaci贸n de la interfaz de servicio web**.<br>
> La interfaz de servicio web suele ubicarse en un paquete de datos, network o servicios del proyecto para mantener una estructura limpia y organizada.<br>
> ★ **Anotaciones de Retrofit.**<br>
> Las anotaciones de Retrofit se utilizan para describir las operaciones disponibles en el servicio web. Por ejemplo, la anotaci贸n @GET se utiliza para realizar una petici贸n GET al servidor, la anotaci贸n @POST se utiliza para realizar una petici贸n POST al servidor, y as铆 sucesivamente
