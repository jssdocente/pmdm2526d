# 4.0 Persistencia de Datos en Android

En Android, "persistencia" significa guardar datos para que no se pierdan cuando el usuario cierra la aplicaci√≥n o reinicia el tel√©fono.

Elegir la herramienta correcta es vital para el rendimiento de la app. No es lo mismo guardar un simple "Modo Oscuro: Activado" que guardar una lista de 5,000 pel√≠culas con su sinopsis.

### üìä Gu√≠a R√°pida de Elecci√≥n

| Herramienta | Tipo de Datos | Caso de Uso Ideal |
| :--- | :--- | :--- |
| **Jetpack DataStore** | Clave-Valor (Simples) | Preferencias de usuario, flags, tokens de sesi√≥n. |
| **Room** | Estructurados (Relacionales) | Listas de objetos, datos complejos, cach√© offline. |
| **Ficheros** | Datos binarios/grandes | Fotos, PDFs, audio, logs largos. |
| **SharedPreferences** | Clave-Valor (Legacy) | **Obsoleto**. Usar solo en proyectos antiguos. |

---

## 1. üöÄ Jetpack DataStore (El Est√°ndar Moderno)

**DataStore** es la soluci√≥n moderna para guardar pares clave-valor (como `settings: true`). Est√° construido desde cero usando **Corrutinas** y **Flow**, lo que garantiza que las operaciones de disco nunca bloqueen el Hilo Principal (UI Thread).

### ¬øPor qu√© sustituye a SharedPreferences?

*   ‚úÖ **As√≠ncrono**: Todo funciona con `suspend` y `Flow`.
*   ‚úÖ **Seguro**: Maneja los errores de I/O por ti.
*   ‚úÖ **Transaccional**: Las operaciones son at√≥micas (todo o nada).

### Implementaci√≥n (Preferences DataStore)

#### A. Dependencias y Creaci√≥n

A√±ade la librer√≠a en `build.gradle.kts` e instancia el DataStore. Lo ideal es tener **una sola instancia** para toda la app (Singleton o Extensi√≥n global).

```kotlin
// En tu fichero de dependencias (libs.versions.toml) o build.gradle
// implementation("androidx.datastore:datastore-preferences:1.0.0")

// En un fichero Kotlin (ej: DataStoreModule.kt)
val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")
```

#### B. Guardar datos (Escritura)
Usamos `edit` dentro de una corrutina.
```kotlin
suspend fun guardarToken(context: Context, token: String) {
    val TOKEN_KEY = stringPreferencesKey("auth_token")
    
    context.dataStore.edit { preferences ->
        preferences[TOKEN_KEY] = token
    }
}
```

#### C. Leer datos (Lectura)

DataStore expone los datos como un `Flow`. Esto significa que si el dato cambia, **la UI se actualiza autom√°ticamente**.
```kotlin
val TOKEN_KEY = stringPreferencesKey("auth_token")

val tokenFlow: Flow<String?> = context.dataStore.data
    .map { preferences ->
        preferences[TOKEN_KEY] // Devuelve null si no existe
    }
```

---

## 2. üèõÔ∏è Room (Base de Datos Robusta)

**Room** es una librer√≠a que nos facilita enormemente el uso de bases de datos SQLite en Android.
En lugar de escribir SQL crudo y manejar cursores manualmente (propenso a errores), Room nos permite usar **Objetos Kotlin**.

Room verifica tus consultas SQL en **tiempo de compilaci√≥n**. Si escribes mal el nombre de una tabla, la app no compilar√° (¬°lo cual es genial!).

Consta de 3 componentes principales:

### A. La Entidad (`@Entity`)
Representa una **tabla** en la base de datos.
```kotlin
@Entity(tableName = "usuarios")
data class Usuario(
    @PrimaryKey(autoGenerate = true) val id: Int = 0,
    @ColumnInfo(name = "nombre_completo") val nombre: String,
    val edad: Int
)
```

### B. El DAO (Data Access Object) (`@Dao`)
Define **c√≥mo** accedemos a los datos. Es una interfaz donde declaramos nuestros m√©todos. Room genera el c√≥digo por nosotros.
```kotlin
@Dao
interface UsuarioDao {
    // Lectura reactiva: Si la tabla cambia, emite una nueva lista autom√°ticamente
    @Query("SELECT * FROM usuarios ORDER BY nombre ASC")
    fun getAllUsuarios(): Flow<List<Usuario>>

    // Operaci√≥n as√≠ncrona simple
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(usuario: Usuario)

    @Delete
    suspend fun delete(usuario: Usuario)
}
```

### C. La Base de Datos (`@Database`)

El punto de entrada principal. Debe ser abstracta y extender `RoomDatabase`.
```kotlin
@Database(entities = [Usuario::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun usuarioDao(): UsuarioDao
}
```

---

## 3. üóÑÔ∏è SharedPreferences (Legacy)

Era la forma antigua de guardar datos simples. Aunque sigue funcionando, **Google recomienda migrar a DataStore**.

*   **Problema principal**: Su m√©todo `apply()` es as√≠ncrono pero no seguro, y `commit()` es s√≠ncrono y puede bloquear la UI. Adem√°s, al iniciar la app, carga TODO el fichero en memoria de golpe, lo que puede causar lag.

```kotlin
// Ejemplo r√°pido (OBSOLETO - Solo referencia)
val sharedPref = activity?.getPreferences(Context.MODE_PRIVATE) ?: return
with (sharedPref.edit()) {
    putInt("puntuacion_alta", 500)
    apply()
}
```

---

## 4. üìÅ Ficheros (Almacenamiento Crudo)

A veces necesitas guardar un PDF, una imagen editada o un audio. Para esto usamos el sistema de ficheros de Android.

*   **Almacenamiento Interno (`filesDir`)**: Privado de tu app. Nadie m√°s puede verlo. Si el usuario desinstala la app, se borra.
*   **Almacenamiento Externo / Cach√©**: Para datos temporales o p√∫blicos.

```kotlin
// Escribir un fichero en almacenamiento interno
fun guardarTexto(context: Context, nombreFichero: String, contenido: String) {
    context.openFileOutput(nombreFichero, Context.MODE_PRIVATE).use {
        it.write(contenido.toByteArray())
    }
}

// Leer un fichero
fun leerTexto(context: Context, nombreFichero: String): String {
    return context.openFileInput(nombreFichero).bufferedReader().useLines { lines ->
        lines.fold("") { some, text -> "$some\n$text" }
    }
}
```

---

### Resumen: ¬øCu√°l uso?

1.  ¬øEs un ajuste? (ej: "Sonido on/off") -> **DataStore**.
2.  ¬øSon mis datos principales? (ej: "Notas", "Tareas") -> **Room**.
3.  ¬øEs una foto o archivo descargado? -> **Ficheros**.
