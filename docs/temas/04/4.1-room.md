# 4.1 Room: Base de Datos SQL en Android

**Room** es una de las librer铆as m谩s importantes de Android Jetpack. Act煤a como una capa de abstracci贸n sobre SQLite, permiti茅ndote usar toda la potencia de una base de datos relacional pero con una sintaxis fluida en Kotlin y verificaci贸n de errores en tiempo de compilaci贸n.

---

??? video "VIDEO: Bases de datos con Room | Persistencia de datos en Android con Kotlin y Jetpack Compose"
    <iframe width="560" height="315" src="https://www.youtube.com/embed/FK06jz_dg3E?list=PLgqNF1r2jtYwfw2AsRY-xDi1ZfNaE8vg6" title="Bases de datos con Room | Persistencia de datos en Android con Kotlin y Jetpack Compose" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## **驴Qu茅 es Room?**

Room es una biblioteca de persistencia de datos que forma parte de Jetpack, el conjunto de bibliotecas y herramientas recomendadas por Google para el desarrollo de aplicaciones Android. Room proporciona una capa de abstracci贸n sobre SQLite, la base de datos relacional integrada en Android, y facilita el acceso a la base de datos y la gesti贸n de los datos de la aplicaci贸n.

Room se compone de tres componentes principales:

- **Database**: Representa la base de datos de la aplicaci贸n y contiene la l贸gica para crear y acceder a las tablas de la base de datos.
    
- **Entity**: Representa una tabla de la base de datos y contiene la definici贸n de las columnas y los tipos de datos de la tabla.
    
- **DAO (Data Access Object)**: Define las operaciones de acceso a la base de datos, como la inserci贸n, actualizaci贸n y eliminaci贸n de datos.
    

![Room](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/a3288e8f37250031_960.png)


## Implementaci贸n de Room en Jetpack Compose

### 1\. Agregar las dependencias de Room[

Para utilizar Room en una aplicaci贸n Android con Jetpack Compose, primero debemos agregar las dependencias necesarias en el archivo `build.gradle.kts` del proyecto y del m贸dulo de la aplicaci贸n:

> build.gradle.kts (Project)
```kotlin
plugins {
    // Add this line
    id("com.google.devtools.ksp") version "2.0.21-1.0.27" apply false
}
```

> build.gradle.kts (Module)
```kotlin
plugins {
    // Add this line
    id("com.google.devtools.ksp")
}

dependencies {
    //Room (add the following dependencies)
    implementation(libs.androidx.room.runtime)
    implementation(libs.androidx.room.ktx)
    ksp(libs.androidx.room.compiler)
}
```

KSP es una API simple y potente para analizar las anotaciones de Kotlin.

Hay que tener en cuenta que la versi贸n utilizada de KSP debe ser compatible con la versi贸n de Kotlin que se est茅 utilizando en el proyecto, la compatibilidad entre las diferentes versiones puede consultarse en la documentaci贸n.

La versi贸n utilizada en el ejemplo es compatible con la versi贸n 2.0.21 de Kotlin.

### 2. Definir la entidad

La clase `Entity` representa una tabla de la base de datos y contiene la definici贸n de las columnas y los tipos de datos de la tabla. Para definir una entidad en Room, debemos crear una clase que anote con `@Entity` y que contenga las propiedades correspondientes a las columnas de la tabla. Por ejemplo, la siguiente clase `User` representa una entidad de usuario con las columnas `id`, `name` y `email`:

```
@Entity(tableName = "users")data class User(    @PrimaryKey val id: Int,    val name: String,    val email: String)
```

En este ejemplo, la clase `User` representa una tabla de la base de datos con las columnas `id`, `name` y `email`. La propiedad `id` se anota con `@PrimaryKey` para indicar que es la clave primaria de la tabla.

![Representaci贸n de Entity en formato de tabla](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/8c9f1659ee82ca43_960.png)

!!! info "Anotaciones de Room"

    Room proporciona varias anotaciones que se pueden utilizar para personalizar la definici贸n de la entidad, como `@Entity`, `@PrimaryKey`, `@ColumnInfo`, `@Ignore`, `@ForeignKey`, entre otras.

    Las anotaciones tienen los siguientes significados:

    - `@Entity`: Indica que la clase es una entidad de la base de datos.
    - `@PrimaryKey`: Indica que la propiedad es la clave primaria de la tabla.
    - `@ColumnInfo`: Permite personalizar el nombre de la columna en la tabla.
    - `@Ignore`: Indica que la propiedad no se debe incluir en la tabla.
    - `@ForeignKey`: Permite definir una clave for谩nea en la tabla.

Ejemplo de ForeignKey

```kotlin
@Entity(tableName = "users")
data class User(
    @PrimaryKey val id: Int,
    val name: String,
    val email: String,
    @ForeignKey(entity = Company::class, parentColumns = ["id"], childColumns = ["company_id"])
    val companyId: Int
)
```

En este ejemplo, la propiedad `companyId` se anota con `@ForeignKey` para indicar que es una clave for谩nea que hace referencia a la tabla `Company` y a la columna `id`.

> **Ubicaci贸n del archivo Entity**<br>
> Es recomendable tener las clases Entity en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.

### **3. Definir el DAO**

La interfaz `DAO` (Data Access Object) define las operaciones de acceso a la base de datos, como la inserci贸n, actualizaci贸n y eliminaci贸n de datos.

El Data Access Object (DAO) es un patr贸n de dise帽o que permite separar la l贸gica de acceso a los datos de la l贸gica de negocio de una aplicaci贸n.

La funci贸n del DAO es ocultar todas las complejidades relacionadas con las operaciones de acceso a los datos, como la conexi贸n a la base de datos, la creaci贸n de consultas SQL y la gesti贸n de transacciones.

Esto nos permite intercambiar f谩cilmente la fuente de datos subyacente sin tener que modificar la l贸gica de negocio de la aplicaci贸n.

![Ejemplo de representaci贸n del DAO](https://developer.android.com/static/codelabs/basic-android-kotlin-compose-persisting-data-room/img/8b91b8bbd7256a63_960.png)

Para definir un DAO en Room, debemos crear una interfaz que anote con `@Dao` y que contenga las operaciones de acceso a la base de datos.

Por ejemplo, la siguiente interfaz `UserDao` define las operaciones de acceso a la tabla de usuarios:

```kotlin
@Dao
interface UserDao {
    @Query("SELECT * FROM users")
    fun getUsers(): Flow<List<User>>

    @Insert
    suspend fun insertUser(user: User)

    @Update
    suspend fun updateUser(user: User)

    @Delete
    suspend fun deleteUser(user: User)
}
```

En este ejemplo, la interfaz `UserDao` define las operaciones `getUsers()`, `insertUser()`, `updateUser()` y `deleteUser()` para acceder a la tabla de usuarios.

Como se puede obversar, antes de cada funci贸n se anota con la operaci贸n que se va a realizar, ya sea `@Query`, `@Insert`, `@Update` o `@Delete`.

Estas operaciones definen las consultas SQL que se ejecutar谩n en la base de datos para realizar las operaciones correspondientes:

- `@Query`: Permite definir una consulta SQL personalizada para recuperar datos de la base de datos.
- `@Insert`: Permite definir una operaci贸n de inserci贸n de datos en la base de datos.
- `@Update`: Permite definir una operaci贸n de actualizaci贸n de datos en la base de datos.
- `@Delete`: Permite definir una operaci贸n de eliminaci贸n de datos en la base de datos.

> **Ubicaci贸n del archivo DAO**<br>
> Es recomendable tener las interfaces DAO en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.

### **4. Definir la base de datos**

La clase `Database` representa la base de datos de la aplicaci贸n y contiene la l贸gica para crear y acceder a las tablas de la base de datos.

Para definir una base de datos en Room, debemos crear una clase que extienda de `RoomDatabase` y que contenga las definiciones de las entidades y los DAOs de la base de datos.

Por ejemplo, la siguiente clase `AppDatabase` define una base de datos con la tabla de usuarios y el DAO correspondiente:

```kotlin
@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
```

En este ejemplo, la clase `AppDatabase` representa una base de datos con la tabla de usuarios y el DAO `UserDao`.

La anotaci贸n `@Database` se utiliza para indicar que la clase es una base de datos de Room y para especificar las entidades y la versi贸n de la base de datos.

La clase `AppDatabase` debe ser abstracta y extender de `RoomDatabase`. Tambi茅n debe contener una funci贸n abstracta que devuelva el DAO correspondiente a la tabla de usuarios.

Si queremos que no se conserven copias de seguridad del historial de versiones podemos a帽adir `exportSchema = false` a la anotaci贸n `@Database`.

Adem谩s, es interesante definir un `companion object` para obtener una instancia de la base de datos de forma segura y eficiente:

```kotlin
@Database(entities = [User::class], version = 1, exportSchema = false)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database"
                ).build()
                .also { INSTANCE = it }
                instance
            }
        }
    }
}
```

En este ejemplo, el `companion object` de la clase `AppDatabase` define una funci贸n `getDatabase()` que devuelve una instancia de la base de datos de forma segura y eficiente.

La funci贸n `getDatabase()` utiliza una variable `INSTANCE` para almacenar la instancia de la base de datos y la inicializa si es `null`.

La funci贸n `getDatabase()` tambi茅n utiliza la funci贸n `databaseBuilder()` para crear una instancia de la base de datos con el contexto de la aplicaci贸n, la clase de la base de datos y el nombre de la base de datos.

> **Ubicaci贸n del archivo Database**<br>
> Es recomendable tener la clase Database en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo suele estar en el mismo paquete que las clases Entity y DAO o en un paquete separado, dependiendo de la estructura del proyecto.

> **Sobre la anotaci贸n @Volatile**<br>
> La anotaci贸n `@Volatile` se utiliza para indicar que la variable `INSTANCE` es vol谩til y que su valor puede cambiar en cualquier momento. Esto garantiza que la variable `INSTANCE` siempre se lea desde la memoria principal y no desde la cach茅 de un subprocesos, lo que evita problemas de concurrencia.

En general, las variables vol谩tiles se utilizan para garantizar la coherencia de la memoria en entornos multiproceso o multihilo.

En este caso, la variable `INSTANCE` se utiliza para almacenar la instancia de la base de datos y garantizar que solo se cree una instancia de la base de datos en la aplicaci贸n.

Esto se utiliza adem谩s en un bloque `synchronized` para garantizar que solo se cree una instancia de la base de datos en entornos multiproceso o multihilo.

### **5. Implementar un repositorio**

El repositorio es una capa intermedia entre la capa de datos y la capa de presentaci贸n de la aplicaci贸n.

El repositorio se encarga de gestionar la obtenci贸n de datos de la base de datos y de proporcionar los datos a la capa de presentaci贸n de la aplicaci贸n.

El repositorio tambi茅n puede realizar operaciones de red, almacenamiento en cach茅 y otras operaciones relacionadas con la obtenci贸n y el almacenamiento de datos.

Para implementar un repositorio en Room, debemos crear una clase que contenga las operaciones de acceso a la base de datos y que proporcione los datos a la capa de presentaci贸n.

Para este ejemplo, crearemos una interfaz `UserRepository` que defina las operaciones de acceso a la tabla de usuarios, es decir, las operaciones del DAO `UserDao`:

```
import kotlinx.coroutines.flow.Flowinterface UserRepository {    fun getUsers(): Flow<List<User>>    suspend fun insertUser(user: User)    suspend fun updateUser(user: User)    suspend fun deleteUser(user: User)}
```

Debajo de la declaraci贸n de la interfaz `UserRepository`, creamos una clase `UserRepositoryImpl` que implementa la interfaz `UserRepository` y que contiene las operaciones de acceso a la base de datos:

```kotlin
class MyApplication : Application() {
    val appContainer by lazy { AppContainer(this) }

    override fun onCreate() {
        super.onCreate()
        // Inicializar la base de datos y otras dependencias
        val userRepository = appContainer.provideUserRepository()
    }
}
```

En este ejemplo, la clase `UserRepositoryImpl` implementa la interfaz `UserRepository` y contiene las operaciones `getUsers()`, `insertUser()`, `updateUser()` y `deleteUser()` que acceden a la tabla de usuarios a trav茅s del DAO `UserDao`.

La clase `UserRepositoryImpl` recibe una instancia de `UserDao` como par谩metro en su constructor y utiliza el DAO para realizar las operaciones de acceso a la base de datos.

> **Ubicaci贸n del archivo Repository**<br>
> Es recomendable tener la clase Repository en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo suele estar en el paquete `data` o en un paquete separado, dependiendo de la estructura del proyecto.

### **6. Implementar la clase AppContainer**

La clase `AppContainer` es una clase de contenedor que se utiliza para proporcionar instancias de las dependencias de la aplicaci贸n a las clases que las necesitan.

La clase `AppContainer` se utiliza para gestionar la creaci贸n y la inyecci贸n de dependencias en la aplicaci贸n y para garantizar que las dependencias se creen y se proporcionen de forma segura y eficiente.

Para implementar la clase `AppContainer`, debemos crear una clase que contenga las instancias de las dependencias de la aplicaci贸n y que proporcione m茅todos para obtener las instancias de las dependencias.

Por ejemplo, la siguiente clase `AppContainer` define las instancias de la base de datos, el DAO y el repositorio de la aplicaci贸n:

```kotlin
class AppContainer(context: Context) {    private val appDatabase = AppDatabase.getDatabase(context)    private val userDao = appDatabase.userDao()    private val userRepository = UserRepositoryImpl(userDao)    fun provideUserRepository(): UserRepository {        return userRepository    }}
```

En este ejemplo, la clase `AppContainer` define las instancias de la base de datos, el DAO y el repositorio de la aplicaci贸n y proporciona un m茅todo `provideUserRepository()` para obtener la instancia del repositorio.

La clase `AppContainer` recibe el contexto de la aplicaci贸n como par谩metro en su constructor y utiliza el contexto para crear la instancia de la base de datos y el DAO.

La clase `AppContainer` tambi茅n utiliza la instancia del DAO para crear la instancia del repositorio y proporcionarla a las clases que la necesitan.

> **Ubicaci贸n del archivo AppContainer**<br>
> Es recomendable tener la clase AppContainer en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo suele estar en el paquete `data` o en un paquete separado, dependiendo de la estructura del proyecto.

### **7. Inyectar dependencias en la aplicaci贸n**

Una vez que hemos definido las entidades, los DAOs, la base de datos, el repositorio y la clase `AppContainer`, podemos inyectar las dependencias en la aplicaci贸n para acceder a los datos de la base de datos.

Para inyectar las dependencias en la aplicaci贸n, debemos crear una instancia de la clase `AppContainer` en la clase de aplicaci贸n de la aplicaci贸n y utilizarla para obtener las instancias de las dependencias.

Por ejemplo, la siguiente clase `MyApplication` define una instancia de la clase `AppContainer` y la utiliza para obtener la instancia del repositorio de usuarios:

```kotlin
class MyApplication : Application() {
    val appContainer by lazy { AppContainer(this) }

    override fun onCreate() {
        super.onCreate()
        // Inicializar la base de datos y otras dependencias
        val userRepository = appContainer.provideUserRepository()
    }
}
```

En este ejemplo, la clase `MyApplication` define una instancia de la clase `AppContainer` utilizando la funci贸n `lazy()` para crear la instancia de forma diferida.

La clase `MyApplication` utiliza la instancia de `AppContainer` para obtener la instancia del repositorio de usuarios a trav茅s del m茅todo `provideUserRepository()`.

La clase `MyApplication` tambi茅n puede utilizar la instancia de `AppContainer` para obtener otras instancias de dependencias, como la base de datos y el DAO.

> **Ubicaci贸n del archivo Application**<br>
Es recomendable tener la clase Application en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo suele estar en el paquete application o en un paquete separado, dependiendo de la estructura del proyecto.

---

> 癸**Sobre la funci贸n lazy()**<br>
> La funci贸n lazy() se utiliza para crear una instancia de una clase de forma diferida, es decir, la instancia se crea solo cuando se accede por primera vez a ella.<br><br>
> Esto permite inicializar las dependencias de la aplicaci贸n de forma segura y eficiente, ya que las dependencias se crean solo cuando se necesitan y no antes.<br><br>
> En este caso, la funci贸n lazy() se utiliza para crear la instancia de la clase AppContainer de forma diferida y para garantizar que la instancia se cree solo cuando se accede a ella por primera vez.<br><br>
Esto es 煤til para evitar la creaci贸n innecesaria de instancias de dependencias en la aplicaci贸n y para mejorar el rendimiento de la aplicaci贸n.

Tambi茅n se podr铆a crear el contenedor con lateinit:

```kotlin
class MyApplication : Application() {
    private lateinit var appContainer: AppContainer

    override fun onCreate() {
        super.onCreate()
        appContainer = AppContainer(this)
        // Inicializar la base de datos y otras dependencias
        val userRepository = appContainer.provideUserRepository()
    }
}
```

En este caso, se inicializa la variable `appContainer` en el m茅todo `onCreate()` de la clase `MyApplication` y se utiliza para obtener la instancia del repositorio de usuarios.

Esta forma de inicializaci贸n es 煤til cuando se necesita inicializar la instancia de la clase `AppContainer` en el m茅todo `onCreate()` de la clase `MyApplication` y no antes.

> 癸 **Sobre lateinit**<br>
> La palabra clave `lateinit` se utiliza para indicar que una variable se inicializar谩 m谩s tarde, es decir, que su valor se asignar谩 en alg煤n momento antes de que se acceda a ella por primera vez.<br><br>
> Esto permite diferir la inicializaci贸n de la variable y garantizar que se inicialice solo cuando sea necesario.<br><br>
> En este caso, la palabra clave `lateinit` se utiliza para inicializar la variable `appContainer` en el m茅todo `onCreate()` de la clase `MyApplication` y para garantizar que la instancia de la clase `AppContainer` se cree solo cuando se acceda a ella por primera vez.<br><br>
> Esto es 煤til para evitar la inicializaci贸n innecesaria de la variable `appContainer` y para mejorar el rendimiento de la aplicaci贸n.

### **8. Acceder a los datos de la base de datos desde un ViewModel**

Una vez que hemos inyectado las dependencias en la aplicaci贸n, podemos acceder a los datos de la base de datos desde un ViewModel de Jetpack Compose.

Para acceder a los datos de la base de datos desde un ViewModel, debemos crear una clase que extienda de `ViewModel` y que contenga las operaciones de acceso a los datos.

Por ejemplo, la siguiente clase `UserViewModel` define un ViewModel que accede a los datos de la base de datos a trav茅s del repositorio de usuarios:

```kotlin
class UserViewModel(private val userRepository: UserRepository) : ViewModel() {
    val users: Flow<List<User>> = usersRepository.getUsers().asFlow()
}
```

En este ejemplo, la clase `UserViewModel` define un ViewModel que accede a los datos de la base de datos a trav茅s del repositorio de usuarios y proporciona los datos a la capa de presentaci贸n.

La clase `UserViewModel` recibe una instancia del repositorio de usuarios como par谩metro en su constructor y utiliza el repositorio para obtener los datos de la base de datos.

La clase `UserViewModel` tambi茅n define una propiedad `users` que contiene los datos de los usuarios como un flujo de datos (`Flow`) y que se puede observar desde la capa de UI.

>  **Ubicaci贸n del archivo ViewModel**<br>
> Es recomendable tener la clase ViewModel en un archivo separado, para mantener la organizaci贸n del c贸digo. Este archivo suele estar en el paquete ui o en un paquete separado, dependiendo de la estructura del proyecto.

Si quisieramos tambi茅n implementar la funcionalidad para insertar, borrar o actualizar un usuario, podr铆amos hacerlo de la siguiente manera:

```kotlin
class UserViewModel(private val userRepository: UserRepository) : ViewModel() {
    val users: Flow<List<User>> = usersRepository.getUsers().asFlow()

    fun insertUser(user: User) {
        viewModelScope.launch {
            userRepository.insertUser(user)
        }
    }

    fun updateUser(user: User) {
        viewModelScope.launch {
            userRepository.updateUser(user)
        }
    }

    fun deleteUser(user: User) {
        viewModelScope.launch {
            userRepository.deleteUser(user)
        }
    }
}
```

En este caso, se han a帽adido las funciones `insertUser()`, `updateUser()` y `deleteUser()` al ViewModel para insertar, actualizar y eliminar un usuario en la base de datos.

!!! warning "Sobre los datos a guardar, borrar o actualizar en la base de datos"

    Es importante tener en cuenta que las operaciones de inserci贸n, actualizaci贸n y eliminaci贸n de datos en la base de datos deben realizarse en un hilo de fondo para evitar bloquear el hilo principal de la aplicaci贸n.

    Adem谩s, estas operaciones deben realizarse dentro de un bloque `viewModelScope.launch` para garantizar que se realicen de forma segura y eficiente.

    En general, es recomendable utilizar corutinas para realizar operaciones as铆ncronas en la base de datos y para garantizar que la aplicaci贸n sea reactiva y eficiente.

    Tambi茅n es importante comprobar que los datos introducidos en la base de datos sean v谩lidos y est茅n correctamente formateados antes de realizar las operaciones de inserci贸n, actualizaci贸n o eliminaci贸n.

    Para ello, se pueden utilizar validaciones y comprobaciones de datos en el ViewModel o en el repositorio antes de realizar las operaciones en la base de datos.
    

### **9. Observar los datos en la capa de UI**

Una vez que hemos definido el ViewModel y hemos accedido a los datos de la base de datos, podemos observar los datos en la capa de UI de Jetpack Compose.

Para observar los datos en la capa de UI, debemos utilizar la funci贸n collectAsState() para convertir el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI.

Por ejemplo, la siguiente funci贸n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel:

```kotlin
@Composable
fun UserListScreen(userViewModel: UserViewModel) {
    val users by userViewModel.users.collectAsState(emptyList())

    LazyColumn {
        items(users) { user ->
            UserItem(user = user)
        }
    }
}
```

En este ejemplo, la funci贸n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel a trav茅s de la propiedad users.

La propiedad users se convierte en un estado que se puede observar desde la capa de UI utilizando la funci贸n collectAsState().

La funci贸n collectAsState() convierte el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI y que se actualiza autom谩ticamente cuando cambian los datos.

Esto permite mostrar los datos de la base de datos en la pantalla y actualizar la pantalla autom谩ticamente cuando cambian los datos.

Si quisieramos crear un peque帽o formulario para insertar un usuario, podr铆amos hacerlo de la siguiente manera:

```kotlin
@Composable
fun AddUserScreen(userViewModel: UserViewModel) {
    var name by remember { mutableStateOf("") }
    var email by remember { mutableStateOf("") }

    Column {
        TextField(
            value = name,
            onValueChange = { name = it },
            label = { Text("Name") }
        )
        TextField(
            value = email,
            onValueChange = { email = it },
            label = { Text("Email") }
        )
        Button(onClick = { 
            userViewModel.insertUser(User(name = name, email = email))
        }) {
            Text("Add User")
        }
    }
}
```

En este caso, se han definido dos variables name y email para almacenar el nombre y el email del usuario introducidos en el formulario.

!!! warning "Sobre las variables en la UI"

    Aclarar que en este ejemplo, por hacerlo m谩s ameno, no se han inclu铆do las variables `name` y `email` en un ViewModel, lo cual ser铆a lo recomendable para mantener la l贸gica de la aplicaci贸n separada de la capa de UI.

    En general, es recomendable utilizar un ViewModel para gestionar la l贸gica de la aplicaci贸n y para mantener la capa de UI lo m谩s simple y desacoplada posible.

La funci贸n `TextField` se utiliza para mostrar los campos de texto para introducir el nombre y el email del usuario y para actualizar las variables `name` y `email` cuando se introducen los datos.

La funci贸n `Button` se utiliza para mostrar un bot贸n que permite insertar un usuario en la base de datos cuando se hace clic en 茅l.

Tambi茅n podr铆amos a帽adir a la lista de usuarios un bot贸n para eliminar un usuario:

```kotlin
@Composable
fun UserItem(user: User, onDeleteUser: (User) -> Unit) {
    Row {
        Text(text = user.name)
        Text(text = user.email)
        Button(onClick = { onDeleteUser(user) }) {
            Text("Delete")
        }
    }
}
```

En este caso, se ha a帽adido un bot贸n a la lista de usuarios que permite eliminar un usuario de la base de datos cuando se hace clic en 茅l.

La funci贸n `UserItem` recibe un par谩metro `onDeleteUser` que es una funci贸n de tipo `(User) -> Unit` que se llama cuando se hace clic en el bot贸n de eliminar.

La funci贸n `onDeleteUser` se utiliza para eliminar un usuario de la base de datos a trav茅s del ViewModel.

!!! warning "Sobre la eliminaci贸n de un usuario"

    Es importante tener en cuenta que la eliminaci贸n de un usuario de la base de datos debe realizarse de forma segura y eficiente para evitar problemas de integridad de los datos.

    Antes de eliminar un usuario de la base de datos, es recomendable comprobar que el usuario existe y que los datos son v谩lidos y est谩n correctamente formateados.

    Tambi茅n es importante tener en cuenta que la eliminaci贸n de un usuario de la base de datos puede afectar a otras tablas relacionadas, por lo que es importante gestionar las relaciones entre las tablas de forma adecuada.

    En general, es recomendable utilizar corutinas para realizar operaciones as铆ncronas en la base de datos y para garantizar que la aplicaci贸n sea reactiva y eficiente.

La lambda que le pasar铆amos a la funci贸n UserItem ser铆a la siguiente:

```kotlin
@Composable
fun UserListScreen(userViewModel: UserViewModel) {
    val users by userViewModel.users.collectAsState(emptyList())

    LazyColumn {
        items(users) { user ->
            UserItem(user = user) {
                userViewModel.deleteUser(it)
            }
        }
    }
}
```

En este caso, se ha pasado una lambda a la funci贸n UserItem que llama a la funci贸n deleteUser() del ViewModel cuando se hace clic en el bot贸n de eliminar.

La lambda recibe un par谩metro it que es el usuario que se va a eliminar de la base de datos.


## Consultar el contenido de las bases de datos con el inspector en Android Studio

Para consultar el contenido de las bases de datos de Room en Android Studio, podemos utilizar el inspector de bases de datos integrado en Android Studio.

El inspector de bases de datos permite ver y modificar los datos de las tablas de la base de datos, ejecutar consultas SQL personalizadas y realizar otras operaciones relacionadas con la base de datos.

Para abrir el inspector de bases de datos en Android Studio, debemos seguir los siguientes pasos:

1. Abrir el panel de herramientas de Android Studio.
2. Seleccionar la pesta帽a `Device File Explorer`.
3. Navegar a la carpeta `/data/data/<nombre del paquete de la aplicaci贸n>/databases/`.
4. Hacer clic con el bot贸n derecho en el archivo de la base de datos y seleccionar `Database Inspector`.

## Guardado de preferencias con DataStore

DataStore es una biblioteca de Jetpack que proporciona una forma sencilla y eficiente de almacenar y recuperar datos de preferencias en una aplicaci贸n Android.

DataStore reemplaza a SharedPreferences como la forma recomendada de almacenar y recuperar datos de preferencias en una aplicaci贸n Android y proporciona una API reactiva y segura para trabajar con datos de preferencias.

A diferencia de los datos guardados con Room, que tienden a ser m谩s complejos y pesados, DataStore es m谩s ligero y est谩 pensado para guardar datos de preferencias de forma sencilla y eficiente.

Es decir, utilizaremos las preferencias para guardar datos simples como configuraciones de la aplicaci贸n, preferencias del usuario, etc.

DataStore tiene dos implmenetaciones:

- **Preferences DataStore**: Almacena y recupera datos de preferencias clave-valor de forma as铆ncrona y reactiva.
    - Los datos almacenados con preferencias solo pueden ser de tipo primitivo o String.
    - No se pueden almacenar ocnjuntos de datos complejos.
    - No se requiere un esquema predeterminado.
- **Proto DataStore**: Almacena y recupera datos de preferencias en formato de mensajes protobuf de forma as铆ncrona y reactiva.
    - Permite almacenar y recuperar datos de preferencias m谩s complejos.
    - Requiere un esquema definido.

Para utilizar DataStore en una aplicaci贸n Android, debemos agregar las dependencias necesarias en el archivo `build.gradle.kts` del m贸dulo de la aplicaci贸n:

```kotlin
dependencies {
    // DataStore
    implementation("androidx.datastore:datastore-preferences:1.0.0")
}
```

Para implementar las preferencias empezaremos creando una nueva clase en el paquete `data` llamada `UserPreferencesRepository`.

En esta clase definiremos una propiedad privada para representar una instancia de DataStore de tipo Preferences.

Este objeto almacenar谩 pares clave-valor. Para ello, debemos definir una clave, crearemos un objeto companion y usaremos las funciones `stringPreferencesKey()` e `intPreferencesKey()` para definir las claves de las preferencias.

Tamnbi茅n crearemos una funci贸n una funci贸n `writeUserPreferences()` para escribir las preferencias del usuario y dos flujos de datos para observar los cambios en las preferencias del usuario.

```kotlin
class UserPreferencesRepository(
    private val dataStore: DataStore<Preferences>
) {
    private companion object {
        val USER_NAME_KEY = stringPreferencesKey("user_name")
        val USER_AGE_KEY = intPreferencesKey("user_age")
    }

    val userNameFlow: Flow<String> = dataStore.data.map { preferences ->
        preferences[USER_NAME_KEY] ?: ""
    }

    val userAgeFlow: Flow<Int> = dataStore.data.map { preferences ->
        preferences[USER_AGE_KEY] ?: 0
    }

    suspend fun writeUserPreferences(userName: String, userAge: Int) {
        dataStore.edit { preferences ->
            preferences[USER_NAME_KEY] = userName
            preferences[USER_AGE_KEY] = userAge
        }
    }
}
```

En este ejemplo, la clase `UserPreferencesRepository` define una propiedad `dataStore` que representa una instancia de DataStore de tipo Preferences y que se utiliza para almacenar y recuperar los datos de preferencias del usuario.

Al utilizar archivos de preferencias estamos interactuando con el sistema de archivos, y esto puede darnos alg煤n que otro problema.

Para lidiar con los posibles problemas es recomendable capturar las posibles excepciones que puedan surgir al interactuar con el sistema de archivos.

Podemos usar el operador catch para capturar las excepciones y manejarlas de forma adecuada.

```kotlin
val userNameFlow: Flow<String> = dataStore.data
    .catch { exception ->
        if (exception is IOException) {
            emit(emptyPreferences())
        } else {
            throw exception
        }
    }
    .map { preferences ->
        preferences[USER_NAME_KEY] ?: ""
    }
```

En este ejemplo, se ha a帽adido un bloque `catch` al flujo de datos `userNameFlow` para capturar las excepciones de tipo `IOException` que puedan surgir al interactuar con el sistema de archivos.

Si se produce una excepci贸n de tipo `IOException`, se emite un valor predeterminado (`emptyPreferences()`) en el flujo de datos para evitar que la aplicaci贸n se bloquee o se cierre.

Esto permite manejar las excepciones de forma adecuada y garantizar que la aplicaci贸n sea reactiva y eficiente.

Para utilizar el `UserPreferencesRepository` en la aplicaci贸n, debemos crear una instancia de la clase en la clase de aplicaci贸n y utilizarla para acceder a los datos de preferencias del usuario.

```kotlin
private const val USER_PREFERENCES_NAME = "user_preferences"
private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = USER_PREFERENCES_NAME)

class MyApplication : Application() {
    lateinit var userPreferencesRepository: UserPreferencesRepository

    override fun onCreate() {
        super.onCreate()
        userPreferencesRepository = UserPreferencesRepository(dataStore)
    }
}
```

!!! data "Actualizar archivo AndroidManifest.xml"

    Para poder utilizar la clase `MyApplication` como clase de aplicaci贸n, debemos actualizar el archivo `AndroidManifest.xml` y a帽adir la propiedad `android:name` al elemento `<application>` para indicar la clase de aplicaci贸n.

    ```xml
    <application
        android:name=".MyApplication"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:theme="@style/AppTheme">
        ...
    </application>
    ```

Una vez hecho esto ya podemos proporcionar el `UserPreferencesRepository` a las clases que lo necesiten, como por ejemplo un ViewModel.

Haremos que este repositorio sea una propiedad del constructor del ViewModel y crearemos una funci贸n para escribir las preferencias del usuario.

Adem谩s, tambi茅n crearemos un companion object para obtener una instancia de la clase de forma segura y eficiente.

```kotlin
class UserViewModel(
    private val userPreferencesRepository: UserPreferencesRepository
) : ViewModel() {
    val userNameFlow: Flow<String> = userPreferencesRepository.userNameFlow
    val userAgeFlow: Flow<Int> = userPreferencesRepository.userAgeFlow

    fun writeUserPreferences(userName: String, userAge: Int) {
        viewModelScope.launch {
            userPreferencesRepository.writeUserPreferences(userName, userAge)
        }
    }

    companion object {
        val Factory: ViewModelProvider.Factory = viewModelFactory {
            initializer  {
                val application = (this[APLICATION_KEY] as MyApplication)
                UserViewModel(application.userPreferencesRepository)
            }
        }
    }
}
```

Para leer la preferencia podemos crear un uiState en el ViewModel para reflejar el flujo de datos de la preferencia.

```kotlin
val uiState: StateFlow<UiState> = 
    userPreferencesRepository.userName.map {
        UiState(userName = it)
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5_000),
        initialValue = UiState()
    )
```

!!! info "Sobre funci贸n StateIn"

    La funci贸n `stateIn()` se utiliza para convertir un flujo de datos en un estado que se puede observar desde la capa de UI y que se actualiza autom谩ticamente cuando cambian los datos.

    La funci贸n `stateIn()` toma varios par谩metros, como el 谩mbito de la corutina, el tiempo de inicio, el valor inicial y otros par谩metros, para configurar el estado y garantizar que se actualice de forma segura y eficiente.

    En este caso, la funci贸n `stateIn()` se utiliza para convertir el flujo de datos `userName` en un estado que se puede observar desde la capa de UI y que se actualiza autom谩ticamente cuando cambia el nombre de usuario.

    Esto permite mostrar el nombre de usuario en la pantalla y actualizar la pantalla autom谩ticamente cuando cambia el nombre de usuario.

    Los par谩metros sirven para lo siguiente:

    - `scope`: El 谩mbito de la corutina en el que se ejecutar谩 el estado.
    - `started`: El tiempo de inicio del estado.
    - `initialValue`: El valor inicial del estado.
