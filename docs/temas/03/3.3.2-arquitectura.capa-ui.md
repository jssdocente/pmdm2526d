## 3.3.2 П **Capa UI.** Arquitectura

La **capa de UI** es la parte de tu aplicaci贸n con la que el usuario interact煤a directamente. Su principal responsabilidad es **mostrar los datos de la aplicaci贸n en la pantalla** y, a su vez, **ser el punto de entrada para las acciones del usuario** (clics, escritura, etc.).

Piensa en ella como la cabina de un avi贸n 锔. El piloto (usuario) ve los instrumentos (la pantalla) y acciona los controles (botones, gestos). La cabina no sabe c贸mo funciona el motor; solo muestra la velocidad y env铆a la orden "acelerar" a las capas internas.

Esta capa se compone fundamentalmente de dos tipos de elementos:

1.  **Elementos de la UI (UI Elements):** Son los componentes visuales que dibujan la pantalla. En Jetpack Compose, estos son tus funciones **`@Composable`**. Su 煤nica misi贸n es transformar un estado en una interfaz gr谩fica. Son "tontos" por dise帽o: reciben un estado y lo pintan. No toman decisiones de l贸gica de negocio.
    
2.  **Contenedores de Estado (State Holders):** Son clases responsables de **contener el estado**, gestionar la l贸gica de la UI y exponer los datos a los Elementos de la UI. La clase m谩s com煤n para esto es el **`ViewModel`**. Este es el "cerebro"  de la pantalla.
    

### 锔 El Flujo de Datos Unidireccional (UDF) 

Para que todo funcione de forma ordenada y predecible, la comunicaci贸n entre estos dos componentes sigue un patr贸n estricto llamado **Flujo de Datos Unidireccional** (Unidirectional Data Flow o UDF).

Es muy simple de entender:

*   **El Estado fluye hacia abajo (State flows down) :** El `ViewModel` expone el estado (usando un `StateFlow`). El Composable lo recoge y se dibuja bas谩ndose en 茅l.
    
*   **Los Eventos fluyen hacia arriba (Events flow up) :** El Composable no modifica el estado directamente. Cuando el usuario hace clic en un bot贸n, el Composable notifica al `ViewModel` de este "evento" (ej: `viewModel.onIncrementarClick()`). El `ViewModel` es quien decide qu茅 hacer y, si es necesario, actualiza su estado.
    
<figcaption>
  <img src="./images/udf.png" alt="Unidirectional Data Flow." width="130%">
  <p style="text-align: center; font-style: italic;">UDF: Flujo de datos unidireccional.</p>
</figcaption>


Este ciclo crea un bucle predecible: `Evento -> Actualizar Estado -> Mostrar Nuevo Estado`.

El *flujo de datos unidireccional (UDF)* es una t茅cnica que se utiliza principalmente en la **programaci贸n reactiva** funcional. Tambi茅n se conoce como flujo de datos unidireccional, lo que significa que los datos **solo pueden transferirse de una manera** a otras partes de la aplicaci贸n.

La *unidireccionalidad* significa que no obtenemos nuestros datos solicit谩ndolos directamente. La 煤nica forma de obtenerlos es activando una acci贸n desde nuestra vista a nuestra capa de datos. El efecto secundario de esta acci贸n es actualizar el estado de nuestros datos.

La *vista es el resultado del estado* de la aplicaci贸n. El **estado** solo puede cambiar al activar acciones. Cuando se realizan acciones, el estado se actualiza.

<figcaption>
  <img src="./images/UDF-2.png" alt="Unidirectional Data Flow." width="80%">
  <p style="text-align: center; font-style: italic;">Acci贸n del estado sobre la vista.</p>
</figcaption>

* * *

### **驴C贸mo definir el estado de la UI?**

La IU es lo que **ve el usuario**, el estado de la IU es lo que la **app dice que deber铆a ver**. Al igual que dos caras de una moneda, la IU es la representaci贸n visual del estado de la IU. Cualquier cambio en el estado de la IU se refleja de inmediato en la IU.

<figcaption>
  <img src="./images/estado-ui.png" alt="." width="80%">
  <p class="text-small" style="text-align: center; font-style: italic;">La IU es el resultado de la vinculaci贸n de sus elementos en la pantalla con el estado correspondiente..</p>
</figcaption>


```kotlin
data class NewsUiState(
    val isSignedIn: Boolean = false,
    val isPremium: Boolean = false,
    val newsItems: List<NewsItemUiState> = listOf(),
    val userMessages: List<Message> = listOf()
)

data class NewsItemUiState(
    val title: String,
    val body: String,
    val bookmarked: Boolean = false,
    ...
)
```

**Inmutabilidad**

La **inmutabilidad** del estado significa que la UI tiene prohibido modificar los datos que recibe. Su 煤nica misi贸n es actuar como un **espejo**, reflejando fielmente el estado actual.

Para realizar un cambio, no se "edita" el estado viejo, sino que se reemplaza por completo con una **instancia nueva y actualizada**.

Esto impone un orden estricto, garantizando una **煤nica fuente de verdad**. As铆 se eliminan los errores impredecibles que ocurren cuando distintas partes del c贸digo intentan modificar los mismos datos a la vez, resultando en una app mucho m谩s estable y predecible.

!!! info "Inmutablidad de forma simple"

    La **inmutabilidad** en Compose es crucial porque convierte el estado de tu pantalla en una **fotograf铆a perfecta e inalterable** de un momento concreto.

    Pi茅nsalo con esta analog铆a:

    *   **El Estado Inmutable** es como un **plano de una casa  sellado y firmado por el arquitecto**.
    *   **Jetpack Compose** es el **equipo de construcci贸n **.
    *   **El ViewModel** es el **arquitecto **.
        

    Ahora, analicemos por qu茅 esto es tan importante:

    1. **Claridad y Previsibilidad**

        El equipo de construcci贸n (Compose) recibe el plano (el objeto de estado) y su 煤nica tarea es construir la casa _exactamente_ como dice el plano. No tienen que adivinar nada. Saben que el plano que tienen en sus manos es la **verdad absoluta** en ese momento. Esto hace que su trabajo sea simple y **predecible**.

        Esto es lo que el texto quiere decir con: _"los objetos inmutables proporcionan garant铆as sobre el estado de la aplicaci贸n en un momento determinado"_.

    2. **Evitar el Caos y los Errores**

        Imagina que el estado fuera **mutable** (que se pudiera cambiar). Ser铆a como si, mientras los obreros construyen, 隆cualquiera de ellos pudiera coger un l谩piz y modificar el plano sobre la marcha!

        *   驴D贸nde ir铆a esa pared ahora?
        *   驴El electricista estar铆a trabajando con el plano antiguo o con el nuevo que acaba de cambiar un fontanero?
        

        Ser铆a un caos absoluto. Tendr铆as varias versiones de la "verdad" al mismo tiempo, lo que llevar铆a a errores de construcci贸n (bugs en tu app) muy dif铆ciles de encontrar.

        Esto es a lo que se refiere el texto con: _"Infringir este principio genera varias fuentes ver铆dicas para la misma informaci贸n, lo que genera inconsistencias en los datos y errores leves"_.

    3. **驴C贸mo se hacen los cambios entonces?**

        Cuando el arquitecto (ViewModel) quiere hacer un cambio (por ejemplo, a帽adir una ventana), no borra y redibuja sobre el plano viejo. Lo que hace es crear **un plano completamente nuevo** con la ventana a帽adida y se lo entrega al equipo de construcci贸n.

        El equipo de construcci贸n ve el nuevo plano, lo compara con el anterior y de forma muy eficiente solo construye la parte nueva: la ventana.


**Contenedores de estado**

Un **State Holder** (o "contenedor de estado") es simplemente una clase responsable de **guardar y gestionar** los datos que tu UI necesita para mostrar en pantalla.

Su principal objetivo es **separar la l贸gica del dise帽o visual**. De esta forma, tus componentes de UI (`Composables`) se dedican 煤nicamente a "pintar" el estado que reciben, mientras que el State Holder act煤a como el **"cerebro" ** que procesa las acciones del usuario y decide qu茅 datos se deben mostrar.

En resumen, es el lugar donde vive el estado y la l贸gica de tu pantalla, manteniendo tu c贸digo de UI limpio, simple y f谩cil de probar. El `ViewModel` es el tipo de State Holder m谩s com煤n y recomendado en Android.

!!! important "Punto clave "

    El **ViewModel** es la implementaci贸n recomendada para administrar el estado de la IU a nivel de pantalla con acceso a la capa de datos. Adem谩s, sobrevive autom谩ticamente a los cambios de configuraci贸n. Las clases ViewModel definen la l贸gica que se aplica a los eventos en la app y, como resultado, producen un estado actualizado.

### М **MVVM: El Patr贸n Arquitect贸nico por Excelencia**

**MVVM** son las siglas de **Model-View-ViewModel**. Es un patr贸n de dise帽o arquitect贸nico que se adapta como un guante a los principios de la capa de UI y el flujo de datos unidireccional. Su objetivo es separar las responsabilidades de forma muy clara.

Vamos a desglosar sus tres componentes:

1. **Model (Modelo)**

      - **驴Qu茅 es?** Es la capa de **datos** de tu aplicaci贸n. Contiene la l贸gica de negocio y es la fuente de la verdad.  
      - **驴Qu茅 hace?** Es responsable de obtener y manipular los datos, ya sea desde una base de datos local (Room), una API de red (Retrofit) o cualquier otra fuente.
      - **Componentes:** Clases de datos (data classes), Repositorios, Casos de Uso, Fuentes de Datos (Data Sources).    

2. **View (Vista)**

      *   **驴Qu茅 es?** Es la **interfaz de usuario** (UI). Lo que el usuario ve y con lo que interact煤a.  
      *   **驴Qu茅 hace?** Su 煤nica responsabilidad es observar los datos expuestos por el ViewModel y dibujarse a s铆 misma. Captura las interacciones del usuario y las notifica al ViewModel como eventos.
      *   **Componentes:** En Android tradicional, eran los `Activities` y `Fragments` con XML. En el mundo moderno, son tus funciones **`@Composable`** en Jetpack Compose.
    

3. **ViewModel (Vista-Modelo)**

      *   **驴Qu茅 es?** Es el **intermediario** entre el Modelo y la Vista.  
      *   **驴Qu茅 hace?** No tiene ninguna referencia a la Vista (隆muy importante!), lo que lo hace f谩cil de testear. Solicita datos al Modelo, aplica la l贸gica de presentaci贸n necesaria y expone el estado listo para ser consumido por la Vista (a trav茅s de `StateFlow`). Tambi茅n recibe los eventos de la Vista y decide qu茅 acci贸n pedirle al Modelo.
      *   **Componentes:** Clases que heredan de `androidx.lifecycle.ViewModel`.


<figcaption>
  <img src="./images/mvvm-flow.png" alt="." width="100%">
  <p class="text-small" style="text-align: center; font-style: italic;">Diagrama que ilustra el ciclo de eventos y datos en el flujo unidireccional de datos</p>
</figcaption>


#### Tipos de L贸gica

La "l贸gica" se refiere de manera general a las **instrucciones, reglas y procesos algor铆tmicos** que dictan el comportamiento de una aplicaci贸n de software.

El texto distingue principalmente entre dos tipos de l贸gica esenciales en el desarrollo de aplicaciones: la **l贸gica empresarial** y la **l贸gica de la Interfaz de Usuario (IU)**, a veces llamada **l贸gica de comportamiento de la IU**.

-  **L贸gica Empresarial**

    Representa la aplicaci贸n de las reglas y requerimientos funcionales fundamentales del producto directamente sobre los **datos** de la aplicaci贸n. Su prop贸sito es definir qu茅 debe hacer la aplicaci贸n con la informaci贸n para cumplir con sus objetivos de valor.

    *   `Ubicaci贸n:` Generalmente reside en las capas de **dominio** o **datos**, asegurando que est茅 desacoplada de c贸mo se presenta la informaci贸n. 
    *   `Principio Clave:` **Nunca** debe ubicarse en la capa de la Interfaz de Usuario (IU).


- **L贸gica de la Interfaz de Usuario (IU) o Comportamiento de la IU**

    Determina **c贸mo** se manifiestan los cambios de estado o las acciones en la pantalla para el usuario. Se encarga de la gesti贸n de la presentaci贸n visual y la interacci贸n.

    - `Funci贸n:` Incluye la preparaci贸n de elementos para su visualizaci贸n, la navegaci贸n entre vistas como respuesta a interacciones, y la gesti贸n de retroalimentaci贸n visual al usuario (como mensajes temporales).
        
    - `Ubicaci贸n:` Debe encontrarse en la capa de la **IU** (la Vista). Si esta l贸gica se vuelve compleja, puede delegarse a una clase auxiliar dentro de la propia IU para mejorar la separaci贸n de responsabilidades y la capacidad de prueba, manteniendo su v铆nculo al ciclo de vida de la IU.



## **Aplicando todo. Ejemplos**

El el "Ejemplo 1" tenemos una aplicaci贸n simple "Contador", con un bot贸n que incrementa un n煤mero al darle click al Bot贸n. El estado "vive" dentro del componente "CounterScreen".

??? example "Ejemplo 1: App contador simple"

    ```kotlin
    // 1. Contador Simple (Estado Local)
    // El estado y la l贸gica residen en el mismo Composable.

    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.unit.dp

    // Funci贸n de entrada para la aplicaci贸n (simulando una actividad/main)
    @Composable
    fun CounterApp1() {
        MaterialTheme {
            CounterScreen()
        }
    }

    @Composable
    fun CounterScreen(modifier: Modifier = Modifier) {
        // 1. Definici贸n del Estado: 'remember' conserva el valor, 'mutableStateOf' lo hace observable.
        var count by remember { mutableStateOf(0) } // Estado del contador

        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            Text("Estado: LOCAL", style = MaterialTheme.typography.titleMedium)
            Spacer(modifier = Modifier.height(32.dp))

            Card(
                modifier = Modifier.width(200.dp),
                elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)
            ) {
                Column(
                    modifier = Modifier
                        .padding(24.dp)
                        .fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(
                        text = "Contador nico",
                        style = MaterialTheme.typography.headlineSmall
                    )
                    Spacer(modifier = Modifier.height(16.dp))

                    // Muestra el valor del estado
                    Text(
                        text = "$count",
                        style = MaterialTheme.typography.displayLarge,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Spacer(modifier = Modifier.height(24.dp))

                    // Bot贸n que modifica el estado directamente
                    Button(
                        onClick = { count++ },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Aumentar (+1)")
                    }
                    Spacer(modifier = Modifier.height(8.dp))

                    // Bot贸n para reiniciar el estado
                    OutlinedButton(
                        onClick = { count = 0 },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Reiniciar a 0")
                    }
                }
            }
        }
    }
    ```

En esta ejemplo 2, la complejidad aumenta. Ahora tenemos tres piezas de estado (count1, count2, generalCount) y toda la l贸gica que las conecta reside en el mismo componente CounterApp2.

??? example "Ejemplo 2: App 2 contadores"

    ```kotlin
    // 2. Contadores M煤ltiples y General (Todo Local)
    // Todos los estados (individuales y general) y la l贸gica de negocio combinada residen
    // en el mismo componente ra铆z.

    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.unit.dp

    @Composable
    fun CounterApp2() {
        MaterialTheme {
            CounterScreenWithCombinedState()
        }
    }

    @Composable
    fun CounterScreenWithCombinedState(modifier: Modifier = Modifier) {
        // Estados Individuales
        var count1 by remember { mutableStateOf(0) }
        var count2 by remember { mutableStateOf(0) }
        
        // Estado General: Se mantiene localmente y se actualiza junto con los otros.
        var generalCount by remember { mutableStateOf(0) }

        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Arquitectura: M煤ltiples Estados LOCALES", style = MaterialTheme.typography.titleMedium)
            Spacer(modifier = Modifier.height(16.dp))

            // Tarjeta del Contador General
            Card(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.fillMaxWidth().padding(16.dp)
                ) {
                    Text("Contador General", style = MaterialTheme.typography.headlineSmall)
                    Text("$generalCount", style = MaterialTheme.typography.displaySmall)
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            Row(Modifier.fillMaxWidth()) {
                // L贸gica para el Contador 1
                CounterCard(
                    title = "Contador #1",
                    currentCount = count1,
                    onIncrement = {
                        count1++
                        generalCount++ // L贸gica de negocio dentro de este Composable
                    },
                    onReset = { count1 = 0 },
                    modifier = Modifier.weight(1f)
                )

                // L贸gica para el Contador 2
                CounterCard(
                    title = "Contador #2",
                    currentCount = count2,
                    onIncrement = {
                        count2++
                        generalCount++ // L贸gica de negocio dentro de este Composable
                    },
                    onReset = { count2 = 0 },
                    modifier = Modifier.weight(1f)
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = {
                count1 = 0
                count2 = 0
                generalCount = 0
            }) {
                Text("Reiniciar TODO")
            }
        }
    }

    // Componente Reutilizable Simple (UI Pura)
    @Composable
    fun CounterCard(
        title: String,
        currentCount: Int,
        onIncrement: () -> Unit,
        onReset: () -> Unit,
        modifier: Modifier = Modifier
    ) {
        Card(
            modifier = modifier
                .padding(8.dp),
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(text = title, style = MaterialTheme.typography.titleMedium)
                Spacer(modifier = Modifier.height(8.dp))
                Text(
                    text = "$currentCount",
                    style = MaterialTheme.typography.headlineLarge,
                    color = MaterialTheme.colorScheme.primary
                )
                Spacer(modifier = Modifier.height(16.dp))

                Button(onClick = onIncrement, modifier = Modifier.fillMaxWidth()) {
                    Text("Aumentar (+1)")
                }
                Spacer(modifier = Modifier.height(8.dp))
                OutlinedButton(onClick = onReset, modifier = Modifier.fillMaxWidth()) {
                    Text("Reiniciar")
                }
            }
        }
    }
    ```

En esta ejemplo 3, es la versi贸n m谩s importante para entender la arquitectura.

El estado que afecta a varios componentes se "eleva" al componente padre com煤n m谩s cercano. El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.

??? example "Ejemplo 3: App 2 contadores con Elevaci贸n del Estado (State Hoisting)"

    ```kotlin
    // 3. Elevaci贸n de Estado (State Hoisting)
    // El estado que afecta a varios componentes se "eleva" al componente padre com煤n m谩s cercano.
    // El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.

    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.unit.dp

    @Composable
    fun CounterApp3() {
        MaterialTheme {
            ParentCounterScreen()
        }
    }

    // 1. Componente Padre: Responsable de los estados COMPARTIDOS
    @Composable
    fun ParentCounterScreen(modifier: Modifier = Modifier) {
        // Estado General: Se define y gestiona en el padre porque afecta a toda la pantalla.
        var generalCount by remember { mutableStateOf(0) }

        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Arquitectura: ELEVACIN DE ESTADO (State Hoisting)", style = MaterialTheme.typography.titleMedium)
            Spacer(modifier = Modifier.height(16.dp))

            // Tarjeta del Contador General (gestionada por el padre)
            Card(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.fillMaxWidth().padding(16.dp)
                ) {
                    Text("Contador General (Manejado por PADRE)", style = MaterialTheme.typography.headlineSmall)
                    Text("$generalCount", style = MaterialTheme.typography.displaySmall)
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            Row(Modifier.fillMaxWidth()) {
                // Contador 1 (Hijo): El padre pasa la funci贸n callback
                IndividualCounter(
                    title = "Contador #1 (Hijo)",
                    modifier = Modifier.weight(1f),
                    // Callback: Cuando el hijo se incrementa, el padre reacciona.
                    onIncremented = { generalCount++ } 
                )

                // Contador 2 (Hijo): El padre pasa la funci贸n callback
                IndividualCounter(
                    title = "Contador #2 (Hijo)",
                    modifier = Modifier.weight(1f),
                    // Callback: Cuando el hijo se incrementa, el padre reacciona.
                    onIncremented = { generalCount++ }
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            // Bot贸n global que el padre gestiona
            Button(onClick = { generalCount = 0 }) {
                Text("Reiniciar Contador General (El padre no puede resetear al hijo)")
            }
        }
    }

    // 2. Componente Hijo: Responsable de su estado INDIVIDUAL
    @Composable
    fun IndividualCounter(
        title: String,
        onIncremented: () -> Unit, // Callback para notificar al padre
        modifier: Modifier = Modifier
    ) {
        // Estado Individual: El hijo gestiona su propio 'count'.
        var count by remember { mutableStateOf(0) }
        
        Card(
            modifier = modifier
                .padding(8.dp),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(text = title, style = MaterialTheme.typography.titleMedium)
                Text("Estado: $count", style = MaterialTheme.typography.headlineLarge)
                
                Spacer(modifier = Modifier.height(16.dp))

                Button(
                    onClick = {
                        count++ // 1. Actualiza su estado local
                        onIncremented() // 2. Llama al callback para notificar al padre
                    }, 
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Aumentar (+1)")
                }
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedButton(
                    onClick = { count = 0 },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Reiniciar Individual")
                }
            }
        }
    }
    ```

En el ejemplo 4, le agregamos un TextField para permitir al usuario indicar la cantidad a incrementar.

??? example "Ejemplo 4: App 4. Contador con incremento por TextField"

    ```kotlin
    // 4. Elevaci贸n de Estado con Input (TextField)
    // El componente hijo gestiona su estado local (count y amount) y notifica al padre
    // la cantidad exacta que se ha a帽adido para que el padre pueda actualizar el contador general.

    import androidx.compose.runtime.*
    import androidx.compose.ui.Modifier
    import androidx.compose.foundation.layout.*
    import androidx.compose.material3.*
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.unit.dp
    import androidx.compose.foundation.text.KeyboardOptions
    import androidx.compose.ui.text.input.KeyboardType

    @Composable
    fun CounterApp4() {
        MaterialTheme {
            ParentCounterScreenWithInput()
        }
    }

    // 1. Componente Padre: Mantiene el estado COMPARTIDO (General Count)
    @Composable
    fun ParentCounterScreenWithInput(modifier: Modifier = Modifier) {
        // Estado General: Se define y gestiona en el padre
        var generalCount by remember { mutableStateOf(0) }

        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text("Arquitectura: ELEVACIN DE ESTADO con Input", style = MaterialTheme.typography.titleMedium)
            Text("El Hijo notifica al Padre la cantidad sumada.", style = MaterialTheme.typography.bodySmall)
            Spacer(modifier = Modifier.height(16.dp))

            // Tarjeta del Contador General
            Card(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
            ) {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    modifier = Modifier.fillMaxWidth().padding(16.dp)
                ) {
                    Text("Contador General (Manejado por PADRE)", style = MaterialTheme.typography.headlineSmall)
                    Text("$generalCount", style = MaterialTheme.typography.displaySmall)
                }
            }
            Spacer(modifier = Modifier.height(16.dp))

            Row(Modifier.fillMaxWidth()) {
                // Contador 1 (Hijo): El callback ahora recibe la cantidad sumada
                IndividualCounterWithInput(
                    title = "Contador #1 (Hijo)",
                    modifier = Modifier.weight(1f),
                    // Callback: Recibe la 'amount' y la suma al estado general
                    onIncremented = { amount -> generalCount += amount } 
                )

                // Contador 2 (Hijo)
                IndividualCounterWithInput(
                    title = "Contador #2 (Hijo)",
                    modifier = Modifier.weight(1f),
                    // Callback: Recibe la 'amount' y la suma al estado general
                    onIncremented = { amount -> generalCount += amount }
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            Button(onClick = { generalCount = 0 }) {
                Text("Reiniciar Contador General")
            }
        }
    }

    // 2. Componente Hijo: Ahora gestiona dos estados locales (count y incrementAmount)
    @Composable
    fun IndividualCounterWithInput(
        title: String,
        onIncremented: (amount: Int) -> Unit, // Callback ahora espera un par谩metro Int
        modifier: Modifier = Modifier
    ) {
        // Estado 1: Valor actual del contador
        var count by remember { mutableStateOf(0) }
        // Estado 2: Valor del TextField (cantidad a incrementar)
        var incrementAmountText by remember { mutableStateOf("1") }
        
        // Calcula la cantidad real a incrementar (parsea el texto a Int)
        val incrementAmount = incrementAmountText.toIntOrNull() ?: 0 // Usa 0 si no es v谩lido

        Card(
            modifier = modifier
                .padding(8.dp),
            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
        ) {
            Column(
                modifier = Modifier
                    .padding(16.dp)
                    .fillMaxWidth(),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text(text = title, style = MaterialTheme.typography.titleMedium)
                Text("Estado: $count", style = MaterialTheme.typography.headlineLarge)
                
                Spacer(modifier = Modifier.height(16.dp))

                // TextField para modificar la cantidad
                OutlinedTextField(
                    value = incrementAmountText,
                    onValueChange = { newValue ->
                        // Solo permite n煤meros enteros positivos en el estado
                        if (newValue.all { it.isDigit() } || newValue.isEmpty()) {
                            incrementAmountText = newValue
                        }
                    },
                    label = { Text("Aumentar en") },
                    keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                    modifier = Modifier.fillMaxWidth()
                )
                Spacer(modifier = Modifier.height(16.dp))

                Button(
                    // Deshabilita si el input no es un n煤mero v谩lido > 0
                    enabled = incrementAmount > 0, 
                    onClick = {
                        count += incrementAmount // 1. Actualiza su estado local
                        onIncremented(incrementAmount) // 2. Llama al padre con la cantidad
                    }, 
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Aumentar (+ $incrementAmount)")
                }
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedButton(
                    onClick = { 
                        count = 0 
                    },
                    modifier = Modifier.fillMaxWidth()
                ) {
                    Text("Reiniciar Individual")
                }
            }
        }
    }
    ```

Ejemplo 5, versi贸n final. Agregamos el ViewModel (VM)

??? example "Ejemplo 5: App 5. Contador con VM"

    === "Explicaci贸n"

        La aplicaci贸n se divide en tres capas bien definidas:

        1. La Capa de Estado (Data Layer)

            Aqu铆 es donde se define **qu茅** son los datos de la UI.

            - **`data class CounterState`:** Define el estado de un 煤nico contador. No solo almacena el `count` (el n煤mero actual), sino tambi茅n el `amountText` (el texto que el usuario ve en el `TextField`) y el `incrementAmount` (el valor entero ya parseado).
            - **`data class CountersScreenState`:** Es el contenedor de todo el estado que necesita la pantalla. Es una **煤nica fuente de verdad** que incluye:
                
                *   `counter1`: El estado del primer contador (`CounterState`).        
                *   `counter2`: El estado del segundo contador (`CounterState`).
                *   `generalCount`: El estado del contador general.
                

        2. La Capa de L贸gica (ViewModel)

            Aqu铆 es donde se define **c贸mo** cambian los datos.

            - **`class CounterViewModel : ViewModel()`:**
                
                - **Contiene el Estado Mutable:** Utiliza `private val _state = MutableStateFlow(CountersScreenState())`. Este es el estado interno y mutable que solo el `ViewModel` puede modificar.
                    
                - **Expone el Estado Observado:** Utiliza `val state: StateFlow<CountersScreenState> = _state`. Este es el estado que la UI (los Composable) observa; es de **solo lectura**.
                    
                - **Define los Eventos (L贸gica de Negocio):** Las funciones p煤blicas (`incrementCounter`, `setIncrementAmount`, `resetAll`) son los **eventos** o **intenciones** que la UI env铆a al `ViewModel`.
                    
                    - **Seguridad y Centralizaci贸n:** Cuando la UI llama a `incrementCounter`, el `ViewModel` usa `_state.update { ... }` para calcular el _nuevo_ estado a partir del _estado actual_. Esto garantiza que toda la l贸gica (incrementar el contador individual, validar el texto, y sumar al contador general) ocurre en un solo lugar, de forma segura.
                    

        3. La Capa de Presentaci贸n (Composable / UI)

            Aqu铆 es donde se define **c贸mo** se muestra el estado y **qu茅** eventos se env铆an.

            - **`CounterScreenWithViewModel()`:**
                
                *   **Observaci贸n:** Usa `val state = viewModel.state.collectAsState().value` para **leer** el estado emitido por el `ViewModel`.      
                *   **UI Pura:** Toda la estructura de la pantalla es una funci贸n pura de la variable `state`. Si `state` cambia, la UI se recompone.
                *   **Delegaci贸n:** No contiene ninguna l贸gica de `remember { mutableStateOf(...) }` ni de negocio. Simplemente llama a las funciones del `ViewModel` cuando hay interacci贸n (ej: `Button(onClick = { viewModel.incrementCounter(1) })`).
                    
            - **`IndividualCounterWithInput_VM()` (Componente Hijo):**
                
                *   Este es un componente **completamente pasivo**.
                *   Solo recibe el estado a trav茅s de sus par谩metros (`currentCount`, `incrementAmountText`).
                *   Solo emite eventos (callbacks) a su componente padre (`onIncrement`, `onAmountChange`). En este caso, el padre es el `CounterScreenWithViewModel`, que a su vez pasa la llamada al `ViewModel`.

    === "C贸digo"

        ```kotlin
        // 5. Versi贸n Final: Implementaci贸n con ViewModel y StateFlow
        // Esta es la arquitectura recomendada: L贸gica en el ViewModel, UI observando el estado.

        import androidx.compose.runtime.*
        import androidx.compose.ui.Modifier
        import androidx.lifecycle.ViewModel
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.StateFlow
        import kotlinx.coroutines.flow.update // Import necesario para actualizar el StateFlow de forma segura
        import androidx.compose.foundation.layout.*
        import androidx.compose.material3.*
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.unit.dp
        import androidx.compose.foundation.text.KeyboardOptions
        import androidx.compose.ui.text.input.KeyboardType
        import androidx.lifecycle.viewmodel.compose.viewModel 

        // ========== DATOS y VIEWMODEL (La capa de L贸gica y Estado) ==========

        // 1. Definir el estado de un Contador individual
        data class CounterState(
            val count: Int = 0,
            val incrementAmount: Int = 1,
            val amountText: String = "1"
        )

        // 2. Definir el estado global de la Pantalla (Contenedor de todos los estados de la UI)
        data class CountersScreenState(
            val counter1: CounterState = CounterState(),
            val counter2: CounterState = CounterState(),
            val generalCount: Int = 0 
        )

        // 3. Implementar el ViewModel (Lugar de la LGICA DE NEGOCIO)
        class CounterViewModel : ViewModel() { // Clase renombrada
            // StateFlow privado y mutable
            private val _state = MutableStateFlow(CountersScreenState())
            // StateFlow p煤blico (solo lectura)
            val state: StateFlow<CountersScreenState> = _state

            /**
            * L贸gica para incrementar un contador y el contador general.
            * TODA la actualizaci贸n del estado ocurre aqu铆.
            * @param counterId El ID del contador (1 o 2).
            */
            fun incrementCounter(counterId: Int) {
                _state.update { currentState ->
                    // 1. Determinar el valor de incremento y el nuevo estado del contador individual
                    val (newCounterState, incrementValue) = when (counterId) {
                        1 -> {
                            val amount = currentState.counter1.amountText.toIntOrNull() ?: 0
                            Pair(currentState.counter1.copy(count = currentState.counter1.count + amount), amount)
                        }
                        2 -> {
                            val amount = currentState.counter2.amountText.toIntOrNull() ?: 0
                            Pair(currentState.counter2.copy(count = currentState.counter2.count + amount), amount)
                        }
                        else -> Pair(CounterState(), 0)
                    }

                    // 2. Retornar el nuevo estado de la pantalla
                    currentState.copy(
                        counter1 = if (counterId == 1) newCounterState else currentState.counter1,
                        counter2 = if (counterId == 2) newCounterState else currentState.counter2,
                        generalCount = currentState.generalCount + incrementValue // Actualiza el general
                    )
                }
            }
            
            /**
            * L贸gica para actualizar el valor del TextField.
            * @param counterId El ID del contador.
            * @param amountText El nuevo texto ingresado.
            */
            fun setIncrementAmount(counterId: Int, amountText: String) {
                // Validaci贸n b谩sica: solo permitir d铆gitos o cadena vac铆a
                if (amountText.all { it.isDigit() } || amountText.isEmpty()) {
                    _state.update { currentState ->
                        val newAmount = amountText.toIntOrNull() ?: 0
                        when (counterId) {
                            1 -> currentState.copy(
                                counter1 = currentState.counter1.copy(
                                    amountText = amountText,
                                    incrementAmount = newAmount
                                )
                            )
                            2 -> currentState.copy(
                                counter2 = currentState.counter2.copy(
                                    amountText = amountText,
                                    incrementAmount = newAmount
                                )
                            )
                            else -> currentState
                        }
                    }
                }
            }
            
            /**
            * L贸gica para resetear todos los contadores.
            */
            fun resetAll() {
                // Al resetear al estado inicial, se resetea toda la UI autom谩ticamente.
                _state.value = CountersScreenState()
            }
        }


        // ========== COMPOSABLES (La capa de Presentaci贸n/UI) ==========

        @Composable
        fun CounterApp_ViewModel() { // Funci贸n principal renombrada
            MaterialTheme {
                // 4. Obtener el ViewModel. Compose se encarga de su ciclo de vida.
                val viewModel: CounterViewModel = viewModel() // Renombrado aqu铆
                CounterScreenWithViewModel(viewModel)
            }
        }

        @Composable
        fun CounterScreenWithViewModel(viewModel: CounterViewModel, modifier: Modifier = Modifier) {
            // 5. Observar el estado. Transforma el StateFlow en un Compose State.
            // La UI se recompone cuando el estado cambia.
            val state = viewModel.state.collectAsState().value

            Column(
                modifier = modifier
                    .fillMaxSize()
                    .padding(16.dp),
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                Text("Arquitectura: ViewModel & StateFlow", style = MaterialTheme.typography.titleMedium)
                Text("La UI solo LEE el estado y ENVA eventos al ViewModel.", style = MaterialTheme.typography.bodySmall)
                Spacer(modifier = Modifier.height(16.dp))

                // Tarjeta del Contador General
                Card(
                    modifier = Modifier.fillMaxWidth().padding(8.dp),
                    colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)
                ) {
                    Column(
                        horizontalAlignment = Alignment.CenterHorizontally,
                        modifier = Modifier.fillMaxWidth().padding(16.dp)
                    ) {
                        Text("Contador General (Manejado por ViewModel)", style = MaterialTheme.typography.headlineSmall)
                        // 6. Mostrar el estado general
                        Text("${state.generalCount}", style = MaterialTheme.typography.displaySmall)
                    }
                }
                Spacer(modifier = Modifier.height(16.dp))

                Row(Modifier.fillMaxWidth()) {
                    // 7. Usar un componente puro (Hijo)
                    // Se le pasa el estado espec铆fico (state.counter1) y los callbacks (que llaman al VM)
                    IndividualCounterWithInput_VM(
                        title = "Contador #1 (VM)",
                        currentCount = state.counter1.count,
                        incrementAmountText = state.counter1.amountText,
                        onIncrement = { viewModel.incrementCounter(1) },
                        onAmountChange = { newText -> viewModel.setIncrementAmount(1, newText) },
                        onReset = { viewModel.resetAll() }, 
                        modifier = Modifier.weight(1f)
                    )

                    IndividualCounterWithInput_VM(
                        title = "Contador #2 (VM)",
                        currentCount = state.counter2.count,
                        incrementAmountText = state.counter2.amountText,
                        onIncrement = { viewModel.incrementCounter(2) },
                        onAmountChange = { newText -> viewModel.setIncrementAmount(2, newText) },
                        onReset = { viewModel.resetAll() },
                        modifier = Modifier.weight(1f)
                    )
                }

                Spacer(modifier = Modifier.height(16.dp))
                // 8. Llamar a la funci贸n del ViewModel para resetear todo
                Button(onClick = { viewModel.resetAll() }) {
                    Text("Reiniciar TODO (Llamando a VM)")
                }
            }
        }

        // Componente Puro de UI: Solo recibe ESTADO y CALLBACKS (no tiene l贸gica 'remember')
        @Composable
        fun IndividualCounterWithInput_VM(
            title: String,
            currentCount: Int,
            incrementAmountText: String,
            onIncrement: () -> Unit,
            onAmountChange: (String) -> Unit,
            onReset: () -> Unit,
            modifier: Modifier = Modifier
        ) {
            // La l贸gica de c谩lculo del 'incrementAmount' pasa al ViewModel.
            val incrementAmount = incrementAmountText.toIntOrNull() ?: 0

            Card(
                modifier = modifier.padding(8.dp),
                colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)
            ) {
                Column(
                    modifier = Modifier.padding(16.dp).fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Text(text = title, style = MaterialTheme.typography.titleMedium)
                    Text("Estado: $currentCount", style = MaterialTheme.typography.headlineLarge)

                    Spacer(modifier = Modifier.height(16.dp))

                    OutlinedTextField(
                        value = incrementAmountText,
                        onValueChange = onAmountChange, // Llama al callback que va al ViewModel
                        label = { Text("Aumentar en") },
                        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                        modifier = Modifier.fillMaxWidth()
                    )
                    Spacer(modifier = Modifier.height(16.dp))

                    Button(
                        enabled = incrementAmount > 0,
                        onClick = onIncrement, // Llama al callback que va al ViewModel
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Aumentar (+ $incrementAmount)")
                    }
                    Spacer(modifier = Modifier.height(8.dp))

                    OutlinedButton(
                        onClick = onReset, // Llama al callback que va al ViewModel
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Reiniciar Individual")
                    }
                }
            }
        }
        ```





<br/>

---
