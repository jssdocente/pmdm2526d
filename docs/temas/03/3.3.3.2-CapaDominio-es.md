# Android Clean Architecture - Entendiendo la Capa de Dominio

A medida que las aplicaciones Android crecen en complejidad, una base de c√≥digo no estructurada puede conducir a un acoplamiento estrecho, l√≥gica duplicada y pruebas unitarias fr√°giles, lo que en √∫ltima instancia ralentiza el desarrollo. Los principios de Clean Architecture abordan estos desaf√≠os imponiendo una clara separaci√≥n de preocupaciones, haciendo que las aplicaciones sean m√°s escalables, mantenibles y comprobables.

En el coraz√≥n de esta arquitectura, la **Capa de Dominio** juega un papel crucial en la encapsulaci√≥n de la l√≥gica de negocio, asegurando un l√≠mite distinto entre la interfaz de usuario y el manejo de datos. Este art√≠culo profundiza en la Capa de Dominio, explicando su prop√≥sito, mejores pr√°cticas y c√≥mo implementarla eficazmente en aplicaciones Android.

## ¬øQu√© es la Capa de Dominio?

La Capa de Dominio es responsable de manejar la l√≥gica de negocio central de una aplicaci√≥n. Act√∫a como una capa independiente, separada tanto de la Capa de Presentaci√≥n (que gestiona la interfaz de usuario y las interacciones del usuario) como de la [Capa de Datos](/asos-techblog/android-clean-architecture-understanding-the-data-layer-a8df03b508c2) (que maneja el almacenamiento y recuperaci√≥n de datos de fuentes como bases de datos y APIs REST).

Mientras que las Capas de Presentaci√≥n y de Datos dependen de la Capa de Dominio, esta permanece completamente desacoplada de ellas. Esto asegura que la l√≥gica de negocio permanezca inalterada por cambios en los frameworks de UI o fuentes de datos.

![Un diagrama que describe las tres capas en Clean Architecture. La Capa de Presentaci√≥n, la Capa de Dominio y la Capa de Datos.](https://miro.medium.com/v2/resize:fit:700/1*If9QK8tE1VlzSDc_5CEKKw.jpeg)

Disposici√≥n de Dependencias en Clean Architecture

La Capa de Dominio contiene principalmente:

*   **Casos de Uso:** Manejan piezas espec√≠ficas de l√≥gica de negocio, definiendo c√≥mo deben procesarse y usarse los datos dentro de la app.
*   **Modelos de Dominio:** Representan entidades dentro del dominio del negocio.
*   **Interfaces de Repositorio:** Definen c√≥mo se puede acceder a los datos sin especificar la fuente subyacente (como una base de datos o API REST), asegurando el desacoplamiento de los internos de la Capa de Datos.

<figcaption>
  <img src="https://miro.medium.com/v2/resize:fit:700/1*rYeTfVXyDbwqpVaj9E0EmA.jpeg" alt="Representaci√≥n del Flujo de Datos en Android Clean Architecture" />
  <caption>Representaci√≥n del Flujo de Datos en Android Clean Architecture</caption>
</figcaption>

## Responsabilidades Clave de la Capa de Dominio

‚úÖ **Encapsula la L√≥gica de Negocio y Promueve la Modularidad**
La Capa de Dominio centraliza y encapsula la l√≥gica de negocio, asegurando que est√© desacoplada tanto de la Capa de Presentaci√≥n como de la Capa de Datos. Define Casos de Uso, que representan flujos de trabajo de negocio espec√≠ficos como realizar un pedido o validar la entrada del usuario. Adem√°s, al aislar la l√≥gica en esta capa, se puede compartir usando Kotlin Multiplatform (KMP), reduciendo la duplicaci√≥n de l√≥gica con iOS y otras plataformas.

‚úÖ **Desacopla la L√≥gica de Negocio de las Fuentes de Datos**
La Capa de Dominio asegura que la l√≥gica de negocio permanezca independiente de las fuentes de datos al depender de abstracciones en lugar de implementaciones concretas. Esto permite flexibilidad en c√≥mo se obtienen o persisten los datos, por lo que cambios como cambiar de APIs REST a GraphQL o modificar proveedores de bases de datos no afectan la l√≥gica de negocio central.

‚úÖ **Mejora la Testabilidad**
Al mantener la l√≥gica de negocio en clases peque√±as y de responsabilidad √∫nica, la Capa de Dominio mejora la testabilidad. Los Casos de Uso dependen de abstracciones (por ejemplo, interfaces de Repositorio), lo que hace f√°cil simular dependencias y escribir pruebas unitarias en aislamiento. Este dise√±o soporta el desarrollo guiado por pruebas (TDD) y asegura una alta cobertura de pruebas.

‚úÖ **Reduce la Complejidad en la Capa de Presentaci√≥n**
Al manejar la l√≥gica de negocio y las transformaciones, la Capa de Dominio asegura que los ViewModels permanezcan ligeros, centr√°ndose √∫nicamente en gestionar el estado de la UI. Extraer la l√≥gica de los ViewModels a Casos de Uso nos permite reutilizarla en toda la aplicaci√≥n. Esto mejora la mantenibilidad, haciendo que la Capa de Presentaci√≥n sea m√°s f√°cil de probar.

‚ùå **No es Responsable del Almacenamiento o Recuperaci√≥n de Datos**
La Capa de Dominio no maneja la persistencia o recuperaci√≥n de datos. Estas responsabilidades pertenecen a la [Capa de Datos](/asos-techblog/android-clean-architecture-understanding-the-data-layer-a8df03b508c2), que incluye componentes como Repositorios, Fuentes de Datos, APIs REST y Bases de Datos. La Capa de Dominio permanece agn√≥stica a c√≥mo se obtienen o persisten los datos.

‚ùå **No es Responsable de la Gesti√≥n del Estado de la UI**
La Capa de Dominio no gestiona el estado de la UI, esto es manejado por la Capa de Presentaci√≥n (ViewModels). En su lugar, la Capa de Dominio ejecuta la l√≥gica de negocio y devuelve resultados inmutables.

## **La Anatom√≠a de un Caso de Uso**

Un Caso de Uso es una clase que encapsula una sola operaci√≥n de negocio, haci√©ndola reutilizable y f√°cil de probar. Un Caso de Uso bien estructurado debe tener solo **una** funci√≥n p√∫blica, ya que debe centrarse en una sola responsabilidad.

Si un Caso de Uso tiene m√∫ltiples funciones p√∫blicas, puede estar manejando demasiadas preocupaciones, violando el **Principio de Responsabilidad √önica (SRP)**. En tales casos, considera dividir la l√≥gica en Casos de Uso separados y m√°s enfocados.

### 1. Nombrando Casos de Uso

El nombrado de Casos de Uso debe seguir el formato:

> **_[Verbo_**_]_ + _[_Sustantivo_]_ + _UseCase_

Ejemplos:

‚úÖ `**_Get_**_CustomerBag_UseCase`
‚úÖ `**_Logout_**_User_UseCase`   
‚úÖ `**Cache**_OrderDetails_UseCase`

### 2. Definiendo la L√≥gica de Negocio

La l√≥gica de negocio define las reglas y decisiones que controlan c√≥mo se comporta la app en diferentes situaciones. Determina:

*   **C√≥mo se procesan los datos ‚Äî** aplicando transformaciones antes de mostrarlos.
*   **Cu√°ndo y c√≥mo deben realizarse las acciones ‚Äî** validando la entrada del usuario antes de guardarla.
*   **C√≥mo interact√∫an las diferentes partes de la app ‚Äî** manteniendo las responsabilidades separadas.

### 3. Dependencias del Caso de Uso

Un Caso de Uso solo debe depender de abstracciones y construcciones puras de Kotlin, asegurando la independencia de la plataforma. A continuaci√≥n hay una gu√≠a sobre qu√© incluir y evitar en los Casos de Uso:

‚úÖ **Otros Casos de Uso ‚Äî** Para l√≥gica de negocio compartida (√∫salo con moderaci√≥n para evitar un encadenamiento excesivo).

‚úÖ **Clases de Utilidad Puras de Kotlin ‚Äî** Para l√≥gica reutilizable como reglas de validaci√≥n, formato de n√∫meros, etc.

‚úÖ **Interfaces de Repositorio ‚Äî** Para interactuar con la Capa de Datos sin depender de implementaciones concretas.

‚ùå **Dependencias de Android** ‚Äî Evita usar `Context`, `LiveData`, `Application`, etc. En lugar de usar `LiveData`, prefiere Kotlin `Flow` o funciones `suspend` para asegurar que la Capa de Dominio permanezca desacoplada del framework de Android.

### 4. C√≥mo Exponen Datos los Casos de Uso

Los Casos de Uso proporcionan datos a la Capa de Presentaci√≥n a trav√©s de diferentes mecanismos, dependiendo de c√≥mo se ejecute la operaci√≥n:

*   **Llamadas a funciones regulares** ‚Äî Para operaciones s√≠ncronas (por ejemplo, comprobaciones en memoria, c√°lculos simples).
*   **Funciones suspend** ‚Äî Para operaciones as√≠ncronas de una sola vez (por ejemplo, solicitudes de red, consultas a base de datos).
*   **Flow** ‚Äî Para flujos reactivos que emiten actualizaciones a lo largo del tiempo (por ejemplo, observando cambios en la base de datos).
*   **Observables/Callbacks** ‚Äî Para arquitecturas basadas en RxJava.

La elecci√≥n depende de si la operaci√≥n es inmediata y ligera o as√≠ncrona y de larga duraci√≥n.

## Mejores Pr√°cticas en Casos de Uso

### 1. El Operador Invoke

Dado que los Casos de Uso tienen una responsabilidad √∫nica, podemos usar el operador `invoke` de Kotlin para hacerlos invocables como funciones, eliminando llamadas a m√©todos redundantes.

```kotlin
class GetCustomerBagUseCase @Inject constructor(
    private val userRepository: UserRepository, // interface
    private val bagRepository: BagRepository // interface
) {
    suspend operator fun invoke(): Bag {
        val userId = userRepository.getUserId()
        return bagRepository.getCustomerBag(userId)
    }
}
```

Esto permite que la llamada en el ViewModel sea m√°s concisa e intuitiva:

```kotlin
val customerBag = getCustomerBagUseCase()
```

### 2. Seguridad de Hilos (Thread Safety)

Los Casos de Uso deben ser **seguros para el hilo principal (main-thread safe)**, lo que significa que pueden ser llamados desde el hilo principal sin bloquear la UI. Las operaciones de larga duraci√≥n, como llamadas a API REST o consultas a bases de datos, deben delegarse a la Capa de Datos.

La Capa de Dominio no debe cambiar a hilos vinculados a E/S (como `Dispatchers.IO`). La [Capa de Datos](/asos-techblog/android-clean-architecture-understanding-the-data-layer-a8df03b508c2) es responsable de gestionar los hilos y cambiar√° a un hilo en segundo plano tan cerca de la fuente de la llamada como sea posible. Sin embargo, para tareas intensivas de CPU como ordenaci√≥n y transformaciones, podemos usar `Dispatchers.Default` dentro de la Capa de Dominio.

Imagina que necesitamos procesar un lote de productos obtenidos y aplicar ordenaci√≥n, formateando sus fechas de creaci√≥n y calculando descuentos.

*   **Obtenci√≥n de productos** ‚Üí Manejado en la Capa de Datos (por ejemplo, Repositorio obteniendo de API REST o base de datos).
*   **Ordenaci√≥n y Formato** ‚Üí L√≥gica de negocio que pertenece a la Capa de Dominio.

Dado que procesar estos productos es **intensivo en CPU**, debe ejecutarse en un hilo en segundo plano para evitar bloqueos de la UI y errores de ANR **(**Application Not Responding**)**.

**‚úÖ Mejor Pr√°ctica: Mover Computaci√≥n Pesada a un Hilo en Segundo Plano**

```kotlin
class FormatProductListUseCase @Inject constructor(
    private val productRepository: ProductRepository, // interface
    private val formatDateUseCase: FormatDateUseCase,
    private val calculateDiscountUseCase: CalculateDiscountUseCase,
    @CoroutineDefault private val defaultDispatcher: CoroutineDispatcher
) {
   suspend operator fun invoke(): List<Product> = withContext(defaultDispatcher) {
    productRepository.getProducts()
        .sortedByDescending { it.price }
        .map { product ->
            val formattedDate = formatDateUseCase(product.createdAt)
            val discount = calculateDiscountUseCase(product.price)

            product.copy(
                createdAt = formattedDate,
                discount = discount
            )
        }
}
  
data class Product(
    val id: String,
    val name: String,
    val price: Double,
    val createdAt: String,
    val discount: Double = 0.0
)
```

### Por Qu√© Funciona Esto

‚úÖ **Delega la Obtenci√≥n a la Capa de Datos**
La responsabilidad de obtener los productos es manejada por la Capa de Datos, manteniendo la l√≥gica de negocio centrada en la Capa de Dominio.

‚úÖ **Usa** `**Dispatchers.Default**` **para Tareas Intensivas de CPU**
La ordenaci√≥n y las transformaciones se ejecutan en un hilo en segundo plano, mejorando el rendimiento y evitando bloqueos de la UI.

‚úÖ **Inyecta** `**CoroutineDispatcher**` **para Testabilidad**
Esto permite un f√°cil reemplazo con un despachador de prueba durante las pruebas unitarias. Esto asegura que las Corrutinas se ejecuten en un entorno controlado, haciendo que las pruebas sean m√°s r√°pidas, predecibles y aisladas de preocupaciones reales de hilos.

‚úÖ **Mantiene la L√≥gica de Negocio Modular**
Al encapsular el formato de fecha y el c√°lculo de descuentos en Casos de Uso separados y reutilizables, el c√≥digo permanece modular y m√°s f√°cil de mantener.

### 3. Combinando Datos de M√∫ltiples Repositorios

Aunque es posible fusionar datos de m√∫ltiples fuentes en un ViewModel o Repositorio, hacerlo puede hacer que estas clases sean complejas y dif√≠ciles de probar. En su lugar, es mejor crear un Caso de Uso que agregue datos de diferentes Repositorios, manteniendo la l√≥gica de negocio separada y reutilizable.

‚úÖ **Mejor Pr√°ctica: Combinando Productos Con Conteo de Bolsa de Usuario Usando Flows**

```kotlin
class GetProductsWithBagCountUseCase @Inject constructor(
    private val productsRepository: ProductsRepository, // interface
    private val bagRepository: BagRepository, // interface
    private val userRepository: UserRepository // interface
) {
    operator fun invoke(): Flow<ProductsWithBagCount> {
        val userId = userRepository.getUserId()
        return combine(
            productsRepository.getUserProducts(userId),
            bagRepository.getUserBagCount(userId)
        ) { products, bagCount ->
            ProductsWithBagCount(products, bagCount)
        }
    }
}
  
data class ProductsWithBagCount(
    val products: List<Products>,
    val bagCount: Int
)
```

### Por Qu√© Esto es Mejor

‚úÖ **Usa** `**Flow.combine()**`
Agrega datos reactivamente, asegurando que cualquier actualizaci√≥n de cualquiera de los Repositorios se propague autom√°ticamente. `combine()` emite los √∫ltimos valores de todos los flows combinados.

‚úÖ **Evita Bloquear Hilos**
La obtenci√≥n de datos es as√≠ncrona a trav√©s de Flows, asegurando una ejecuci√≥n no bloqueante y eficiente.

‚úÖ **Mantiene el ViewModel Enfocado**
El ViewModel solo recoge una √∫nica fuente de verdad, en lugar de gestionar m√∫ltiples llamadas a Repositorios, haci√©ndolo m√°s simple y enfocado en el estado de la UI.

‚úÖ **Los Repositorios Mantienen una Responsabilidad √önica**
Los Repositorios evitan dependencias entre s√≠, manteniendo una clara separaci√≥n de preocupaciones, lo que simplifica las pruebas y el mantenimiento.

‚úÖ **Mejora la Testabilidad**
El Caso de Uso es m√°s f√°cil de simular en pruebas unitarias, eliminando la necesidad de manejar m√∫ltiples instancias de `StateFlow` o `Flow` directamente en el ViewModel.

### 4. Validaci√≥n de Datos

La validaci√≥n de datos es un aspecto cr√≠tico para asegurar la integridad y correctitud de los datos que fluyen a trav√©s de tu aplicaci√≥n. Al manejar la l√≥gica de validaci√≥n dentro de la **Capa de Dominio**, logramos:

‚úÖ **Consistencia**
Asegurar que los datos sean validados antes de ser procesados o presentados.

‚úÖ **Reutilizaci√≥n**
Evitar l√≥gica de validaci√≥n redundante en diferentes partes de la app.

‚úÖ **Separaci√≥n de Preocupaciones**
Mantener la validaci√≥n independiente de las Capas de Presentaci√≥n y de Datos.

**Validaci√≥n de Entrada**
Asegura que las entradas del usuario cumplan criterios espec√≠ficos antes de ser procesadas o almacenadas.

*   Comprobar si un correo electr√≥nico sigue el formato correcto (por ejemplo, `user@example.com`).
*   Verificar que una contrase√±a cumpla con los requisitos m√≠nimos de longitud y complejidad.

**Validaci√≥n de Reglas de Negocio**
Asegura que los datos cumplan con las reglas de negocio espec√≠ficas del dominio. La validaci√≥n en el frontend puede ayudar a mejorar la UX comprobando reglas de negocio antes de que se realice una acci√≥n, bas√°ndose en los datos recibidos.

*   Comprobar si un usuario tiene fondos suficientes antes de realizar un pedido para evitar llamadas innecesarias a la API REST.
*   Asegurar que un producto est√© en stock antes de proceder con una compra. Si esta comprobaci√≥n falla, podr√≠amos deshabilitar el bot√≥n "Comprar".

**Validaci√≥n de Formato**
Asegura que los datos sigan una estructura o patr√≥n predefinido.

*   Validar que una cadena de fecha siga cierto formato como `YYYY-MM-DD`.
*   Asegurar que un n√∫mero de tel√©fono contenga el n√∫mero correcto de d√≠gitos.

**‚úÖ Mejor Pr√°ctica: Validaci√≥n de Datos en la Capa de Dominio**
Consideremos un ejemplo donde necesitamos validar la direcci√≥n de correo electr√≥nico y la contrase√±a de un usuario antes de permitirle registrarse.

```kotlin
class ValidateUserRegistrationUseCase @Inject constructor(
    private val emailValidator: EmailValidator,
    private val passwordValidator: PasswordValidator
) {
    suspend operator fun invoke(
      email: String,
      password: String
    ): ValidationResult {
        return when {
            !emailValidator.isValid(email) -> ValidationResult.InvalidEmail
            !passwordValidator.isValid(password) -> ValidationResult.InvalidPassword
            else -> ValidationResult.Valid
        }
    }
}
  
sealed interface ValidationResult {
    data object Valid : ValidationResult
    data object InvalidEmail : ValidationResult
    data object InvalidPassword : ValidationResult
}
```

### Resumen de Validaci√≥n

‚úÖ **Mant√©n la L√≥gica de Validaci√≥n Simple y Enfocada**
Cada validador debe centrarse en una tarea espec√≠fica (por ejemplo, validar formato de correo electr√≥nico o longitud de contrase√±a).

‚úÖ **Manejo de Errores**
Usa clases selladas o interfaces selladas para representar estados de validaci√≥n (v√°lido/inv√°lido), haciendo el manejo de errores m√°s simple y legible.

‚úÖ **Evita Duplicar L√≥gica de Validaci√≥n**
Mant√©n la l√≥gica de validaci√≥n reutilizable para evitar duplicar c√≥digo en diferentes partes de la app.

‚úÖ **Prueba la L√≥gica de Validaci√≥n Independientemente**
Dado que la l√≥gica de validaci√≥n es parte de las reglas de negocio, las pruebas unitarias deben centrarse en asegurar que la l√≥gica de validaci√≥n funcione correctamente en varios escenarios (por ejemplo, formatos de correo electr√≥nico inv√°lidos, contrase√±as cortas, etc.).

‚ùå **Codificar Mensajes de Error**
Evita codificar mensajes de error. En su lugar, define estados de error para asegurar consistencia en toda la app.

## Gestionando Casos de Uso: Inyecci√≥n, Ciclo de Vida y Ejecuci√≥n

En una arquitectura basada en ViewModel, los Casos de Uso se inyectan en el ViewModel y se ejecutan seg√∫n sea necesario. Hilt puede proporcionar autom√°ticamente un Caso de Uso si tiene una sola implementaci√≥n. Para asegurar que el Caso de Uso viva tanto como el ViewModel, an√≥talo con `**@ViewModelScoped**`. Esto asegura que la instancia del Caso de Uso se **cree una vez** cuando se inicializa el ViewModel y permanezca igual durante todo el ciclo de vida del ViewModel, evitando recreaciones innecesarias.

```kotlin
@ViewModelScoped
class GetCustomerBagUseCase @Inject constructor() {}
```

Algunos Casos de Uso pueden beneficiarse de tener un alcance `**@Singleton**`, lo que asegura que existe una √∫nica instancia durante el ciclo de vida de la app. Esto puede ser √∫til para l√≥gica de negocio persistente como la autenticaci√≥n.

Si un Caso de Uso tiene m√∫ltiples implementaciones o sigue una abstracci√≥n basada en interfaces, vincula la implementaci√≥n en un `@Module` e inst√°lalo en `ViewModelComponent`.

```kotlin
@Module
@InstallIn(ViewModelComponent::class)
abstract class BagModule {
    @Binds
    @ViewModelScoped
    abstract fun bindGetCustomerBagUseCase(
        impl: GetCustomerBagUseCaseImpl
    ): GetCustomerBagUseCase
}
```

### M√©todos de Inyecci√≥n: Est√°ndar vs Lazy

Hay dos formas principales de inyectar Casos de Uso:

*   **Inyecci√≥n est√°ndar** para Casos de Uso usados frecuentemente
*   **Inyecci√≥n diferida (Lazy)** para Casos de Uso que solo se necesitan condicionalmente

### 1. Inyecci√≥n Est√°ndar (Para Casos de Uso Usados Frecuentemente)

Para Casos de Uso que se usan frecuentemente, podemos inyectarlos en el constructor directamente en el ViewModel. La instancia se crea una vez cuando se inicializa el ViewModel y permanece activa durante todo el ciclo de vida del ViewModel.

```kotlin
@HiltViewModel
class BagViewModel @Inject constructor(
    private val getCustomerBagUseCase: GetCustomerBagUseCase
) : ViewModel() {
  
    private val _customerBag = MutableStateFlow<CustomerBag?>(null)
    val customerBag: StateFlow<CustomerBag?> = _customerBag.asStateFlow()
      
    fun getCustomerBag() {
        viewModelScope.launch {
            _customerBag.update { getCustomerBagUseCase() }
        }
    }
}
```

### 2. Inyecci√≥n Lazy (Para Casos de Uso Usados Selectivamente)

Para Casos de Uso que solo se usan en escenarios espec√≠ficos, la inyecci√≥n lazy retrasa la instanciaci√≥n hasta que se necesita. Esto reduce la creaci√≥n de objetos innecesarios y evita inyectar dependencias que podr√≠an no usarse.

```kotlin
import dagger.Lazy
  
@HiltViewModel
class BagViewModel @Inject constructor(
    private val saveItemToWishListUseCase: Lazy<SaveItemToWishListUseCase>
) : ViewModel() {
  
    fun saveItemToWishList(item: Item) {
        viewModelScope.launch {
            saveItemToWishListUseCase.get().invoke(item)
        }
    }
}
```

Aqu√≠, `SaveItemToWishListUseCase` no se instancia hasta que se llama a `get()`, reduciendo el uso de memoria y mejorando el rendimiento de la app cuando el Caso de Uso no siempre es necesario.

### Usa `viewModelScope` para Gesti√≥n de Corrutinas üöÄ

Al ejecutar Casos de Uso dentro de un ViewModel, usa siempre `viewModelScope.launch{}`. Esto asegura:

*   Las Corrutinas se cancelan autom√°ticamente cuando se destruye el ViewModel, previniendo fugas de memoria.
*   Las tareas en segundo plano terminan correctamente cuando la UI ya no est√° activa.

Por defecto, `viewModelScope.launch{}` usa el **Main Dispatcher**, haci√©ndolo ideal para operaciones relacionadas con la UI.

> Ten en cuenta que `_@ViewModelScoped_` controla el ciclo de vida de la instancia del Caso de Uso. Asegura una √∫nica instancia de Caso de Uso por ciclo de vida del ViewModel, mientras que `_viewModelScope.launch{}_` gestiona la ejecuci√≥n y cancelaci√≥n de Corrutinas. Aunque se nombran de forma similar, son preocupaciones separadas.

### Puntos Clave

‚úÖ **Los Casos de Uso persisten con el ViewModel**
Dar un alcance a un Caso de Uso con `@ViewModelScoped` asegura que viva tanto como el ViewModel, evitando recreaciones innecesarias.

‚úÖ **Aprovecha** `**viewModelScope.launch{}**` **en ViewModels**
Se ejecuta en el Main Dispatcher por defecto, haci√©ndolo adecuado para operaciones de UI y garantiza la cancelaci√≥n autom√°tica de Corrutinas cuando se borra el ViewModel, previniendo fugas de memoria.

‚úÖ **Elige el m√©todo de inyecci√≥n correcto basado en el uso**
Inyecci√≥n est√°ndar para Casos de Uso usados frecuentemente e inyecci√≥n lazy para Casos de Uso opcionales para diferir la instanciaci√≥n y reducir la sobrecarga de memoria.

‚ùå **No inyectes Casos de Uso en la Capa de Datos**
Los Casos de Uso pertenecen a la Capa de Dominio y deben ser invocados desde la Capa de Presentaci√≥n u otros Casos de Uso cuando sea necesario. **No** deben inyectarse en la [Capa de Datos](/asos-techblog/android-clean-architecture-understanding-the-data-layer-a8df03b508c2) (por ejemplo, Repositorios, Fuentes de Datos o Mappers) ya que esto viola los principios de Clean Architecture al introducir dependencias innecesarias y aumentar el acoplamiento entre capas.

---

## Restricciones de Acceso a Datos en la Capa de Dominio

Una pregunta com√∫n en Clean Architecture es:

> ¬øDeber√≠an los ViewModels y otros componentes de la Capa de Presentaci√≥n acceder directamente a los Repositorios, o todo el acceso a datos deber√≠a pasar por Casos de Uso?

Restringir el acceso a datos a la Capa de Dominio tiene sus ventajas y desventajas:

‚úÖ **Asegura una Ejecuci√≥n Consistente de la L√≥gica de Negocio**
Los Casos de Uso hacen cumplir reglas como el seguimiento de an√°lisis, validaci√≥n y transformaciones de datos, asegurando que la l√≥gica de negocio se aplique consistentemente y previniendo el acceso inconsistente a datos brutos de la Capa de Datos.

‚úÖ **Soporta la Modularizaci√≥n**
En proyectos [modularizados por API/Implementaci√≥n](/asos-techblog/slaying-the-monolith-api-implementation-modularisation-pattern-in-android-development-22a07c24e9dd), los m√≥dulos de caracter√≠sticas exponen interfaces de Caso de Uso en el m√≥dulo `:api`. Esto mantiene m√≠nimas las dependencias entre m√≥dulos y simplifica la arquitectura general.

‚úÖ **Simplifica las Pruebas de ViewModel**
Dado que los ViewModels dependen solo de Casos de Uso en lugar de Repositorios, las pruebas se vuelven m√°s f√°ciles. No hay necesidad de simular Repositorios en pruebas de ViewModel, permitiendo pruebas unitarias m√°s aisladas, enfocadas y mantenibles.

‚ùå **Introduce Sobrecarga para Obtenciones Simples**
Cuando un Caso de Uso simplemente envuelve una llamada a Repositorio sin agregar l√≥gica de negocio, puede sentirse redundante e introducir complejidad innecesaria.

En ASOS, seguimos la estrategia de [**modularizaci√≥n API/Implementaci√≥n**](/asos-techblog/slaying-the-monolith-api-implementation-modularisation-pattern-in-android-development-22a07c24e9dd), donde restringir el acceso directo a datos a la Capa de Dominio se alinea naturalmente con nuestra arquitectura. Esto asegura un manejo consistente de datos, reduce el acoplamiento y simplifica la mantenibilidad a largo plazo a medida que el proyecto escala.

## Estructura de Paquetes

A continuaci√≥n se muestra un ejemplo de c√≥mo se puede estructurar la Capa de Dominio. Esta es una representaci√≥n simple y podr√≠a cambiar en una app modularizada.

```text
üìÇ domain
‚îú‚îÄ‚îÄ üìÇ model
‚îÇ    ‚îú‚îÄ‚îÄ ProductsWithBagCount.kt
‚îÇ    ‚îú‚îÄ‚îÄ Bag.kt
‚îÇ    ‚îú‚îÄ‚îÄ Product.kt
‚îÇ
‚îú‚îÄ‚îÄ üìÇ repository
‚îÇ    ‚îú‚îÄ‚îÄ ProductsRepository.kt  //interface
‚îÇ    ‚îú‚îÄ‚îÄ BagRepository.kt  //interface
‚îÇ
‚îú‚îÄ‚îÄ üìÇ usecase
‚îÇ    ‚îú‚îÄ‚îÄ AddItemToBagUseCase.kt
‚îÇ    ‚îú‚îÄ‚îÄ RemoveItemFromBagUseCase.kt
```

## Conclusi√≥n

Incorporar la Capa de Dominio en tu aplicaci√≥n Android ofrece numerosos beneficios, incluyendo escalabilidad, testabilidad y mantenibilidad. Al aislar la l√≥gica de negocio dentro de la Capa de Dominio, aseguras que el ViewModel y otros componentes de UI permanezcan ligeros y centrados √∫nicamente en renderizar la UI, sin la carga de operaciones complejas o gesti√≥n de datos. Esta separaci√≥n de preocupaciones ayuda a crear una arquitectura robusta y f√°cilmente extensible, especialmente a medida que la app crece en tama√±o y complejidad.

Al estructurar adecuadamente los Casos de Uso, manejar la hiler√≠a eficientemente y decidir sabiamente sobre las restricciones de acceso, puedes construir una arquitectura de app mantenible que resista el paso del tiempo.
