## Android Clean Architecture - Capa de Datos

La Capa de Datos se encarga de todo el trabajo entre bastidores cuando se trata de manejar datos en la aplicaci√≥n. Ya sea obteniendo datos de una API remota, leyendo de una base de datos local o gestionando una cach√© en memoria, esta capa hace el trabajo pesado. Su trabajo es proporcionar datos de una manera consistente para que el resto de la app no tenga que preocuparse de d√≥nde vinieron o c√≥mo se almacenaron.

En Clean Architecture, una regla clave es que la Capa de Datos no debe ser accedida directamente por la Capa de Presentaci√≥n (como ViewModels o componentes de UI). En su lugar, habla solo con la Capa de Dominio, que define las reglas de negocio en las que conf√≠a la aplicaci√≥n. Esta separaci√≥n mantiene las cosas modulares y flexibles, por lo que si alguna vez necesitas cambiar APIs remotas o cambiar la configuraci√≥n de almacenamiento, puedes hacerlo sin afectar al resto de la aplicaci√≥n.

Presiona enter o haz clic para ver la imagen en tama√±o completo

<figcaption>
  <img src="https://miro.medium.com/v2/resize:fit:700/1*INX-TUwdPXyR1bzMsEoPyQ.jpeg" alt="La Capa de Presentaci√≥n, la Capa de Dominio y la Capa de Datos" />
  <caption>Disposici√≥n de Dependencias en Clean Architecture</caption>
</figcaption>


## Anatom√≠a de la Capa de Datos

### Fuentes de Datos (Data Sources)

Definen c√≥mo se recuperan los datos, ya sea de APIs remotas, bases de datos o cach√©s en memoria. A menudo se categorizan en RemoteDataSources (Remotas) y LocalDataSources (Locales).

### **Repositorios**

Sirven como el punto de entrada para el acceso a datos, actuando como la interfaz entre la Capa de Datos y la Capa de Dominio. Los Repositorios orquestan datos de Fuentes de Datos remotas o locales.

### **Interfaces de API Remota**

Definen el contrato para la comunicaci√≥n de red. Especifican m√©todos HTTP (como `@GET`, `@POST`), rutas de endpoint, par√°metros de consulta/ruta, cabeceras y los modelos de respuesta esperados. Esto asegura una interacci√≥n consistente y segura en tipos con APIs remotas.

### **Objetos de Acceso a Datos (DAOs)**

Proporcionan una capa de abstracci√≥n sobre la base de datos. Definen las consultas SQL y operaciones de datos usadas para realizar acciones CRUD (Crear, Leer, Actualizar y Borrar).

### **Objetos de Transferencia de Datos (DTOs)**

Son representaciones estructuradas de datos externos como respuestas de API REST.

### **Entidades (Entities)**

Son representaciones de base de datos que se mapean directamente a tablas. Definen el esquema de la base de datos.

### **Mappers**

Transforman datos entre DTOs, Entidades y Modelos de Dominio. Los Mappers son necesarios para evitar dependencias directas entre las Capas de Datos y de Dominio.

Presiona enter o haz clic para ver la imagen en tama√±o completo

<figcaption >
  <img src="https://miro.medium.com/v2/resize:fit:700/1*pZatdH0cAp8y3hT9ZVc8Yg.jpeg" alt="Un diagrama que muestra una representaci√≥n del flujo de datos a trav√©s de las capas de Clean Architecture comenzando en la Capa de Presentaci√≥n con un Fragment, movi√©ndose al ViewModel y cruzando a la Capa de Dominio con un Caso de Uso. El Caso de Uso luego llama a la Interfaz del Repositorio. Luego cruzamos a la Capa de Datos hacia la Implementaci√≥n del Repositorio. Desde aqu√≠ podemos ir a una Fuente de Datos Local o una Fuente de Datos Remota para enviar o obtener informaci√≥n." />
  <caption>Representaci√≥n del Flujo de Datos en Android Clean Architecture</caption>
</figcaption>

## Responsabilidades Clave de la Capa de Datos

‚úÖ **Obtenci√≥n, Persistencia y Cach√© de Datos**
La Capa de Datos maneja operaciones CRUD de fuentes de datos remotas como APIs REST, y puede persistir datos localmente usando herramientas como Room (para bases de datos), DataStore (para pares clave-valor), o cach√© en memoria (para datos temporales) cuando es necesario.

‚úÖ **Manejo de Respuestas de Red**
La Capa de Datos procesa y valida respuestas de red. Asegura que los datos de fuentes externas como APIs REST sean v√°lidos, completos y est√©n en el formato correcto antes de ser pasados a la Capa de Dominio.

‚úÖ **L√≥gica de Reintento y Manejo de Fallos**
La Capa de Datos maneja condiciones de red poco fiables implementando estrategias de reintento como espera exponencial (exponential back-off) y gestionando elegantemente los fallos para evitar interrumpir la experiencia del usuario.

‚úÖ **Registro y Reporte de Errores**
Cuando las operaciones fallan, capturar esos fallos en la fuente es importante. La Capa de Datos debe registrar excepciones y opcionalmente reportarlas usando herramientas de reporte de fallos para facilitar la depuraci√≥n y el an√°lisis.

‚úÖ **Hiler√≠a (Threading)**
Bibliotecas como Retrofit, Room y DataStore manejan autom√°ticamente la hiler√≠a cuando se usan Corrutinas, asegurando que las operaciones de datos no bloqueen el hilo principal. Si se usa una biblioteca diferente, la responsabilidad de cambiar hilos para trabajo de E/S pertenece a la Capa de Datos.

‚úÖ **Mapeo de DTOs y Entidades a Modelos de Dominio**
Transformar datos brutos (como respuestas de API REST o entidades de base de datos) en modelos de dominio utilizables es una responsabilidad clave de esta capa. Esta separaci√≥n ayuda a mantener un l√≠mite claro entre los formatos de datos externos y la l√≥gica de negocio de la aplicaci√≥n.

‚úÖ **Asegurar la Consistencia de Datos**
Las Fuentes de Datos deben devolver datos inmutables para asegurar la consistencia y prevenir condiciones de carrera o corrupci√≥n de datos. Los datos inmutables garantizan que los datos pasados a las capas superiores de la aplicaci√≥n sean fiables.

‚úÖ **Seguridad y Privacidad de Datos**
Aunque la seguridad es una responsabilidad compartida a trav√©s de las capas, la Capa de Datos juega un papel importante. Ya sea cifrando el almacenamiento local o asegurando la transmisi√≥n segura de datos a trav√©s de la red, esta capa ayuda a proteger los datos y la privacidad del usuario.

‚ùå **No Debe Contener L√≥gica de Negocio**
La Capa de Datos se centra en la gesti√≥n de datos, no en la toma de decisiones. La l√≥gica de negocio debe residir dentro de la Capa de Dominio para mantener la separaci√≥n de preocupaciones y la mantenibilidad.

‚ùå **No Debe Ser Accedida Directamente por la Capa de Presentaci√≥n**
El acceso a la Capa de Datos est√° restringido a trav√©s de la Capa de Dominio para asegurar que la l√≥gica de negocio se aplique consistentemente y para prevenir un acceso inconsistente a la Capa de Datos en toda la aplicaci√≥n.

> üí° En proyectos m√°s peque√±os donde se omite una Capa de Dominio, este l√≠mite podr√≠a ser m√°s relajado. Pero en apps escalables, adherirse a esta separaci√≥n conduce a una base de c√≥digo m√°s mantenible.

## Patr√≥n Repositorio en Clean Architecture

Los Repositorios act√∫an como la capa intermedia entre la Capa de Dominio y las Fuentes de Datos (como APIs REST o bases de datos locales). Su trabajo es exponer una interfaz estable y centrada en el dominio que oculta la complejidad subyacente de c√≥mo y d√≥nde se obtienen o almacenan los datos.

T√≠picamente **no** manejan mapeo, hiler√≠a o manejo de errores de bajo nivel. Esas preocupaciones viven en las clases de Fuente de Datos remota y local. Sin embargo, si tu aplicaci√≥n no usa clases de Fuente de Datos (proyectos m√°s peque√±os) es aceptable que el Repositorio asuma estas responsabilidades. Los Repositorios se centran en orquestar datos entre fuentes (remotas y locales), y decidir c√≥mo combinar o priorizar datos antes de devolver el resultado a la Capa de Dominio.

### 1. Nombrando Repositorios

Los Repositorios deben seguir el formato:

> **_[Tipo de Dato]_** _\+ Repository_

Por ejemplo:
‚úÖ `**Bag**Repository`
‚úÖ `**Checkout**Repository`

### 2. Responsabilidades Clave de los Repositorios

‚úÖ **Orquestaci√≥n de Datos**
Los Repositorios coordinan entre m√∫ltiples fuentes de datos. Por ejemplo, obteniendo de la cach√© local primero y recurriendo a remoto si es necesario (o viceversa). Deciden de d√≥nde obtener los datos, no c√≥mo obtenerlos.

‚úÖ **Devolver Modelos de Dominio**
Los Repositorios siempre exponen Modelos de Dominio a la Capa de Dominio. Cualquier mapeo de DTOs o Entidades de base de datos ocurre en las clases de Fuente de Datos remota o local. Si tu aplicaci√≥n omite clases de Fuente de Datos, el Repositorio puede asumir la responsabilidad del mapeo.

‚úÖ **Seguridad del Hilo Principal**
Los Repositorios no deben realizar operaciones de larga duraci√≥n en el hilo principal. Pero tampoco deben ser responsables de la hiler√≠a. Si se requiere cambio de hilos, esa responsabilidad pertenece a la Fuente de Datos que realiza la operaci√≥n. Si tu aplicaci√≥n omite clases de Fuente de Datos, es aceptable que el Repositorio maneje la hiler√≠a.

‚ùå **Contener L√≥gica de Negocio**
La l√≥gica de negocio pertenece a la Capa de Dominio (Casos de Uso)**.** Los Repositorios son responsables de la orquestaci√≥n de datos, no de la toma de decisiones sobre c√≥mo deben usarse los datos.

‚ùå **Depender de Casos de Uso**
Esto crea una dependencia circular entre las capas de Datos y Dominio. En su lugar, deja que el Caso de Uso re√∫na todas las entradas requeridas antes de llamar al Repositorio.

‚ùå **Depender de Otros Repositorios**
Los Repositorios no deben depender de otros Repositorios. Cada Repositorio es responsable de manejar una Fuente de Datos espec√≠fica o tipo de dato. Introducir dependencias entre repositorios conduce a un acoplamiento estrecho. Si necesitas datos de m√∫ltiples fuentes, agr√©galos en un Caso de Uso en la Capa de Dominio.

### 3. Cach√© en Repositorios

Los Repositorios son un buen lugar para activar el almacenamiento en cach√©, siempre y cuando no se necesite aplicar l√≥gica de negocio antes de que se almacenen los datos. Si una respuesta de API REST es directamente cacheable, el Repositorio debe **almacenarla inmediatamente despu√©s de la recuperaci√≥n**.

```kotlin
internal class NavigationRepositoryImpl @Inject constructor(
    private val navigationRemoteDataSource: NavigationRemoteDataSource, // interface
    private val navigationLocalDataSource: NavigationLocalDataSource, // interface
) : NavigationRepository {

    override suspend fun getNavigationApi(): Result<Unit> {
        return when (val result = navigationRemoteDataSource.getNavigationApi()) {
            is Result.Success -> insertNavigationToCache(result.data)
            is Result.Error -> Result.Error(result.error)
        }
    }

    private suspend fun insertNavigationToCache(navigationModel: NavigationModel): Result<Unit> {
        return when (val result = navigationLocalDataSource.insert(navigationModel) {
            is Result.Success -> Result.Success(Unit)
            is Result.Error -> Result.Error(result.error)
        }
    }
    
}
```

En este ejemplo, el Repositorio delega tanto la obtenci√≥n remota como la inserci√≥n en cach√© a sus respectivas Fuentes de Datos. No maneja _c√≥mo_ se hacen esas operaciones, solo _cu√°ndo_ y _en qu√© orden_ ocurren.

### Procesando Datos Antes de Cachear

Si los datos necesitan ser transformados, validados o enmendados antes de ser cacheados. Por ejemplo, si la l√≥gica de negocio determina qu√© partes de los datos almacenar o si deben combinarse con otra fuente, entonces ese trabajo debe ocurrir en la Capa de Dominio, dentro de un Caso de Uso.

Deja que el Caso de Uso realice las transformaciones necesarias, luego pasa el resultado final de dominio de vuelta al Repositorio para ser persistido. Esto mantiene la l√≥gica de negocio fuera de la Capa de Datos y asegura una separaci√≥n de preocupaciones.

### Estrategias de Cach√©

El almacenamiento en cach√© es una parte clave de la Capa de Datos, pero no hay un enfoque √∫nico para todos. Tu estrategia debe depender de cu√°n frescos necesiten ser los datos. Por ejemplo, contenido est√°tico como configuraciones de la app se beneficia del cach√©, mientras que datos en tiempo real (por ejemplo, carritos de compra, niveles de stock) no deben ser cacheados para evitar servir informaci√≥n desactualizada. üîó [Consulta la documentaci√≥n oficial de Android Developers](https://developer.android.com/topic/architecture/data-layer/offline-first) para una visi√≥n completa de las estrategias de cach√© en Android.

### 4. M√∫ltiples Repositorios y Agregaci√≥n de Dependencias

Los Repositorios no deben contener l√≥gica de negocio o comunicaci√≥n entre repositorios. Permitir que los Repositorios se comuniquen directamente entre s√≠ puede conducir a un acoplamiento estrecho. Si necesitas agregar datos de m√∫ltiples Repositorios utiliza un Caso de Uso.

**Por Qu√© los Casos de Uso Agregan Datos**
Cuando una pantalla o caracter√≠stica necesita datos de m√°s de una fuente, el Caso de Uso sabe c√≥mo coordinar esas llamadas, aplicar cualquier l√≥gica de negocio y devolver el resultado de una manera que tenga sentido para la Capa de Presentaci√≥n. Esto mantiene la arquitectura modular y m√°s f√°cil de mantener a medida que la aplicaci√≥n crece.

‚ùå **Ejemplo Incorrecto: Agregando Datos en un Repositorio**

```kotlin
internal class StockRepositoryImpl @Inject constructor(
    private val pricingRepository: PricingRepository, // ‚ùå Dependencia entre repositorios
    private val stockRemoteDataSource: StockRemoteDataSource
) : StockRepository {

    override suspend fun getStockSummary(productId: String): StockSummary {
        val price = pricingRepository.getPriceForProduct(productId) // ‚ùå No relacionado con stock
        val stockLevel = stockRemoteDataSource.getStockLevel(productId)
        return StockSummary(productId, stockLevel, price)
    }
}
```

### **¬øPor qu√© es esto incorrecto?**

‚ùå **Viola el Principio de Responsabilidad √önica (SRP)**
El Repositorio es ahora responsable de obtener datos de stock **y** precio, lo que introduce un acoplamiento innecesario.

‚ùå **Acopla Estrechamente los Repositorios**
Si PricingRepository cambia, StockRepository podr√≠a necesitar modificaciones, aunque no est√© relacionado con datos de precios.

‚ùå **Aumenta la Complejidad de las Pruebas**
Las pruebas unitarias para StockRepository ahora necesitan simular o falsificar el PricingRepository, haciendo las pruebas m√°s engorrosas.

‚úÖ **Ejemplo Correcto: Agregar Datos en el Caso de Uso**
El enfoque correcto es dejar que los Repositorios se centren en sus propias preocupaciones de datos y mover cualquier l√≥gica de coordinaci√≥n o transformaci√≥n a un Caso de Uso.

```kotlin
internal class GetStockSummaryUseCase @Inject constructor(
    private val pricingRepository: PricingRepository, // interface
    private val stockRepository: StockRepository // interface
) {
    suspend operator fun invoke(productId: String): StockSummary {
        val price = pricingRepository.getPriceForProduct(productId)
        val stockLevel = stockRepository.getStockLevel(productId)
        return StockSummary(productId, stockLevel, price)
        // ‚úÖ Mantiene las responsabilidades claramente separadas
    }
}
```

### **¬øPor qu√© es esto correcto?**

‚úÖ **Los Repositorios permanecen independientes**
Cada repositorio hace una cosa (stock o precio), y no depende del otro.

‚úÖ **El Caso de Uso Maneja la Coordinaci√≥n**
El GetStockSummaryUseCase orquesta los datos de ambos Repositorios, aplica cualquier regla de negocio (si es necesario), y devuelve el resultado final a la **Capa de Presentaci√≥n**.

‚úÖ **M√°s F√°cil de Probar y Mantener**
Los Repositorios son m√°s f√°ciles de probar en aislamiento, y los cambios en la l√≥gica de precios no impactar√°n al StockRepository.

> üîó [Consulta el art√≠culo anterior de la serie](/asos-techblog/android-clean-architecture-understanding-the-domain-layer-28bf81d83ef7) para una inmersi√≥n profunda en la Capa de Dominio y Casos de Uso.

## **Entendiendo las Fuentes de Datos**

### 1. ¬øQu√© es una Fuente de Datos?

Una Fuente de Datos es responsable de acceder y gestionar datos de una ubicaci√≥n espec√≠fica, ya sea a trav√©s de la red, en almacenamiento local o desde una cach√© en memoria. Abstrae los detalles de c√≥mo se recuperan o persisten esos datos, ofreciendo una interfaz enfocada para realizar operaciones CRUD.

Las Fuentes de Datos tambi√©n manejan la transformaci√≥n de datos, mapeando respuestas en bruto (como DTOs o entidades de base de datos) en modelos amigables con el dominio antes de pasarlos aguas abajo.

> üí° Si tu arquitectura no usa clases de Fuente de Datos expl√≠citas, entonces el trabajo de mapeo y transformaci√≥n usualmente se desplazar√° al Repositorio. Aunque eso puede funcionar para apps m√°s peque√±as, tener clases de Fuente de Datos separadas ofrece l√≠mites m√°s claros y mejor escalabilidad.

### 2. Tipos de Fuentes de Datos

T√≠picamente hay dos tipos principales de Fuentes de Datos

**Fuentes de Datos Remotas**
Manejan la comunicaci√≥n con APIs remotas. Son responsables de enviar solicitudes, analizar respuestas y mapear resultados de API en modelos de dominio.

**Fuentes de Datos Locales**
Gestionan el acceso al almacenamiento en el dispositivo, como bases de datos, sistemas de archivos o almacenes de preferencias. Estas fuentes manejan la persistencia local, y t√≠picamente usan herramientas como Room o DataStore.

### 3. C√≥mo Estructurar Fuentes de Datos

Cada Fuente de Datos debe centrarse en una sola entidad de datos. Por ejemplo, un `UserRemoteDataSourceImpl` trabajar√≠a con un `UserDto`, mientras que un `UserLocalDataSourceImpl` manejar√≠a una `UserEntity` de Room.

Aunque es ideal separar por tipo de almacenamiento (p.ej. Room vs. DataStore), tambi√©n es perfectamente v√°lido combinarlos detr√°s de una √∫nica interfaz de fuente de datos local, siempre y cuando las responsabilidades permanezcan cohesivas y el Repositorio no est√© expuesto a los detalles de almacenamiento subyacentes.

### 4. Nombrando Fuentes de Datos

El nombrado de Fuentes de Datos debe seguir el formato:

> **_\[Tipo de Dato]_** + _\[_tipo de fuente_\]_ + _DataSource_

Ejemplos:
‚úÖ `**_Bag_**_Remote_DataSource`
‚úÖ `**Checkout**_Local_DataSource`

> _üö´_ **_Evita nombres de interfaz espec√≠ficos de implementaci√≥n_**_(p.ej._ `_BagSharedPreferencesDataSource_`_)._ Los Repositorios no deben ser conscientes del mecanismo de almacenamiento subyacente, permitiendo flexibilidad en cambios futuros.

## Mejores Pr√°cticas para Implementar Fuentes de Datos

### 1. Separaci√≥n de Preocupaciones

Una Fuente de Datos nunca debe ser accedida directamente por otras capas de tu aplicaci√≥n, como Casos de Uso o ViewModels. En su lugar, todos los datos fluyen a trav√©s de un Repositorio, que sirve como un puente entre las Fuentes de Datos y la Capa de Dominio.

Mantener las Fuentes de Datos detr√°s de interfaces te da la flexibilidad de intercambiar mecanismos de almacenamiento o APIs REST sin impactar al resto de la aplicaci√≥n. Por ejemplo, cambiar de Firebase a una API REST o de Room a DataStore no deber√≠a requerir cambios fuera de la clase Implementaci√≥n de Fuente de Datos. Tambi√©n facilita pruebas m√°s f√°ciles permiti√©ndonos intercambiar las implementaciones reales por falsificaciones de prueba.

### 2. Mapeo

El mapeo entre DTOs, Entidades y Modelos de Dominio es necesario para mantener la separaci√≥n de preocupaciones y evitar acoplamiento estrecho entre capas.

**¬øD√≥nde Deber√≠a Ocurrir el Mapeo?**
El mapeo deber√≠a ocurrir idealmente dentro de las clases de Fuente de Datos. Esto asegura que para cuando los datos lleguen al Repositorio, ya est√©n en forma de Modelo de Dominio. Esto mantiene a los Repositorios centrados puramente en la orquestaci√≥n.

Si tu proyecto no tiene clases de Fuente de Datos expl√≠citas, es aceptable que el Repositorio asuma esta responsabilidad. Si tus Repositorios se vuelven hinchados y complejos, considera mover la l√≥gica de mapeo a la Fuente de Datos.

**¬øC√≥mo Deber√≠as Mapear?**
Hay dos enfoques est√°ndar para el mapeo:

*   Usar una clase mapper dedicada
*   Usar una funci√≥n de extensi√≥n de Kotlin

**¬øCu√°l Deber√≠as Elegir?**

*   Si el mapper tiene dependencias usa una clase mapper independiente.
*   Si el mapper no tiene dependencias usa una funci√≥n de extensi√≥n de Kotlin.

**Funciones de Extensi√≥n de Mapeo**
Cuando uses funciones de extensi√≥n para mapeo, col√≥calas en un archivo Kotlin claramente nombrado como UserMappingExtensionFunctions.kt, ubicado en el paquete /data/mapper. Este archivo contiene funciones de mapeo entre un UserDto, UserModel y UserEntity. Estas funciones deben ser **probadas unitariamente**, igual que los mappers independientes. Crea una clase de prueba correspondiente junto a ellas.

```kotlin
// Ejemplo de una funci√≥n de extensi√≥n de mapeo de Kotlin
fun UserDto.toDomain() = User(
    id = this.id,
    name = this.name,
    email = this.email
)

// Ejemplo de una clase mapper independiente
class UserDtoToDomainMapper @Inject constructor() {
    fun map(dto: UserDto): User {
        return User(
            id = dto.id,
            name = dto.name,
            email = dto.email
        )
    }
}
```

> üí° Evita usar valores por defecto para enmascarar datos faltantes (p.ej. cadenas vac√≠as o valores cero) a menos que est√©s manejando intencionalmente campos opcionales. Fallar silenciosamente puede conducir a errores dif√≠ciles de rastrear en la UI o Capa de Dominio.

### 3. Manejo de Errores y Registro (Logging)

Las Fuentes de Datos son el lugar correcto para capturar y registrar excepciones. Sin embargo, nunca deben exponer excepciones en bruto al Repositorio o Capa de Dominio. En su lugar, deben mapear esas excepciones a tipos de error amigables con el dominio.

Esto permite al Repositorio pasar informaci√≥n de error estructurada y significativa a la Capa de Presentaci√≥n, que luego puede responder de maneras que mejoren la experiencia del usuario. Por ejemplo, mostrando un mensaje de error, deshabilitando un bot√≥n o activando un reintento.

El principio clave aqu√≠ es que las excepciones en bruto como c√≥digos de error HTTP nunca deben exponerse directamente a las Capas de Dominio o Presentaci√≥n. En su lugar, las excepciones deben mapearse a tipos de error espec√≠ficos que tengan sentido en el dominio de la aplicaci√≥n.

**Usando una Clase Result Personalizada**
Usamos una interfaz sellada personalizada llamada `BagResult` para representar el resultado de una operaci√≥n. Esto ayuda a unificar la forma en que manejamos tanto el √©xito como el fracaso.

```kotlin
// Ejemplo de una clase Result personalizada
sealed interface BagResult {
    data class Success(val data: Bag) : BagResult
    data class Error(val error: BagError) : BagResult
}
```

*   **Success**: Contiene los datos devueltos de la operaci√≥n (de una llamada a API REST o consulta de base de datos).
*   **Error**: Contiene un `BagError`, que es una clase amigable con el dominio que contiene errores predefinidos que podr√≠an ocurrir al interactuar con la API de Bolsa.

La clase `BagResult` nos permite manejar tanto el √©xito como el fracaso de una operaci√≥n de manera consistente, simplificando la propagaci√≥n de errores a trav√©s de diferentes capas de la app.

**Mapeando a Tipos de Error Espec√≠ficos del Dominio**
Para mantener el manejo de errores en la capa de datos claro y enfocado en el dominio, usamos una **enum class** para definir tipos de error. Aqu√≠ hay un ejemplo de c√≥mo definimos una clase de error personalizada para manejar diferentes tipos de errores relacionados con una API REST de bolsa de compras.

```kotlin
enum class BagError {
    NetworkError,
    InvalidRequest,
    Unauthorized,
    Forbidden,
    NotFound,
    InternalServerError,
    UndefinedError
    // se pueden agregar casos adicionales...
}
```

El enum `BagError` captura condiciones de error espec√≠ficas que podr√≠an ocurrir en el contexto de obtener o gestionar datos de la bolsa. El beneficio de usar tal enfoque es que podemos diferenciar claramente entre varios tipos de errores (p.ej. problemas de red, solicitudes inv√°lidas o errores del servidor). Esto hace que sea m√°s f√°cil responder a los errores apropiadamente en la UI, como mostrar mensajes de error relevantes, redirigir al usuario a la pantalla de inicio de sesi√≥n, etc.

En este caso, usamos un `BagErrorMapper.kt` con una funci√≥n de nivel superior para mapear excepciones en bruto al tipo de error espec√≠fico del dominio:

```kotlin
internal fun mapToBagError(exception: Throwable): BagError {
    return when (exception) {
        is IOException -> BagError.NetworkError
        is HttpException -> mapHttpErrorCode(exception)
        else -> BagError.UndefinedError
    }
      
    private fun mapHttpErrorCode(exception: HttpException): BagError {
        return when (exception.code()) {
            400 -> BagError.InvalidRequest
            401 -> BagError.Unauthorized
            403 -> BagError.Forbidden
            404 -> BagError.NotFound
            in 500..599 -> BagError.InternalServerError
            else -> BagError.UndefinedError
        }
    }
}
```

Al manejar errores en el nivel de Fuente de Datos, nosotros:
‚úÖ Aseguramos consistencia registrando errores en el punto de fallo.
‚úÖ Proporcionamos errores significativos a las capas de Dominio y Presentaci√≥n.
‚úÖ Tipos de error predecibles facilitan pruebas m√°s f√°ciles.
‚úÖ Evitamos registros redundantes a trav√©s de m√∫ltiples Repositorios.
‚úÖ Mantenemos los Repositorios centrados en la orquestaci√≥n.

### Manejo de CancellationException

> ‚ö†Ô∏è **Importante**: Si usas runCatching, asegura que expl√≠citamente **relanzas CancellationExceptions**. Si una Corrutina se cancela debido a un tiempo de espera o cancelaci√≥n de trabajo, debe propagarse aguas abajo en lugar de ser tragada. No hacerlo puede conducir a un comportamiento inesperado como estados de carga infinita o UIs que no responden.

Usamos una funci√≥n auxiliar para relanzar autom√°ticamente la CancellationException.

```kotlin
suspend fun <R> runSuspendCatching(block: suspend () -> R): Result<R> {
    return try {
        Result.success(block())
    } catch(c: CancellationException) {
        throw c
    } catch (e: Throwable) {
        Result.failure(e)
    }
}
```

### 4. Inyecci√≥n de Dependencias

Usa inyecci√≥n de constructor est√°ndar para cualquier Fuente de Datos que se requiera inmediatamente. Si la Fuente de Datos es opcional o raramente usada (una cach√© que solo se golpea en ciertos flujos), puedes usar inyecci√≥n lazy. Esto difiere la instanciaci√≥n hasta que realmente se necesita, lo que ayuda a reducir el uso de memoria y mejorar el tiempo de inicio de la app.

### 5. Hiler√≠a (Threading)

En Corrutinas, bibliotecas como Retrofit, Ktor, Room y DataStore usan internamente `Dispatchers.IO` para operaciones de red/disco as√≠ que no es necesario cambiar hilos manualmente. Sin embargo, si est√°s leyendo/escribiendo de archivos de almacenamiento local o cualquier otra soluci√≥n de almacenamiento personalizada necesitar√°s cambiar manualmente a un hilo en segundo plano usando Dispatcher.IO en la clase DataSource antes de que ocurra la operaci√≥n.

## Implementando Fuentes de Datos Remotas

Las Fuentes de Datos Remotas manejan la comunicaci√≥n con fuentes remotas, m√°s com√∫nmente APIs REST. Bibliotecas como Retrofit o Ktor se usan com√∫nmente para manejar solicitudes de red. Cada Fuente de Datos Remota debe definir una interfaz que especifique c√≥mo interact√∫a con la API REST.

### 1. Nombrando Interfaces de API REST

Las interfaces de API REST deben seguir el formato:

> **_\[Caracter√≠stica]_** _\+ Api_

Ejemplos:
‚úÖ `**Bag**Api`
‚úÖ `**Checkout**Api`

```kotlin
interface BagApi {
    @GET("bags/{bagId}")
    suspend fun getBagByBagId(
        @Path("bagId") bagId: String,
    ): BagDto
}
```

### **2.** ‚ùå **Ejemplo Incorrecto de una Fuente de Datos Remota**

Aqu√≠ hay una implementaci√≥n de Fuente de Datos Remota que viola los l√≠mites de Clean Architecture e introduce complejidad innecesaria.

```kotlin
internal class BagRemoteDataSourceImpl @Inject constructor(
    private val bagApi: BagApi, // interface
    private val bagDtoToDomainMapper: BagDtoToDomainMapper,
    private val userRepository: UserRepository, // ‚ùå No permitido
    @IODispatcher private val ioDispatcher: CoroutineDispatcher // ‚ùå Innecesario
) : BagRemoteDataSource {

    override suspend fun getBag(): BagResult<Bag> {
      return withContext(ioDispatcher) { // ‚ùå Retrofit maneja la hiler√≠a internamente
          runCatching { // ‚ùå Usa runSuspendCatching para relanzar auto CancellationExceptions
            bagApi.getBag(userRepository.getUserId()) // ‚ùå El id de usuario debe pasarse en getBag()
          }.fold(
              onSuccess = { result ->
                  BagResult.Success(bagDtoToDomainMapper.map(result)) // ‚ùå Cualquier error de json malformado puede bloquear la app
              }
          },
              onFailure = { exception ->
                  val bagError = mapToBagError(exception)
                  // ‚ùå Sin registro de errores a herramientas de reporte de fallos
                  BagResult.Error(bagError)
              }
           )
        }
    }
}
```

### ¬øPor qu√© es esto incorrecto?

‚ùå **Dependencia Circular**
La Fuente de Datos depende de un Repositorio (`UserRepository`). Esto rompe el flujo de datos unidireccional y crea una dependencia circular. Valores como el id de usuario deben ser recuperados por la Capa de Dominio y pasados como par√°metros.

‚ùå **Gesti√≥n de Hilos Innecesaria**
Se inyecta y usa un `CoroutineDispatcher` expl√≠cito v√≠a `withContext`. Esto es innecesario cuando se usa Retrofit con Corrutinas, ya que Retrofit ya maneja llamadas de red fuera del hilo principal.

‚ùå **Sin Registro de Errores**
Es importante que registremos errores usando herramientas de reporte de fallos para que podamos monitorear las APIs REST en producci√≥n.

‚ùå **Errores de Mapeo No Capturados**
Cualquier NullPointerException lanzado durante el mapeo debido a JSON malformado bloquear√° la app ya que el mapeo ocurre fuera del runCatching. Un ejemplo de esto podr√≠a ser un problema con el contrato que no se respeta y devuelve datos diferentes a los esperados.

‚ùå **Usando runCatching**
Es preferible usar la funci√≥n auxiliar runSuspendCatching mencionada anteriormente ya que esto relanzar√° CancellationExceptions por ti, negando la necesidad de que los desarrolladores recuerden hacer esto manualmente.

### 3. ‚úÖ Ejemplo Correcto de una Fuente de Datos Remota

La siguiente versi√≥n respeta los principios de Clean Architecture y evita anti-patrones.

```kotlin
internal class BagRemoteDataSourceImpl @Inject constructor(
    private val bagApi: BagApi, // interface
    private val crashLogger: CrashLogger, // interface
    private val eventLogger: EventLogger, // interface
    private val bagDtoToDomainMapper: BagDtoToDomainMapper
) : BagRemoteDataSource {

    override suspend fun getBag(userId: String): BagResult<Bag> { // ‚úÖ Id de usuario pasado como param
      return runSuspendCatching { // ‚úÖ runSuspendCatching relanza CancellationExceptions
          val result = bagApi.getBag(userId) // ‚úÖ Sin cambio de hilo
          bagDtoToDomainMapper.map(result) // ‚úÖ Mapea en el runSuspendCatching para capturar json malformado
        }.fold(
            onSuccess = { mappedResult ->
                BagResult.Success(mappedResult)
            }
        },
            onFailure = { exception ->
                val bagError = mapToBagError(exception) // ‚úÖ Usa funci√≥n mapper para convertir throwable en bruto a tipo de error de dominio
                logError(exception, bagError) // ‚úÖ Registra excepciones
                BagResult.Error(bagError)
            }
        )
    }

    private fun logError(
        exception: Throwable,
        bagError: BagError
    ) {
        Log.e(this.javaClass.simpleName, exception.message.toString())
        crashLogger.logException(exception)
          
        eventLogger.logEvent(
            eventAttributes = mapOf(
                NAME to bagError.name,
                DESCRIPTION to exception.message.orEmpty()
            )
        )
    }
}
```

### ¬øPor qu√© es esto correcto?

‚úÖ **Sin Dependencias Circulares**
El id de usuario se pasa como un par√°metro en lugar de obtenerse de un Repositorio, lo cual viola los principios de Clean Architecture. Esto mantiene la Fuente de Datos libre de l√≥gica de negocio y dependencias externas.

‚úÖ **Delegaci√≥n de Hiler√≠a**
La hiler√≠a se delega y gestiona internamente por Retrofit, eliminando la necesidad de inyectar un despachador o cambiar hilos manualmente. Esto simplifica la configuraci√≥n y las pruebas.

‚úÖ **Mapeo**
El DTO se convierte a un modelo de dominio antes de que el resultado se devuelva al Repositorio.

‚úÖ **Registro de Errores**
Los errores se registran en la fuente y se mapean a tipos espec√≠ficos del dominio permitiendo el monitoreo en producci√≥n. Las herramientas de registro se abstraen a trav√©s de interfaces desacopladas. Esto hace que la implementaci√≥n sea f√°cil de probar y reemplazar si las herramientas de registro cambian en el futuro.

‚úÖ **Usa runSuspendCatching**
Usar runSuspendCatching relanza CancellationExceptions por nosotros autom√°ticamente y preserva la concurrencia estructurada.

## Implementando Fuentes de Datos Locales

Las Fuentes de Datos Locales son responsables de interactuar con datos almacenados en el dispositivo. Siguen la misma estructura de Clean Architecture que las Fuentes de Datos Remotas pero en su lugar interact√∫an con mecanismos de almacenamiento local como bases de datos, archivos o almacenes de clave-valor.

### 1. Opciones de Almacenamiento

La elecci√≥n del almacenamiento local depende del tipo de datos y c√≥mo se acceder√° a ellos:

*   **Room / SQLDelight**
    Usa una base de datos cuando tus datos sean estructurados, relacionales y requieran persistencia a largo plazo. Las bases de datos permiten consultas complejas como uniones, filtros y transacciones.
*   **DataStore**
    DataStore es el reemplazo moderno respaldado por Corrutinas para SharedPreferences. Es el m√°s adecuado para peque√±os conjuntos de datos como configuraciones de usuario, banderas o preferencias que no requieren consultas complejas.
*   **Archivos (JSON, CSV, XML, etc)**
    Los archivos son adecuados para configuraciones, registros o datos exportables que no requieren consultas.
*   **Cach√© en Memoria**
    Este es almacenamiento temporal para objetos de datos accedidos frecuentemente que no esperan persistir si la app se mata o reinicia.

> ‚ö†Ô∏è Ten cuidado con las cach√©s en memoria. Si la app se coloca en segundo plano y ocurre una muerte de proceso, el sistema puede matar el proceso para reclamar recursos. Cuando el usuario regresa a la app, intentar√° restaurar el estado anterior, pero la cach√© en memoria se habr√° borrado. Esto puede resultar en estados de UI no intencionados y bloqueos.

### 2. Nombrando Interfaces DAO

Cuando usas una base de datos como Room, un DAO es donde defines c√≥mo la app interact√∫a con las tablas locales (inserciones, consultas, borrados, etc).

El nombrado de interfaz DAO debe seguir el formato:

> **_\[Tipo de Dato]_** _\+ Dao_

Ejemplos:
‚úÖ `**Navigation**Dao`
‚úÖ `**SearchHistory**Dao`

```kotlin
@Dao
interface NavigationDao {

    @Query("SELECT * FROM navigation WHERE id = :id")
    suspend fun getNavigation(id: String): NavigationEntity?

    @Insert(onConflict = OnConflictStrategy.REPLACE) // reemplaza entradas duplicadas
    suspend fun insertNavigation(navigation: NavigationEntity)

    @Delete
    suspend fun deleteNavigation(navigation: NavigationEntity)
}
```

> üí° Los m√©todos DAO usando funciones suspend corren autom√°ticamente en un hilo en segundo plano gracias al soporte de Corrutinas de Room, as√≠ que no necesitas gestionar expl√≠citamente la hiler√≠a.

### 3. Ejemplo de Fuente de Datos Local

Las Fuentes de Datos Locales y Remotas comparten una estructura similar: inyecci√≥n de dependencias, manejo de errores, envoltura de resultados y mapeo a modelos de dominio. Para estos patrones compartidos, consulta la secci√≥n de Fuente de Datos Remota arriba. La diferencia clave es que en lugar de inyectar una interfaz de API REST, inyectas la interfaz DAO cuando usas Room, o una interfaz apropiada cuando trabajas con DataStore u otros mecanismos de almacenamiento local.

## Entendiendo los Modelos de la Capa de Datos

En la Capa de Datos, se usan dos tipos principales de modelos:

*   **DTOs** representan modelos de respuesta de API REST. Deben permanecer inmutables y mapear estrechamente a la respuesta de la API REST.
*   **Entidades** representan tablas de base de datos y persisten datos dentro de la base de datos local. T√≠picamente se anotan con `@Entity` cuando se usa Room. üîó [Consulta la documentaci√≥n oficial de Room](https://developer.android.com/training/data-storage/room/defining-data) para m√°s detalles sobre estructuraci√≥n de Entidades.

### 1. Nombrando Modelos de Datos

Los modelos de datos deben seguir el formato:

> **_\[Tipo de Dato]_** _\+_ Dto/Entity

Por ejemplo:
‚úÖ `**Navigation**Dto`
‚úÖ `**Navigation**Entity`

### 2. Mejores Pr√°cticas para DTOs

‚úÖ **Clases de Datos Inmutables**
Haz los DTOs inmutables usando solo propiedades `val`. Esto ayuda a evitar cambios accidentales y mantiene tus datos consistentes.

‚úÖ **Manejo de Nulabilidad**
Coincide la nulabilidad de las propiedades DTO con la especificaci√≥n de la API REST. Maneja cualquier nulo durante el mapeo para evitar bloqueos m√°s tarde en la app.

‚úÖ **Mappers para Transformaci√≥n**
Usa un mapper dedicado para transformar DTOs a Entidades o Modelos de Dominio. Esto asegura que ning√∫n detalle innecesario de la API REST se filtre a las otras capas.

‚úÖ **Serializaci√≥n y Mapeo de Campos**
Si tus nombres de campo JSON difieren de tus nombres de propiedad Kotlin, usa la anotaci√≥n `@SerialName` de Kotlin Serialization. Kotlin Serialization es preferido sobre Gson debido a su mejor rendimiento y soporte nativo de Kotlin.

> ‚ö†Ô∏è Ten en cuenta que `@SerialName` ayuda a prevenir la ofuscaci√≥n de propiedades cuando se usan herramientas como R8.

‚úÖ **Evita Campos Espec√≠ficos de API**
Excluye cualquier campo de metadatos de API como c√≥digos de estado o marcas de tiempo que no se necesiten. Mant√©n los DTOs centrados solo en los datos requeridos.

‚úÖ **Separaci√≥n de Preocupaciones**
Los DTOs deben centrarse solo en la representaci√≥n de datos. Evita incrustar l√≥gica de negocio o incluir funciones de mapeo dentro de clases DTO.

```kotlin
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
  
@Serializable
data class NavigationDto(
    @SerialName("navigation_id")
    val id: String?,
    @SerialName("navigation_title")
    val title: String?,
    @SerialName("navigation_url")
    val url: String?
)
```

## Estructura de Paquetes

A continuaci√≥n se muestra un ejemplo de c√≥mo se puede estructurar la Capa de Datos. Esta es una representaci√≥n simple y podr√≠a cambiar en una app modularizada.

```text
üìÇ data
 ‚îú‚îÄ‚îÄ üìÇ local
 ‚îÇ    ‚îú‚îÄ‚îÄ BagDao.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagEntity.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagEntityMapper.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagLocalDataSourceImpl.kt
 ‚îÇ
 ‚îú‚îÄ‚îÄ üìÇ remote
 ‚îÇ    ‚îú‚îÄ‚îÄ BagApi.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagDto.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagErrorMapper.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagDtoMapper.kt
 ‚îÇ    ‚îú‚îÄ‚îÄ BagRemoteDataSourceImpl.kt
 ‚îÇ
 ‚îú‚îÄ‚îÄ üìÇ repository
 ‚îÇ    ‚îú‚îÄ‚îÄ BagLocalDataSource.kt  // interface
 ‚îÇ    ‚îú‚îÄ‚îÄ BagRemoteDataSource.kt. // interface
 ‚îÇ    ‚îú‚îÄ‚îÄ BagRepositoryImpl.kt
  
üìÇ domain
 ‚îú‚îÄ‚îÄ üìÇ repository
 ‚îÇ    ‚îú‚îÄ‚îÄ BagRepository.kt // interface
```
