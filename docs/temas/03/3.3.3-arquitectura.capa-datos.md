## 3.3.3 üß† **Capas de Dominio y Datos.** El Cerebro y la Memoria

Si la capa de UI es la "cara bonita" de la aplicaci√≥n, las capas de **Dominio** y **Datos** son el cerebro y la memoria que hacen que todo funcione. Sin ellas, nuestra app ser√≠a una c√°scara vac√≠a.

---

### üß± La Capa de Datos (Data Layer)

Es la base de la pir√°mide. Su responsabilidad es **manejar los datos de la aplicaci√≥n**.
¬øDe d√≥nde vienen los datos? ¬øC√≥mo se guardan? ¬øQu√© pasa si no hay internet? La UI no deber√≠a preocuparse por nada de esto; esa es tarea exclusiva de la Capa de Datos.

Se compone de dos piezas clave:

#### 1. Data Sources (Fuentes de Datos)

Son las clases de "bajo nivel" que saben hablar con una fuente espec√≠fica.

*   **Remote Data Source**: Sabe hablar con internet (APIs REST, Firebase, GraphQl).
*   **Local Data Source**: Sabe hablar con el almacenamiento del tel√©fono (Base de Datos Room, DataStore, Archivos).

#### 2. Repositorios (Repositories)

Son los **gestores** o mediadores. Es la parte m√°s importante de esta capa.
El resto de la aplicaci√≥n (el Dominio o la UI) **NUNCA** deber√≠a hablar directamente con un Data Source. Siempre deben pedirle los datos al Repositorio.

!!! info "üìö La Analog√≠a del Bibliotecario"

    Imagina que vas a una biblioteca a por un libro ("Los Datos").
    T√∫ no vas al almac√©n del s√≥tano ni llamas a la editorial. T√∫ hablas con el **Bibliotecario (Repositorio)**.

    *   T√∫ le pides el libro.
    *   El bibliotecario mira si lo tiene a mano en el mostrador (**Cach√© en memoria**).
    *   Si no, baja al archivo a buscarlo (**Base de datos Local**).
    *   Si no est√°, llama a la editorial para pedir una copia (**Red/API**).

    A ti te da igual de d√≥nde lo haya sacado. T√∫ solo quer√≠as el libro y el bibliotecario te lo ha conseguido.

Esta estrategia se llama **Single Source of Truth (√önica Fuente de Verdad)**. El repositorio centraliza los datos para que nadie m√°s tenga que adivinar de d√≥nde vienen.

---

### üß† La Capa de Dominio (Domain Layer)

*Nota: Esta capa es opcional en apps muy sencillas, pero recomendada en cuanto la app crece.*

Es la capa que contiene la **L√≥gica de Negocio Pura**. Son las reglas del juego que hacen que tu app sea √∫nica, independientemente de si los botones son azules o rojos, o si los datos vienen de una API o de un Excel.

#### Casos de Uso (Use Cases / Interactors)
Son clases que encapsulan **una √∫nica acci√≥n** o tarea de negocio.
Su nombre debe describir exactamente lo que hacen (verbo + sustantivo + UseCase).

Ejemplos:

*   `LoginUserUseCase`
*   `FormatDateUseCase`
*   `GetLatestNewsUseCase`

**¬øPor qu√© usarlos?**

1.  **Reutilizaci√≥n**: Si varios ViewModels necesitan la misma l√≥gica (ej: formatear una fecha), no copias y pegas c√≥digo. Llamas al mismo UseCase.
2.  **Legibilidad**: Al abrir la carpeta de "Dominio", ves una lista de todo lo que HACE tu app ("Code screams architecture").
3.  **Independencia**: Los UseCases no saben nada de Android (ni de Views, ni de JSONs). Son c√≥digo Kotlin puro.

---

### üöÄ Ejemplo Pr√°ctico: App de Noticias

Vamos a ver c√≥mo se conectan todas las piezas, desde que el dato sale de internet hasta que llega al ViewModel.
Imagina una pantalla que muestra una lista de noticias recientes.

#### 1. Data Source (El especialista)
Primero, necesitamos alguien que sepa descargar datos de la API.
```kotlin
// Data Source (Retrofit)
interface NewsApiService {
    @GET("news")
    suspend fun fetchNews(): List<NewsDto> // Devuelve datos "feos" (DTOs) de la red
}
```

#### 2. Repository (El bibliotecario)

El repositorio coordina. En este caso simple, solo llama a la API, pero podr√≠a guardar en base de datos si quisi√©ramos modo offline.
```kotlin
class NewsRepository(
    private val api: NewsApiService
) {
    // Devuelve listas del Dominio (News), no DTOs de red. Limpia los datos.
    suspend fun getNews(): List<News> {
        return try {
            val apiData = api.fetchNews()
            apiData.map { it.toDomain() } // Mapea a objetos limpios
        } catch (e: Exception) {
            emptyList() // O manejar el error
        }
    }
}
```

#### 3. Use Case (La l√≥gica de negocio)
Queremos mostrar noticias, pero una regla de negocio dice: *"Solo mostrar noticias de las √∫ltimas 24h y ordenadas por fecha"*. El ViewModel no deber√≠a saber calcular esto.
```kotlin
class GetRecentNewsUseCase(
    private val repository: NewsRepository
) {
    // El operador 'invoke' permite llamar a la clase como si fuera una funci√≥n
    suspend operator fun invoke(): List<News> {
        val allNews = repository.getNews()
        
        // APLICAMOS L√ìGICA DE NEGOCIO AQU√ç
        return allNews
            .filter { it.date > ayer() }
            .sortedByDescending { it.date }
    }
}
```

#### 4. ViewModel (El consumidor)
El ViewModel es mucho m√°s simple ahora. Solo llama al UseCase y actualiza el estado.
```kotlin
class NewsViewModel(
    private val getRecentNewsUseCase: GetRecentNewsUseCase // Inyectamos el UseCase
) : ViewModel() {

    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState = _uiState.asStateFlow()

    fun loadNews() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            // ¬°Magia! Solo llamamos al caso de uso.
            // No sabemos si viene de red, base de datos o si se ha filtrado.
            val news = getRecentNewsUseCase() 
            
            _uiState.update { 
                it.copy(isLoading = false, news = news) 
            }
        }
    }
}
```

### Resumen del Flujo de Datos

1.  **UI (Composable)**: "Usuario pulsa bot√≥n 'Recargar'". Llama a `viewModel.loadNews()`.
2.  **ViewModel**: Llama a `GetRecentNewsUseCase()`.
3.  **UseCase**: Pide datos al `Repository` y aplica filtro de fecha.
4.  **Repository**: Pide datos al `NetworkDataSource` (API).
5.  **Data Source**: Descarga el JSON.

¬°Y el camino de vuelta es igual pero con los datos ya procesados! üîÑ
