# Operador When

Piensa en el operador `when` como el `switch` de Java que fue al gimnasio, leyó varios libros de filosofía y se volvió increíblemente flexible y poderoso.

Vamos a desglosar todos sus usos, desde el reemplazo directo del `switch` hasta sus capacidades más expresivas.

### 1. El Caso Básico: `when` como un `switch` Mejorado

Este es el uso más directo y fácil de entender. Se parece mucho a un `switch-case` de Java, pero con mejoras clave.

**Correlación con `switch` de Java:**
*   `case X:` se convierte en `X ->`.
*   `default:` se convierte en `else ->`.
*   **No necesitas `break;`**. ¡Esto elimina toda una categoría de bugs! La ejecución se detiene automáticamente al encontrar la primera rama que coincide.

**Ejemplo en Java:**
```java
int day = 2;
String dayName;
switch (day) {
    case 1:
        dayName = "Lunes";
        break;
    case 2:
        dayName = "Martes";
        break;
    case 3:
        dayName = "Miércoles";
        break;
    default:
        dayName = "Otro día";
        break;
}
System.out.println(dayName); // Martes
```

**Ejemplo equivalente en Kotlin:**
```kotlin
val day = 2
val dayName = when (day) {
    1 -> "Lunes"
    2 -> "Martes"
    3 -> "Miércoles"
    else -> "Otro día"
}
println(dayName) // Martes
```

**Ventajas inmediatas:**

*   Más limpio y conciso.
*   A prueba de errores de "fall-through" (olvidar un `break`).
*   **Puede ser una expresión:** Fíjate que asignamos el resultado del `when` directamente a la variable `dayName`. Esto es imposible con el `switch` de Java.

### 2. `when` como Expresión (Su primer superpoder)

Cuando usas `when` para devolver un valor (como en el ejemplo anterior), el compilador de Kotlin te exige que seas **exhaustivo**. Esto significa que *debes* cubrir todos los casos posibles.

Esto es increíblemente útil con `enum` o `sealed classes`.

**Ejemplo con un `enum`:**

```kotlin
enum class DayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }

fun getDayType(day: DayOfWeek): String {
    return when (day) {
        DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY -> "Día laboral"
        DayOfWeek.SATURDAY, DayOfWeek.SUNDAY -> "Fin de semana"
        // No se necesita 'else' aquí. ¿Por qué?
        // Porque hemos cubierto TODOS los valores posibles del enum.
        // Si añadieras un nuevo día al enum, ¡este código daría un error de compilación
        // hasta que lo manejes! Esto es seguridad en estado puro.
    }
}
```
**Nuevas características mostradas:**

*   **Combinar casos:** Puedes poner varias condiciones en la misma rama, separadas por comas (`,`).
*   **Exhaustividad:** El compilador te protege de olvidar casos.

### 3. `when` sin Argumento (El modo "if-else if" inteligente)

Aquí es donde `when` deja al `switch` de Java a años luz. Puedes usar `when` sin pasarle un objeto entre paréntesis. Cuando lo haces, cada rama se convierte en una condición booleana que se evalúa en orden.

**Correlación con Java:** 
Es como una cadena de `if-else if-else` más legible.

**Ejemplo:**

```kotlin
val name = "Pedro"
val score = 85

val description = when {
    name == "Admin" -> "El usuario es un administrador."
    score < 50 -> "Necesita mejorar."
    score >= 95 -> "¡Excelente trabajo!"
    name.startsWith("P") && score > 80 -> "Usuario destacado del grupo P."
    else -> "Usuario estándar."
}
println(description) // "Usuario destacado del grupo P."
```
Como puedes ver, cada rama es una expresión booleana arbitraria. Se ejecutará la primera que sea `true`.

### 4. `when` para Comprobar Tipos (con Smart Casting)

Este es uno de los usos más idiomáticos y potentes en Kotlin, especialmente para manejar datos heterogéneos.

**Ejemplo con `is` y `smart casting`:**
```kotlin
fun processObject(obj: Any) { // Any es como Object en Java
    when (obj) {
        is String -> {
            // Smart Casting: El compilador sabe que 'obj' es un String aquí.
            // Puedes llamar a métodos de String directamente sin castear.
            println("Es un String con longitud ${obj.length}")
        }
        is Int -> {
            println("Es un Entero con valor ${obj + 10}")
        }
        is Boolean -> {
            println("Es un Booleano: ${!obj}")
        }
        else -> {
            println("Es un tipo desconocido.")
        }
    }
}

processObject("Hola Kotlin") // "Es un String con longitud 11"
processObject(25)            // "Es un Entero con valor 35"
```
En la rama `is String`, `obj` es tratado automáticamente como un `String`. ¡No necesitas hacer `((String) obj).length()`!

### 5. `when` para Comprobar Rangos y Colecciones

Puedes usar el operador `in` para verificar si un valor está dentro de un rango o una colección.

**Ejemplo con `in`:**
```kotlin
val temperature = 25
val numbers = listOf(1, 3, 5, 7, 9)

when (temperature) {
    in -10..10 -> println("Hace frío.")
    in 11..22 -> println("Está templado.")
    in numbers -> println("¡Es un número impar de un solo dígito!")
    !in 0..100 -> println("Temperatura fuera del rango normal.") // También puedes usar !in
    else -> println("Temperatura agradable.")
}
// Salida: "Temperatura agradable."
```

### Tabla Comparativa: `when` (Kotlin) vs. `switch` (Java)

| Característica | `switch` (Java) | `when` (Kotlin) | Ventaja de Kotlin |
| :--- | :--- | :--- | :--- |
| **Sintaxis básica** | `case X: ...; break;` | `X -> ...` | Más concisa y segura (sin `break`). |
| **Valor por defecto** | `default:` | `else ->` | Nombres más intuitivos. |
| **Puede ser una expresión?** | No | **Sí** | Permite código más funcional y reduce la mutabilidad. |
| **Exhaustividad** | No forzada por el compilador | **Sí** (cuando se usa como expresión) | Código mucho más seguro y robusto. |
| **Tipos de condición** | Constantes (primitivos, `String`, `enum`) | **Cualquier objeto y expresión** | Inmensamente más flexible. |
| **Combinar casos** | Sí (con `case` apilados sin `break`) | **Sí** (usando comas `,`) | Más explícito y menos propenso a errores. |
| **Uso sin argumento** | No es posible | **Sí** (`when { ... }`) | Permite condiciones complejas, actuando como un `if-else` mejorado. |
| **Comprobar tipos** | No directamente (necesita `instanceof`) | **Sí** (con `is` y smart casting) | Código más limpio y seguro para polimorfismo. |
| **Comprobar rangos** | No directamente | **Sí** (con `in X..Y`) | Muy útil para lógica de rangos numéricos. |

En resumen, `when` en Kotlin comienza como un simple `switch` pero se expande para convertirse en una de las herramientas de control de flujo más versátiles y seguras que existen en cualquier lenguaje de programación moderno.