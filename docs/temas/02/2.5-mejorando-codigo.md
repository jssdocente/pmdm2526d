# **Mejorar para reestructurar el código en Jetpack Compose**

Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad también puede llevar a que el código crezca rápidamente y se vuelva desordenado.

## ✅ **Consejo 1: Crea un Composable Base para tu Aplicación**

**El Problema:** Ciertas configuraciones, como aplicar el tema de Material Design (`MaterialTheme`) o un color de fondo base con `Surface`, deben repetirse en cada pantalla y en cada `@Preview` para que se vean correctamente. Esto genera mucho código duplicado.

**La Solución:** Encapsula toda esta configuración común en un único *Composable* que sirva como la base para toda tu aplicación y tus vistas previas.

!!! example "Ejemplo Práctico"

    *   **Antes:** Tu `MainActivity` podría verse así, con la configuración directamente en `setContent`.

    ```kotlin
    class MainActivity : ComponentActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
                MyMoviesTheme { // Aplicando el tema
                    // Un contenedor Surface que usa el color de fondo del tema
                    Surface(color = MaterialTheme.colors.background) {
                        MainScreen() // La pantalla principal
                    }
                }
            }
        }
    }
    ```

    *   **Después:** Extraemos esa lógica a un nuevo *Composable*.

    ```kotlin
    // Archivo: ui/MyMoviesApp.kt

    @Composable
    fun MyMoviesApp(content: @Composable () -> Unit) {
        MyMoviesTheme {
            Surface(color = MaterialTheme.colors.background) {
                content() // Aquí se insertará el contenido específico de cada pantalla
            }
        }
    }

    // Ahora, tu MainActivity es mucho más limpia:
    class MainActivity : ComponentActivity() {
        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
                MyMoviesApp {
                    MainScreen()
                }
            }
        }
    }
    ```
    Ahora puedes reutilizar `MyMoviesApp` en todas tus `@Preview` para asegurar consistencia visual.

---

## ✅ **Consejo 2: Divide los Composables Grandes en Otros más Pequeños**

**El Problema:** Una función *Composable* puede crecer hasta tener cientos de líneas, mezclando la lógica de una barra de navegación, una lista, botones, etc. Esto dificulta la lectura y el mantenimiento.

**La Solución:** Aplica el principio de responsabilidad única. Crea funciones *Composable* pequeñas y con nombres descriptivos (semánticos) que hagan una sola cosa.

!!! example "Ejemplo Práctico"

    *   **Antes:** La `TopAppBar` se define directamente dentro del `Scaffold`, haciendo el código más denso.

    ```kotlin
    @Composable
    fun MainScreen() {
        Scaffold(
            topBar = {
                TopAppBar(
                    title = { Text(text = stringResource(id = R.string.app_name)) },
                    actions = {
                        IconButton(onClick = { /* TODO */ }) {
                            Icon(imageVector = Icons.Default.Search, contentDescription = null)
                        }
                        IconButton(onClick = { /* TODO */ }) {
                            Icon(imageVector = Icons.Default.Share, contentDescription = null)
                        }
                    }
                )
            }
        ) { padding ->
            // Contenido de la pantalla
        }
    }
    ```

    *   **Después:** Extraemos la `TopAppBar` a su propia función.

    ```kotlin
    // Archivo: ui/screens/main/MainAppBar.kt

    @Composable
    fun MainAppBar() {
        TopAppBar(
            title = { Text(text = stringResource(id = R.string.app_name)) },
            actions = {
                // Podríamos incluso extraer estos botones a otro Composable si fueran más complejos
                IconButton(onClick = { /* TODO */ }) {
                    Icon(imageVector = Icons.Default.Search, contentDescription = null)
                }
                IconButton(onClick = { /* TODO */ }) {
                    Icon(imageVector = Icons.Default.Share, contentDescription = null)
                }
            }
        )
    }

    // Ahora el Scaffold es mucho más legible:
    @Composable
    fun MainScreen() {
        Scaffold(
            topBar = { MainAppBar() }
        ) { padding ->
            // Contenido de la pantalla
        }
    }
    ```

## ✅ **Consejo 3: Crea Composables que Definan una Pantalla Completa**

**El Problema:** Si tu aplicación tiene varias pantallas (inicio, detalle, perfil), colocar la lógica de todas ellas en `MainActivity` es insostenible.

**La Solución:** Crea un *Composable* de alto nivel para cada pantalla. Esta función será la responsable de construir la UI completa de esa pantalla, incluyendo su `Scaffold`, `TopAppBar`, etc.

!!! example "Ejemplo Práctico"

    *   **Antes:** La lógica del `Scaffold` estaba directamente en `setContent` o en un *Composable* base.
    *   **Después:** Creamos un *Composable* que representa la pantalla principal.

    ```kotlin
    // Archivo: ui/screens/main/MainScreen.kt

    @Composable
    fun MainScreen() {
        // Scaffold define la estructura básica de la pantalla (barra superior, contenido, etc.)
        Scaffold(
            topBar = { MainAppBar() }
        ) { padding ->
            // El contenido principal de la pantalla es una lista de medios
            MediaList(modifier = Modifier.padding(padding))
        }
    }

    // El setContent de la Activity ahora solo llama al Composable de la pantalla.
    // Cuando implementes navegación, aquí decidirás qué pantalla mostrar.
    setContent {
        MyMoviesApp {
            MainScreen()
        }
    }
    ```

---

## ✅ **Consejo 4: Estructura los Paquetes de UI por Pantallas**

**El Problema:** Tener todos los archivos *Composable* en un mismo paquete (`ui`) funciona para proyectos pequeños, pero se vuelve un caos a medida que la aplicación crece.

**La Solución:** Organiza tus archivos en paquetes que reflejen la estructura de tu aplicación, generalmente por funcionalidad o por pantalla.

!!! example "Ejemplo Práctico"

    *   **Antes:** Todos los archivos de UI en un solo lugar.

    ```
    com.antonioleiva.mymovies
    └── ui
        ├── MainActivity.kt
        ├── MainAppBar.kt
        ├── MediaList.kt
        ├── MediaItem.kt
        └── theme
            └── ...
    ```

    *   **Después:** Creamos una estructura más organizada.

    ```
    com.antonioleiva.mymovies
    ├── model // Clases de datos (ej. MediaItem.kt)
    │   └── MediaItem.kt
    └── ui
        ├── MainActivity.kt // La Actividad principal, punto de entrada
        ├── MyMoviesApp.kt  // El Composable base
        ├── screens
        │   ├── main        // Paquete para la pantalla principal
        │   │   ├── MainScreen.kt
        │   │   ├── MainAppBar.kt
        │   │   └── MediaList.kt
        │   └── detail      // Paquete para la pantalla de detalle (futuro)
        └── theme
            └── ...
    ```
Esta estructura te dice de un vistazo qué componentes pertenecen a qué pantalla.

---

## ✅ **Consejo 5: Extrae las Dimensiones a Recursos**

**El Problema:** Escribir valores como `padding(16.dp)` o `height(200.dp)` directamente en el código (hardcodear) dificulta hacer cambios globales y adaptar la UI a diferentes tamaños de pantalla (móviles vs. tablets).

**La Solución:** Define todas tus dimensiones en archivos de recursos XML (`res/values/dimens.xml`) y accede a ellos desde tu código Compose.

!!! example "Ejemplo Práctico"

    *   **Paso 1: Crear el archivo de recursos `dimens.xml`.**

    ```xml
    <!-- Archivo: app/src/main/res/values/dimens.xml -->
    <?xml version="1.0" encoding="utf-8"?>
    <resources>
        <dimen name="padding_xsmall">2dp</dimen>
        <dimen name="padding_medium">16dp</dimen>
        <dimen name="cell_min_width">150dp</dimen>
        <dimen name="cell_thumb_height">200dp</dimen>
        <dimen name="cell_play_icon_size">92dp</dimen>
    </resources>
    ```

    *   **Paso 2: Usar los recursos en el código.**

    *   **Antes:**

    ```kotlin
    @Composable
    fun MediaListItem(...) {
        Column {
            Box(modifier = Modifier.height(200.dp)) {
                //...
                Icon(
                    modifier = Modifier.size(92.dp),
                    //...
                )
            }
            Box(modifier = Modifier.padding(16.dp)) {
                //...
            }
        }
    }
    ```

    *   **Después:** Usamos `dimensionResource` para obtener los valores del XML.

    ```kotlin
    import androidx.compose.ui.res.dimensionResource
    import com.antonioleiva.mymovies.R // Importante importar tu clase R

    @Composable
    fun MediaListItem(...) {
        Column {
            Box(modifier = Modifier.height(dimensionResource(R.dimen.cell_thumb_height))) {
                //...
                Icon(
                    modifier = Modifier.size(dimensionResource(R.dimen.cell_play_icon_size)),
                    //...
                )
            }
            Box(modifier = Modifier.padding(dimensionResource(R.dimen.padding_medium))) {
                //...
            }
        }
    }
    ```

    De esta forma, si necesitas cambiar un espaciado en toda la app, solo modificas el archivo `dimens.xml`.