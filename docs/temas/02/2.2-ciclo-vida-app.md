# **2.2 Ciclo de vida de una aplicaci칩n Android**

El ciclo de vida de una aplicaci칩n Android es el conjunto de estados por los que pasa una aplicaci칩n desde que se inicia hasta que se detiene. Comprender el ciclo de vida de una aplicaci칩n es fundamental para desarrollar aplicaciones robustas y eficientes en Android. 

## **A. Componentes del ciclo de vida**

En Android, los componentes del ciclo de vida de una aplicaci칩n son actividades, fragmentos, servicios y receptores de difusi칩n. Cada uno de estos componentes tiene su propio ciclo de vida y se comporta de manera diferente en funci칩n de los eventos que se producen en la aplicaci칩n.

Vamos a centrarnos en las Actividades o `Activity`, que son los componentes principales de una aplicaci칩n Android y representan una 칰nica pantalla con la que el usuario puede interactuar. 

### 쯈u칠 es una Activity?

Una **Activity** es uno de los componentes fundamentales de una aplicaci칩n de Android. En t칠rminos simples, una Activity representa una 칰nica pantalla con una interfaz de usuario (UI). Piensa en cualquier aplicaci칩n que uses: la lista de correos en Gmail, la pantalla para redactar un nuevo email, o la pantalla de configuraci칩n; cada una de estas es, generalmente, una Activity.

Sin embargo, su funci칩n va m치s all치 de ser solo un contenedor visual. Es el punto de entrada para la interacci칩n del usuario y el lugar donde se aloja la l칩gica de la interfaz. Cada Activity es una clase en tu c칩digo que se encarga de:

-   **Dibujar la interfaz de usuario:** Infla los layouts XML que definen la apariencia y la disposici칩n de los elementos en pantalla (botones, texto, im치genes, etc.).

-   **Gestionar eventos del usuario:** Responde a las interacciones del usuario, como toques en botones, deslizamientos o entradas de texto.

-   **Coordinar la l칩gica de la pantalla:** Ejecuta el c칩digo necesario para que esa pantalla funcione como se espera.

Una aplicaci칩n suele estar compuesta por m칰ltiples Activities que se comunican entre s칤. Por ejemplo, una Activity puede iniciar otra para realizar una acci칩n diferente. Cuando una nueva Activity se inicia, la anterior se detiene y se coloca en una pila (conocida como "back stack" o pila de retroceso). Esto permite al usuario navegar hacia atr치s presionando el bot칩n correspondiente. 

??? info "Video: 쯈u칠 es una Activity en Android?"

    <iframe width="780" height="440" src="https://www.youtube.com/embed/YDPHFl5LC34?list=PLrn69hTK5FByEfJEtLzJMEi0cKIwCVgJi" title="Curso Android desde cero - Qu칠 es una Activity #11" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Estados de una actividad

Las actividades en Android pueden estar en uno de los siguientes estados:

- **Created**: La actividad ha sido creada pero a칰n no es visible para el usuario.
- **Started**: La actividad es visible para el usuario pero no tiene el foco.
- **Resumed**: La actividad est치 en primer plano y tiene el foco.
- **Paused**: La actividad ha perdido el foco pero a칰n es visible para el usuario.
- **Stopped**: La actividad ya no es visible para el usuario.
- **Destroyed**: La actividad ha sido destruida y liberada de la memoria.

### M칠todos del ciclo de vida

En Android, cada actividad tiene una serie de m칠todos que se invocan en funci칩n de su estado en el ciclo de vida. Algunos de los m칠todos m치s comunes son:

- `onCreate()`: Se llama cuando la actividad se crea por primera vez.
- `onStart()`: Se llama cuando la actividad se hace visible para el usuario.
- `onResume()`: Se llama cuando la actividad obtiene el foco y se convierte en activa.
- `onPause()`: Se llama cuando la actividad pierde el foco pero a칰n es visible.
- `onStop()`: Se llama cuando la actividad ya no es visible para el usuario.
- `onDestroy()`: Se llama cuando la actividad es destruida y liberada de la memoria.

### Ejemplo de ciclo de vida de una actividad

A continuaci칩n, se muestra un ejemplo del ciclo de vida de una actividad en Android:

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d("MainActivity", "onCreate")
    }

    override fun onStart() {
        super.onStart()
        Log.d("MainActivity", "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d("MainActivity", "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d("MainActivity", "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d("MainActivity", "onStop")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d("MainActivity", "onDestroy")
    }
}
```

En el ejemplo anterior, se define una actividad `MainActivity` con los m칠todos del ciclo de vida m치s comunes. Cada m칠todo imprime un mensaje de registro en la consola para indicar en qu칠 estado se encuentra la actividad.

### Imagen del ciclo de vida de una actividad

A continuaci칩n, se muestra una imagen que representa el ciclo de vida de una actividad en Android:

![Ciclo de vida de una actividad en Android](https://developer.android.com/guide/components/images/activity_lifecycle.png?hl=es-419)

C칩mo podemos observar, el ciclo de vida de una actividad en Android consta de varios estados y transiciones entre ellos. 

Es importante comprender estos estados para gestionar correctamente el ciclo de vida de una aplicaci칩n Android.


#### La activity: El contenedor Principal de tu Pantalla

Imagina una aplicaci칩n como una obra de teatro. La **Activity** ser칤a el escenario principal donde se desarrolla un acto completo. En t칠rminos m치s t칠cnicos, una `Activity` es un componente de la aplicaci칩n que proporciona una pantalla con la que los usuarios pueden interactuar para hacer algo, como marcar un n칰mero de tel칠fono, tomar una foto, enviar un correo electr칩nico o ver un mapa. Cada `Activity` recibe una ventana en la que puede dibujar su interfaz de usuario.

Piensa en las aplicaciones que usas a diario. Cuando abres tu cliente de correo, la lista de correos es probablemente una `Activity`. Al hacer clic en un correo, se abre una nueva pantalla para leerlo; esa es otra `Activity`.

**Ejemplo Pr치ctico:**

Supongamos que estamos creando una aplicaci칩n de notas simple. La pantalla principal que muestra la lista de todas las notas ser칤a nuestra `MainActivity`.

```kotlin
// MainActivity.kt
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // Aqu칤 inicializar칤amos la lista de notas, etc.
    }
}
```

Y su correspondiente layout en XML:

```xml
<!-- activity_main.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ListView
        android:id="@+id/notes_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

### 游 **Pr치cticamos: Etapas del ciclo de vida**

Para esta pr치ctica, vamos a ejecutar una App, y probar cada una de las etapas del ciclo de vida..

Para ello, realiza el siguiente *Codelab*:

 - Etapas del ciclo de vida de la actividad [Codelab](https://developer.android.com/codelabs/basic-android-kotlin-compose-activity-lifecycle?hl=es-41#0).

<br>

#### El Ciclo de Vida de la Activity: Nacer, Vivir y Morir

Una `Activity` no existe de forma est치tica; pasa por diferentes estados a lo largo de su existencia, desde que se crea hasta que se destruye. Este es el famoso **ciclo de vida de la Activity**, y entenderlo es absolutamente crucial para construir aplicaciones robustas y evitar errores, como fugas de memoria o fallos inesperados.

El sistema operativo Android gestiona estos estados a trav칠s de una serie de m칠todos que puedes sobrescribir en tu clase `Activity`:

*   **`onCreate()`**: Es el primer m칠todo que se llama cuando se crea la `Activity`. Aqu칤 es donde debes realizar toda la inicializaci칩n est치tica: crear vistas, vincular datos a listas, etc. Este m칠todo recibe un `Bundle` que contiene el estado previamente guardado de la actividad, si es que existe (por ejemplo, despu칠s de una rotaci칩n de pantalla).
*   **`onStart()`**: Se llama cuando la `Activity` est치 a punto de hacerse visible para el usuario.
*   **`onResume()`**: Se invoca cuando la `Activity` ya es visible y el usuario puede empezar a interactuar con ella. La `Activity` permanece en este estado hasta que algo interrumpe el foco, como una llamada telef칩nica entrante o la navegaci칩n a otra `Activity`.
*   **`onPause()`**: Es la contraparte de `onResume()`. Se llama cuando la `Activity` est치 a punto de pasar a segundo plano, pero a칰n es parcialmente visible. Aqu칤 deber칤as detener operaciones que consuman muchos recursos y que no necesiten ejecutarse mientras la `Activity` no est치 en primer plano.
*   **`onStop()`**: Se llama cuando la `Activity` ya no es visible para el usuario. Esto puede ocurrir porque se ha iniciado una nueva `Activity` que la cubre por completo o porque el usuario ha vuelto a la pantalla de inicio.
*   **`onRestart()`**: Se invoca justo antes de que una `Activity` que estaba detenida (`onStop()`) vuelva a iniciarse.
*   **`onDestroy()`**: Es la llamada final antes de que la `Activity` sea destruida. Esto puede suceder porque la aplicaci칩n se est치 cerrando, o porque el sistema necesita liberar memoria.

Visual칤zalo como el viaje de un personaje en nuestra obra de teatro: entra en escena (`onCreate`, `onStart`, `onResume`), interact칰a con el p칰blico (`onResume`), otro personaje le quita el foco temporalmente (`onPause`), sale del escenario (`onStop`), y finalmente, termina su papel en la obra (`onDestroy`).


!!! question "쯋na Activity por cada Pantalla?."

    Esta es una pregunta importante y la respuesta ha evolucionado con el tiempo.

    En los inicios de Android, la respuesta habr칤a sido un rotundo **"s칤"**. Cada pantalla completa de tu aplicaci칩n se implementaba como una `Activity` separada. Por lo tanto, para una aplicaci칩n con 5 pantallas, tendr칤as 5 archivos de `Activity` (por ejemplo, `LoginActivity.kt`, `HomeActivity.kt`, `ProfileActivity.kt`, `SettingsActivity.kt`, `DetailActivity.kt`) y 5 archivos de layout XML correspondientes.

    **Sin embargo, esta no es la pr치ctica recomendada hoy en d칤a, ni siquiera en el mundo del XML.**

    La introducci칩n de los `Fragment`s cambi칩 las reglas del juego. La arquitectura moderna, incluso antes de Jetpack Compose, aboga por una **Arquitectura de Actividad 칔nica (Single Activity Architecture)**.

**Arquitectura de Actividad 칔nica (Single Activity Architecture)**

Significa que tu aplicaci칩n podr칤a tener una 칰nica `Activity` (por ejemplo, `MainActivity.kt`) que act칰a como el contenedor principal, y las "pantallas" diferentes ser칤an en realidad `Fragment`s distintos. La navegaci칩n entre pantallas consistir칤a en reemplazar un `Fragment` por otro dentro de la misma `Activity`.



> 游꿢 Revisa el siguiente cuadro para conocer c칩mo funciona el dise침o de Android antes de Jetpack compose.

??? abstract "En profundidad. Desarrollo Android antes de Compose 游빌"

    **A: El Fragment: Piezas Modulares y Reutilizables de tu Interfaz**

    Ahora, volvamos a nuestro escenario teatral. Si la `Activity` es el acto completo, un **Fragment** ser칤a un actor o un conjunto de actores con su propio guion y comportamiento. Un `Fragment` representa una porci칩n reutilizable de la interfaz de usuario de tu aplicaci칩n. No puede existir por s칤 solo; debe ser alojado por una `Activity` u otro `Fragment`.

    Piensa en una aplicaci칩n de noticias en una tablet. Podr칤as tener una `Activity` principal que, en la parte izquierda, muestra una lista de titulares (un `Fragment`) y, en la parte derecha, muestra el contenido del titular seleccionado (otro `Fragment`). En un tel칠fono, debido al menor espacio, la `Activity` podr칤a mostrar solo la lista de titulares. Al seleccionar uno, se reemplazar칤a el `Fragment` de la lista por el del contenido. 춰Es la misma l칩gica y c칩digo de `Fragment`, pero reutilizado en diferentes contextos!

    **Relaci칩n entre Activity y Fragment:**

    *   **Contenedor-Contenido**: La `Activity` es el contenedor, y el `Fragment` es una parte de su contenido.
    *   **Ciclo de Vida Anidado**: El ciclo de vida de un `Fragment` est치 directamente ligado al de su `Activity` anfitriona. Por ejemplo, cuando la `Activity` se pausa (`onPause()`), todos los `Fragment`s dentro de ella tambi칠n reciben su llamada a `onPause()`. Sin embargo, el `Fragment` tiene m칠todos de ciclo de vida adicionales propios, como `onAttach()` (cuando se asocia a la `Activity`), `onCreateView()` (cuando dibuja su propia interfaz) y `onDetach()` (cuando se desvincula).
    *   **Comunicaci칩n**: La `Activity` puede pasar datos a sus `Fragment`s, y los `Fragment`s pueden comunicarse con su `Activity` (y a trav칠s de ella, con otros `Fragments` ) para coordinar acciones.

    !!! tip "Ventajas de la Arquitectura de Actividad 칔nica con Fragments"

        1.  **Rendimiento y Eficiencia**: Cambiar entre `Fragment`s es mucho m치s ligero y r치pido que iniciar `Activities` completamente nuevas, que son componentes m치s pesados del sistema.
        2.  **Facilidad para Compartir Datos**: Es mucho m치s sencillo compartir datos y estados entre `Fragment`s que est치n en la misma `Activity` (usando un `ViewModel` compartido, por ejemplo) que pasar datos complejos entre `Activities`.
        3.  **Experiencia de Usuario Fluida**: Las transiciones y animaciones entre `Fragment`s son m치s f치ciles de implementar y se sienten m치s integradas.
        4.  **Modularidad**: Fomenta la creaci칩n de componentes de UI reutilizables.

    Entonces, para una aplicaci칩n de 5 pantallas, la aproximaci칩n moderna (XML) ser칤a:

    *   **1 Activity**: `MainActivity.kt` con su layout. Este layout tendr칤a un contenedor, como un `FrameLayout` o un `FragmentContainerView`, donde se alojar치n los `Fragment`s.
    *   **5 Fragments**: Cada uno con su propio archivo de clase Kotlin y su archivo de layout. Por ejemplo, `LoginFragment.kt` con `fragment_login.xml`, `HomeFragment.kt` con `fragment_home.xml`, etc.


    **B: Ciclo de Vida en la arquitectura de Actividad 칰nica con Fragments**

    쯃a pregunta l칩gica entonces ser칤a? Si solo tengo una Actividad, 쯖칰al ser칤a su ciclo de vida? y 쯖칩mo afectar칤a si el usuario se desplaza de una pantalla a otra de la Aplicaci칩n?

    La respuesta corta y fundamental es: **el ciclo de vida de la `Activity` ya no se ve afectado por la navegaci칩n *interna* de la aplicaci칩n, sino 칰nicamente por eventos que afectan a la ventana de la aplicaci칩n en su totalidad.**

    Vamos a desglosarlo con detalle, manteniendo nuestra analog칤a del teatro.

    Nuestra `MainActivity` es el **teatro entero**. Los `Fragment`s son los **actos o escenas** que ocurren en su 칰nico escenario.

    ---
    **El Rol Inmutable del Ciclo de Vida de la Activity**

    En un modelo de Actividad 칔nica, los m칠todos del ciclo de vida de tu `MainActivity` (`onCreate`, `onStart`, `onResume`, `onPause`, `onStop`, `onDestroy`) se seguir치n llamando, pero las razones para que se llamen son diferentes y m치s simples de predecir.

    **Piensa en el ciclo de vida de la `Activity` como el estado del "teatro":**

    *   `onCreate()`: El teatro se construye por primera vez. Esto pasa solo una vez al iniciar la app.
    *   `onStart()` / `onResume()`: Se abren las puertas del teatro y las luces del escenario se encienden. El espect치culo est치 en curso y el p칰blico (el usuario) est치 prestando atenci칩n. La `Activity` est치 en primer plano y es interactiva.
    *   `onPause()` / `onStop()`: Las luces del escenario se aten칰an o se apagan. El espect치culo se detiene. Esto ocurre cuando **algo externo interrumpe la aplicaci칩n**. Por ejemplo:
        *   El usuario presiona el bot칩n "Home" del dispositivo.
        *   El usuario presiona el bot칩n "Recientes" para cambiar a otra aplicaci칩n.
        *   Recibes una llamada telef칩nica que aparece sobre tu aplicaci칩n.
        *   Aparece un di치logo de permisos del sistema.
    *   `onDestroy()`: El teatro va a ser demolido. Esto sucede cuando el usuario cierra la aplicaci칩n o si el sistema operativo necesita recuperar memoria de forma agresiva.

    Como puedes ver, **ninguno de estos eventos tiene que ver con cambiar de la "pantalla de lista" a la "pantalla de detalle"**. El cambio entre `Fragment`s es un evento interno. Para el sistema operativo, el "teatro" (`MainActivity`) ha permanecido abierto, con las luces encendidas y el p칰blico atento todo el tiempo.

    ---
    **El Doble Ciclo de Vida en Acci칩n: Activity vs. Fragment**

    Aqu칤 es donde reside la magia y la clave de la pregunta. Cuando navegas de un `Fragment` a otro, est치s operando con el **ciclo de vida del `Fragment`**, mientras que el **ciclo de vida de la `Activity` permanece estable**.

    Veamos el escenario exacto:

    Tu aplicaci칩n est치 en `HomeFragment` y el usuario hace clic en un elemento para ir a `DetailFragment`.

    1.  **Estado Inicial:**
        *   **`MainActivity`**: Est치 en el estado `RESUMED` (ha pasado por `onCreate`, `onStart`, `onResume`). Su estado no va a cambiar.
        *   **`HomeFragment`**: Tambi칠n est치 en el estado `RESUMED` (ha pasado por su propio ciclo de vida: `onAttach`, `onCreate`, `onCreateView`, `onStart`, `onResume`).

    2.  **El Usuario Inicia la Navegaci칩n (hace clic):**
        *   El `FragmentManager` (o la librer칤a de Navegaci칩n de Jetpack) recibe la orden de reemplazar `HomeFragment` con `DetailFragment`.

    3.  **El Ciclo de Vida de los Fragments se Activa:**
        *   **`HomeFragment` (el que se va):** El sistema lo retira del escenario. Pasa por su ciclo de vida de "destrucci칩n de vista":
            *   `onPause()`
            *   `onStop()`
            *   `onDestroyView()` (춰Muy importante! Su l칩gica se va, pero su vista (el layout XML) es lo que se destruye).
            *   Si no se a침ade a la "pila de retroceso" (back stack), tambi칠n pasar치 por `onDestroy()` y `onDetach()`. Si se a침ade, el objeto del fragmento permanece en memoria.

        *   **`DetailFragment` (el que llega):** El sistema lo pone en el escenario. Pasa por su ciclo de vida de "creaci칩n":
            *   `onAttach()` (se engancha a la `MainActivity`).
            *   `onCreate()` (se inicializa el fragmento).
            *   `onCreateView()` (infla su layout XML para convertirse en una vista).
            *   `onStart()`
            *   `onResume()` (ahora es visible e interactivo para el usuario).

    4.  **Estado Final (Temporal):**
        *   **`MainActivity`**: Sigue en `RESUMED`. No se ha enterado del cambio a nivel de su propio ciclo de vida. Para ella, todo sigue igual.
        *   **`HomeFragment`**: Su vista ha sido destruida.
        *   **`DetailFragment`**: Est치 en el estado `RESUMED`.

    **쯈u칠 pasa si el usuario presiona el bot칩n "Atr치s"?** El proceso se invierte. `DetailFragment` es destruido y `HomeFragment` se vuelve a crear (pasa por `onCreateView` de nuevo) para mostrarse en pantalla. Y durante todo este proceso, `MainActivity` sigue felizmente en su estado `RESUMED`.

    !!! bug "Las Reglas de Oro del Ciclo de Vida en una Actividad 칔nica"

        Para que te quede grabado, aqu칤 tienes las reglas fundamentales:

        1.  **El Ciclo de Vida de la `Activity` gestiona el estado de la ventana de la aplicaci칩n.** 쮼st치 tu app en primer plano o en segundo plano? 쯃a est치n interrumpiendo?
        2.  **El Ciclo de Vida del `Fragment` gestiona el estado de una porci칩n de la UI *dentro* de la ventana de la aplicaci칩n.** 쮼st치 esta porci칩n de UI visible en pantalla o no?
        3.  **La `Activity` es la directora de orquesta; el `Fragment` es un m칰sico.** Cuando la directora (Activity) dice "pausa" (porque llega una llamada), todos los m칰sicos (Fragments activos) tambi칠n pausan. Pero un m칰sico puede dejar de tocar y ser reemplazado por otro sin que la directora altere el tempo general de la orquesta.

        Entender esta separaci칩n es la clave para dominar el desarrollo moderno de Android (incluso en Compose, donde los conceptos de ciclo de vida siguen siendo vitales) y para crear aplicaciones eficientes, r치pidas y sin fugas de memoria.

















<!-- ## Sobre el contexto o `Context`

El contexto o `Context` es un objeto que proporciona informaci칩n sobre el entorno en el que se ejecuta una aplicaci칩n Android. 

El contexto se utiliza para acceder a recursos de la aplicaci칩n, iniciar actividades, crear servicios y mucho m치s.

En Android, el contexto se puede obtener a trav칠s de la clase `Context` o de una subclase de `Context`, como `Activity` o `Service`.

### Obtener el contexto en Android

En Android, puedes obtener el contexto de varias formas, dependiendo de la clase en la que te encuentres. Algunas de las formas m치s comunes de obtener el contexto son:

- `this`: En una actividad, puedes utilizar `this` para hacer referencia al contexto de la actividad.
- `getApplicationContext()`: En una actividad o un servicio, puedes utilizar `getApplicationContext()` para obtener el contexto de la aplicaci칩n.
- `getContext()`: En una vista, puedes utilizar `getContext()` para obtener el contexto de la vista.

!!! tip "Contexto en Compose"
    Para obtener el contexto en un entorno de Compose, puedes utilizar el modificador `LocalContext.current`.

## Usos comunes del contexto

Algunos de los usos comunes del contexto en Android son:

- Acceder a recursos de la aplicaci칩n, como cadenas, im치genes y estilos.
- Iniciar actividades y servicios.
- Crear notificaciones y alarmas.
- Acceder a la base de datos de la aplicaci칩n.

El contexto es fundamental para el desarrollo de aplicaciones Android y te permite interactuar con el sistema operativo y los servicios de la plataforma.

## Toasts en Android

Los toasts son mensajes breves que se muestran en la pantalla durante un corto per칤odo de tiempo. En Android, puedes utilizar la clase `Toast` para mostrar toasts en tu aplicaci칩n.

A continuaci칩n, se muestra un ejemplo de c칩mo mostrar un toast en Android:

```kotlin
Toast.makeText(this, "Hola, mundo!", Toast.LENGTH_SHORT).show()
```

En el ejemplo anterior, se utiliza `Toast.makeText()` para crear un toast con el mensaje "Hola, mundo!" y `Toast.LENGTH_SHORT` para especificar la duraci칩n del toast.

Los toasts son 칰tiles para mostrar mensajes informativos o de confirmaci칩n al usuario de forma r치pida y sencilla.

## Snackbar en Android

Los snackbar son mensajes breves que se muestran en la parte inferior de la pantalla y permiten al usuario realizar una acci칩n o deshacer una acci칩n.

En Android, puedes utilizar la clase `Snackbar` de la biblioteca de dise침o de materiales para mostrar snackbar en tu aplicaci칩n.

A continuaci칩n, se muestra un ejemplo de c칩mo mostrar un snackbar en Android:

```kotlin
Snackbar.make(view, "Mensaje de snackbar", Snackbar.LENGTH_SHORT)
    .setAction("Deshacer") {
        // Acci칩n al deshacer
    }
    .show()
```

En el ejemplo anterior, se utiliza `Snackbar.make()` para crear un snackbar con el mensaje "Mensaje de snackbar" y `Snackbar.LENGTH_SHORT` para especificar la duraci칩n del snackbar. Se utiliza `setAction()` para a침adir un bot칩n de deshacer al snackbar y `show()` para mostrar el snackbar en la pantalla.

Los snackbar son 칰tiles para mostrar mensajes informativos o de confirmaci칩n al usuario y permitirle realizar acciones adicionales.

## Di치logos en Android

Los di치logos son ventanas emergentes que se utilizan para mostrar informaci칩n, solicitar confirmaci칩n al usuario o realizar una acci칩n.

En Android, puedes utilizar la clase `AlertDialog` para crear di치logos en tu aplicaci칩n.

A continuaci칩n, se muestra un ejemplo de c칩mo mostrar un di치logo en Android:

```kotlin
val builder = AlertDialog.Builder(this)
builder.setTitle("T칤tulo del di치logo")
builder.setMessage("Mensaje del di치logo")
builder.setPositiveButton("Aceptar") { dialog, which ->
    // Acci칩n al hacer clic en Aceptar
}
builder.setNegativeButton("Cancelar") { dialog, which ->
    // Acci칩n al hacer clic en Cancelar
}
builder.show()
```

En compose, puedes utilizar el componente `AlertDialog` para crear di치logos de forma declarativa.

Los di치logos son 칰tiles para interactuar con el usuario y solicitar su entrada o confirmaci칩n de forma clara y concisa.
 -->
