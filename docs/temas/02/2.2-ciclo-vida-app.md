# **2.2 Ciclo de vida de una aplicación Android**

El ciclo de vida de una aplicación Android es el conjunto de estados por los que pasa una aplicación desde que se inicia hasta que se detiene. Comprender el ciclo de vida de una aplicación es fundamental para desarrollar aplicaciones robustas y eficientes en Android. 

## **A. Componentes del ciclo de vida**

En Android, los componentes del ciclo de vida de una aplicación son actividades, fragmentos, servicios y receptores de difusión. Cada uno de estos componentes tiene su propio ciclo de vida y se comporta de manera diferente en función de los eventos que se producen en la aplicación.

Vamos a centrarnos en las Actividades o `Activity`, que son los componentes principales de una aplicación Android y representan una única pantalla con la que el usuario puede interactuar. 

### ¿Qué es una Activity?

Una **Activity** es uno de los componentes fundamentales de una aplicación de Android. En términos simples, una Activity representa una única pantalla con una interfaz de usuario (UI). Piensa en cualquier aplicación que uses: la lista de correos en Gmail, la pantalla para redactar un nuevo email, o la pantalla de configuración; cada una de estas es, generalmente, una Activity.

Sin embargo, su función va más allá de ser solo un contenedor visual. Es el punto de entrada para la interacción del usuario y el lugar donde se aloja la lógica de la interfaz. Cada Activity es una clase en tu código que se encarga de:

-   **Dibujar la interfaz de usuario:** Infla los layouts XML que definen la apariencia y la disposición de los elementos en pantalla (botones, texto, imágenes, etc.).

-   **Gestionar eventos del usuario:** Responde a las interacciones del usuario, como toques en botones, deslizamientos o entradas de texto.

-   **Coordinar la lógica de la pantalla:** Ejecuta el código necesario para que esa pantalla funcione como se espera.

Una aplicación suele estar compuesta por múltiples Activities que se comunican entre sí. Por ejemplo, una Activity puede iniciar otra para realizar una acción diferente. Cuando una nueva Activity se inicia, la anterior se detiene y se coloca en una pila (conocida como "back stack" o pila de retroceso). Esto permite al usuario navegar hacia atrás presionando el botón correspondiente. 

??? info "Video: ¿Qué es una Activity en Android?"

    <iframe width="780" height="440" src="https://www.youtube.com/embed/YDPHFl5LC34?list=PLrn69hTK5FByEfJEtLzJMEi0cKIwCVgJi" title="Curso Android desde cero - Qué es una Activity #11" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

### Estados de una actividad

Las actividades en Android pueden estar en uno de los siguientes estados:

- **Created**: La actividad ha sido creada pero aún no es visible para el usuario.
- **Started**: La actividad es visible para el usuario pero no tiene el foco.
- **Resumed**: La actividad está en primer plano y tiene el foco.
- **Paused**: La actividad ha perdido el foco pero aún es visible para el usuario.
- **Stopped**: La actividad ya no es visible para el usuario.
- **Destroyed**: La actividad ha sido destruida y liberada de la memoria.

### Métodos del ciclo de vida

En Android, cada actividad tiene una serie de métodos que se invocan en función de su estado en el ciclo de vida. Algunos de los métodos más comunes son:

- `onCreate()`: Se llama cuando la actividad se crea por primera vez.
- `onStart()`: Se llama cuando la actividad se hace visible para el usuario.
- `onResume()`: Se llama cuando la actividad obtiene el foco y se convierte en activa.
- `onPause()`: Se llama cuando la actividad pierde el foco pero aún es visible.
- `onStop()`: Se llama cuando la actividad ya no es visible para el usuario.
- `onDestroy()`: Se llama cuando la actividad es destruida y liberada de la memoria.

### Ejemplo de ciclo de vida de una actividad

A continuación, se muestra un ejemplo del ciclo de vida de una actividad en Android:

```kotlin
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d("MainActivity", "onCreate")
    }

    override fun onStart() {
        super.onStart()
        Log.d("MainActivity", "onStart")
    }

    override fun onResume() {
        super.onResume()
        Log.d("MainActivity", "onResume")
    }

    override fun onPause() {
        super.onPause()
        Log.d("MainActivity", "onPause")
    }

    override fun onStop() {
        super.onStop()
        Log.d("MainActivity", "onStop")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d("MainActivity", "onDestroy")
    }
}
```

En el ejemplo anterior, se define una actividad `MainActivity` con los métodos del ciclo de vida más comunes. Cada método imprime un mensaje de registro en la consola para indicar en qué estado se encuentra la actividad.

### Imagen del ciclo de vida de una actividad

A continuación, se muestra una imagen que representa el ciclo de vida de una actividad en Android:

![Ciclo de vida de una actividad en Android](https://developer.android.com/guide/components/images/activity_lifecycle.png?hl=es-419)

Cómo podemos observar, el ciclo de vida de una actividad en Android consta de varios estados y transiciones entre ellos. 

Es importante comprender estos estados para gestionar correctamente el ciclo de vida de una aplicación Android.


#### La activity: El contenedor Principal de tu Pantalla

Imagina una aplicación como una obra de teatro. La **Activity** sería el escenario principal donde se desarrolla un acto completo. En términos más técnicos, una `Activity` es un componente de la aplicación que proporciona una pantalla con la que los usuarios pueden interactuar para hacer algo, como marcar un número de teléfono, tomar una foto, enviar un correo electrónico o ver un mapa. Cada `Activity` recibe una ventana en la que puede dibujar su interfaz de usuario.

Piensa en las aplicaciones que usas a diario. Cuando abres tu cliente de correo, la lista de correos es probablemente una `Activity`. Al hacer clic en un correo, se abre una nueva pantalla para leerlo; esa es otra `Activity`.

**Ejemplo Práctico:**

Supongamos que estamos creando una aplicación de notas simple. La pantalla principal que muestra la lista de todas las notas sería nuestra `MainActivity`.

```kotlin
// MainActivity.kt
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        // Aquí inicializaríamos la lista de notas, etc.
    }
}
```

Y su correspondiente layout en XML:

```xml
<!-- activity_main.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ListView
        android:id="@+id/notes_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

#### El Ciclo de Vida de la Activity: Nacer, Vivir y Morir

Una `Activity` no existe de forma estática; pasa por diferentes estados a lo largo de su existencia, desde que se crea hasta que se destruye. Este es el famoso **ciclo de vida de la Activity**, y entenderlo es absolutamente crucial para construir aplicaciones robustas y evitar errores, como fugas de memoria o fallos inesperados.

El sistema operativo Android gestiona estos estados a través de una serie de métodos que puedes sobrescribir en tu clase `Activity`:

*   **`onCreate()`**: Es el primer método que se llama cuando se crea la `Activity`. Aquí es donde debes realizar toda la inicialización estática: crear vistas, vincular datos a listas, etc. Este método recibe un `Bundle` que contiene el estado previamente guardado de la actividad, si es que existe (por ejemplo, después de una rotación de pantalla).
*   **`onStart()`**: Se llama cuando la `Activity` está a punto de hacerse visible para el usuario.
*   **`onResume()`**: Se invoca cuando la `Activity` ya es visible y el usuario puede empezar a interactuar con ella. La `Activity` permanece en este estado hasta que algo interrumpe el foco, como una llamada telefónica entrante o la navegación a otra `Activity`.
*   **`onPause()`**: Es la contraparte de `onResume()`. Se llama cuando la `Activity` está a punto de pasar a segundo plano, pero aún es parcialmente visible. Aquí deberías detener operaciones que consuman muchos recursos y que no necesiten ejecutarse mientras la `Activity` no está en primer plano.
*   **`onStop()`**: Se llama cuando la `Activity` ya no es visible para el usuario. Esto puede ocurrir porque se ha iniciado una nueva `Activity` que la cubre por completo o porque el usuario ha vuelto a la pantalla de inicio.
*   **`onRestart()`**: Se invoca justo antes de que una `Activity` que estaba detenida (`onStop()`) vuelva a iniciarse.
*   **`onDestroy()`**: Es la llamada final antes de que la `Activity` sea destruida. Esto puede suceder porque la aplicación se está cerrando, o porque el sistema necesita liberar memoria.

Visualízalo como el viaje de un personaje en nuestra obra de teatro: entra en escena (`onCreate`, `onStart`, `onResume`), interactúa con el público (`onResume`), otro personaje le quita el foco temporalmente (`onPause`), sale del escenario (`onStop`), y finalmente, termina su papel en la obra (`onDestroy`).


!!! question "¿Una Activity por cada Pantalla?."

    Esta es una pregunta importante y la respuesta ha evolucionado con el tiempo.

    En los inicios de Android, la respuesta habría sido un rotundo **"sí"**. Cada pantalla completa de tu aplicación se implementaba como una `Activity` separada. Por lo tanto, para una aplicación con 5 pantallas, tendrías 5 archivos de `Activity` (por ejemplo, `LoginActivity.kt`, `HomeActivity.kt`, `ProfileActivity.kt`, `SettingsActivity.kt`, `DetailActivity.kt`) y 5 archivos de layout XML correspondientes.

    **Sin embargo, esta no es la práctica recomendada hoy en día, ni siquiera en el mundo del XML.**

    La introducción de los `Fragment`s cambió las reglas del juego. La arquitectura moderna, incluso antes de Jetpack Compose, aboga por una **Arquitectura de Actividad Única (Single Activity Architecture)**.

**Arquitectura de Actividad Única (Single Activity Architecture)**

Significa que tu aplicación podría tener una única `Activity` (por ejemplo, `MainActivity.kt`) que actúa como el contenedor principal, y las "pantallas" diferentes serían en realidad `Fragment`s distintos. La navegación entre pantallas consistiría en reemplazar un `Fragment` por otro dentro de la misma `Activity`.

## **B. El Fragment: Piezas Modulares y Reutilizables de tu Interfaz**

Ahora, volvamos a nuestro escenario teatral. Si la `Activity` es el acto completo, un **Fragment** sería un actor o un conjunto de actores con su propio guion y comportamiento. Un `Fragment` representa una porción reutilizable de la interfaz de usuario de tu aplicación. No puede existir por sí solo; debe ser alojado por una `Activity` u otro `Fragment`.

Piensa en una aplicación de noticias en una tablet. Podrías tener una `Activity` principal que, en la parte izquierda, muestra una lista de titulares (un `Fragment`) y, en la parte derecha, muestra el contenido del titular seleccionado (otro `Fragment`). En un teléfono, debido al menor espacio, la `Activity` podría mostrar solo la lista de titulares. Al seleccionar uno, se reemplazaría el `Fragment` de la lista por el del contenido. ¡Es la misma lógica y código de `Fragment`, pero reutilizado en diferentes contextos!

**Relación entre Activity y Fragment:**

*   **Contenedor-Contenido**: La `Activity` es el contenedor, y el `Fragment` es una parte de su contenido.
*   **Ciclo de Vida Anidado**: El ciclo de vida de un `Fragment` está directamente ligado al de su `Activity` anfitriona. Por ejemplo, cuando la `Activity` se pausa (`onPause()`), todos los `Fragment`s dentro de ella también reciben su llamada a `onPause()`. Sin embargo, el `Fragment` tiene métodos de ciclo de vida adicionales propios, como `onAttach()` (cuando se asocia a la `Activity`), `onCreateView()` (cuando dibuja su propia interfaz) y `onDetach()` (cuando se desvincula).
*   **Comunicación**: La `Activity` puede pasar datos a sus `Fragment`s, y los `Fragment`s pueden comunicarse con su `Activity` (y a través de ella, con otros `Fragments` ) para coordinar acciones.

!!! tip "Ventajas de la Arquitectura de Actividad Única con Fragments"

    1.  **Rendimiento y Eficiencia**: Cambiar entre `Fragment`s es mucho más ligero y rápido que iniciar `Activities` completamente nuevas, que son componentes más pesados del sistema.
    2.  **Facilidad para Compartir Datos**: Es mucho más sencillo compartir datos y estados entre `Fragment`s que están en la misma `Activity` (usando un `ViewModel` compartido, por ejemplo) que pasar datos complejos entre `Activities`.
    3.  **Experiencia de Usuario Fluida**: Las transiciones y animaciones entre `Fragment`s son más fáciles de implementar y se sienten más integradas.
    4.  **Modularidad**: Fomenta la creación de componentes de UI reutilizables.

Entonces, para una aplicación de 5 pantallas, la aproximación moderna (XML) sería:

*   **1 Activity**: `MainActivity.kt` con su layout. Este layout tendría un contenedor, como un `FrameLayout` o un `FragmentContainerView`, donde se alojarán los `Fragment`s.
*   **5 Fragments**: Cada uno con su propio archivo de clase Kotlin y su archivo de layout. Por ejemplo, `LoginFragment.kt` con `fragment_login.xml`, `HomeFragment.kt` con `fragment_home.xml`, etc.


## **C. Ciclo de Vida en la arquitectura de Actividad única con Fragments**

¿La pregunta lógica entonces sería? Si solo tengo una Actividad, ¿cúal sería su ciclo de vida? y ¿cómo afectaría si el usuario se desplaza de una pantalla a otra de la Aplicación?

La respuesta corta y fundamental es: **el ciclo de vida de la `Activity` ya no se ve afectado por la navegación *interna* de la aplicación, sino únicamente por eventos que afectan a la ventana de la aplicación en su totalidad.**

Vamos a desglosarlo con detalle, manteniendo nuestra analogía del teatro.

Nuestra `MainActivity` es el **teatro entero**. Los `Fragment`s son los **actos o escenas** que ocurren en su único escenario.

### El Rol Inmutable del Ciclo de Vida de la Activity

En un modelo de Actividad Única, los métodos del ciclo de vida de tu `MainActivity` (`onCreate`, `onStart`, `onResume`, `onPause`, `onStop`, `onDestroy`) se seguirán llamando, pero las razones para que se llamen son diferentes y más simples de predecir.

**Piensa en el ciclo de vida de la `Activity` como el estado del "teatro":**

*   `onCreate()`: El teatro se construye por primera vez. Esto pasa solo una vez al iniciar la app.
*   `onStart()` / `onResume()`: Se abren las puertas del teatro y las luces del escenario se encienden. El espectáculo está en curso y el público (el usuario) está prestando atención. La `Activity` está en primer plano y es interactiva.
*   `onPause()` / `onStop()`: Las luces del escenario se atenúan o se apagan. El espectáculo se detiene. Esto ocurre cuando **algo externo interrumpe la aplicación**. Por ejemplo:
    *   El usuario presiona el botón "Home" del dispositivo.
    *   El usuario presiona el botón "Recientes" para cambiar a otra aplicación.
    *   Recibes una llamada telefónica que aparece sobre tu aplicación.
    *   Aparece un diálogo de permisos del sistema.
*   `onDestroy()`: El teatro va a ser demolido. Esto sucede cuando el usuario cierra la aplicación o si el sistema operativo necesita recuperar memoria de forma agresiva.

Como puedes ver, **ninguno de estos eventos tiene que ver con cambiar de la "pantalla de lista" a la "pantalla de detalle"**. El cambio entre `Fragment`s es un evento interno. Para el sistema operativo, el "teatro" (`MainActivity`) ha permanecido abierto, con las luces encendidas y el público atento todo el tiempo.

### El Doble Ciclo de Vida en Acción: Activity vs. Fragment

Aquí es donde reside la magia y la clave de la pregunta. Cuando navegas de un `Fragment` a otro, estás operando con el **ciclo de vida del `Fragment`**, mientras que el **ciclo de vida de la `Activity` permanece estable**.

Veamos el escenario exacto:

Tu aplicación está en `HomeFragment` y el usuario hace clic en un elemento para ir a `DetailFragment`.

1.  **Estado Inicial:**
    *   **`MainActivity`**: Está en el estado `RESUMED` (ha pasado por `onCreate`, `onStart`, `onResume`). Su estado no va a cambiar.
    *   **`HomeFragment`**: También está en el estado `RESUMED` (ha pasado por su propio ciclo de vida: `onAttach`, `onCreate`, `onCreateView`, `onStart`, `onResume`).

2.  **El Usuario Inicia la Navegación (hace clic):**
    *   El `FragmentManager` (o la librería de Navegación de Jetpack) recibe la orden de reemplazar `HomeFragment` con `DetailFragment`.

3.  **El Ciclo de Vida de los Fragments se Activa:**
    *   **`HomeFragment` (el que se va):** El sistema lo retira del escenario. Pasa por su ciclo de vida de "destrucción de vista":
        *   `onPause()`
        *   `onStop()`
        *   `onDestroyView()` (¡Muy importante! Su lógica se va, pero su vista (el layout XML) es lo que se destruye).
        *   Si no se añade a la "pila de retroceso" (back stack), también pasará por `onDestroy()` y `onDetach()`. Si se añade, el objeto del fragmento permanece en memoria.

    *   **`DetailFragment` (el que llega):** El sistema lo pone en el escenario. Pasa por su ciclo de vida de "creación":
        *   `onAttach()` (se engancha a la `MainActivity`).
        *   `onCreate()` (se inicializa el fragmento).
        *   `onCreateView()` (infla su layout XML para convertirse en una vista).
        *   `onStart()`
        *   `onResume()` (ahora es visible e interactivo para el usuario).

4.  **Estado Final (Temporal):**
    *   **`MainActivity`**: Sigue en `RESUMED`. No se ha enterado del cambio a nivel de su propio ciclo de vida. Para ella, todo sigue igual.
    *   **`HomeFragment`**: Su vista ha sido destruida.
    *   **`DetailFragment`**: Está en el estado `RESUMED`.

**¿Qué pasa si el usuario presiona el botón "Atrás"?** El proceso se invierte. `DetailFragment` es destruido y `HomeFragment` se vuelve a crear (pasa por `onCreateView` de nuevo) para mostrarse en pantalla. Y durante todo este proceso, `MainActivity` sigue felizmente en su estado `RESUMED`.

!!! bug "Las Reglas de Oro del Ciclo de Vida en una Actividad Única"

    Para que te quede grabado, aquí tienes las reglas fundamentales:

    1.  **El Ciclo de Vida de la `Activity` gestiona el estado de la ventana de la aplicación.** ¿Está tu app en primer plano o en segundo plano? ¿La están interrumpiendo?
    2.  **El Ciclo de Vida del `Fragment` gestiona el estado de una porción de la UI *dentro* de la ventana de la aplicación.** ¿Está esta porción de UI visible en pantalla o no?
    3.  **La `Activity` es la directora de orquesta; el `Fragment` es un músico.** Cuando la directora (Activity) dice "pausa" (porque llega una llamada), todos los músicos (Fragments activos) también pausan. Pero un músico puede dejar de tocar y ser reemplazado por otro sin que la directora altere el tempo general de la orquesta.

    Entender esta separación es la clave para dominar el desarrollo moderno de Android (incluso en Compose, donde los conceptos de ciclo de vida siguen siendo vitales) y para crear aplicaciones eficientes, rápidas y sin fugas de memoria.

















<!-- ## Sobre el contexto o `Context`

El contexto o `Context` es un objeto que proporciona información sobre el entorno en el que se ejecuta una aplicación Android. 

El contexto se utiliza para acceder a recursos de la aplicación, iniciar actividades, crear servicios y mucho más.

En Android, el contexto se puede obtener a través de la clase `Context` o de una subclase de `Context`, como `Activity` o `Service`.

### Obtener el contexto en Android

En Android, puedes obtener el contexto de varias formas, dependiendo de la clase en la que te encuentres. Algunas de las formas más comunes de obtener el contexto son:

- `this`: En una actividad, puedes utilizar `this` para hacer referencia al contexto de la actividad.
- `getApplicationContext()`: En una actividad o un servicio, puedes utilizar `getApplicationContext()` para obtener el contexto de la aplicación.
- `getContext()`: En una vista, puedes utilizar `getContext()` para obtener el contexto de la vista.

!!! tip "Contexto en Compose"
    Para obtener el contexto en un entorno de Compose, puedes utilizar el modificador `LocalContext.current`.

## Usos comunes del contexto

Algunos de los usos comunes del contexto en Android son:

- Acceder a recursos de la aplicación, como cadenas, imágenes y estilos.
- Iniciar actividades y servicios.
- Crear notificaciones y alarmas.
- Acceder a la base de datos de la aplicación.

El contexto es fundamental para el desarrollo de aplicaciones Android y te permite interactuar con el sistema operativo y los servicios de la plataforma.

## Toasts en Android

Los toasts son mensajes breves que se muestran en la pantalla durante un corto período de tiempo. En Android, puedes utilizar la clase `Toast` para mostrar toasts en tu aplicación.

A continuación, se muestra un ejemplo de cómo mostrar un toast en Android:

```kotlin
Toast.makeText(this, "Hola, mundo!", Toast.LENGTH_SHORT).show()
```

En el ejemplo anterior, se utiliza `Toast.makeText()` para crear un toast con el mensaje "Hola, mundo!" y `Toast.LENGTH_SHORT` para especificar la duración del toast.

Los toasts son útiles para mostrar mensajes informativos o de confirmación al usuario de forma rápida y sencilla.

## Snackbar en Android

Los snackbar son mensajes breves que se muestran en la parte inferior de la pantalla y permiten al usuario realizar una acción o deshacer una acción.

En Android, puedes utilizar la clase `Snackbar` de la biblioteca de diseño de materiales para mostrar snackbar en tu aplicación.

A continuación, se muestra un ejemplo de cómo mostrar un snackbar en Android:

```kotlin
Snackbar.make(view, "Mensaje de snackbar", Snackbar.LENGTH_SHORT)
    .setAction("Deshacer") {
        // Acción al deshacer
    }
    .show()
```

En el ejemplo anterior, se utiliza `Snackbar.make()` para crear un snackbar con el mensaje "Mensaje de snackbar" y `Snackbar.LENGTH_SHORT` para especificar la duración del snackbar. Se utiliza `setAction()` para añadir un botón de deshacer al snackbar y `show()` para mostrar el snackbar en la pantalla.

Los snackbar son útiles para mostrar mensajes informativos o de confirmación al usuario y permitirle realizar acciones adicionales.

## Diálogos en Android

Los diálogos son ventanas emergentes que se utilizan para mostrar información, solicitar confirmación al usuario o realizar una acción.

En Android, puedes utilizar la clase `AlertDialog` para crear diálogos en tu aplicación.

A continuación, se muestra un ejemplo de cómo mostrar un diálogo en Android:

```kotlin
val builder = AlertDialog.Builder(this)
builder.setTitle("Título del diálogo")
builder.setMessage("Mensaje del diálogo")
builder.setPositiveButton("Aceptar") { dialog, which ->
    // Acción al hacer clic en Aceptar
}
builder.setNegativeButton("Cancelar") { dialog, which ->
    // Acción al hacer clic en Cancelar
}
builder.show()
```

En compose, puedes utilizar el componente `AlertDialog` para crear diálogos de forma declarativa.

Los diálogos son útiles para interactuar con el usuario y solicitar su entrada o confirmación de forma clara y concisa.
 -->
