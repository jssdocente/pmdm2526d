# **2.5. Listas en Compose**

Las listas son unos de los principales componentes de cualquier aplicaci√≥n, ya que nos van a permitir mostrar una lista de elementos. Si estos elementos son pocos, y solo ocupan parte de la pantalla, se pueden utilizar los elementos que ya conocemos como `Column` o `Row`, pero cuando son muchos los elementos necesitamos algo m√°s potente, y que nos permita ser eficientes y que consuma los m√≠nimos recursos.

Para esto *Compose* nos provee los componentes `LazColum` y `LazyRow`


Antes de continuar y realizar las actividades de este apartado, [**lee a la documentaci√≥n sobre listas y cuadriculas**](../00-android/00-compose/23-listas-cuadriculas.md)


Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad tambi√©n puede llevar a que el c√≥digo crezca r√°pidamente y se vuelva desordenado.

## **üí°Desmitificando LazyRow y LazyColumn en Jetpack Compose**

---
### 1. ¬øCu√°l es la Necesidad? El Problema de las Listas Largas

Imaginemos una aplicaci√≥n com√∫n: una red social con un feed de noticias, una tienda online con cientos de productos o una simple lista de contactos. Todas estas aplicaciones comparten un requisito: mostrar una cantidad potencialmente grande de elementos en pantalla.

Si abord√°ramos este problema de forma ingenua, utilizando los componentes b√°sicos `Row` o `Column`, nos encontrar√≠amos con un grave problema de rendimiento. Un `Column`, por ejemplo, renderizar√° **todos y cada uno** de sus elementos hijos de una sola vez, sin importar si son visibles en la pantalla o no. Para una lista de diez o veinte elementos, esto podr√≠a ser aceptable. Pero, ¬øqu√© sucede con cien, mil o una lista de longitud desconocida? La aplicaci√≥n intentar√≠a componer y dibujar todos los elementos, consumiendo una cantidad masiva de memoria y ciclos de CPU. El resultado es inevitable: una interfaz que se congela, responde con lentitud (lo que conocemos como "lag") y, en el peor de los casos, una aplicaci√≥n que colapsa con un error de `OutOfMemoryError`.

Aqu√≠ es donde la "pereza" (del ingl√©s "lazy") se convierte en nuestra mayor aliada.

### 2. La Funci√≥n de LazyRow y LazyColumn: Composici√≥n "Perezosa"

`LazyRow` y `LazyColumn` son los equivalentes en Jetpack Compose al veterano `RecyclerView` del sistema de vistas tradicional de Android. Su prop√≥sito fundamental es mostrar de manera eficiente listas de elementos, ya sea de forma horizontal (`LazyRow`) o vertical (`LazyColumn`).

La magia detr√°s de estos componentes radica en su estrategia de **composici√≥n y renderizado "perezoso"**. En lugar de componer todos los elementos de la lista de una vez, `LazyColumn` y `LazyRow` solo componen y dibujan los elementos que son actualmente visibles dentro del viewport (el √°rea visible en la pantalla) y unos pocos m√°s que est√°n a punto de aparecer para garantizar un desplazamiento suave. A medida que el usuario se desplaza, los elementos que salen del viewport son descartados (liberando recursos), y nuevos elementos son compuestos justo a tiempo para ser mostrados.

Este enfoque "justo a tiempo" tiene un impacto dr√°stico y positivo en el rendimiento de la aplicaci√≥n:

*   **Uso de Memoria Optimizado:** Al no mantener en memoria elementos que no est√°n en pantalla, se reduce significativamente la huella de memoria de la aplicaci√≥n.
*   **Mejora del Rendimiento de Renderizado:** La CPU y la GPU tienen mucho menos trabajo que hacer en cada frame, lo que se traduce en una interfaz de usuario fluida y receptiva, libre de "lag".
*   **Tiempos de Carga Iniciales R√°pidos:** La pantalla se muestra r√°pidamente, ya que no es necesario procesar toda la lista de datos para la primera visualizaci√≥n.

### 3. ¬øC√≥mo Funcionan Internamente?

A diferencia de `RecyclerView`, que se basa en un mecanismo de reciclaje de vistas (reutilizando instancias de `View` ya creadas), `LazyColumn` y `LazyRow` aprovechan el modelo de funcionamiento de Jetpack Compose.

Cuando un elemento en una `LazyColumn` se desplaza fuera de la pantalla, su composici√≥n es **descartada** del √°rbol de la UI. Cuando un nuevo elemento necesita ser mostrado, se crea una **nueva composici√≥n** para √©l. Podr√≠a pensarse que crear nuevas composiciones constantemente es costoso, pero el sistema de recomposici√≥n inteligente de Compose es extremadamente eficiente. Solo las partes de la UI que cambian se vuelven a componer, y la creaci√≥n de estos `Composables` es significativamente m√°s ligera que la inflaci√≥n de vistas XML en el sistema tradicional.

Para gestionar todo este proceso, estos componentes utilizan un `LazyListScope`, un DSL (Lenguaje Espec√≠fico de Dominio) que permite definir los elementos de la lista de una manera declarativa y sencilla.

___
### 4. Ejemplos Pr√°cticos: De lo B√°sico a lo Avanzado üë®‚Äçüíª

Veamos c√≥mo se traduce todo esto en c√≥digo. La simplicidad de su implementaci√≥n es una de las grandes ventajas de Compose.

#### Ejemplo 1: Una Lista Vertical Simple

Supongamos que tenemos una lista de nombres de estudiantes que queremos mostrar verticalmente.

```kotlin
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp

@Composable
fun StudentList(students: List<String>) {
    LazyColumn {
        items(students) { studentName ->
            Text(
                text = studentName,
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            )
        }
    }
}
```

En este sencillo ejemplo, `LazyColumn` recibe una lista de `students`. El bloque `items` itera sobre esta lista y genera un `Composable` `Text` para cada estudiante. `LazyColumn` se encarga autom√°ticamente de componer solo los elementos visibles.

#### Ejemplo 2: Un Carrusel Horizontal de Im√°genes (`LazyRow`)

Ahora, creemos un carrusel horizontal, ideal para galer√≠as de im√°genes o categor√≠as de productos.

```kotlin
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.unit.dp
import com.example.myapp.R // Aseg√∫rate de tener tus recursos de imagen

@Composable
fun ImageCarousel(imageResIds: List<Int>) {
    LazyRow {
        items(imageResIds) { imageResId ->
            Image(
                painter = painterResource(id = imageResId),
                contentDescription = null, // Deber√≠a ser descriptivo
                modifier = Modifier
                    .size(150.dp)
                    .padding(8.dp)
            )
        }
    }
}
```

El funcionamiento es id√©ntico al de `LazyColumn`, pero la disposici√≥n y el desplazamiento son horizontales.

#### Ejemplo 3: Lista con M√∫ltiples Tipos de Elementos

Una de las grandes ventajas de `LazyColumn` es la facilidad para manejar listas heterog√©neas. Imaginemos una lista que contiene cabeceras de secci√≥n y elementos de datos.

```kotlin
sealed class ListItem {
    data class Header(val title: String) : ListItem()
    data class DataItem(val content: String) : ListItem()
}

@Composable
fun MixedList(items: List<ListItem>) {
    LazyColumn {
        items(items) { item ->
            when (item) {
                is ListItem.Header -> {
                    Text(
                        text = item.title,
                        // Estilos para la cabecera
                    )
                }
                is ListItem.DataItem -> {
                    Text(
                        text = item.content,
                        // Estilos para el item de dato
                    )
                }
            }
        }
    }
}
```

Simplemente utilizando una estructura `when` dentro del bloque `items`, podemos emitir diferentes `Composables` seg√∫n el tipo de dato, de una forma mucho m√°s limpia que con el `getItemViewType` de `RecyclerView`.

#### Ejemplo 4: Cabeceras Adhesivas (Sticky Headers)

Con una peque√±a modificaci√≥n, podemos hacer que nuestras cabeceras se queden "pegadas" en la parte superior de la pantalla mientras el contenido de su secci√≥n se desplaza.

```kotlin
@OptIn(ExperimentalFoundationApi::class)
@Composable
fun StickyHeaderList(sections: Map<String, List<String>>) {
    LazyColumn {
        sections.forEach { (headerTitle, items) ->
            stickyHeader {
                Text(
                    text = headerTitle,
                    // Estilos para la cabecera adhesiva
                )
            }
            items(items) { itemContent ->
                Text(
                    text = itemContent,
                    modifier = Modifier.padding(16.dp)
                )
            }
        }
    }
}
```

El DSL `stickyHeader` (actualmente experimental) nos brinda esta compleja funcionalidad con una simplicidad asombrosa.

### 5. La Clave del Rendimiento: `key`

Para optimizar a√∫n m√°s el rendimiento, especialmente en listas din√°micas donde los elementos pueden a√±adirse, eliminarse o reordenarse, es fundamental proporcionar una `key` √∫nica y estable para cada elemento.

```kotlin
items(items = myItems, key = { it.id }) { item ->
    // Tu Composable para el item
}
```

Al proporcionar una clave, ayudamos a Compose a identificar de manera √∫nica cada elemento. Esto permite que el estado del elemento (como el estado de un `remember`) se mantenga correctamente cuando la lista cambia, y habilita animaciones de reordenamiento m√°s eficientes.

---

## üèãÔ∏è **Actividades**

### üöÄ **Proyecto guiado: Aplicaci√≥n "Lista de cursos"**

Para esta pr√°ctica, vamos a crear una sencilla aplicaci√≥n en la que vamos a mostrar en una cuadricula una **lista de cursos**.

‚¨ÜÔ∏è **Proyecto: Lista de cursos**

Proyecto. **Lista de Cursos**. Sigue las indicaciones [aqu√≠](https://developer.android.com/codelabs/basic-android-kotlin-compose-practice-grid?hl=es-419).

<br/>

!!! example "Aprende los conceptos previos que aplican en los proyectos"

    Para ello, realiza los siguientes proyectos guiados:

    1. Codelab. Agregar una lista desplazable. [Codelab](https://developer.android.com/codelabs/basic-android-kotlin-compose-training-add-scrollable-list?hl=es-419).
    2. Codelab. C√≥mo cambiar el icono de la App. [Codelab](https://developer.android.com/codelabs/basic-android-kotlin-compose-training-change-app-icon?hl=es-419).



