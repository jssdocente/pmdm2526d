{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Inicio","text":""},{"location":"index.html#programacion-multimedia-y-dispositivos-moviles-pmdm","title":"Programaci\u00f3n multimedia y dispositivos m\u00f3viles (PMDM)","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n multimedia y dispositivos m\u00f3viles, que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 160 horas lectivas, a raz\u00f3n de 4 horas semanales, y se desarrolla a lo largo de los dos primeros trimestres del curso. Se ha planificado bas\u00e1ndose en 2 sesiones de 2 horas lectivas por semana.</p> <p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso. </p> <p>Esta p\u00e1gina servir\u00e1 b\u00e1sicamente de gu\u00eda y contendr\u00e1 ejemplos, enlaces a otros repositorios con proyectos y ejercicios que iremos viendo en clase, o peque\u00f1os tutoriales y codelabs para ir aprendiendo diferentes conceptos.</p> <p>El m\u00f3dulo est\u00e1 dividido en dos grandes bloques, un primer bloque en d\u00f3nde aprender\u00e9is sobre desarrollo de aplicaciones Android usando Kotlin como lenguaje de programaci\u00f3n y Jetpack Compose para el desarrollo de la UI de las mismas.</p> <p>El segundo bloque trata sobre el desarrollo de videojuegos, para lo cual usaremos el motor de videojuegos Unity y el lenguaje C#.</p>"},{"location":"index.html#recursos","title":"Recursos","text":"Recursos del m\u00f3dulo Documentaci\u00f3nAndroid Code LabsSoftwareCursos <ul> <li>Documentaci\u00f3n oficial de Android</li> <li>Documentaci\u00f3n oficial de Kotlin</li> <li>Documentaci\u00f3n oficial de Jetpack Compose</li> </ul> <ul> <li> <p>Principales</p> <ul> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ul> </li> </ul> <ul> <li>IDEs<ul> <li>Android Studio</li> </ul> </li> </ul> <ul> <li>Pildoras inform\u00e1ticas<ul> <li>Curso Android &amp; Kotlin</li> <li>Curso de Android (java) con Android Studio</li> </ul> </li> <li>Youtube<ul> <li>Curso: Android con Kotlin</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul> </li> </ul>"},{"location":"temas/00-android/index.html","title":"Inicio","text":""},{"location":"temas/00-android/index.html#desarrollo-de-aplicaciones-android-con-kotlin-y-jetpack-compose","title":"Desarrollo de aplicaciones Android con Kotlin y Jetpack Compose","text":"<p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso de la parte de Android.</p> <p>P\u00e1gina de descarga de Android Studio</p> <p>Kotlin Playground</p> <p>Repositorio con respuestas a algunas dudas habituales</p>"},{"location":"temas/00-android/index.html#apartados-del-curso","title":"Apartados del curso","text":"<ol> <li> <p>Introducci\u00f3n Kotlin</p> </li> <li> <p>Jetpack Compose</p> <ol> <li> <p>Composable functions</p> </li> <li> <p>State management</p> </li> <li> <p>Listas y cuadr\u00edculas</p> </li> <li> <p>Navegaci\u00f3n y rutas</p> </li> <li> <p>Material Design</p> </li> </ol> </li> <li> <p>Ciclo de vida de una app</p> </li> <li> <p>Arquitecturas en Android</p> </li> <li> <p>La capa de UI</p> </li> <li> <p>Conexi\u00f3n a internet</p> </li> <li> <p>Conversi\u00f3n JSON a objetos</p> </li> <li> <p>Persistencia de datos</p> </li> <li> <p>Ejercicios: Enunciados y soluciones</p> </li> <li> <p>Documentaci\u00f3n extra y recursos externos</p> </li> </ol>"},{"location":"temas/00-android/index.html#codelabs-primordiales","title":"Codelabs primordiales","text":"<ol> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ol>"},{"location":"temas/00-android/02-arquitectura.html","title":"Arquitectura en Android","text":""},{"location":"temas/00-android/02-arquitectura.html#arquitectura-en-android","title":"Arquitectura en Android","text":"<p>En Android, la arquitectura de una aplicaci\u00f3n se refiere a la estructura y organizaci\u00f3n de sus componentes, como las actividades, fragmentos, servicios y otros elementos que la componen. Una buena arquitectura es fundamental para crear aplicaciones robustas, escalables y f\u00e1ciles de mantener.</p> <p>En este documento, veremos los principios b\u00e1sicos de la arquitectura en Android y c\u00f3mo puedes aplicarlos en tus propias aplicaciones. Tambi\u00e9n veremos algunas de las arquitecturas m\u00e1s comunes en Android, como MVC, MVP, MVVM y Clean Architecture, y c\u00f3mo puedes elegir la mejor arquitectura para tu proyecto.</p>"},{"location":"temas/00-android/02-arquitectura.html#principios-basicos-de-la-arquitectura-en-android","title":"Principios b\u00e1sicos de la arquitectura en Android","text":"<p>Al dise\u00f1ar la arquitectura de una aplicaci\u00f3n Android, es importante tener en cuenta los siguientes principios b\u00e1sicos:  </p> <ul> <li> <p>Separaci\u00f3n de responsabilidades: Divide tu aplicaci\u00f3n en capas o componentes que tengan responsabilidades claras y bien definidas. Por ejemplo, separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y de acceso a datos. </p> </li> <li> <p>Escalabilidad: Dise\u00f1a tu arquitectura de manera que puedas agregar nuevas funcionalidades o componentes sin tener que reescribir todo el c\u00f3digo.  </p> </li> <li> <p>Mantenibilidad: Haz que tu c\u00f3digo sea f\u00e1cil de entender, modificar y depurar. Utiliza patrones de dise\u00f1o y buenas pr\u00e1cticas de programaci\u00f3n para mantener tu c\u00f3digo limpio y organizado.  </p> </li> <li> <p>Pruebas unitarias: Dise\u00f1a tu arquitectura de manera que puedas escribir pruebas unitarias para cada componente de tu aplicaci\u00f3n. Las pruebas unitarias te permiten validar el comportamiento de tu c\u00f3digo de forma automatizada y garantizar su calidad.  </p> </li> <li> <p>Reactividad: Dise\u00f1a tu arquitectura de manera que puedas responder de forma r\u00e1pida y eficiente a los eventos y cambios en tu aplicaci\u00f3n. Utiliza patrones de dise\u00f1o reactivos para crear interfaces de usuario din\u00e1micas y reactivas. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#arquitecturas-comunes-en-android","title":"Arquitecturas comunes en Android","text":"<p>En Android, existen varias arquitecturas comunes que puedes utilizar para dise\u00f1ar tu aplicaci\u00f3n. Algunas de las arquitecturas m\u00e1s populares son las siguientes: </p> <ul> <li> <p>MVC (Modelo-Vista-Controlador): En el patr\u00f3n MVC, la vista es responsable de mostrar la interfaz de usuario, el controlador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos.  </p> </li> <li> <p>MVP (Modelo-Vista-Presentador): En el patr\u00f3n MVP, la vista es responsable de mostrar la interfaz de usuario, el presentador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El presentador act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>MVVM (Modelo-Vista-ViewModel): En el patr\u00f3n MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>Clean Architecture: La Clean Architecture es una arquitectura en capas que separa la aplicaci\u00f3n en capas de dominio, aplicaci\u00f3n e infraestructura. Cada capa tiene responsabilidades claras y bien definidas, lo que facilita la escalabilidad y mantenibilidad de la aplicaci\u00f3n. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#eleccion-de-la-arquitectura-adecuada","title":"Elecci\u00f3n de la arquitectura adecuada","text":"<p>A la hora de elegir la arquitectura para tu aplicaci\u00f3n Android, es importante tener en cuenta varios factores, como el tama\u00f1o y complejidad de la aplicaci\u00f3n, el equipo de desarrollo, los requisitos de rendimiento y escalabilidad, y la experiencia previa con las arquitecturas disponibles.    </p> <p>Algunos consejos para elegir la arquitectura adecuada son los siguientes:   </p> <ul> <li> <p>Eval\u00faa tus necesidades: Analiza los requisitos de tu aplicaci\u00f3n y elige la arquitectura que mejor se adapte a ellos. Por ejemplo, si tu aplicaci\u00f3n es peque\u00f1a y sencilla, puedes optar por una arquitectura MVC o MVP. Si tu aplicaci\u00f3n es grande y compleja, puedes optar por una arquitectura MVVM o Clean Architecture.    </p> </li> <li> <p>Prueba diferentes arquitecturas: Experimenta con diferentes arquitecturas y eval\u00faa sus ventajas y desventajas en funci\u00f3n de tus necesidades. No tengas miedo de probar nuevas arquitecturas y adaptarlas a tus necesidades espec\u00edficas.   </p> </li> <li> <p>Consulta la comunidad: Busca en la comunidad de desarrolladores de Android y consulta ejemplos, tutoriales y buenas pr\u00e1cticas sobre arquitectura. La comunidad de desarrolladores es una gran fuente de informaci\u00f3n y te puede ayudar a elegir la arquitectura adecuada para tu proyecto. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#la-arquitectura-que-vamos-a-utilizar-en-este-curso-es-mvvm","title":"La arquitectura que vamos a utilizar en este curso es MVVM","text":"<p>En este curso, vamos a utilizar la arquitectura MVVM (Modelo-Vista-ViewModel) para dise\u00f1ar nuestras aplicaciones Android. La arquitectura MVVM es una arquitectura moderna y escalable que separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y acceso a datos.   </p> <p>En la arquitectura MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo, lo que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo. </p> <p>La arquitectura MVVM es una arquitectura popular en Android y es compatible con las bibliotecas y herramientas de Jetpack, como LiveData, ViewModel y Room. Utilizaremos estas bibliotecas y herramientas en nuestro curso para crear aplicaciones Android modernas y eficientes.   </p> <p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/02-arquitectura.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Android: La documentaci\u00f3n oficial de Android, que incluye gu\u00edas, tutoriales y ejemplos para aprender a desarrollar aplicaciones Android.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio Lista de la compra - Enunciado - Soluci\u00f3n</p> </li> <li> <p>App de Carta Alta - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/03-capa-ui.html","title":"Capa de UI","text":""},{"location":"temas/00-android/03-capa-ui.html#capa-de-ui","title":"Capa de UI","text":"<p>En esta secci\u00f3n vamos a ver c\u00f3mo implementar la capa de UI en una arquitectura MVVM (Model-View-ViewModel) en una aplicaci\u00f3n Android con Jetpack Compose.</p>"},{"location":"temas/00-android/03-capa-ui.html#que-es-mvvm","title":"\u00bfQu\u00e9 es MVVM?","text":"<p>MVVM es un patr\u00f3n de arquitectura de software que se utiliza para separar la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio en una aplicaci\u00f3n. En MVVM, la capa de UI se divide en tres componentes principales:</p> <ul> <li> <p>Model: Representa los datos y la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> </li> <li> <p>View: Representa la interfaz de usuario de la aplicaci\u00f3n.</p> </li> <li> <p>ViewModel: Act\u00faa como un intermediario entre el Model y la View. Se encarga de manejar la l\u00f3gica de presentaci\u00f3n y de exponer los datos necesarios para que la View pueda mostrarlos. </p> </li> </ul> <p>MVVM es un patr\u00f3n muy utilizado en el desarrollo de aplicaciones Android, ya que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo.  </p>"},{"location":"temas/00-android/03-capa-ui.html#implementacion-de-la-capa-de-ui-en-mvvm","title":"Implementaci\u00f3n de la capa de UI en MVVM","text":"<p>Para implementar la capa de UI en una arquitectura MVVM en una aplicaci\u00f3n Android con Jetpack Compose, puedes seguir los siguientes pasos:  </p> <ol> <li> <p>Definir el Model: Define las clases y estructuras de datos que representan los datos y la l\u00f3gica de negocio de tu aplicaci\u00f3n. Por ejemplo, puedes definir una clase <code>User</code> que represente un usuario de la aplicaci\u00f3n.</p> </li> <li> <p>Definir el ViewModel: Define una clase que extienda <code>ViewModel</code> y que contenga la l\u00f3gica de presentaci\u00f3n de tu aplicaci\u00f3n. Por ejemplo, puedes definir un ViewModel que contenga la l\u00f3gica para cargar los datos de un usuario.</p> </li> <li> <p>Definir la View: Define la interfaz de usuario de tu aplicaci\u00f3n utilizando Jetpack Compose. Por ejemplo, puedes definir una funci\u00f3n componible que muestre los datos de un usuario en la pantalla.</p> </li> <li> <p>Conectar el ViewModel con la View: Conecta el ViewModel con la View para que la View pueda mostrar los datos del ViewModel. Puedes utilizar <code>rememberViewModel</code> para crear una instancia del ViewModel en la View y <code>viewModel</code> para acceder a los datos del ViewModel.</p> </li> </ol>"},{"location":"temas/00-android/03-capa-ui.html#ejemplo-de-implementacion","title":"Ejemplo de implementaci\u00f3n","text":"<p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/03-capa-ui.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/00-android/00-compose/index.html#jetpack-compose","title":"Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.    </p>"},{"location":"temas/00-android/00-compose/index.html#caracteristicas-de-jetpack-compose","title":"Caracter\u00edsticas de Jetpack Compose","text":"<ul> <li> <p>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </p> </li> <li> <p>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </p> </li> <li> <p>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </p> </li> <li> <p>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </p> </li> <li> <p>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.    </p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html#apartados","title":"Apartados","text":"<ul> <li> <p>Composable functions: Aprende a crear funciones componibles en Jetpack Compose y a componerlas para crear interfaces de usuario complejas.</p> </li> <li> <p>State management: Descubre c\u00f3mo gestionar el estado de tu aplicaci\u00f3n en Jetpack Compose y c\u00f3mo hacer que tu interfaz de usuario sea reactiva.</p> </li> <li> <p>Listas y cuadr\u00edculas: Aprende a mostrar listas y cuadr\u00edculas de elementos en Jetpack Compose y a personalizar su apariencia.</p> </li> <li> <p>Navegaci\u00f3n y rutas: Descubre c\u00f3mo implementar la navegaci\u00f3n entre pantallas en Jetpack Compose y c\u00f3mo definir rutas para tu aplicaci\u00f3n.</p> </li> <li> <p>Material Design: Aprende a implementar los principios de Material Design en Jetpack Compose y a personalizar los estilos de tus componentes.</p> </li> </ul> <p>Video Creaci\u00f3n de un proyecto Android y sus partes</p> <p></p> <p>Video L\u00f3gica de actividades e introducci\u00f3n al ciclo de vida</p> <p></p>"},{"location":"temas/00-android/00-compose/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.  </p> </li> <li> <p>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html","title":"Funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#funciones-componibles-en-jetpack-compose","title":"Funciones componibles en Jetpack Compose","text":"<p>En Jetpack Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#crear-una-funcion-componible","title":"Crear una funci\u00f3n componible","text":"<p>Para crear una funci\u00f3n componible en Jetpack Compose, utiliza la anotaci\u00f3n <code>@Composable</code> antes de la definici\u00f3n de la funci\u00f3n. Una funci\u00f3n componible puede tener par\u00e1metros y devolver un \u00e1rbol de elementos de la interfaz de usuario utilizando las funciones de composici\u00f3n proporcionadas por Compose.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Greeting</code> que toma un par\u00e1metro <code>name</code> de tipo <code>String</code> y devuelve un elemento de texto <code>Text</code> que muestra un saludo personalizado.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#componer-funciones-componibles","title":"Componer funciones componibles","text":"<p>Puedes componer funciones componibles para crear interfaces de usuario m\u00e1s complejas. Utiliza las funciones de composici\u00f3n proporcionadas por Compose, como <code>Column</code>, <code>Row</code>, <code>Box</code>, <code>Spacer</code>, etc., para organizar y dise\u00f1ar los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>GreetingList</code> que toma una lista de nombres y muestra un saludo personalizado para cada nombre utilizando la funci\u00f3n componible <code>Greeting</code>.</p> <p>Video introducci\u00f3n a Compose</p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#actualizacion-de-funciones-componibles","title":"Actualizaci\u00f3n de funciones componibles","text":"<p>Las funciones componibles en Jetpack Compose son reactivas, lo que significa que se vuelven a ejecutar autom\u00e1ticamente cuando cambian los datos de entrada. Esto permite que la interfaz de usuario se actualice de forma din\u00e1mica en respuesta a los cambios en los datos.</p> <pre><code>@Composable\nfun Counter(count: Int) {\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Counter</code> que muestra el recuento actual. Cuando cambia el recuento, la funci\u00f3n componible se vuelve a ejecutar autom\u00e1ticamente para reflejar el nuevo valor.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#columnas-y-filas-en-jetpack-compose","title":"Columnas y filas en Jetpack Compose+","text":"<p>Jetpack Compose proporciona las funciones <code>Column</code> y <code>Row</code> para organizar elementos de la interfaz de usuario en columnas y filas respectivamente. Puedes anidar columnas y filas para crear dise\u00f1os m\u00e1s complejos y reutilizables.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Spacer(modifier = Modifier.height(8.dp))\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical. Se a\u00f1ade un <code>Spacer</code> entre cada saludo para separarlos visualmente.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificadores-en-jetpack-compose","title":"Modificadores en Jetpack Compose","text":"<p>Jetpack Compose utiliza modificadores para aplicar estilos y comportamientos a los elementos de la interfaz de usuario. Puedes utilizar modificadores para cambiar el tama\u00f1o, la posici\u00f3n, el color, la forma, etc., de los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier\n            .padding(16.dp)\n            .background(Color.Blue)\n            .clickable { /* Acci\u00f3n al hacer clic */ }\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un relleno alrededor del texto, el modificador <code>background</code> para cambiar el color de fondo del texto, y el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p> <p>!!! info \"Video Modificadores y uso del tema]     </p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#recursos-en-jetpack-compose","title":"Recursos en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de recursos de Android para gestionar los recursos de la interfaz de usuario, como cadenas, colores, dimensiones, etc. Puedes acceder a los recursos utilizando la funci\u00f3n <code>stringResource()</code>, <code>colorResource()</code>, <code>dimenResource()</code>, etc.</p> <pre><code>@Composable\nfun Greeting() {\n    Text(\n        text = stringResource(id = R.string.hello),\n        color = colorResource(id = R.color.primary),\n        fontSize = dimenResource(id = R.dimen.text_size)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>stringResource()</code> para obtener una cadena de recursos, la funci\u00f3n <code>colorResource()</code> para obtener un color de recursos, y la funci\u00f3n <code>dimenResource()</code> para obtener una dimensi\u00f3n de recursos.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#temas-en-jetpack-compose","title":"Temas en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de temas de Android para aplicar estilos coherentes a la interfaz de usuario. Puedes definir un tema personalizado utilizando la funci\u00f3n <code>provideAppTheme()</code> y aplicarlo a tu aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p> <pre><code>@Composable\nfun MyApp() {\n    MaterialTheme(\n        colors = lightColors(),\n        typography = Typography,\n        shapes = Shapes\n    ) {\n        Greeting()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado con colores, tipograf\u00eda y formas personalizadas, y se aplica a la aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplos-de-funciones-componibles","title":"Ejemplos de funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-row","title":"Ejemplo de funci\u00f3n con Row","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Row</code> para organizar el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-box","title":"Ejemplo de funci\u00f3n con Box","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Box(\n        modifier = Modifier\n            .background(Color.Blue)\n            .padding(16.dp)\n    ) {\n        Text(text = \"Hello, $name!\", color = Color.White)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Box</code> para colocar el texto en un cuadro azul con un relleno de 16 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-column","title":"Ejemplo de funci\u00f3n con Column","text":"<pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Divider(color = Color.Gray, thickness = 1.dp)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical con una l\u00ednea divisoria entre cada saludo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#como-anadir-imagenes-usando-image-y-painterresource","title":"C\u00f3mo a\u00f1adir im\u00e1genes usando Image y painterResource","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Image(\n            painter = painterResource(id = R.drawable.ic_launcher_foreground),\n            contentDescription = null,\n            modifier = Modifier.size(48.dp)\n        )\n        Spacer(modifier = Modifier.width(8.dp))\n        Text(text = \"Hello, $name!\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Image</code> para a\u00f1adir una imagen a la interfaz de usuario utilizando un recurso de imagen.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#previews-en-jetpack-compose","title":"Previews en Jetpack Compose","text":"<p>Jetpack Compose proporciona una funci\u00f3n <code>@Preview</code> que te permite previsualizar tus funciones componibles en tiempo real en Android Studio. Puedes definir previsualizaciones para tus funciones componibles y ver c\u00f3mo se ven en diferentes configuraciones y estados.</p> <pre><code>@Preview\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una previsualizaci\u00f3n <code>GreetingPreview</code> para la funci\u00f3n componible <code>Greeting</code> con el nombre \"World\". Puedes ver la previsualizaci\u00f3n en Android Studio y ajustarla seg\u00fan sea necesario.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-previsualizacion","title":"Opciones de previsualizaci\u00f3n","text":"<p>Jetpack Compose proporciona varias opciones de previsualizaci\u00f3n que te permiten personalizar la apariencia de tus previsualizaciones. Puedes definir diferentes configuraciones, tama\u00f1os, orientaciones, temas, etc., para tus previsualizaciones y ver c\u00f3mo se ven en diferentes contextos.</p> <pre><code>@Preview(\n    showBackground = true,\n    name = \"Greeting Preview\",\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    widthDp = 320,\n    heightDp = 240\n)\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>Las opciones de previsualizaci\u00f3n son las siguientes:</p> <ul> <li><code>showBackground</code>: Muestra un fondo en la previsualizaci\u00f3n.</li> <li><code>name</code>: Nombre de la previsualizaci\u00f3n.</li> <li><code>uiMode</code>: Modo de interfaz de usuario (claro, oscuro, etc.).</li> <li><code>widthDp</code>: Ancho de la previsualizaci\u00f3n en dp.</li> <li><code>heightDp</code>: Alto de la previsualizaci\u00f3n en dp.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-en-jetpack-compose","title":"Opciones de alineaci\u00f3n en Jetpack Compose","text":"<p>Jetpack Compose proporciona opciones de alineaci\u00f3n que te permiten alinear los elementos de la interfaz de usuario de forma horizontal y vertical. Puedes utilizar las opciones de alineaci\u00f3n para controlar la posici\u00f3n de los elementos en la pantalla y crear dise\u00f1os m\u00e1s precisos y coherentes.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier.align(Alignment.CenterHorizontally)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro de la pantalla.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-horizontal","title":"Opciones de alineaci\u00f3n horizontal","text":"<p>Las opciones de alineaci\u00f3n horizontal en Jetpack Compose son las siguientes:</p> <ul> <li><code>start</code>: Alinea el elemento al principio del eje horizontal.</li> <li><code>centerHorizontally</code>: Alinea el elemento en el centro del eje horizontal.</li> <li><code>end</code>: Alinea el elemento al final del eje horizontal.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-vertical","title":"Opciones de alineaci\u00f3n vertical","text":"<p>Las opciones de alineaci\u00f3n vertical en Jetpack Compose son las siguientes:</p> <ul> <li><code>top</code>: Alinea el elemento en la parte superior del eje vertical.</li> <li><code>centerVertically</code>: Alinea el elemento en el centro del eje vertical.</li> <li><code>bottom</code>: Alinea el elemento en la parte inferior del eje vertical.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-personalizadas","title":"Opciones de alineaci\u00f3n personalizadas","text":"<p>Adem\u00e1s de las opciones de alineaci\u00f3n predefinidas, Jetpack Compose te permite crear opciones de alineaci\u00f3n personalizadas utilizando la funci\u00f3n <code>Alignment</code>.</p> <pre><code>val CustomAlignment = Alignment(0.25f, 0.75f)\n</code></pre> <p>En el ejemplo anterior, se define una opci\u00f3n de alineaci\u00f3n personalizada <code>CustomAlignment</code> con un desplazamiento horizontal del 25% y un desplazamiento vertical del 75%.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#uso-de-opciones-de-alineacion-en-column-y-row","title":"Uso de opciones de alineaci\u00f3n en Column y Row","text":"<p>Puedes utilizar las opciones de alineaci\u00f3n en las funciones <code>Column</code> y <code>Row</code> para alinear los elementos de la interfaz de usuario de forma horizontal y vertical.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.SpaceEvenly\n    ) {\n        Text(text = \"Hello, $name!\")\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la opci\u00f3n de alineaci\u00f3n vertical <code>Alignment.CenterVertically</code> y la disposici\u00f3n horizontal <code>Arrangement.SpaceEvenly</code> para alinear el texto y el icono en una fila horizontal.</p> <p>Las diferentes opciones de alineaci\u00f3n y disposici\u00f3n te permiten crear dise\u00f1os flexibles y personalizados en Jetpack Compose.</p> <p>Para el Arrangement existen las siguientes opciones:</p> <ul> <li><code>SpaceAround</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos.</li> <li><code>SpaceBetween</code>: Distribuye el espacio entre los elementos de forma uniforme, sin espacio adicional alrededor de los elementos.</li> <li><code>SpaceEvenly</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos y en los extremos.</li> <li><code>Center</code>: Centra los elementos en el espacio disponible.</li> <li><code>Start</code>: Coloca los elementos al principio del espacio disponible.</li> <li><code>End</code>: Coloca los elementos al final del espacio disponible.</li> </ul> <p>En las siguientes im\u00e1genes animadas se muestran ejemplos de alineaci\u00f3n horizontal y vertical en Jetpack Compose:</p> <p></p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#mas-ejemplos-de-modificaciones","title":"M\u00e1s ejemplos de modificaciones","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tamano","title":"Modificador de tama\u00f1o","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.size(48.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>size</code> para cambiar el tama\u00f1o del texto a 48 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-altura-y-anchura","title":"Modificador de altura y anchura","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.width(100.dp).height(50.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utilizan los modificadores <code>width</code> y <code>height</code> para cambiar la anchura del texto a 100 dp y la altura a 50 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tipografia","title":"Modificador de tipograf\u00eda","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", style = TextStyle(fontWeight = FontWeight.Bold))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>style</code> para cambiar el peso de la fuente del texto a negrita.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-alineacion","title":"Modificador de alineaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.align(Alignment.CenterHorizontally))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-margen","title":"Modificador de margen","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.padding(16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un margen de 16 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-color-de-fondo","title":"Modificador de color de fondo","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.background(Color.Blue))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>background</code> para cambiar el color de fondo del texto a azul.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-borde","title":"Modificador de borde","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.border(1.dp, Color.Black))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>border</code> para a\u00f1adir un borde de 1 dp de grosor alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-clic","title":"Modificador de clic","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ })\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-forma","title":"Modificador de forma","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clip(RoundedCornerShape(4.dp)))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clip</code> para aplicar una forma redondeada con un radio de 4 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-rotacion","title":"Modificador de rotaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.rotate(45f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>rotate</code> para rotar el texto 45 grados.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-escala","title":"Modificador de escala","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.scale(1.5f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>scale</code> para escalar el texto a 1.5 veces su tama\u00f1o original.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desplazamiento","title":"Modificador de desplazamiento","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.offset(x = 16.dp, y = 16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>offset</code> para desplazar el texto 16 dp hacia la derecha y 16 dp hacia abajo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-sombra","title":"Modificador de sombra","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.shadow(4.dp, shape = CircleShape))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>shadow</code> para a\u00f1adir una sombra de 4 dp alrededor del texto con una forma circular.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desenfoque","title":"Modificador de desenfoque","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.blur(4.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>blur</code> para aplicar un efecto de desenfoque al texto con un radio de 4 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#otros-ejemplos-de-funciones-componibles-de-interes","title":"Otros ejemplos de funciones componibles de inter\u00e9s","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#el-uso-de-spacer","title":"El uso de Spacer","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Spacer</code> para a\u00f1adir un espacio entre el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html","title":"Gesti\u00f3n del estado","text":""},{"location":"temas/00-android/00-compose/22-state-management.html#gestion-de-estado-en-jetpack-compose","title":"Gesti\u00f3n de estado en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#que-es-el-estado-y-por-que-es-importante","title":"\u2753\u00bfQu\u00e9 es el estado y por qu\u00e9 es importante ?","text":"<p>Imagina que construyes una aplicaci\u00f3n sin pensar en c\u00f3mo se gestionan los datos. Al principio, todo parece funcionar. Un bot\u00f3n cambia un texto. Un campo de entrada muestra lo que el usuario escribe. Pero pronto, la complejidad crece:</p> <ul> <li>\u00bfQu\u00e9 pasa si al girar la pantalla todo el texto que el usuario escribi\u00f3 desaparece?</li> <li>\u00bfC\u00f3mo se asegura una pantalla de que est\u00e1 mostrando los datos m\u00e1s actualizados que acaban de llegar de internet?</li> <li>Si actualizas un dato en la pantalla A, \u00bfc\u00f3mo se entera la pantalla B de que debe mostrar ese cambio?</li> </ul> <p>Estos problemas surgen de una gesti\u00f3n de estado deficiente o inexistente. La gesti\u00f3n del estado no es un concepto acad\u00e9mico y abstracto; es el pilar fundamental sobre el que se construye cualquier aplicaci\u00f3n interactiva y fiable.</p> <p>En esencia, el estado es la verdad; es el conjunto de datos que define c\u00f3mo se ve y se comporta tu aplicaci\u00f3n en un momento dado. La gesti\u00f3n del estado es la disciplina de controlar c\u00f3mo y d\u00f3nde fluye esa verdad a trav\u00e9s de tu aplicaci\u00f3n.</p> <p>En Jetpack Compose, un framework de UI declarativo, esta importancia se multiplica por diez. A diferencia de los sistemas imperativos (como las Vistas de Android XML) donde t\u00fa manualmente buscas un <code>TextView</code> y le dices <code>setText()</code>, en Compose simplemente declaras: \"La UI debe mostrar el valor de esta variable de estado\". Cuando la variable cambia, la UI reacciona y se actualiza sola.</p> <p>Importante</p> <p>dominar la gesti\u00f3n del estado en Compose no es una opci\u00f3n, es el requisito principal para construir aplicaciones que funcionen correctamente, sean f\u00e1ciles de mantener y est\u00e9n libres de errores impredecibles.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#que-es-el-estado-en-jetpack-compose","title":"\u00bfQu\u00e9 es el Estado en Jetpack Compose?","text":"<p>En Jetpack Compose, el estado es cualquier valor que puede cambiar con el tiempo y que, al hacerlo, debe provocar que la interfaz de usuario se actualice (se redibuje).</p> <p>Pi\u00e9nsalo de esta manera:</p> <ul> <li>El texto que un usuario introduce en un <code>TextField</code>.</li> <li>El estado de un <code>Checkbox</code> (marcado o no marcado).</li> <li>La posici\u00f3n de un <code>Slider</code>.</li> <li>Una lista de mensajes que se carga desde una base de datos.</li> </ul> <p>Todos estos son ejemplos de estado. Si el valor cambia, la UI debe reflejar ese cambio. El mecanismo por el cual Compose redibuja la UI cuando el estado cambia se llama Recomposici\u00f3n.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#declarando-el-estado-el-duo-indispensable-remember-y-mutablestateof","title":"Declarando el Estado: El D\u00fao Indispensable <code>remember</code> y <code>mutableStateOf</code>","text":"<p>Para que Compose pueda \"observar\" un valor y reaccionar a sus cambios, no podemos usar una variable normal como <code>var nombre = \"Android\"</code>. Necesitamos declararla de una forma especial. Aqu\u00ed es donde entran en juego dos funciones clave:</p> <ol> <li> <p><code>mutableStateOf(valorInicial)</code>: Esta funci\u00f3n toma un valor inicial y lo envuelve en un objeto <code>State</code> observable. Cuando el <code>.value</code> de este objeto cambia, Compose se entera y programa una recomposici\u00f3n para todas las funciones Composable que lean ese estado.</p> </li> <li> <p><code>remember { ... }</code>: Las funciones Composable pueden ejecutarse muchas veces (durante las recomposiciones). <code>remember</code> es el ant\u00eddoto contra la \"amnesia\" de la recomposici\u00f3n. Almacena en cach\u00e9 el resultado del bloque de c\u00f3digo que se le pasa, asegurando que este valor sobreviva y no se reinicie cada vez que la UI se redibuja.</p> </li> </ol> <p>La combinaci\u00f3n de ambos es la f\u00f3rmula m\u00e1gica para el estado local en un Composable:</p> <p><code>remember { mutableStateOf(valorInicial) }</code></p> <ul> <li><code>mutableStateOf</code> crea el estado observable.</li> <li><code>remember</code> se asegura de que este estado no se pierda en las recomposiciones.</li> </ul>"},{"location":"temas/00-android/00-compose/22-state-management.html#formas-de-definir-el-estado","title":"Formas de Definir el Estado","text":"<p>Veamos un ejemplo pr\u00e1ctico: un simple contador que incrementa un n\u00famero cada vez que se presiona un bot\u00f3n. Exploraremos las tres formas sint\u00e1cticas de declarar y usar el estado.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-1-la-forma-explicita-con-value","title":"Ejemplo 1: La Forma Expl\u00edcita con <code>.value</code>","text":"<p>Esta es la forma m\u00e1s literal. Accedemos y modificamos el valor del estado a trav\u00e9s de su propiedad <code>.value</code>. Es excelente para entender lo que sucede internamente.</p> <p>Analog\u00eda: Tienes una caja (<code>contadorState</code>) que es inmutable, pero puedes abrirla para cambiar su contenido (<code>contadorState.value</code>).</p> <pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorConValue() {\n    // Creamos el estado y lo recordamos. Su tipo es MutableState&lt;Int&gt;.\n    val contadorState = remember { mutableStateOf(0) }\n\n    Column {\n        // Para leer el valor, debemos usar .value\n        Text(text = \"Has presionado el bot\u00f3n ${contadorState.value} veces.\")\n\n        Button(onClick = {\n            // Para modificar el valor, tambi\u00e9n usamos .value\n            contadorState.value = contadorState.value + 1\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-2-la-forma-idiomatica-con-el-delegado-by","title":"Ejemplo 2: La Forma Idiom\u00e1tica con el Delegado <code>by</code>","text":"<p>Esta es la forma m\u00e1s com\u00fan y recomendada en Kotlin. Usamos el delegado de propiedad <code>by</code> para que Compose gestione el acceso a <code>.value</code> por nosotros. El c\u00f3digo resulta mucho m\u00e1s limpio y legible.</p> <p>Analog\u00eda: Contratas a un asistente (<code>by</code>). En lugar de abrir la caja t\u00fa mismo, le pides el valor directamente a tu asistente, y \u00e9l se encarga de los detalles.</p> <p></p><pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorConDelegado() {\n    // Usamos 'var' porque reasignaremos el valor y 'by' para delegar.\n    // 'contador' se comporta ahora como un Int, no como un State&lt;Int&gt;.\n    var contador by remember { mutableStateOf(0) }\n\n    Column {\n        // Leemos el valor directamente, \u00a1sin .value!\n        Text(text = \"Has presionado el bot\u00f3n $contador veces.\")\n\n        Button(onClick = {\n            // Modificamos el valor directamente.\n            contador++ // o contador = contador + 1\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre> (Nota: Para usar el delegado <code>by</code>, es posible que necesites a\u00f1adir <code>import androidx.compose.runtime.getValue</code> y <code>setValue</code>)<p></p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-3-la-forma-con-desestructuracion","title":"Ejemplo 3: La Forma con Desestructuraci\u00f3n","text":"<p>Esta sintaxis, popular en otros frameworks como React, permite desestructurar el estado en una variable de solo lectura para el valor y una funci\u00f3n para actualizarlo.</p> <p>Analog\u00eda: Tienes un termostato con dos partes: una pantalla que te muestra la temperatura (<code>contador</code>) y una rueda que te permite cambiarla (<code>setContador</code>).</p> <pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorDesestructurado() {\n    // Desestructuramos el State en un valor y una funci\u00f3n lambda para actualizarlo.\n    val (contador, setContador) = remember { mutableStateOf(0) }\n\n    Column {\n        // Leemos el valor directamente.\n        Text(text = \"Has presionado el bot\u00f3n $contador veces.\")\n\n        Button(onClick = {\n            // Usamos la funci\u00f3n para establecer el nuevo valor.\n            setContador(contador + 1)\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre> <p>Recuerda los puntos clave</p> <ol> <li>El estado es la fuente de verdad que impulsa tu UI.</li> <li>La recomposici\u00f3n es el proceso autom\u00e1tico por el cual Compose actualiza la UI cuando el estado cambia.</li> <li><code>mutableStateOf</code> crea un estado observable que Compose puede rastrear.</li> <li><code>remember</code> le da memoria a tus Composables, permitiendo que el estado sobreviva a las recomposiciones.</li> <li>La sintaxis con el delegado <code>by</code> es la forma preferida por su simplicidad y legibilidad.</li> </ol> <p>Video introducci\u00f3n al manejo del estado en Compose</p> <p></p>"},{"location":"temas/00-android/00-compose/22-state-management.html#mas-en-detalle","title":"\ud83d\udd2c M\u00e1s en detalle","text":"<p>Puedes definir el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>mutableStateOf()</code> de Compose.</p> <pre><code>val contador = mutableStateOf(0)\n</code></pre> <p>En el ejemplo anterior, se define un estado <code>contador</code> con un valor inicial de <code>0</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-estado","title":"Observaci\u00f3n de estado","text":"<p>Puedes observar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>observeAsState()</code> de Compose.</p> <pre><code>val contadorState = contador.observeAsState()\nval contador = contadorState.value\n</code></pre> <p>En el ejemplo anterior, se observa el estado <code>contador</code> y se obtiene su valor actual.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#actualizacion-de-estado","title":"Actualizaci\u00f3n de estado","text":"<p>Puedes actualizar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>value</code> de Compose.</p> <pre><code>contador.value++\n</code></pre> <p>En el ejemplo anterior, se incrementa en uno el valor del estado <code>contador</code>.</p> <p>\u00a1Importante!</p> <p>El estado en Compose es inmutable, por lo que debes utilizar la funci\u00f3n <code>value</code> para actualizar el estado.</p> <p>Para que haya recomposici\u00f3n, la actualizaci\u00f3n del estado debe realizarse dentro de un evento de un componente <code>@Composable</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-completo","title":"Ejemplo completo","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#tipos-de-estado","title":"Tipos de estado","text":"<p>En Jetpack Compose, puedes utilizar diferentes tipos de estado para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <ul> <li><code>mutableStateOf()</code>: Crea un estado mutable que puede cambiar a lo largo del tiempo.</li> <li><code>remember</code>: Crea un estado que se mantiene entre recomposiciones.</li> <li><code>derivedStateOf()</code>: Crea un estado derivado a partir de otros estados.</li> </ul>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remember","title":"Uso de remember","text":"<p>La funci\u00f3n <code>remember</code> de Compose te permite crear un estado que se mantiene entre recomposiciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>remember</code> para crear un estado <code>contador</code> que se mantiene entre recomposiciones.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remembersaveable","title":"Uso de rememberSaveable","text":"<p>La funci\u00f3n <code>rememberSaveable</code> de Compose te permite crear un estado que se mantiene entre configuraciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = rememberSaveable { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>rememberSaveable</code> para crear un estado <code>contador</code> que se mantiene entre configuraciones.</p> <p>Remember vs RememberSaveable</p> <p>La diferencia entre <code>remember</code> y <code>rememberSaveable</code> es que <code>rememberSaveable</code> guarda el estado en el <code>Bundle</code> de la actividad para que se pueda restaurar despu\u00e9s de una recreaci\u00f3n de la actividad.</p> <p>Esto es \u00fatil para guardar el estado de la aplicaci\u00f3n cuando la actividad se destruye y se vuelve a crear, por ejemplo, al girar la pantalla.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-derivedstateof","title":"Uso de derivedStateOf","text":"<p>La funci\u00f3n <code>derivedStateOf</code> de Compose te permite crear un estado derivado a partir de otros estados.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val doble = derivedStateOf { contador.value * 2 }\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contador.value}, Doble: ${doble.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>derivedStateOf</code> para crear un estado <code>doble</code> que es el doble del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-kotlin","title":"\ud83d\udca6 Flows en Kotlin","text":"<p>En Kotlin, un <code>Flow</code> es una secuencia de valores que se emiten de forma as\u00edncrona y reactiva. Los <code>Flow</code> te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla.</p> <p>Explicaci\u00f3n sencilla</p> <p>Imagina que los Flows son como mangueras de agua \ud83d\udca7. Transportan datos (el agua) desde un emisor (el grifo) hasta un colector (alguien que recoge el agua). La diferencia entre los tipos de Flow radica en c\u00f3mo y a qui\u00e9n entregan esa agua.</p> <p>Existen principalmente tres tipos que debes dominar:</p> <ul> <li> <p>Flow (Fr\u00edo \ud83e\udd76): Es la manguera est\u00e1ndar. Solo empieza a soltar agua (emitir datos) cuando alguien abre el grifo (collect). Cada persona que se conecta (collect) obtiene su propia manguera y recibe toda la secuencia de datos desde el principio. No empieza a producir si nadie est\u00e1 escuchando.</p> </li> <li> <p>SharedFlow (Caliente \ud83d\udd25): Es como un aspersor en un jard\u00edn. Emite datos constantemente (o bajo ciertas condiciones) sin importar si alguien est\u00e1 mirando o no. M\u00faltiples colectores pueden conectarse a \u00e9l y todos recibir\u00e1n los mismos datos que se emitan despu\u00e9s de que se conecten. Es ideal para eventos que deben ser compartidos entre varias partes de tu app (ej: \"\u00a1Pago realizado con \u00e9xito!\").</p> </li> <li> <p>StateFlow (Caliente y con memoria \ud83e\uddd0): Es una especializaci\u00f3n de SharedFlow. Piensa en \u00e9l como un term\u00f3metro digital en la pared. Siempre tiene un valor (la temperatura actual) y cualquiera que lo mire ver\u00e1 ese valor. Si el valor cambia, todos los que lo est\u00e9n mirando ver\u00e1n la actualizaci\u00f3n. La clave es que siempre tiene un valor inicial y solo emite el valor m\u00e1s reciente a los nuevos colectores. No emite valores repetidos si son id\u00e9nticos al anterior.</p> </li> </ul> Ejemplo 1 <code>Flow</code>: El Flujo Fr\u00edo <p>Un Flow solo se activa cuando se consume. Perfecto para operaciones de un solo disparo que devuelven una secuencia, como leer de una base de datos o hacer una petici\u00f3n de red.</p> <p></p><pre><code>import kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.flow\nimport kotlinx.coroutines.runBlocking\n\n// 1. Definimos un Flow que emite n\u00fameros del 1 al 3, con una pausa.\nfun getNumeros(): Flow&lt;Int&gt; = flow {\n    println(\"El Flow ha comenzado a emitir.\")\n    for (i in 1..3) {\n        delay(1000) // Simula trabajo o espera\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    println(\"Llamando a la funci\u00f3n que devuelve el Flow...\")\n    val miFlow = getNumeros()\n\n    println(\"Esperando para recolectar...\")\n    delay(2000)\n\n    println(\"Iniciando la recolecci\u00f3n.\")\n    miFlow.collect { numero -&gt;\n        println(\"N\u00famero recibido: $numero\")\n    }\n\n    println(\"La recolecci\u00f3n ha terminado.\")\n}\n</code></pre> Resultado de la ejecuci\u00f3n:<p></p> <pre><code>Llamando a la funci\u00f3n que devuelve el Flow...\nEsperando para recolectar...\nIniciando la recolecci\u00f3n.\nEl Flow ha comenzado a emitir. // &lt;-- \u00a1NOTA! El c\u00f3digo del flow no se ejecuta hasta el .collect()\nN\u00famero recibido: 1\nN\u00famero recibido: 2\nN\u00famero recibido: 3\nLa recolecci\u00f3n ha terminado.\n</code></pre> Ejemplo 2 <code>SharedFlow</code>: El flujo para eventos <p>Ideal para enviar eventos a m\u00faltiples suscriptores. No tiene un estado inicial.</p> <p></p><pre><code>import kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\n\nfun main() = runBlocking {\n// Creamos un SharedFlow mutable para poder emitir valores.\nval eventos = MutableSharedFlow&lt;String&gt;()\n\n// Lanzamos una corrutina para el primer suscriptor\nlaunch {\n    println(\"Suscriptor 1 esperando eventos...\")\n    eventos.collect { evento -&gt;\n        println(\"Suscriptor 1 recibi\u00f3: $evento\")\n    }\n}\n\ndelay(500) // Damos tiempo a que el primer suscriptor se conecte\n\nprintln(\"Emitiendo 'Evento A'\")\neventos.emit(\"Evento A\")\n\n// Lanzamos una segunda corrutina para otro suscriptor\nlaunch {\n    println(\"Suscriptor 2 esperando eventos...\")\n    eventos.collect { evento -&gt;\n        println(\"Suscriptor 2 recibi\u00f3: $evento\")\n    }\n}\n\ndelay(500)\n\nprintln(\"Emitiendo 'Evento B'\")\neventos.emit(\"Evento B\") // Ambos suscriptores reciben este\n}\n</code></pre> Resultado de la ejecuci\u00f3n:<p></p> <pre><code>Suscriptor 1 esperando eventos...\nEmitiendo 'Evento A'\nSuscriptor 1 recibi\u00f3: Evento A\nSuscriptor 2 esperando eventos...\nEmitiendo 'Evento B'\nSuscriptor 1 recibi\u00f3: Evento B\nSuscriptor 2 recibi\u00f3: Evento B // &lt;-- Ambos reciben los eventos emitidos DESPU\u00c9S de suscribirse\n</code></pre> Ejemplo 3 <code>StateFlow</code>: El Rey de Jetpack Compose \ud83d\udc51 EjemploExplicaci\u00f3n del c\u00f3digo <p>En este ejemplo, crearemos una clase Carrito que expondr\u00e1 el n\u00famero de art\u00edculos como un StateFlow. As\u00ed, cualquier parte de nuestro c\u00f3digo que est\u00e9 \"observando\" el carrito sabr\u00e1 inmediatamente cu\u00e1ntos art\u00edculos hay.</p> <p></p><pre><code>import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\n\n// 1. La clase que gestiona el estado\nclass Carrito {\n\n    // Privado y Mutable: Solo el carrito puede cambiar el n\u00famero de art\u00edculos.\n    // Lo inicializamos con un valor de 0 art\u00edculos.\n    private val _numeroDeArticulos = MutableStateFlow(0)\n\n    // P\u00fablico e Inmutable: Exponemos el Flow como solo lectura.\n    // Cualquiera puede observar cu\u00e1ntos art\u00edculos hay, pero no pueden cambiar el valor directamente.\n    val numeroDeArticulos = _numeroDeArticulos.asStateFlow()\n\n    fun anadirArticulo() {\n        // Usamos .update para cambiar el valor de forma segura.\n        // Es la forma recomendada para modificar un StateFlow.\n        _numeroDeArticulos.update { valorActual -&gt;\n            valorActual + 1\n        }\n        println(\"\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: ${_numeroDeArticulos.value}\")\n    }\n\n    fun quitarArticulo() {\n        if (_numeroDeArticulos.value &gt; 0) {\n            _numeroDeArticulos.update { it - 1 } // 'it' es el valor actual\n            println(\"\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: ${_numeroDeArticulos.value}\")\n        } else {\n            println(\"\u26a0\ufe0f El carrito ya est\u00e1 vac\u00edo.\")\n        }\n    }\n}\n\n// 2. La funci\u00f3n principal que simula el uso\nfun main() = runBlocking {\n    val miCarrito = Carrito()\n\n    // Lanzamos una corrutina que se quedar\u00e1 observando el carrito.\n    // Este ser\u00eda el equivalente a nuestra \"UI\" o consumidor de datos.\n    val jobObservador = launch {\n        println(\"\ud83d\udc40 Observador conectado. Esperando actualizaciones del carrito...\")\n        miCarrito.numeroDeArticulos.collect { total -&gt;\n            // Este bloque se ejecutar\u00e1 cada vez que el valor del StateFlow cambie.\n            println(\"\ud83d\uded2 (Observador) El carrito ahora tiene $total art\u00edculos.\")\n        }\n    }\n\n    // Damos un peque\u00f1o respiro para que el observador se inicie\n    delay(100)\n\n    // Simulamos interacciones del usuario\n    println(\"\\n--- Simulaci\u00f3n de usuario ---\")\n    miCarrito.anadirArticulo()\n    delay(1000)\n\n    miCarrito.anadirArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo() // Intentamos quitar cuando est\u00e1 vac\u00edo\n    println(\"--- Fin de la simulaci\u00f3n ---\\n\")\n\n    // Cancelamos la corrutina del observador para que el programa termine\n    jobObservador.cancel()\n}\n</code></pre> Salida esperada en la consola:<p></p> <pre><code>\ud83d\udc40 Observador conectado. Esperando actualizaciones del carrito...\n\ud83d\uded2 (Observador) El carrito ahora tiene 0 art\u00edculos.\n\n--- Simulaci\u00f3n de usuario ---\n\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: 1\n\ud83d\uded2 (Observador) El carrito ahora tiene 1 art\u00edculos.\n\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: 2\n\ud83d\uded2 (Observador) El carrito ahora tiene 2 art\u00edculos.\n\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: 1\n\ud83d\uded2 (Observador) El carrito ahora tiene 1 art\u00edculos.\n\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: 0\n\ud83d\uded2 (Observador) El carrito ahora tiene 0 art\u00edculos.\n\u26a0\ufe0f El carrito ya est\u00e1 vac\u00edo.\n--- Fin de la simulaci\u00f3n ---\n</code></pre> <ol> <li> <p>La Clase <code>Carrito</code>:</p> <ul> <li> <p><code>_numeroDeArticulos</code>: Es un <code>MutableStateFlow</code>. El guion bajo <code>_</code> es una convenci\u00f3n en Kotlin para indicar que es una propiedad privada que no debe usarse desde fuera. Al ser <code>Mutable</code>, esta clase puede cambiar su valor. Siempre necesita un valor inicial (en este caso, <code>0</code>).</p> </li> <li> <p><code>numeroDeArticulos</code>: Esta es la versi\u00f3n p\u00fablica y de solo lectura (<code>StateFlow</code>). La \"UI\" o el consumidor observar\u00e1 esta propiedad. Esto protege el estado; nadie fuera de la clase <code>Carrito</code> puede modificar el n\u00famero de art\u00edculos. Es un principio de encapsulaci\u00f3n.</p> </li> <li> <p><code>anadirArticulo()</code> y <code>quitarArticulo()</code>: Son las acciones que modifican el estado interno (<code>_numeroDeArticulos</code>). La funci\u00f3n <code>.update { ... }</code> es la forma moderna y segura de hacerlo.</p> </li> </ul> </li> <li> <p>La Funci\u00f3n <code>main</code>:</p> <ul> <li> <p><code>launch</code>: Creamos un \"observador\" en una corrutina separada. Este se suscribe al <code>StateFlow</code> p\u00fablico.</p> </li> <li> <p><code>.collect</code>: Aqu\u00ed ocurre la magia. El c\u00f3digo dentro de <code>.collect</code> se ejecuta inmediatamente con el valor actual del <code>StateFlow</code> (que es <code>0</code>) y luego se vuelve a ejecutar cada vez que el valor cambia.</p> </li> <li> <p><code>delay</code>: Usamos pausas para simular el paso del tiempo y que se pueda ver claramente en la consola c\u00f3mo el observador reacciona a los cambios.</p> </li> </ul> </li> </ol> <p>Puedes crear un <code>Flow</code> utilizando la funci\u00f3n <code>flowOf()</code> de Kotlin.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Flow</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-flows","title":"Observaci\u00f3n de Flows","text":"<p>Puedes observar un <code>Flow</code> utilizando la funci\u00f3n <code>collect()</code> de Kotlin.</p> <pre><code>numeros.collect { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se observa el <code>Flow</code> <code>numeros</code> y se imprime cada valor que se emite.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#transformacion-de-flows","title":"Transformaci\u00f3n de Flows","text":"<p>Puedes transformar un <code>Flow</code> utilizando operadores como <code>map</code>, <code>filter</code>, <code>flatMap</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan los operadores <code>map</code> y <code>filter</code> para transformar el <code>Flow</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#tipos-de-flow-en-kotlin","title":"Tipos de flow en Kotlin","text":""},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-jetpack-compose","title":"Flows en Jetpack Compose","text":"<p>En Jetpack Compose, puedes utilizar Flows para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <p>Puedes convertir un <code>Flow</code> en un estado observable utilizando la funci\u00f3n <code>collectAsState()</code> de Compose.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\nval numerosState = numeros.collectAsState()\n</code></pre> <p>En el ejemplo anterior, se convierte el <code>Flow</code> <code>numeros</code> en un estado observable <code>numerosState</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#elevacion-del-estado","title":"Elevaci\u00f3n del estado","text":"<p>En Jetpack Compose, puedes elevar el estado de un componente para compartirlo con otros componentes.</p> <p>Esto te permite gestionar el estado de tu aplicaci\u00f3n de forma centralizada y compartirlo entre diferentes partes de tu interfaz de usuario.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    ContadorBoton(contador)\n    ContadorTexto(contador)\n}\n\n@Composable\nfun ContadorBoton(contador: MutableState&lt;Int&gt;) {\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Incrementar\")\n    }\n}\n\n@Composable\nfun ContadorTexto(contador: MutableState&lt;Int&gt;) {\n    Text(text = \"Contador: ${contador.value}\")\n}\n</code></pre> <p>En el ejemplo anterior, se eleva el estado <code>contador</code> del componente <code>Contador</code> para compartirlo con los componentes <code>ContadorBoton</code> y <code>ContadorTexto</code>.</p> <p>De esta forma, el estado <code>contador</code> se gestiona de forma centralizada en el componente <code>Contador</code> y se comparte con los componentes hijos. Y ambos se recomponen cuando el estado cambia.</p> <p>Esto tambi\u00e9n facilita la reutilizaci\u00f3n de los componentes y la separaci\u00f3n de las preocupaciones en tu aplicaci\u00f3n. Adem\u00e1s de facilitar la prueba y el mantenimiento del c\u00f3digo.</p> <p>Elevaci\u00f3n del estado vs. Inyecci\u00f3n de dependencias</p> <ul> <li>La elevaci\u00f3n del estado es una t\u00e9cnica com\u00fan en Jetpack Compose para compartir el estado entre componentes.</li> <li>Otra t\u00e9cnica com\u00fan es la inyecci\u00f3n de dependencias, que consiste en pasar el estado como argumento a los componentes que lo necesitan.</li> </ul> <p>Ambas t\u00e9cnicas tienen sus ventajas y desventajas, y la elecci\u00f3n entre ellas depende del dise\u00f1o y la arquitectura de tu aplicaci\u00f3n.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#conclusion","title":"\ud83d\udccc Conclusi\u00f3n","text":"<p>La gesti\u00f3n de estado es una parte fundamental de la arquitectura de tu aplicaci\u00f3n en Jetpack Compose.</p> <p>Con Compose, puedes definir, observar y actualizar el estado de tu aplicaci\u00f3n de forma reactiva y declarativa.</p> <p>Los Flows te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla en Kotlin.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-de-gestion-del-estado-basica-en-una-app-de-contador","title":"Ejemplo de gesti\u00f3n del estado b\u00e1sica en una app de Contador","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#recursos","title":"\ud83d\udce6 Recursos","text":"<ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.   </li> <li>Avanzando con Kotlin y el manejo de la UI - Codelabs</li> <li>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</li> </ul>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html","title":"Listas","text":""},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#listas-en-compose","title":"Listas en Compose","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos utilizando los componentes <code>LazyColumn</code> y <code>LazyRow</code>. Estos componentes te permiten mostrar una lista de elementos de forma eficiente y reactiva.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazycolumn","title":"LazyColumn","text":"<p>El componente <code>LazyColumn</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyColumn</code> para mostrar una lista de elementos verticales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaVertical() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaVertical</code> que muestra una lista de 100 elementos verticales utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p> <p>Video Listas y LazyColumn</p> <p></p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazyrow","title":"LazyRow","text":"<p>El componente <code>LazyRow</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyRow</code> para mostrar una lista de elementos horizontales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaHorizontal() {\n    LazyRow {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaHorizontal</code> que muestra una lista de 100 elementos horizontales utilizando <code>LazyRow</code>. El m\u00e9todo <code>items()</code> de <code>LazyRow</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#scroll-infinito","title":"Scroll infinito","text":"<p>Puedes implementar el scroll infinito en las listas de Compose utilizando el m\u00e9todo <code>items()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando una lista infinita como argumento. Esto te permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ScrollInfinito() {\n    val elementos = remember { mutableStateListOf&lt;String&gt;() }\n\n    LazyColumn {\n        items(elementos) { elemento -&gt;\n            Text(text = elemento)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ScrollInfinito</code> que muestra una lista de elementos utilizando <code>LazyColumn</code>. Se utiliza un estado mutable <code>mutableStateListOf</code> para almacenar los elementos de la lista, y se pasa esta lista como argumento al m\u00e9todo <code>items()</code> de <code>LazyColumn</code>. Esto permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El manejo del scroll infinito en Compose es similar al manejo del scroll infinito en otras bibliotecas de UI, como RecyclerView en Android. Puedes utilizar t\u00e9cnicas como la paginaci\u00f3n y la carga perezosa para cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El estado mutable <code>mutableStateListOf</code> se utiliza para almacenar los elementos de la lista y notificar a Compose cuando se actualizan los elementos. Esto permite que Compose vuelva a renderizar la lista con los nuevos elementos.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#elementos-personalizados","title":"Elementos personalizados","text":"<p>Puedes utilizar elementos personalizados en las listas de Compose para mostrar elementos m\u00e1s complejos. Para ello, puedes utilizar el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasar un componente personalizado como argumento.</p> <pre><code>@Composable\nfun ListaPersonalizada() {\n    LazyColumn {\n        items(100) { index -&gt;\n            ElementoPersonalizado(index)\n        }\n    }\n}\n\n@Composable\nfun ElementoPersonalizado(index: Int) {\n    Text(text = \"Elemento $index\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaPersonalizada</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices, y se pasa un componente personalizado <code>ElementoPersonalizado</code> como argumento.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#escuchadores-de-eventos","title":"Escuchadores de eventos","text":"<p>Puedes a\u00f1adir escuchadores de eventos a los elementos de la lista para responder a las interacciones del usuario. Por ejemplo, puedes a\u00f1adir un escuchador de clics a un elemento de la lista para realizar una acci\u00f3n cuando el usuario haga clic en \u00e9l.</p> <pre><code>@Composable\nfun ListaConClics() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(\n                text = \"Elemento $index\",\n                modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ }\n            )\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConClics</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un escuchador de clics al elemento de la lista utilizando el modificador <code>clickable</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#separadores","title":"Separadores","text":"<p>Puedes a\u00f1adir separadores entre los elementos de la lista utilizando el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando un componente separador como argumento.</p> <pre><code>@Composable\nfun ListaConSeparadores() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Column {\n                ElementoPersonalizado(index)\n                Divider()\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConSeparadores</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un separador <code>Divider()</code> entre cada elemento de la lista.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#filtrado-y-ordenacion","title":"Filtrado y ordenaci\u00f3n","text":"<p>Puedes filtrar y ordenar los elementos de la lista utilizando funciones de extensi\u00f3n como <code>filter()</code> y <code>sortedBy()</code>. Estas funciones te permiten realizar operaciones comunes con las listas de forma sencilla y eficiente.</p> <pre><code>@Composable\nfun ListaFiltrada() {\n    val numeros = (0..100).toList()\n\n    LazyColumn {\n        items(numeros.filter { it % 2 == 0 }) { numero -&gt;\n            Text(text = \"N\u00famero $numero\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaFiltrada</code> que muestra una lista de n\u00fameros pares del 0 al 100 utilizando <code>LazyColumn</code>. Se filtran los n\u00fameros pares utilizando la funci\u00f3n de extensi\u00f3n <code>filter()</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#porque-usar-lazycolumn-y-lazyrow-en-lugar-de-column-y-row","title":"Porqu\u00e9 usar LazyColumn y LazyRow en lugar de Column y Row","text":"<p><code>LazyColumn</code> y <code>LazyRow</code> son componentes optimizados para mostrar listas de elementos de forma eficiente y reactiva. A diferencia de <code>Column</code> y <code>Row</code>, que renderizan todos los elementos de la lista de forma inmediata, <code>LazyColumn</code> y <code>LazyRow</code> renderizan solo los elementos visibles en la pantalla y los elementos que est\u00e1n cerca de la zona visible.</p> <p>Esto hace que <code>LazyColumn</code> y <code>LazyRow</code> sean m\u00e1s eficientes en t\u00e9rminos de rendimiento y consumo de recursos, especialmente cuando se trabaja con listas grandes o infinitas.</p> <p>Por lo tanto, es recomendable utilizar <code>LazyColumn</code> y <code>LazyRow</code> para mostrar listas de elementos en Jetpack Compose, ya que proporcionan una experiencia de usuario m\u00e1s fluida y eficiente.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#cuadriculsa-o-grids","title":"Cuadr\u00edculsa o Grids","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos en forma de cuadr\u00edculas utilizando el componente <code>LazyVerticalGrid</code> o <code>LazyHorizontalGrid</code>. Estos componentes te permiten mostrar una cuadr\u00edcula de elementos de forma eficiente y reactiva.</p> <pre><code>@Composable\nfun CuadriculaVertical() {\n    LazyVerticalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaVertical</code> que muestra una cuadr\u00edcula de 100 elementos en 3 columnas utilizando <code>LazyVerticalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyVerticalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p> <pre><code>@Composable\nfun CuadriculaHorizontal() {\n    LazyHorizontalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaHorizontal</code> que muestra una cuadr\u00edcula de 100 elementos en 3 filas utilizando <code>LazyHorizontalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyHorizontalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html","title":"Navegaci\u00f3n Rutas","text":""},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-y-rutas-en-jetpack-compose","title":"Navegaci\u00f3n y rutas en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#configuracion-de-la-navegacion","title":"Configuraci\u00f3n de la navegaci\u00f3n","text":"<p>Para administrar la navegaci\u00f3n en Jetpack Compose, necesitas agregar la dependencia de <code>navigation-compose</code> a tu archivo <code>build.gradle</code> y definir las rutas y destinos de tu aplicaci\u00f3n en un archivo de configuraci\u00f3n de navegaci\u00f3n.</p> build.gradle.kts<pre><code>dependencies {\n    val nav_version = \"2.8.5\"\n\n    implementation(\"androidx.navigation:navigation-compose:$nav_version\")\n}\n</code></pre> <p>Video ejemplo de uso de Navegaci\u00f3n</p> <p></p> <p>Video ejemplo de Splash Screen personalizada</p> <p></p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-en-jetpack-compose","title":"Navegaci\u00f3n en Jetpack Compose","text":"<p>En Jetpack Compose, puedes implementar la navegaci\u00f3n entre pantallas utilizando el componente <code>NavHost</code>. <code>NavHost</code> es un contenedor que muestra las pantallas de tu aplicaci\u00f3n en funci\u00f3n de las rutas definidas.</p> <pre><code>@Composable\nfun MyApp() {\n    val navController = rememberNavController()\n\n    NavHost(navController = navController, startDestination = \"pantalla1\") {\n        composable(\"pantalla1\") {\n            Pantalla1()\n        }\n        composable(\"pantalla2\") {\n            Pantalla2()\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MyApp</code> que utiliza <code>NavHost</code> para implementar la navegaci\u00f3n entre dos pantallas: <code>Pantalla1</code> y <code>Pantalla2</code>. <code>NavHost</code> toma un <code>NavController</code> como argumento y define las rutas de las pantallas utilizando el m\u00e9todo <code>composable</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#definicion-de-rutas","title":"Definici\u00f3n de rutas","text":"<p>Puedes definir las rutas de tu aplicaci\u00f3n utilizando el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Cada ruta tiene un nombre \u00fanico que se utiliza para identificar la pantalla correspondiente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1()\n    }\n    composable(\"pantalla2\") {\n        Pantalla2()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se definen dos rutas: <code>pantalla1</code> y <code>pantalla2</code>, que corresponden a las pantallas <code>Pantalla1</code> y <code>Pantalla2</code>, respectivamente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas","title":"Navegaci\u00f3n entre pantallas","text":"<p>Puedes navegar entre pantallas en Jetpack Compose utilizando el <code>NavController</code> y el m\u00e9todo <code>navigate</code>.</p> <pre><code>Button(onClick = { navController.navigate(\"pantalla2\") }) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>navigate</code> del <code>NavController</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#paso-de-datos-entre-pantallas","title":"Paso de datos entre pantallas","text":"<p>Puedes pasar datos entre pantallas en Jetpack Compose utilizando el m\u00e9todo <code>navigate</code> y el argumento <code>arguments</code>.</p> <pre><code>Button(onClick = {\n    navController.navigate(\"pantalla2\") {\n        launchSingleTop = true\n        popUpTo(\"pantalla1\") { inclusive = true }\n        arguments = bundleOf(\"dato\" to \"Hola, mundo!\")\n    }\n}) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> y pasa el dato <code>\"Hola, mundo!\"</code> como argumento.</p> <p>El argumento <code>arguments</code> se utiliza para pasar datos entre pantallas. Puedes utilizar <code>bundleOf</code> para crear un <code>Bundle</code> con los datos que deseas pasar.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recuperacion-de-datos-en-la-pantalla-de-destino","title":"Recuperaci\u00f3n de datos en la pantalla de destino","text":"<p>Puedes recuperar los datos pasados como argumentos en la pantalla de destino utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p> <pre><code>val navBackStackEntry by navController.currentBackStackEntryAsState()\nval dato = navBackStackEntry?.arguments?.getString(\"dato\")\n</code></pre> <p>En el ejemplo anterior, se recupera el dato pasado como argumento en la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas-usando-lambdas","title":"Navegaci\u00f3n entre pantallas usando lambdas","text":"<p>En Jetpack Compose, puedes utilizar lambdas para definir la navegaci\u00f3n entre pantallas de forma m\u00e1s concisa.</p> <p>La definici\u00f3n de estas lambdas puede hacerse en el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Esto nos ayuda a mantener un c\u00f3digo m\u00e1s limpio y legible.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1 {\n            navController.navigate(\"pantalla2\")\n        }\n    }\n    composable(\"pantalla2\") {\n        Pantalla2 {\n            navController.navigate(\"pantalla1\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define la navegaci\u00f3n entre las pantallas <code>Pantalla1</code> y <code>Pantalla2</code> utilizando lambdas en el m\u00e9todo <code>composable</code> de <code>NavHost</code>.</p> <p>De esta forma, al definir la navegaci\u00f3n en el propio componente, se mantiene un c\u00f3digo m\u00e1s limpio y legible.</p> <p>Por ejemplo, el composable <code>Pantalla1</code> recibe una lambda que navega a la pantalla <code>Pantalla2</code>, y el composable <code>Pantalla2</code> recibe una lambda que navega a la pantalla <code>Pantalla1</code>.</p> <pre><code>@Composable\nfun Pantalla1(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 2\")\n    }\n}\n\n@Composable\nfun Pantalla2(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 1\")\n    }\n}\n</code></pre> <p>En los componibles <code>Pantalla1</code> y <code>Pantalla2</code>, se define un bot\u00f3n que, al hacer clic en \u00e9l, ejecuta la lambda recibida como argumento, que navega a la pantalla correspondiente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#para-la-definicion-de-los-nombres-de-las-pantallas","title":"Para la definici\u00f3n de los nombres de las pantallas","text":"<p>Es importante definir nombres significativos para las pantallas de tu aplicaci\u00f3n. Los nombres de las pantallas deben reflejar claramente el prop\u00f3sito y la funcionalidad de cada pantalla.</p> <p>Por ejemplo, si tienes una pantalla de inicio y una pantalla de perfil, puedes nombrarlas <code>pantallaInicio</code> y <code>pantallaPerfil</code>, respectivamente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantallaInicio\") {\n    composable(\"pantallaInicio\") {\n        PantallaInicio()\n    }\n    composable(\"pantallaPerfil\") {\n        PantallaPerfil()\n    }\n}\n</code></pre> <p>Estos nombres pueden definirse en un archivo de constantes o en un objeto de compa\u00f1ero para mantener un c\u00f3digo m\u00e1s organizado y legible. Existen varias opciones para definir los nombres de las pantallas, como objetos de compa\u00f1ero, constantes o enumeraciones. </p> <p> </p><pre><code>object Rutas {\n    const val PANTALLA_INICIO = \"pantallaInicio\"\n    const val PANTALLA_PERFIL = \"pantallaPerfil\"\n}\n</code></pre> <pre><code>const val PANTALLA_INICIO = \"pantallaInicio\"\nconst val PANTALLA_PERFIL = \"pantallaPerfil\"\n</code></pre> <pre><code>enum class Rutas {\n    PANTALLA_INICIO,\n    PANTALLA_PERFIL\n}\n</code></pre> <pre><code>sealed class Rutas {\n    object PANTALLA_INICIO : Rutas()\n    object PANTALLA_PERFIL : Rutas()\n}\n</code></pre> <p></p> <p>En el ejemplo anterior, se definen los nombres de las pantallas <code>PANTALLA_INICIO</code> y <code>PANTALLA_PERFIL</code> utilizando un objeto an\u00f3nimo, constantes, enumeraciones y clases selladas.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose Navigation: La documentaci\u00f3n oficial de Jetpack Compose Navigation, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar la navegaci\u00f3n en Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio navegaci\u00f3n - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/00-compose/25-material-design.html","title":"Material Design","text":""},{"location":"temas/00-android/00-compose/25-material-design.html#material-design-en-jetpack-compose","title":"Material Design en Jetpack Compose","text":"<p>Material Design es un sistema de dise\u00f1o desarrollado por Google que ayuda a los desarrolladores a crear interfaces de usuario atractivas y coherentes en aplicaciones Android. Con Jetpack Compose, puedes implementar los principios de Material Design de forma sencilla y eficiente.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#temas-y-estilos","title":"Temas y estilos","text":"<p>Jetpack Compose incluye un conjunto de widgets y estilos basados en Material Design que puedes utilizar para crear interfaces de usuario modernas y atractivas. Puedes personalizar los colores, tipograf\u00edas y formas de tus componentes para adaptarlos a la identidad visual de tu aplicaci\u00f3n.</p> <pre><code>@Composable\nfun MiApp() {\n    MaterialTheme {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MiApp</code> que utiliza <code>MaterialTheme</code> para aplicar los estilos de Material Design a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#widgets-de-material-design","title":"Widgets de Material Design","text":"<p>Jetpack Compose incluye una amplia variedad de widgets de Material Design que puedes utilizar para crear interfaces de usuario complejas y atractivas. Algunos de los widgets m\u00e1s comunes son:</p> <ul> <li><code>Button</code>: Un bot\u00f3n interactivo que el usuario puede pulsar para realizar una acci\u00f3n.</li> <li><code>TextField</code>: Un campo de texto que el usuario puede utilizar para introducir texto.</li> <li><code>Checkbox</code>: Una casilla de verificaci\u00f3n que el usuario puede marcar o desmarcar.</li> <li><code>RadioButton</code>: Un bot\u00f3n de opci\u00f3n que el usuario puede seleccionar entre varias opciones.</li> <li><code>Switch</code>: Un interruptor que el usuario puede activar o desactivar.</li> </ul> <p>Puedes utilizar estos widgets y muchos m\u00e1s para crear interfaces de usuario modernas y atractivas en tus aplicaciones Android con Jetpack Compose.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#personalizacion-de-estilos","title":"Personalizaci\u00f3n de estilos","text":"<p>Puedes personalizar los estilos de Material Design en Jetpack Compose para adaptarlos a la identidad visual de tu aplicaci\u00f3n. Puedes definir tus propios temas y estilos utilizando el componente <code>MaterialTheme</code> y los objetos <code>Typography</code>, <code>Colors</code> y <code>Shapes</code>.</p> <pre><code>val MiTema = lightColors(\n    primary = Color(0xFF6200EE),\n    primaryVariant = Color(0xFF3700B3),\n    secondary = Color(0xFF03DAC6)\n)\n\n@Composable\nfun MiApp() {\n    MaterialTheme(colors = MiTema) {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado <code>MiTema</code> con colores personalizados y se utiliza <code>MaterialTheme</code> para aplicar este tema a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Material Design: La documentaci\u00f3n oficial de Material Design, que incluye gu\u00edas, tutoriales y ejemplos para aprender a dise\u00f1ar interfaces de usuario con Material Design.</p> </li> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a crear interfaces de usuario con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-compose/99-glosario-android.html","title":"Glosario","text":""},{"location":"temas/00-android/00-compose/99-glosario-android.html#glosario-de-android","title":"Glosario de Android","text":"<p>Este documento sirve como referencia r\u00e1pida para los conceptos clave del desarrollo moderno de Android. Los t\u00e9rminos est\u00e1n agrupados por \u00e1reas tem\u00e1ticas para facilitar su comprensi\u00f3n en contexto.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#1-fundamentos-de-kotlin-el-lenguaje","title":"1. Fundamentos de Kotlin (El Lenguaje)","text":"<p>Conceptos del lenguaje sobre los que se construye todo el desarrollo moderno.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#data-class","title":"Data Class","text":"<p>Una clase dise\u00f1ada espec\u00edficamente para contener datos. El compilador genera autom\u00e1ticamente m\u00e9todos \u00fatiles como <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> y <code>copy()</code>. Fundamental para definir modelos y estados de UI. </p><pre><code>data class Usuario(val id: String, val nombre: String)\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#sealed-class-interface","title":"Sealed Class / Interface","text":"<p>Una jerarqu\u00eda de clases restringida. Define un conjunto cerrado de posibles subclases. Es ideal para modelar Estados de UI (ej: <code>Cargando</code>, <code>Exito</code>, <code>Error</code>) porque obliga al compilador a manejar todos los casos posibles en un <code>when</code>.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#lambda","title":"Lambda","text":"<p>Una funci\u00f3n an\u00f3nima que puede ser tratada como un valor (pasada como par\u00e1metro o guardada en una variable). Es el motor de Jetpack Compose (ej: <code>onClick = { ... }</code>). </p><pre><code>val suma = { x: Int, y: Int -&gt; x + y }\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#extension-function","title":"Extension Function","text":"<p>Capacidad de Kotlin para a\u00f1adir funciones a una clase existente sin tener que heredar de ella. </p><pre><code>fun String.esEmailValido(): Boolean { ... }\n\"test@test.com\".esEmailValido()\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#higher-order-function-funcion-de-orden-superior","title":"Higher-Order Function (Funci\u00f3n de Orden Superior)","text":"<p>Una funci\u00f3n que acepta otra funci\u00f3n como par\u00e1metro o devuelve una funci\u00f3n. Es la base de los <code>LazyColumn</code>, <code>Button</code>, y casi cualquier Composable contenedor.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#2-android-core-el-sistema","title":"2. Android Core (El Sistema)","text":"<p>Los cimientos del sistema operativo Android que todo desarrollador debe conocer.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#activity","title":"Activity","text":"<p>Un componente fundamental que representa una pantalla con una interfaz de usuario. Es el punto de entrada principal para la interacci\u00f3n del usuario. En Compose, solemos tener una sola Activity (<code>MainActivity</code>) que contiene toda la app (\"Single Activity Architecture\").</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#context","title":"Context","text":"<p>Es el puente entre tu c\u00f3digo y el sistema Android. Permite acceder a recursos (cadenas, colores), iniciar Activities, enviar Broadcasts y acceder a servicios del sistema.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#manifest-androidmanifestxml","title":"Manifest (<code>AndroidManifest.xml</code>)","text":"<p>El \"DNI\" de la aplicaci\u00f3n. Un archivo XML que describe la app al sistema: nombre, icono, componentes (Activities, Services), y permisos requeridos.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#intent","title":"Intent","text":"<p>Un objeto de mensajer\u00eda que se usa para solicitar una acci\u00f3n a otro componente de la app. *   Intents Expl\u00edcitos: Para iniciar una Activity espec\u00edfica dentro de tu app. *   Intents Impl\u00edcitos: Para declarar una intenci\u00f3n general (ej: \"Quiero abrir una URL\") y dejar que el sistema decida qu\u00e9 app usar (Chrome, Firefox, etc.).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#lifecycle-ciclo-de-vida","title":"Lifecycle (Ciclo de Vida)","text":"<p>La serie de estados por los que pasa una Activity o Fragment (Creado, Iniciado, Reanudado, Pausado, Destruido). Entenderlo es vital para evitar fugas de memoria y guardar datos correctamente.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#3-jetpack-compose-la-ui-moderna","title":"3. Jetpack Compose (La UI Moderna)","text":"<p>El kit de herramientas declarativo para construir interfaces nativas.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#composable-composable","title":"Composable (<code>@Composable</code>)","text":"<p>Una funci\u00f3n de Kotlin anotada con <code>@Composable</code> que describe QU\u00c9 UI se debe mostrar (no C\u00d3MO). Es el bloque de construcci\u00f3n b\u00e1sico de Compose.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#state-mutablestatet","title":"State (<code>MutableState&lt;T&gt;</code>)","text":"<p>Un contenedor de datos observable. Cuando el valor dentro de un <code>State</code> cambia, Compose detecta el cambio y programa una Recomposici\u00f3n.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#recomposition-recomposicion","title":"Recomposition (Recomposici\u00f3n)","text":"<p>El proceso mediante el cual Compose re-ejecuta tus funciones composables para actualizar la UI con nuevos datos. Compose es inteligente y solo redibuja las partes que han cambiado.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#modifier","title":"Modifier","text":"<p>Un objeto que se encadena para decorar o configurar un composable. Controla el tama\u00f1o, padding, clics, fondo, bordes, etc. El orden de los modificadores importa. </p><pre><code>Box(modifier = Modifier.size(50.dp).background(Color.Red))\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#side-effect-efecto-secundario","title":"Side Effect (Efecto Secundario)","text":"<p>Cualquier cambio de estado que ocurra fuera del alcance de una funci\u00f3n composable (ej: llamadas a red, acceso a BBDD, logs). En Compose, deben controlarse con APIs especiales como <code>LaunchedEffect</code> para evitar que se ejecuten infinitas veces durante las recomposiciones.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#scaffold","title":"Scaffold","text":"<p>Un composable que implementa la estructura visual b\u00e1sica de Material Design. Proporciona \"slots\" (huecos) predefinidos para la <code>TopBar</code>, <code>BottomBar</code>, <code>FloatingActionButton</code> y el contenido principal.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#4-arquitectura-y-concurrencia-el-cerebro","title":"4. Arquitectura y Concurrencia (El \"Cerebro\")","text":"<p>C\u00f3mo estructurar la aplicaci\u00f3n y manejar tareas en segundo plano.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#mvvm-model-view-viewmodel","title":"MVVM (Model-View-ViewModel)","text":"<p>El patr\u00f3n de arquitectura recomendado por Google. *   Model: Datos y l\u00f3gica de negocio. *   View: La UI (Composable). *   ViewModel: Intermediario que guarda el estado de la UI y gestiona la l\u00f3gica, sobreviviendo a cambios de configuraci\u00f3n (como rotar la pantalla).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#udf-unidirectional-data-flow","title":"UDF (Unidirectional Data Flow)","text":"<p>Flujo de Datos Unidireccional. Un patr\u00f3n donde: 1.  El Estado fluye hacia abajo (del ViewModel a la UI). 2.  Los Eventos fluyen hacia arriba (de la UI al ViewModel). Esto hace que el estado sea predecible y f\u00e1cil de depurar.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#clean-architecture","title":"Clean Architecture","text":"<p>Una forma de organizar el c\u00f3digo en capas (Presentaci\u00f3n, Dominio, Datos) para que sea mantenible, testeable e independiente de librer\u00edas externas. La capa de Dominio (Use Cases) es el n\u00facleo puro de la l\u00f3gica de negocio.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#corrutina-coroutine","title":"Corrutina (Coroutine)","text":"<p>Un hilo ligero gestionado por Kotlin. Permite escribir c\u00f3digo as\u00edncrono (como llamadas a red) de forma secuencial y legible, sin bloquear el hilo principal (UI Thread).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#suspend-function","title":"Suspend Function","text":"<p>Una funci\u00f3n que puede ser pausada y reanudada. Solo puede ser llamada desde una corrutina u otra funci\u00f3n suspendida. Es la base de la asincron\u00eda en Kotlin.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#flow-stateflow","title":"Flow / StateFlow","text":"<p>Mecanismos para manejar flujos de datos as\u00edncronos (streams). *   Flow (Cold): Flujo de datos que solo emite cuando hay un colector activo. *   StateFlow (Hot): Un tipo especial de Flow que siempre tiene un valor actual y emite actualizaciones a sus colectores. Es el reemplazo moderno de <code>LiveData</code> en arquitectura Kotlin pura.</p>"},{"location":"temas/00-android/00-kotlin/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/00-android/00-kotlin/index.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/index.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html","title":"El lenguaje Kotlin","text":""},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html","title":"Variables","text":""},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-variables-y-datos-en-kotlin","title":"Tipos de variables y datos en Kotlin","text":"<p>En Kotlin las variables pueden declararse de dos formas, de forma expl\u00edcita o de forma impl\u00edcita. En el caso de las variables expl\u00edcitas, se debe indicar el tipo de dato que almacenar\u00e1 la variable, mientras que en las variables impl\u00edcitas, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <p>Sobre la inferencia de tipos</p> <p>Que el tipo de dato se infiera autom\u00e1ticamente no quiere decir que Kotlin sea un lenguaje de tipado din\u00e1mico, ya que una vez que se asigna un tipo de dato a una variable, no se puede cambiar.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-explicitas","title":"Variables expl\u00edcitas","text":"<p>Para declarar una variable de forma expl\u00edcita en Kotlin, se debe indicar el tipo de dato que almacenar\u00e1 la variable seguido del nombre de la variable y opcionalmente de su valor inicial.</p> <pre><code>val nombre: String = \"Ejemplo\"\nval edad: Int = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma expl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-implicitas","title":"Variables impl\u00edcitas","text":"<p>Para declarar una variable de forma impl\u00edcita en Kotlin, se debe utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre de la variable y opcionalmente de su valor inicial. En este caso, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <pre><code>val nombre = \"Ejemplo\"\nval edad = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma impl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-primitivos","title":"Tipos de datos primitivos","text":"<p>En Kotlin, los tipos de datos primitivos son los mismos que en Java, pero con algunas diferencias en la forma en que se declaran.</p> <ul> <li>Byte: Almacena n\u00fameros enteros de 8 bits.</li> <li>Short: Almacena n\u00fameros enteros de 16 bits.</li> <li>Int: Almacena n\u00fameros enteros de 32 bits.</li> <li>Long: Almacena n\u00fameros enteros de 64 bits.</li> <li>Float: Almacena n\u00fameros de punto flotante de 32 bits.</li> <li>Double: Almacena n\u00fameros de punto flotante de 64 bits.</li> <li>Char: Almacena caracteres Unicode de 16 bits.</li> <li>Boolean: Almacena valores booleanos (<code>true</code> o <code>false</code>).</li> </ul> <pre><code>val entero: Int = 10\nval flotante: Float = 10.5f\nval caracter: Char = 'A'\nval booleano: Boolean = true\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-compuestos","title":"Tipos de datos compuestos","text":"<p>Adem\u00e1s de los tipos de datos primitivos, Kotlin tambi\u00e9n tiene tipos de datos compuestos que permiten almacenar colecciones de datos.</p> <ul> <li>Array: Almacena una colecci\u00f3n de elementos del mismo tipo.</li> <li>List: Almacena una colecci\u00f3n de elementos ordenados.</li> <li>Set: Almacena una colecci\u00f3n de elementos \u00fanicos.</li> <li>Map: Almacena una colecci\u00f3n de pares clave-valor.</li> </ul> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\nval nombres = listOf(\"Juan\", \"Mar\u00eda\", \"Pedro\")\nval colores = setOf(\"Rojo\", \"Verde\", \"Azul\")\nval edades = mapOf(\"Juan\" to 25, \"Mar\u00eda\" to 30, \"Pedro\" to 35)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#conversion-de-tipos","title":"Conversi\u00f3n de tipos","text":"<p>En Kotlin, la conversi\u00f3n de tipos se realiza de forma segura y expl\u00edcita utilizando funciones espec\u00edficas para cada tipo de dato.</p> <pre><code>val numero: Int = 10\nval texto: String = numero.toString()\n\nval texto: String = \"10\"\nval numero: Int = texto.toInt()\n</code></pre> <p>En el primer ejemplo, se convierte un n\u00famero entero a una cadena de texto utilizando la funci\u00f3n <code>toString()</code>. En el segundo ejemplo, se convierte una cadena de texto a un n\u00famero entero utilizando la funci\u00f3n <code>toInt()</code>.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-mutables-e-inmutables","title":"Sobre las variables mutables e inmutables","text":"<p>En Kotlin, las variables se pueden declarar como <code>val</code> (inmutables) o <code>var</code> (mutables). Las variables inmutables no pueden cambiar su valor una vez asignado, mientras que las variables mutables pueden cambiar su valor en cualquier momento.</p> <pre><code>val nombre: String = \"Ejemplo\" // Variable inmutable\nvar edad: Int = 25 // Variable mutable\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es inmutable, por lo que su valor no puede cambiar una vez asignado. La variable <code>edad</code>, en cambio, es mutable, por lo que su valor puede cambiar en cualquier momento.    </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-la-mutabilidad-y-la-inmutabilidad","title":"Sobre la mutabilidad y la inmutabilidad","text":"<p>La inmutabilidad es una caracter\u00edstica importante en Kotlin, ya que ayuda a prevenir los errores de programaci\u00f3n al evitar que los valores de las variables cambien de forma inesperada. Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s seguro y predecible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.   </p> <p>Cu\u00e1ndo trabajamos con listas o arrays, podemos modificar los elementos de la lista, pero no podemos cambiar la referencia de la lista. </p> <pre><code>val lista = mutableListOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Modifica el elemento en la posici\u00f3n 0\nlista = mutableListOf(6, 7, 8, 9, 10) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se modifica el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero no se puede cambiar la referencia de la lista. Si se intenta asignar una nueva lista a la variable <code>lista</code>, se produce un error de compilaci\u00f3n.</p> <p>Podemos ver tambi\u00e9n un ejemplo de lista mutable pero cuyo contenido no puede ser modificado.</p> <pre><code>val lista = listOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta modificar el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero como la lista es inmutable, se produce un error de compilaci\u00f3n.</p> <p>Esto nos deja claro que la inmutabilidad no solo se refiere a la variable en s\u00ed, sino tambi\u00e9n a los elementos que contiene la variable.</p> <p>Podemos entonces tener cuatro situaciones posibles:</p> <ul> <li>Variable inmutable y elementos inmutables: No se puede cambiar ni la variable ni los elementos.</li> <li>Variable inmutable y elementos mutables: No se puede cambiar la variable, pero s\u00ed los elementos.</li> <li>Variable mutable y elementos inmutables: Se puede cambiar la variable, pero no los elementos.</li> <li>Variable mutable y elementos mutables: Se puede cambiar tanto la variable como los elementos.</li> </ul> <p>Las variables inmutables y la programaci\u00f3n funcional</p> <p>Las variables inmutables son una caracter\u00edstica fundamental de la programaci\u00f3n funcional, ya que permiten escribir c\u00f3digo m\u00e1s seguro y predecible al evitar los efectos secundarios y las mutaciones de estado. </p> <p>Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s conciso, legible y mantenible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-nulas","title":"Sobre las variables nulas","text":"<p>En Kotlin, las variables pueden ser nulas si se declara con el operador <code>?</code>. Esto permite que una variable pueda contener un valor nulo en lugar de un valor no nulo.</p> <pre><code>val nombre: String? = null\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> se declara como nula utilizando el operador <code>?</code>. Esto significa que la variable <code>nombre</code> puede contener un valor nulo en lugar de un valor no nulo.</p> <p>Sobre la seguridad de nulos en Kotlin</p> <p>El manejo de nulos en Kotlin es una de las caracter\u00edsticas m\u00e1s importantes del lenguaje, ya que ayuda a prevenir los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n.</p> <p>M\u00e1s adelante veremos c\u00f3mo manejar los valores nulos de forma segura en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-declaradas-como-const","title":"Sobre las variables declaradas como const","text":"<p>En Kotlin, las variables se pueden declarar como <code>const</code> para indicar que su valor es constante en tiempo de compilaci\u00f3n. Las variables <code>const</code> deben ser de tipo <code>val</code> y deben estar en el \u00e1mbito de un objeto o de un compa\u00f1ero de clase.</p> <pre><code>const val PI = 3.14159\n</code></pre> <p>En el ejemplo anterior, se declara una constante <code>PI</code> con un valor de <code>3.14159</code>. Esta constante es accesible en tiempo de compilaci\u00f3n y su valor no puede cambiar en tiempo de ejecuci\u00f3n.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-strings-en-kotlin","title":"Sobre las Strings en Kotlin","text":"<p>En Kotlin, las cadenas de texto se pueden declarar utilizando comillas simples (<code>'</code>) o comillas dobles (<code>\"</code>). Las cadenas de texto declaradas con comillas simples son de tipo <code>Char</code>, mientras que las declaradas con comillas dobles son de tipo <code>String</code>.</p> <pre><code>val caracter: Char = 'A'\nval texto: String = \"Ejemplo\"\n</code></pre> <p>En el ejemplo anterior, se declara una variable <code>caracter</code> de tipo <code>Char</code> con el valor <code>'A'</code> y una variable <code>texto</code> de tipo <code>String</code> con el valor <code>\"Ejemplo\"</code>.</p> <p>Las Strings en Kotlin se pueden comparar utilizando el operador <code>==</code> para comparar el contenido de las cadenas y el operador <code>===</code> para comparar las referencias de las cadenas.</p> <pre><code>val texto1 = \"Hola\"\nval texto2 = \"Hola\"\n\nprintln(texto1 == texto2) // true\nprintln(texto1 === texto2) // true\n</code></pre> <p>En el ejemplo anterior, se comparan dos cadenas de texto <code>texto1</code> y <code>texto2</code> utilizando los operadores <code>==</code> y <code>===</code>. Ambas comparaciones devuelven <code>true</code> ya que las cadenas son iguales en contenido y referencia. </p> <p>A diferencia de Java, en Kotlin las cadenas de texto son inmutables, lo que significa que una vez que se crea una cadena de texto, no se puede modificar su contenido. Para modificar una cadena de texto en Kotlin, se debe crear una nueva cadena con el contenido modificado.</p> <pre><code>val texto = \"Hola\"\nval nuevoTexto = texto + \" Mundo\"\n</code></pre> <p>En el ejemplo anterior, se crea una nueva cadena de texto <code>nuevoTexto</code> concatenando la cadena <code>texto</code> con la cadena <code>\" Mundo\"</code>. La cadena <code>texto</code> no se modifica, sino que se crea una nueva cadena con el contenido modificado.    </p> <p>Sin embargo, si comparamos una string con un caracter, Kotlin no permite la comparaci\u00f3n directa, ya que son tipos de datos diferentes.</p> <pre><code>val texto = \"H\"\nval caracter = 'H'\n\nprintln(texto == caracter) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta comparar una cadena de texto <code>texto</code> con un caracter <code>caracter</code>, lo cual produce un error de compilaci\u00f3n ya que los tipos de datos son diferentes.   </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html","title":"Expresiones vs Sentencias","text":""},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones-vs-sentencias","title":"Expresiones vs sentencias","text":"<p>En Kotlin, las expresiones y las sentencias son dos conceptos fundamentales que se utilizan para definir el flujo de control y la l\u00f3gica de un programa. Aunque ambos se utilizan para realizar operaciones y tomar decisiones en un programa, existen diferencias importantes entre ellos que es importante comprender.    </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones","title":"Expresiones","text":"<p>En Kotlin, una expresi\u00f3n es una combinaci\u00f3n de valores, variables, operadores y funciones que se eval\u00faa para producir un resultado. Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor. </p> <p>Las expresiones en Kotlin pueden tener un valor de retorno, lo que significa que pueden ser utilizadas en cualquier lugar donde se espere un valor, como en la inicializaci\u00f3n de una variable, en una sentencia de control de flujo o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nval resultado = numero * 2\n</code></pre> <p>En el ejemplo anterior, la expresi\u00f3n <code>numero * 2</code> se eval\u00faa para producir un resultado que se asigna a la variable <code>resultado</code>. La expresi\u00f3n <code>numero * 2</code> es una expresi\u00f3n aritm\u00e9tica que multiplica el valor de la variable <code>numero</code> por <code>2</code> y devuelve el resultado.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#sentencias","title":"Sentencias","text":"<p>En Kotlin, una sentencia es una instrucci\u00f3n que realiza una acci\u00f3n en un programa. Las sentencias pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo que toma decisiones basadas en condiciones.    </p> <p>Las sentencias en Kotlin no tienen un valor de retorno, lo que significa que no pueden ser utilizadas en lugares donde se espere un valor, como en la inicializaci\u00f3n de una variable o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nif (numero &gt; 0) {\n    println(\"El n\u00famero es positivo\")\n} else {\n    println(\"El n\u00famero es negativo\")\n}\n</code></pre> <p>En el ejemplo anterior, la sentencia <code>if (numero &gt; 0) { ... } else { ... }</code> es una estructura de control de flujo que toma una decisi\u00f3n basada en la condici\u00f3n <code>numero &gt; 0</code>. La sentencia <code>if</code> eval\u00faa la condici\u00f3n y ejecuta el bloque de c\u00f3digo correspondiente si la condici\u00f3n es verdadera.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#diferencias-entre-expresiones-y-sentencias","title":"Diferencias entre expresiones y sentencias","text":"<p>Las principales diferencias entre expresiones y sentencias en Kotlin son las siguientes:</p> <ul> <li> <p>Valor de retorno: Las expresiones tienen un valor de retorno y pueden ser utilizadas en lugares donde se espere un valor, mientras que las sentencias no tienen un valor de retorno y no pueden ser utilizadas en lugares donde se espere un valor.</p> </li> <li> <p>Complejidad: Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor, mientras que las sentencias realizan acciones en un programa y pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo.</p> </li> <li> <p>Uso: Las expresiones se utilizan para realizar operaciones y producir resultados, mientras que las sentencias se utilizan para realizar acciones en un programa, como asignar valores a variables, tomar decisiones basadas en condiciones o repetir bloques de c\u00f3digo.</p> </li> </ul> <p>La ventaja de las expresiones en la programaci\u00f3n funcional</p> <p>En la programaci\u00f3n funcional, se fomenta el uso de expresiones en lugar de sentencias, ya que las expresiones son m\u00e1s concisas, legibles y f\u00e1ciles de entender. </p> <p>Al utilizar expresiones en lugar de sentencias, se puede escribir menos c\u00f3digo y hacer m\u00e1s cosas.</p> <p>Esto es especialmente \u00fatil en Kotlin, que es un lenguaje de programaci\u00f3n funcional que fomenta el uso de expresiones para realizar operaciones y producir resultados de forma concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#ejemplo-de-una-funcion-que-usa-sentencias-statement-y-expresiones-expression","title":"Ejemplo de una funci\u00f3n que usa sentencias (statement) y expresiones (expression)","text":"<p>Pongamos el ejemplo de una funci\u00f3n que dictamina si una persona es mayor de edad o no. </p> Versi\u00f3n con sentencias<pre><code>fun esMayorDeEdad(edad: Int): Boolean {\n    if (edad &gt;= 18) {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza sentencias para tomar una decisi\u00f3n basada en la edad de la persona y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> Versi\u00f3n con expresiones<pre><code>fun esMayorDeEdad(edad: Int): Boolean = edad &gt;= 18\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza una expresi\u00f3n para evaluar si la edad de la persona es mayor o igual a <code>18</code> y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> <p>C\u00f3mo se puede observar, la versi\u00f3n con expresiones es m\u00e1s concisa y legible que la versi\u00f3n con sentencias, ya que utiliza una expresi\u00f3n para realizar la misma operaci\u00f3n de forma m\u00e1s eficiente y clara.</p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html","title":"When","text":""},{"location":"temas/00-android/00-kotlin/12.1-when.html#operador-when","title":"Operador When","text":"<p>Piensa en el operador <code>when</code> como el <code>switch</code> de Java que fue al gimnasio, ley\u00f3 varios libros de filosof\u00eda y se volvi\u00f3 incre\u00edblemente flexible y poderoso.</p> <p>Vamos a desglosar todos sus usos, desde el reemplazo directo del <code>switch</code> hasta sus capacidades m\u00e1s expresivas.</p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#1-el-caso-basico-when-como-un-switch-mejorado","title":"1. El Caso B\u00e1sico: <code>when</code> como un <code>switch</code> Mejorado","text":"<p>Este es el uso m\u00e1s directo y f\u00e1cil de entender. Se parece mucho a un <code>switch-case</code> de Java, pero con mejoras clave.</p> <p>Correlaci\u00f3n con <code>switch</code> de Java: *   <code>case X:</code> se convierte en <code>X -&gt;</code>. *   <code>default:</code> se convierte en <code>else -&gt;</code>. *   No necesitas <code>break;</code>. \u00a1Esto elimina toda una categor\u00eda de bugs! La ejecuci\u00f3n se detiene autom\u00e1ticamente al encontrar la primera rama que coincide.</p> <p>Ejemplo en Java: </p><pre><code>int day = 2;\nString dayName;\nswitch (day) {\n    case 1:\n        dayName = \"Lunes\";\n        break;\n    case 2:\n        dayName = \"Martes\";\n        break;\n    case 3:\n        dayName = \"Mi\u00e9rcoles\";\n        break;\n    default:\n        dayName = \"Otro d\u00eda\";\n        break;\n}\nSystem.out.println(dayName); // Martes\n</code></pre><p></p> <p>Ejemplo equivalente en Kotlin: </p><pre><code>val day = 2\nval dayName = when (day) {\n    1 -&gt; \"Lunes\"\n    2 -&gt; \"Martes\"\n    3 -&gt; \"Mi\u00e9rcoles\"\n    else -&gt; \"Otro d\u00eda\"\n}\nprintln(dayName) // Martes\n</code></pre><p></p> <p>Ventajas inmediatas:</p> <ul> <li>M\u00e1s limpio y conciso.</li> <li>A prueba de errores de \"fall-through\" (olvidar un <code>break</code>).</li> <li>Puede ser una expresi\u00f3n: F\u00edjate que asignamos el resultado del <code>when</code> directamente a la variable <code>dayName</code>. Esto es imposible con el <code>switch</code> de Java.</li> </ul>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#2-when-como-expresion-su-primer-superpoder","title":"2. <code>when</code> como Expresi\u00f3n (Su primer superpoder)","text":"<p>Cuando usas <code>when</code> para devolver un valor (como en el ejemplo anterior), el compilador de Kotlin te exige que seas exhaustivo. Esto significa que debes cubrir todos los casos posibles.</p> <p>Esto es incre\u00edblemente \u00fatil con <code>enum</code> o <code>sealed classes</code>.</p> <p>Ejemplo con un <code>enum</code>:</p> <p></p><pre><code>enum class DayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }\n\nfun getDayType(day: DayOfWeek): String {\n    return when (day) {\n        DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY -&gt; \"D\u00eda laboral\"\n        DayOfWeek.SATURDAY, DayOfWeek.SUNDAY -&gt; \"Fin de semana\"\n        // No se necesita 'else' aqu\u00ed. \u00bfPor qu\u00e9?\n        // Porque hemos cubierto TODOS los valores posibles del enum.\n        // Si a\u00f1adieras un nuevo d\u00eda al enum, \u00a1este c\u00f3digo dar\u00eda un error de compilaci\u00f3n\n        // hasta que lo manejes! Esto es seguridad en estado puro.\n    }\n}\n</code></pre> Nuevas caracter\u00edsticas mostradas:<p></p> <ul> <li>Combinar casos: Puedes poner varias condiciones en la misma rama, separadas por comas (<code>,</code>).</li> <li>Exhaustividad: El compilador te protege de olvidar casos.</li> </ul>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#3-when-sin-argumento-el-modo-if-else-if-inteligente","title":"3. <code>when</code> sin Argumento (El modo \"if-else if\" inteligente)","text":"<p>Aqu\u00ed es donde <code>when</code> deja al <code>switch</code> de Java a a\u00f1os luz. Puedes usar <code>when</code> sin pasarle un objeto entre par\u00e9ntesis. Cuando lo haces, cada rama se convierte en una condici\u00f3n booleana que se eval\u00faa en orden.</p> <p>Correlaci\u00f3n con Java:  Es como una cadena de <code>if-else if-else</code> m\u00e1s legible.</p> <p>Ejemplo:</p> <p></p><pre><code>val name = \"Pedro\"\nval score = 85\n\nval description = when {\n    name == \"Admin\" -&gt; \"El usuario es un administrador.\"\n    score &lt; 50 -&gt; \"Necesita mejorar.\"\n    score &gt;= 95 -&gt; \"\u00a1Excelente trabajo!\"\n    name.startsWith(\"P\") &amp;&amp; score &gt; 80 -&gt; \"Usuario destacado del grupo P.\"\n    else -&gt; \"Usuario est\u00e1ndar.\"\n}\nprintln(description) // \"Usuario destacado del grupo P.\"\n</code></pre> Como puedes ver, cada rama es una expresi\u00f3n booleana arbitraria. Se ejecutar\u00e1 la primera que sea <code>true</code>.<p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#4-when-para-comprobar-tipos-con-smart-casting","title":"4. <code>when</code> para Comprobar Tipos (con Smart Casting)","text":"<p>Este es uno de los usos m\u00e1s idiom\u00e1ticos y potentes en Kotlin, especialmente para manejar datos heterog\u00e9neos.</p> <p>Ejemplo con <code>is</code> y <code>smart casting</code>: </p><pre><code>fun processObject(obj: Any) { // Any es como Object en Java\n    when (obj) {\n        is String -&gt; {\n            // Smart Casting: El compilador sabe que 'obj' es un String aqu\u00ed.\n            // Puedes llamar a m\u00e9todos de String directamente sin castear.\n            println(\"Es un String con longitud ${obj.length}\")\n        }\n        is Int -&gt; {\n            println(\"Es un Entero con valor ${obj + 10}\")\n        }\n        is Boolean -&gt; {\n            println(\"Es un Booleano: ${!obj}\")\n        }\n        else -&gt; {\n            println(\"Es un tipo desconocido.\")\n        }\n    }\n}\n\nprocessObject(\"Hola Kotlin\") // \"Es un String con longitud 11\"\nprocessObject(25)            // \"Es un Entero con valor 35\"\n</code></pre> En la rama <code>is String</code>, <code>obj</code> es tratado autom\u00e1ticamente como un <code>String</code>. \u00a1No necesitas hacer <code>((String) obj).length()</code>!<p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#5-when-para-comprobar-rangos-y-colecciones","title":"5. <code>when</code> para Comprobar Rangos y Colecciones","text":"<p>Puedes usar el operador <code>in</code> para verificar si un valor est\u00e1 dentro de un rango o una colecci\u00f3n.</p> <p>Ejemplo con <code>in</code>: </p><pre><code>val temperature = 25\nval numbers = listOf(1, 3, 5, 7, 9)\n\nwhen (temperature) {\n    in -10..10 -&gt; println(\"Hace fr\u00edo.\")\n    in 11..22 -&gt; println(\"Est\u00e1 templado.\")\n    in numbers -&gt; println(\"\u00a1Es un n\u00famero impar de un solo d\u00edgito!\")\n    !in 0..100 -&gt; println(\"Temperatura fuera del rango normal.\") // Tambi\u00e9n puedes usar !in\n    else -&gt; println(\"Temperatura agradable.\")\n}\n// Salida: \"Temperatura agradable.\"\n</code></pre><p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#tabla-comparativa-when-kotlin-vs-switch-java","title":"Tabla Comparativa: <code>when</code> (Kotlin) vs. <code>switch</code> (Java)","text":"Caracter\u00edstica <code>switch</code> (Java) <code>when</code> (Kotlin) Ventaja de Kotlin Sintaxis b\u00e1sica <code>case X: ...; break;</code> <code>X -&gt; ...</code> M\u00e1s concisa y segura (sin <code>break</code>). Valor por defecto <code>default:</code> <code>else -&gt;</code> Nombres m\u00e1s intuitivos. Puede ser una expresi\u00f3n? No S\u00ed Permite c\u00f3digo m\u00e1s funcional y reduce la mutabilidad. Exhaustividad No forzada por el compilador S\u00ed (cuando se usa como expresi\u00f3n) C\u00f3digo mucho m\u00e1s seguro y robusto. Tipos de condici\u00f3n Constantes (primitivos, <code>String</code>, <code>enum</code>) Cualquier objeto y expresi\u00f3n Inmensamente m\u00e1s flexible. Combinar casos S\u00ed (con <code>case</code> apilados sin <code>break</code>) S\u00ed (usando comas <code>,</code>) M\u00e1s expl\u00edcito y menos propenso a errores. Uso sin argumento No es posible S\u00ed (<code>when { ... }</code>) Permite condiciones complejas, actuando como un <code>if-else</code> mejorado. Comprobar tipos No directamente (necesita <code>instanceof</code>) S\u00ed (con <code>is</code> y smart casting) C\u00f3digo m\u00e1s limpio y seguro para polimorfismo. Comprobar rangos No directamente S\u00ed (con <code>in X..Y</code>) Muy \u00fatil para l\u00f3gica de rangos num\u00e9ricos. <p>En resumen, <code>when</code> en Kotlin comienza como un simple <code>switch</code> pero se expande para convertirse en una de las herramientas de control de flujo m\u00e1s vers\u00e1tiles y seguras que existen en cualquier lenguaje de programaci\u00f3n moderno.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html","title":"Funciones y lambdas","text":""},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-y-lambdas-en-kotlin","title":"Funciones y lambdas en Kotlin","text":"<p>En Kotlin, las funciones son ciudadanos de primera clase, lo que significa que puedes tratarlas como cualquier otro tipo de dato, como un <code>Int</code> o un <code>String</code>. Esto te permite pasar funciones como argumentos a otras funciones, devolver funciones de otras funciones y almacenar funciones en variables. </p> <p>Las funciones en Kotlin se definen utilizando la palabra clave <code>fun</code>, seguida del nombre de la funci\u00f3n, los par\u00e1metros de entrada y el tipo de retorno. </p> <pre><code>fun suma(a: Int, b: Int): Int {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n suma los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-orden-superior","title":"Funciones de orden superior","text":"<p>En Kotlin, puedes pasar funciones como argumentos a otras funciones. Estas funciones se conocen como funciones de orden superior y te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable. </p> <pre><code>fun operacion(a: Int, b: Int, funcion: (Int, Int) -&gt; Int): Int {\n    return funcion(a, b)\n}\n\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun resta(a: Int, b: Int): Int {\n    return a - b\n}\n\nval resultadoSuma = operacion(10, 5, ::suma)\nval resultadoResta = operacion(10, 5, ::resta)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>operacion</code> que toma dos par\u00e1metros de tipo <code>Int</code> y una funci\u00f3n de orden superior que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n <code>operacion</code> aplica la funci\u00f3n de orden superior a los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda","title":"Funciones lambda","text":"<p>En Kotlin, puedes definir funciones an\u00f3nimas conocidas como funciones lambda. Las funciones lambda son funciones sin nombre que puedes pasar como argumentos a otras funciones. </p> <pre><code>val suma = { a: Int, b: Int -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n\nval resultadoSuma = suma(10, 5)\nval resultadoResta = resta(10, 5)\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. Las funciones lambda se asignan a variables y se pueden utilizar como cualquier otra funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#los-parametros-en-kotlin","title":"Los par\u00e1metros en Kotlin","text":"<p>A diferencia de Java, en Kotlin los par\u00e1metros de una funci\u00f3n son inmutables por defecto, lo que significa que no se pueden modificar dentro de la funci\u00f3n. Si necesitas modificar un par\u00e1metro dentro de una funci\u00f3n, debes declararlo como una variable <code>var</code>.</p> <pre><code>fun duplicar(numero: Int): Int {\n    var resultado = numero\n    resultado *= 2\n    return resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>duplicar</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. El par\u00e1metro <code>numero</code> se declara como una variable <code>var</code> para poder modificar su valor dentro de la funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-con-valores-por-defecto","title":"Par\u00e1metros con valores por defecto","text":"<p>Los par\u00e1metros de una funci\u00f3n en Kotlin pueden tener valores por defecto, lo que te permite llamar a la funci\u00f3n sin proporcionar todos los argumentos.</p> <pre><code>fun saludar(nombre: String = \"Mundo\") {\n    println(\"Hola, $nombre!\")\n}\n\nsaludar() // Hola, Mundo!\nsaludar(\"Juan\") // Hola, Juan!\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>saludar</code> que toma un par\u00e1metro de tipo <code>String</code> con un valor por defecto de <code>\"Mundo\"</code>. Si no se proporciona un argumento al llamar a la funci\u00f3n, se utiliza el valor por defecto.</p> <p>Funciones con valores por defecto y su no obligatoriedad, su uso en Compose</p> <p>Las funciones con valores por defecto son muy \u00fatiles en Jetpack Compose, ya que te permiten definir componentes con valores por defecto y llamar a esos componentes sin proporcionar todos los argumentos.</p> <p>Por ejemplo, puedes definir un bot\u00f3n con un texto por defecto y un color por defecto, y luego llamar a ese bot\u00f3n sin proporcionar el texto o el color si deseas utilizar los valores por defecto.</p> <pre><code>@Composable\nfun Boton(texto: String = \"Aceptar\", color: Color = Color.Blue) {\n    Button(onClick = { /* Acci\u00f3n al hacer clic */ }) {\n        Text(texto, color = color)\n    }\n}\n\nBoton() // Bot\u00f3n con texto \"Aceptar\" y color azul\nBoton(\"Cancelar\", Color.Red) // Bot\u00f3n con texto \"Cancelar\" y color rojo\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-de-una-funcion-lambda","title":"Par\u00e1metros de una funci\u00f3n lambda","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes especificar los tipos de los par\u00e1metros de entrada o dejar que el compilador infiera los tipos autom\u00e1ticamente.</p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. En la funci\u00f3n lambda <code>suma</code>, se especifican los tipos de los par\u00e1metros de entrada, mientras que en la funci\u00f3n lambda <code>resta</code>, se deja que el compilador infiera los tipos autom\u00e1ticamente.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#la-palabra-reservada-it","title":"La palabra reservada <code>it</code>","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar la palabra reservada <code>it</code> para referirte al \u00fanico par\u00e1metro de entrada si la funci\u00f3n lambda tiene un solo par\u00e1metro.</p> <pre><code>val cuadrado: (Int) -&gt; Int = { it * it }\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>cuadrado</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. </p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>La palabra reservada <code>it</code> se utiliza para referirse al \u00fanico par\u00e1metro de entrada de la funci\u00f3n lambda.</p> <p>Esto es \u00fatil cuando la funci\u00f3n lambda tiene un solo par\u00e1metro y quieres hacer el c\u00f3digo m\u00e1s conciso.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda-con-multiples-lineas","title":"Funciones lambda con m\u00faltiples l\u00edneas","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar m\u00faltiples l\u00edneas de c\u00f3digo si es necesario. </p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt;\n    val resultado = a + b\n    println(\"La suma de $a y $b es $resultado\")\n    resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n lambda realiza la suma de los dos par\u00e1metros y muestra un mensaje por consola con el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#numero-variable-de-argumentos","title":"N\u00famero variable de argumentos","text":"<p>En Kotlin, puedes definir funciones que toman un n\u00famero variable de argumentos utilizando el operador <code>vararg</code>.</p> <pre><code>fun sumar(vararg numeros: Int): Int {\n    var suma = 0\n    for (numero in numeros) {\n        suma += numero\n    }\n    return suma\n}\n\nval resultado = sumar(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma un n\u00famero variable de argumentos de tipo <code>Int</code> utilizando el operador <code>vararg</code>. La funci\u00f3n suma todos los n\u00fameros pasados como argumentos y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-extension-extension-functions","title":"Funciones de extensi\u00f3n (Extension Functions)","text":"<p>En Kotlin, puedes agregar nuevas funciones a las clases existentes sin heredar de ellas. </p> <p>Estas funciones se conocen como funciones de extensi\u00f3n y te permiten extender la funcionalidad de las clases sin modificar su c\u00f3digo fuente.</p> <pre><code>fun String.invertir(): String {\n    return this.reversed()\n}\n\nval texto = \"Hola, mundo!\"\nval textoInvertido = texto.invertir()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>invertir</code> para la clase <code>String</code> que invierte el contenido de la cadena de texto. La funci\u00f3n de extensi\u00f3n se llama como si fuera un m\u00e9todo de la clase <code>String</code>.</p> <p>Funciones de extensi\u00f3n y funciones de orden superior</p> <p>Las funciones de extensi\u00f3n y las funciones de orden superior son dos caracter\u00edsticas poderosas de Kotlin que te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable.</p> <p>Las funciones de extensi\u00f3n te permiten agregar nuevas funciones a las clases existentes sin heredar de ellas, mientras que las funciones de orden superior te permiten pasar funciones como argumentos a otras funciones.</p> <p>Al combinar estas dos caracter\u00edsticas, puedes escribir c\u00f3digo m\u00e1s flexible y expresivo en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#ejemplo-poniendo-en-practica-todo","title":"\ud83c\udfaf Ejemplo. Poniendo en pr\u00e1ctica todo","text":"<p>Imaginen que estamos desarrollando una aplicaci\u00f3n para gestionar los cursos de una universidad. Vamos a trabajar con una lista de estudiantes.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-1-definir-nuestro-modelo-de-datos","title":"Paso 1: Definir nuestro modelo de datos #\ufe0f\u20e3","text":"<p>Primero, definamos una clase de datos (<code>data class</code>) que representar\u00e1 a un estudiante. Las <code>data class</code> en Kotlin son perfectas para este prop\u00f3sito, ya que nos proveen autom\u00e1ticamente de m\u00e9todos \u00fatiles como <code>equals()</code>, <code>hashCode()</code> y <code>toString()</code>.</p> <pre><code>data class Estudiante(\n    val id: Int,\n    val nombre: String,\n    val calificacion: Double,\n    val curso: String,\n    val activo: Boolean = true\n)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-2-generar-nuestra-coleccion-de-datos","title":"Paso 2: Generar nuestra colecci\u00f3n de datos #\ufe0f\u20e3","text":"<p>Ahora, vamos a crear una lista (<code>List</code>) de estudiantes para nuestros ejemplos. Las listas son colecciones ordenadas de elementos. En Kotlin, podemos crearlas f\u00e1cilmente con la funci\u00f3n <code>listOf()</code>.</p> <pre><code>val estudiantes = listOf(\n    Estudiante(1, \"Ana\", 9.5, \"Kotlin Avanzado\", true),\n    Estudiante(2, \"Luis\", 6.8, \"Jetpack Compose\", false),\n    Estudiante(3, \"Carlos\", 8.9, \"Kotlin Avanzado\", true),\n    Estudiante(4, \"Sof\u00eda\", 10.0, \"Arquitectura Android\", true),\n    Estudiante(5, \"Marta\", 7.2, \"Jetpack Compose\", true),\n    Estudiante(6, \"Pedro\", 5.5, \"Kotlin Avanzado\", true),\n    Estudiante(7, \"Luc\u00eda\", 8.1, \"Arquitectura Android\", false)\n)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-3-procesando-la-coleccion-con-funciones-de-orden-superior-y-lambdas","title":"Paso 3: Procesando la colecci\u00f3n con funciones de orden superior y Lambdas #\ufe0f\u20e3","text":"<p>Aqu\u00ed es donde reside la magia de la programaci\u00f3n funcional en Kotlin. En lugar de usar bucles <code>for</code> tradicionales para todo, podemos usar funciones que aceptan otras funciones (lambdas) como par\u00e1metros para procesar colecciones.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#1-filter-filtrando-la-coleccion","title":"1. <code>filter</code>: Filtrando la colecci\u00f3n","text":"<p>La funci\u00f3n <code>filter</code> crea una nueva lista que contiene \u00fanicamente los elementos que cumplen con una condici\u00f3n espec\u00edfica (el \"predicado\").</p> <p>Ejemplo: Queremos obtener solo los estudiantes que hayan aprobado, es decir, que tengan una calificaci\u00f3n mayor o igual a 7.0.</p> <pre><code>val estudiantesAprobados = estudiantes.filter { estudiante -&gt;\n    estudiante.calificacion &gt;= 7.0\n}\n\nprintln(\"Estudiantes Aprobados:\")\nestudiantesAprobados.forEach { println(it) }\n\n// --- Salida ---\n// Estudiantes Aprobados:\n// Estudiante(id=1, nombre=Ana, calificacion=9.5, curso=Kotlin Avanzado, activo=true)\n// Estudiante(id=3, nombre=Carlos, calificacion=8.9, curso=Kotlin Avanzado, activo=true)\n// Estudiante(id=4, nombre=Sof\u00eda, calificacion=10.0, curso=Arquitectura Android, activo=true)\n// Estudiante(id=5, nombre=Marta, calificacion=7.2, curso=Jetpack Compose, activo=true)\n// Estudiante(id=7, nombre=Luc\u00eda, calificacion=8.1, curso=Arquitectura Android, activo=false)\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ estudiante -&gt; estudiante.calificacion &gt;= 7.0 }</code> se ejecuta para cada estudiante en la lista. Si la expresi\u00f3n devuelve <code>true</code>, el estudiante se incluye en la nueva lista <code>estudiantesAprobados</code>.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#2-map-transformando-la-coleccion","title":"2. <code>map</code>: Transformando la colecci\u00f3n #\ufe0f\u20e3","text":"<p>La funci\u00f3n <code>map</code> crea una nueva lista transformando cada elemento de la lista original en algo nuevo.</p> <p>Ejemplo: Necesitamos una lista que contenga solo los nombres de todos los estudiantes, pero en may\u00fasculas.</p> <pre><code>val nombresEnMayusculas = estudiantes.map { it.nombre.uppercase() }\n\nprintln(\"\\nNombres de Estudiantes en May\u00fasculas:\")\nprintln(nombresEnMayusculas)\n\n// --- Salida ---\n// Nombres de Estudiantes en May\u00fasculas:\n// [ANA, LUIS, CARLOS, SOF\u00cdA, MARTA, PEDRO, LUC\u00cdA]\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ it.nombre.uppercase() }</code> toma cada estudiante (<code>it</code> es el nombre impl\u00edcito para un \u00fanico par\u00e1metro) y devuelve su nombre convertido a may\u00fasculas. El resultado es una <code>List&lt;String&gt;</code>.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#3-find-o-firstornull-encontrando-un-elemento","title":"3. <code>find</code> (o <code>firstOrNull</code>): Encontrando un elemento #\ufe0f\u20e3","text":"<p>La funci\u00f3n <code>firstOrNull</code> devuelve el primer elemento que cumple una condici\u00f3n, o <code>null</code> si ninguno la cumple.</p> <p>Ejemplo: Busquemos al estudiante con el ID 4.</p> <pre><code>val estudianteBuscado = estudiantes.firstOrNull { it.id == 4 }\n\nif (estudianteBuscado != null) {\n    println(\"\\nEstudiante encontrado: ${estudianteBuscado.nombre}\")\n} else {\n    println(\"\\nNo se encontr\u00f3 al estudiante.\")\n}\n\n// --- Salida ---\n// Estudiante encontrado: Sof\u00eda\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#4-groupby-agrupando-elementos","title":"4. <code>groupBy</code>: Agrupando elementos #\ufe0f\u20e3","text":"<p>Esta funci\u00f3n es incre\u00edblemente \u00fatil. Agrupa los elementos de una colecci\u00f3n en un <code>Map</code>, donde las claves son el resultado de la lambda y los valores son listas de los elementos que generaron esa clave.</p> <p>Ejemplo: Agrupemos a los estudiantes por el curso en el que est\u00e1n inscritos.</p> <pre><code>val estudiantesPorCurso = estudiantes.groupBy { it.curso }\n\nprintln(\"\\nEstudiantes agrupados por curso:\")\nestudiantesPorCurso.forEach { (curso, listaEstudiantes) -&gt;\n    println(\"Curso: $curso\")\n    listaEstudiantes.forEach { estudiante -&gt;\n        println(\"  - ${estudiante.nombre}\")\n    }\n}\n\n// --- Salida ---\n// Estudiantes agrupados por curso:\n// Curso: Kotlin Avanzado\n//   - Ana\n//   - Carlos\n//   - Pedro\n// Curso: Jetpack Compose\n//   - Luis\n//   - Marta\n// Curso: Arquitectura Android\n//   - Sof\u00eda\n//   - Luc\u00eda\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ it.curso }</code> se ejecuta para cada estudiante, y el valor que devuelve (el nombre del curso) se usa como clave en el <code>Map</code> resultante.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#encadenamiento-de-operaciones-el-verdadero-poder","title":"Encadenamiento de Operaciones: El verdadero poder \ud83d\udcaa","text":"<p>La verdadera expresividad se alcanza cuando encadenamos estas funciones. Las operaciones se ejecutan en secuencia, permiti\u00e9ndonos realizar consultas complejas de forma muy legible.</p> <p>Ejemplo complejo: Queremos obtener los nombres de los estudiantes activos del curso \"Kotlin Avanzado\" que hayan aprobado, ordenados por su calificaci\u00f3n de mayor a menor.</p> <pre><code>val resultadoFinal = estudiantes\n    .filter { it.curso == \"Kotlin Avanzado\" &amp;&amp; it.activo } // 1. Filtra por curso y estado activo\n    .filter { it.calificacion &gt;= 7.0 }                 // 2. Filtra los aprobados de ese grupo\n    .sortedByDescending { it.calificacion }               // 3. Ordena de mayor a menor calificaci\u00f3n\n    .map { \"${it.nombre} - Calificaci\u00f3n: ${it.calificacion}\" } // 4. Mapea al formato deseado (String)\n\nprintln(\"\\nConsulta compleja:\")\nresultadoFinal.forEach { println(it) }\n\n// --- Salida ---\n// Consulta compleja:\n// Ana - Calificaci\u00f3n: 9.5\n// Carlos - Calificaci\u00f3n: 8.9\n</code></pre>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html","title":"Null safety","text":""},{"location":"temas/00-android/00-kotlin/14-null-safety.html#null-safety-en-kotlin","title":"Null safety en Kotlin","text":"<p>En Kotlin, el manejo de nulos es una parte fundamental del lenguaje. </p> <p>Kotlin est\u00e1 dise\u00f1ado para evitar los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n, como Java. </p> <p>En Kotlin, los tipos de datos pueden ser nulos o no nulos, lo que te permite expresar de forma segura si un valor puede ser nulo o no.  </p> <p>Diferencia con Java</p> <p>En Java, todos los tipos de datos pueden ser nulos, lo que puede llevar a errores de referencia nula si no se manejan correctamente. </p> <p>En Kotlin, los tipos de datos no nulos deben ser manejados de forma expl\u00edcita, lo que ayuda a prevenir los errores de referencia nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#tipos-de-datos-nulos","title":"Tipos de datos nulos","text":"<p>En Kotlin, los tipos de datos pueden ser nulos o no nulos.</p> <ul> <li> <p>Tipos de datos no nulos: Los tipos de datos no nulos no pueden contener valores nulos y deben ser inicializados con un valor no nulo.</p> </li> <li> <p>Tipos de datos nulos: Los tipos de datos nulos pueden contener valores nulos y deben ser inicializados con un valor nulo o con la funci\u00f3n <code>null</code>.</p> </li> </ul> <pre><code>val nombre: String = \"Juan\" // Tipo de dato no nulo\n\nval apellido: String? = null // Tipo de dato nulo\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String</code> no nulo, por lo que no puede contener un valor nulo. La variable <code>apellido</code>, en cambio, es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#operadores-de-seguridad-de-nulos","title":"Operadores de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar operadores de seguridad de nulos para manejar los valores nulos de forma segura.</p> <ul> <li> <p>Operador de llamada segura (<code>?.</code>): El operador de llamada segura <code>?.</code> te permite acceder a las propiedades de un objeto nulo sin lanzar una excepci\u00f3n de referencia nula.</p> </li> <li> <p>Operador de elvis (<code>?:</code>): El operador de elvis <code>?:</code> te permite proporcionar un valor predeterminado en caso de que una expresi\u00f3n sea nula.</p> </li> <li> <p>Operador de no nulo (<code>!!</code>): El operador de no nulo <code>!!</code> te permite forzar la ejecuci\u00f3n de una expresi\u00f3n nula, lo que puede lanzar una excepci\u00f3n de referencia nula si la expresi\u00f3n es nula.</p> </li> </ul> <pre><code>val nombre: String? = null\n\nval longitud = nombre?.length // null\n\nval longitud = nombre?.length ?: 0 // 0\n\nval longitud = nombre!!.length // Lanza una excepci\u00f3n de referencia nula\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p> <ul> <li> <p>En la primera l\u00ednea, se utiliza el operador de llamada segura <code>?.</code> para acceder a la propiedad <code>length</code> de la variable <code>nombre</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length</code> devuelve <code>null</code>.</p> </li> <li> <p>En la segunda l\u00ednea, se utiliza el operador de elvis <code>?:</code> para proporcionar un valor predeterminado de <code>0</code> en caso de que la expresi\u00f3n <code>nombre?.length</code> sea nula. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length ?: 0</code> devuelve <code>0</code>.</p> </li> <li> <p>En la tercera l\u00ednea, se utiliza el operador de no nulo <code>!!</code> para forzar la ejecuci\u00f3n de la expresi\u00f3n <code>nombre!!.length</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre!!.length</code> lanza una excepci\u00f3n de referencia nula.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#funciones-de-extension-de-seguridad-de-nulos","title":"Funciones de extensi\u00f3n de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar funciones de extensi\u00f3n para agregar funcionalidades a los tipos de datos nulos.</p> <pre><code>fun String?.oLongitud(): Int {\n    return this?.length ?: 0\n}\n\nval nombre: String? = null\n\nval longitud = nombre.oLongitud() // 0\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>oLongitud</code> para el tipo de dato <code>String?</code>. La funci\u00f3n <code>oLongitud</code> devuelve la longitud de la cadena si no es nula, o <code>0</code> si es nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#conclusiones","title":"Conclusiones","text":"<p>El manejo de nulos en Kotlin es una parte fundamental del lenguaje que te permite expresar de forma segura si un valor puede ser nulo o no.</p> <p>Al utilizar tipos de datos nulos y operadores de seguridad de nulos, puedes prevenir los errores de referencia nula y escribir c\u00f3digo m\u00e1s robusto y seguro.</p> <p>Recursos</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin sobre seguridad de nulos</li> <li>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</li> <li>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</li> </ul>"},{"location":"temas/00-android/00-kotlin/21-poo.html","title":"POO","text":""},{"location":"temas/00-android/00-kotlin/21-poo.html#programacion-orientada-a-objetos-en-kotlin","title":"Programaci\u00f3n orientada a objetos en Kotlin","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se basa en el concepto de \"objetos\", que pueden contener datos en forma de campos (tambi\u00e9n conocidos como atributos) y c\u00f3digo en forma de procedimientos (tambi\u00e9n conocidos como m\u00e9todos).    </p> <p>En Kotlin, puedes crear clases y objetos para modelar entidades del mundo real y encapsular datos y comportamientos relacionados. Kotlin es un lenguaje de programaci\u00f3n orientado a objetos y admite todas las caracter\u00edsticas tradicionales de la programaci\u00f3n orientada a objetos, como la herencia, el polimorfismo, la encapsulaci\u00f3n y la abstracci\u00f3n.  </p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#clases-y-objetos","title":"Clases y objetos","text":"<p>En Kotlin, puedes definir una clase utilizando la palabra clave <code>class</code> seguida del nombre de la clase y el cuerpo de la clase entre llaves <code>{}</code>. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con valores predeterminados.</p> <p>Para crear un objeto de una clase en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#propiedades-y-metodos","title":"Propiedades y m\u00e9todos","text":"<p>En Kotlin, puedes definir propiedades y m\u00e9todos en una clase utilizando la palabra clave <code>var</code> o <code>val</code> seguida del nombre de la propiedad o el m\u00e9todo y el tipo de dato de la propiedad o el m\u00e9todo.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y un m\u00e9todo <code>saludar</code> que imprime un mensaje de saludo con el nombre de la persona.</p> <p>Para acceder a las propiedades y m\u00e9todos de un objeto en Kotlin, puedes utilizar el operador de acceso <code>.</code> seguido del nombre de la propiedad o el m\u00e9todo.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. Luego, se llama al m\u00e9todo <code>saludar</code> en el objeto <code>persona</code> para imprimir un mensaje de saludo con el nombre de la persona.</p> <p>Diferencias con Java</p> <p>A diferencia de Java, en Kotlin, las propiedades y los m\u00e9todos de una clase son p\u00fablicos por defecto, lo que significa que se pueden acceder desde cualquier parte del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>En Kotlin, puedes encapsular propiedades y m\u00e9todos en una clase utilizando los modificadores de acceso <code>public</code>, <code>protected</code>, <code>private</code> y <code>internal</code>.</p> <ul> <li><code>public</code>: Las propiedades y m\u00e9todos p\u00fablicos son accesibles desde cualquier parte del c\u00f3digo.</li> <li><code>protected</code>: Las propiedades y m\u00e9todos protegidos son accesibles desde la clase actual y las clases derivadas.</li> <li><code>private</code>: Las propiedades y m\u00e9todos privados son accesibles solo desde la clase actual.</li> <li><code>internal</code>: Las propiedades y m\u00e9todos internos son accesibles desde el m\u00f3dulo actual.</li> </ul> <pre><code>class Persona {\n    var nombre: String = \"\"\n        private set\n    var edad: Int = 0\n        private set\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que se han encapsulado con el modificador de acceso <code>private</code>. Esto significa que las propiedades <code>nombre</code> y <code>edad</code> solo se pueden acceder y modificar dentro de la clase <code>Persona</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. </p> <p>Sin embargo, al intentar modificar las propiedades <code>nombre</code> y <code>edad</code> desde fuera de la clase <code>Persona</code>, se produce un error de compilaci\u00f3n debido a que las propiedades est\u00e1n encapsuladas con el modificador de acceso <code>private</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#setters-y-getters-personalizados","title":"Setters y Getters personalizados","text":"<p>En Kotlin, puedes definir setters y getters personalizados para las propiedades de una clase utilizando la palabra clave <code>set</code> y <code>get</code> seguida de la l\u00f3gica personalizada para establecer y obtener el valor de la propiedad.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n        set(value) {\n            field = value.capitalize()\n        }\n    var edad: Int = 0\n        set(value) {\n            field = if (value &gt;= 0) value else 0\n        }\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que tienen setters personalizados. El setter de la propiedad <code>nombre</code> capitaliza el valor de la propiedad, y el setter de la propiedad <code>edad</code> establece el valor de la propiedad en <code>0</code> si es menor que <code>0</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"juan\"\npersona.edad = -10\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores","title":"Constructores","text":"<p>En Kotlin, puedes definir un constructor primario utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <p>Sin embargo, en Kotlin, puedes omitir la palabra clave <code>constructor</code> y definir los par\u00e1metros del constructor directamente en la declaraci\u00f3n de la clase.</p> <pre><code>class Persona(nombre: String, edad: Int) {\n    var nombre: String = nombre\n    var edad: Int = edad\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor primario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor.</p> <p>Para crear un objeto de una clase con un constructor primario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor primario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores-secundarios","title":"Constructores secundarios","text":"<p>En Kotlin, puedes definir constructores secundarios utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    constructor(nombre: String, edad: Int) {\n        this.nombre = nombre\n        this.edad = edad\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor secundario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor secundario.</p> <p>Para crear un objeto de una clase con un constructor secundario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor secundario de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor secundario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#herencia","title":"Herencia","text":"<p>En Kotlin, puedes crear una clase que herede de otra clase utilizando la palabra clave <code>:</code> seguida del nombre de la clase base.</p> <pre><code>open class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n\nclass Empleado : Persona() {\n    var salario: Double = 0.0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y agrega una propiedad <code>salario</code>.</p> <p>Para crear un objeto de una clase derivada en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase derivada.</p> <pre><code>val empleado = Empleado()\nempleado.nombre = \"Juan\"\nempleado.edad = 30\nempleado.salario = 1000.0\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se inicializan las propiedades <code>nombre</code>, <code>edad</code> y <code>salario</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#polimorfismo","title":"Polimorfismo","text":"<p>En Kotlin, puedes utilizar el polimorfismo para tratar un objeto de una clase derivada como un objeto de la clase base.</p> <pre><code>open class Persona {\n    open fun saludar() {\n        println(\"Hola, soy una persona\")\n    }\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y sobrescribe el m\u00e9todo <code>saludar</code>.</p> <p>La palabra reservada open</p> <p>La palabra reservada <code>open</code> se utiliza para marcar una clase o un miembro de una clase como \"sobrese\u00edble\", lo que significa que puede ser heredado y sobrescrito por clases derivadas. </p> <p>Para utilizar el polimorfismo en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#abstraccion","title":"Abstracci\u00f3n","text":"<p>En Kotlin, puedes utilizar la abstracci\u00f3n para definir una clase base con m\u00e9todos abstractos que deben ser implementados por las clases derivadas.</p> <pre><code>abstract class Persona {\n    abstract fun saludar()\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo abstracto <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> e implementa el m\u00e9todo <code>saludar</code>.</p> <p>Para utilizar la abstracci\u00f3n en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html","title":"Objetos an\u00f3nimos","text":""},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#objetos-anonimos-en-kotlin","title":"Objetos an\u00f3nimos en Kotlin","text":"<p>En Kotlin, puedes crear objetos an\u00f3nimos utilizando la palabra clave <code>object</code>. </p> <p>Los objetos an\u00f3nimos son instancias de una clase an\u00f3nima que no tienen un nombre y se utilizan para definir una clase de forma concisa y reutilizable.</p> <pre><code>val persona = object {\n    val nombre = \"Juan\"\n    val edad = 25\n}\n\nprintln(persona.nombre) // Juan\nprintln(persona.edad) // 25\n</code></pre> <p>En el ejemplo anterior, se crea un objeto an\u00f3nimo que tiene dos propiedades <code>nombre</code> y <code>edad</code>. </p> <p>El objeto an\u00f3nimo se asigna a la variable <code>persona</code> y se puede acceder a sus propiedades utilizando la notaci\u00f3n de punto.</p> <p>Los objetos an\u00f3nimos son \u00fatiles cuando necesitas crear una instancia de una clase de forma r\u00e1pida y concisa sin tener que definir una clase con nombre.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#uso-de-objetos-anonimos","title":"Uso de objetos an\u00f3nimos","text":"<p>Los objetos an\u00f3nimos se utilizan en Kotlin para:</p> <ul> <li>Crear instancias de una clase de forma r\u00e1pida y concisa.</li> <li>Definir clases de forma reutilizable sin tener que definir una clase con nombre.</li> <li>Implementar interfaces y clases abstractas de forma an\u00f3nima.</li> </ul> <p>Los objetos an\u00f3nimos son una caracter\u00edstica poderosa de Kotlin que te permite escribir c\u00f3digo de forma m\u00e1s concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-de-interfaces-con-objetos-anonimos","title":"Implementaci\u00f3n de interfaces con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar interfaces de forma an\u00f3nima utilizando objetos an\u00f3nimos. Esto te permite definir una clase que implementa una interfaz sin tener que definir una clase con nombre.</p> <pre><code>interface Saludable {\n    fun saludar()\n}\n\nval persona = object : Saludable {\n    override fun saludar() {\n        println(\"Hola, soy una persona saludable!\")\n    }\n}\n\npersona.saludar() // Hola, soy una persona saludable!\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Saludable</code> con un m\u00e9todo <code>saludar</code>.</p> <p>Se crea un objeto an\u00f3nimo que implementa la interfaz <code>Saludable</code> y se asigna a la variable <code>persona</code>.</p> <p>El objeto an\u00f3nimo define la implementaci\u00f3n del m\u00e9todo <code>saludar</code> y se puede llamar al m\u00e9todo utilizando la notaci\u00f3n de punto.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-del-patron-singleton-con-objetos-anonimos","title":"Implementaci\u00f3n del patr\u00f3n Singleton con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos. El patr\u00f3n Singleton garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <pre><code>object Configuracion {\n    val servidor = \"localhost\"\n    val puerto = 8080\n}\n\nprintln(Configuracion.servidor) // localhost\nprintln(Configuracion.puerto) // 8080\n</code></pre> <p>En el ejemplo anterior, se define un objeto an\u00f3nimo <code>Configuracion</code> que tiene dos propiedades <code>servidor</code> y <code>puerto</code>.</p> <p>El objeto an\u00f3nimo se utiliza para almacenar la configuraci\u00f3n de la aplicaci\u00f3n y garantiza que solo haya una instancia de la configuraci\u00f3n en toda la aplicaci\u00f3n.</p> <p>Caracter\u00edsticas de los objetos an\u00f3nimos</p> <p>Los objetos an\u00f3nimos en Kotlin tienen las siguientes caracter\u00edsticas:</p> <ul> <li>No tienen un nombre y se crean utilizando la palabra clave <code>object</code>.</li> <li>Pueden tener propiedades, m\u00e9todos y constructores.</li> <li>Se utilizan para definir clases de forma concisa y reutilizable.</li> <li>Se pueden utilizar para implementar interfaces y clases abstractas de forma an\u00f3nima.</li> <li>Se pueden utilizar para implementar el patr\u00f3n Singleton y almacenar configuraciones globales.</li> </ul> <p>Sobre el patr\u00f3n Singleton</p> <p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o que garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos, que garantizan que solo haya una instancia de la clase en toda la aplicaci\u00f3n.</p> <p>Usos comunes del patr\u00f3n Singleton incluyen la creaci\u00f3n de objetos de configuraci\u00f3n, conexiones a bases de datos y puntos de acceso a servicios globales.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html","title":"Data classes","text":""},{"location":"temas/00-android/00-kotlin/23-data-classes.html#data-classes-en-kotlin","title":"Data classes en Kotlin","text":"<p>En Kotlin, puedes crear clases de datos utilizando la palabra clave <code>data</code>. Las clases de datos son una forma concisa de definir clases que contienen datos y no tienen l\u00f3gica adicional.</p> <pre><code>data class Persona(val nombre: String, val edad: Int)\n</code></pre> <p>En el ejemplo anterior, se define una clase de datos <code>Persona</code> que tiene dos propiedades <code>nombre</code> y <code>edad</code>. La clase de datos se crea utilizando la palabra clave <code>data</code> seguida del nombre de la clase y las propiedades de la clase.</p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>v\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#propiedades-de-las-clases-de-datos","title":"Propiedades de las clases de datos","text":"<p>Las clases de datos en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Propiedades de solo lectura: Las propiedades de una clase de datos son de solo lectura y no se pueden modificar una vez que se han inicializado.</p> </li> <li> <p>M\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente los m\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code> a partir de las propiedades de la clase.</p> </li> <li> <p>M\u00e9todos <code>componentN()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente m\u00e9todos <code>componentN()</code> que te permiten desestructurar objetos de la clase en variables individuales.</p> </li> <li> <p>M\u00e9todo <code>copy()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente un m\u00e9todo <code>copy()</code> que te permite crear copias de objetos de la clase con propiedades modificadas.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#creacion-de-objetos-de-clases-de-datos","title":"Creaci\u00f3n de objetos de clases de datos","text":"<p>Para crear un objeto de una clase de datos en Kotlin, puedes utilizar la palabra clave <code>data</code> seguida del nombre de la clase y los valores de las propiedades.</p> <pre><code>val persona = Persona(\"Juan\", 25)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto de la clase de datos <code>Persona</code> con el nombre <code>Juan</code> y la edad <code>25</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#desestructuracion-de-objetos-de-clases-de-datos","title":"Desestructuraci\u00f3n de objetos de clases de datos","text":"<p>En Kotlin, puedes desestructurar objetos de clases de datos en variables individuales utilizando la notaci\u00f3n de desestructuraci\u00f3n.</p> <pre><code>val (nombre, edad) = persona\n</code></pre> <p>En el ejemplo anterior, se desestructura el objeto <code>persona</code> en las variables <code>nombre</code> y <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#copia-de-objetos-de-clases-de-datos","title":"Copia de objetos de clases de datos","text":"<p>En Kotlin, puedes crear copias de objetos de clases de datos utilizando el m\u00e9todo <code>copy()</code>.</p> <pre><code>val persona2 = persona.copy(edad = 30)\n</code></pre> <p>En el ejemplo anterior, se crea una copia del objeto <code>persona</code> con la edad modificada a <code>30</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html","title":"Enum classes","text":""},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#enum-classes-en-kotlin","title":"Enum classes en Kotlin","text":"<p>En Kotlin, puedes crear enumeraciones utilizando la palabra clave <code>enum class</code>.</p> <p>Las enumeraciones son una forma de definir un conjunto fijo de constantes que representan valores espec\u00edficos. Cada constante en una enumeraci\u00f3n tiene un nombre y un valor asociado.</p> <pre><code>enum class Color {\n    ROJO, VERDE, AZUL\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con tres constantes <code>ROJO</code>, <code>VERDE</code> y <code>AZUL</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-de-las-enumeraciones","title":"Propiedades de las enumeraciones","text":"<p>Las enumeraciones en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Constantes: Las enumeraciones contienen un conjunto fijo de constantes que representan valores espec\u00edficos.</p> </li> <li> <p>Propiedades y m\u00e9todos: Las enumeraciones pueden tener propiedades y m\u00e9todos asociados con cada constante.</p> </li> <li> <p>Constructores: Las enumeraciones pueden tener constructores personalizados para inicializar las constantes con valores espec\u00edficos.</p> </li> <li> <p>Implementaci\u00f3n de interfaces: Las enumeraciones pueden implementar interfaces y heredar de clases.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#acceso-a-las-constantes-de-una-enumeracion","title":"Acceso a las constantes de una enumeraci\u00f3n","text":"<p>Puedes acceder a las constantes de una enumeraci\u00f3n utilizando la notaci\u00f3n de punto.</p> <pre><code>val color = Color.ROJO\n</code></pre> <p>En el ejemplo anterior, se accede a la constante <code>ROJO</code> de la enumeraci\u00f3n <code>Color</code> y se asigna a la variable <code>color</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-y-metodos-de-una-enumeracion","title":"Propiedades y m\u00e9todos de una enumeraci\u00f3n","text":"<p>Puedes definir propiedades y m\u00e9todos en una enumeraci\u00f3n para agregar funcionalidades a las constantes.</p> <pre><code>enum class Color(val rgb: Int) {\n    ROJO(0xFF0000),\n    VERDE(0x00FF00),\n    AZUL(0x0000FF);\n\n    fun nombreEnMayusculas(): String {\n        return name.toUpperCase()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con una propiedad <code>rgb</code> y un m\u00e9todo <code>nombreEnMayusculas</code> que devuelve el nombre de la constante en may\u00fasculas.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#implementacion-de-interfaces-con-enumeraciones","title":"Implementaci\u00f3n de interfaces con enumeraciones","text":"<p>Las enumeraciones en Kotlin pueden implementar interfaces para agregar funcionalidades a las constantes.</p> <pre><code>interface Describible {\n    fun describir(): String\n}\n\nenum class DiaSemana : Describible {\n    LUNES {\n        override fun describir(): String {\n            return \"Primer d\u00eda de la semana\"\n        }\n    },\n    MARTES {\n        override fun describir(): String {\n            return \"Segundo d\u00eda de la semana\"\n        }\n    },\n    MIERCOLES {\n        override fun describir(): String {\n            return \"Tercer d\u00eda de la semana\"\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Describible</code> con un m\u00e9todo <code>describir</code>.</p> <p>Se crea una enumeraci\u00f3n <code>DiaSemana</code> que implementa la interfaz <code>Describible</code> y define la implementaci\u00f3n del m\u00e9todo <code>describir</code> para cada constante.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#uso-de-enumeraciones-en-kotlin","title":"Uso de enumeraciones en Kotlin","text":"<p>Las enumeraciones son \u00fatiles en Kotlin para:</p> <ul> <li>Definir un conjunto fijo de constantes que representan valores espec\u00edficos.</li> <li>Agregar propiedades y m\u00e9todos a las constantes para agregar funcionalidades.</li> <li>Implementar interfaces y heredar de clases para agregar funcionalidades a las constantes.</li> </ul>"},{"location":"temas/00-android/00-kotlin/25-genericos.html","title":"Gen\u00e9ricos","text":""},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-kotlin","title":"Gen\u00e9ricos en Kotlin","text":"<p>En Kotlin, puedes utilizar gen\u00e9ricos para crear clases, funciones e interfaces que trabajen con tipos de datos de forma gen\u00e9rica. Los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p> <p>Video explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#clases-genericas","title":"Clases gen\u00e9ricas","text":"<p>En Kotlin, puedes crear clases gen\u00e9ricas utilizando la palabra clave <code>class</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la clase puede manejar.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval cajaCadena = Caja(\"Hola\")\n\nval entero: Int = cajaEntero.obtenerContenido()\nval cadena: String = cajaCadena.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una clase gen\u00e9rica <code>Caja</code> que tiene un par\u00e1metro de tipo <code>T</code>. La clase <code>Caja</code> tiene una propiedad <code>contenido</code> de tipo <code>T</code> y un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido de la caja.</p> <p>Se crean dos instancias de la clase <code>Caja</code> con tipos de datos diferentes: una con un entero y otra con una cadena. Se obtiene el contenido de cada caja y se asigna a variables de tipo <code>Int</code> y <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#funciones-genericas","title":"Funciones gen\u00e9ricas","text":"<p>En Kotlin, puedes crear funciones gen\u00e9ricas utilizando la palabra clave <code>fun</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la funci\u00f3n puede manejar.</p> <pre><code>fun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\nimprimirElemento(10)\nimprimirElemento(\"Hola\")\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n gen\u00e9rica <code>imprimirElemento</code> que toma un par\u00e1metro de tipo <code>T</code> y lo imprime en la consola. La funci\u00f3n <code>imprimirElemento</code> se llama dos veces con un entero y una cadena como argumentos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#interfaces-genericas","title":"Interfaces gen\u00e9ricas","text":"<p>En Kotlin, puedes crear interfaces gen\u00e9ricas utilizando la palabra clave <code>interface</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la interfaz puede manejar.</p> <pre><code>interface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;T&gt;(val contenido: T) : Contenedor&lt;T&gt; {\n    override fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval entero: Int = cajaEntero.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una interfaz gen\u00e9rica <code>Contenedor</code> que tiene un par\u00e1metro de tipo <code>T</code>. La interfaz <code>Contenedor</code> define un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido del contenedor.</p> <p>Se crea una clase <code>Caja</code> que implementa la interfaz <code>Contenedor</code> con un tipo de dato <code>T</code>. Se crea una instancia de la clase <code>Caja</code> con un entero y se obtiene el contenido de la caja.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#variance-en-genericos","title":"Variance en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar la anotaci\u00f3n <code>in</code> y <code>out</code> para especificar la variabilidad de los par\u00e1metros de tipo en clases y funciones gen\u00e9ricas.</p> <ul> <li><code>in</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de entrada (como par\u00e1metros de m\u00e9todos).</li> <li><code>out</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de salida (como valores de retorno de m\u00e9todos).</li> </ul> <pre><code>interface Contenedor&lt;out T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;in T&gt;(val contenido: T) {\n    fun ponerContenido(nuevoContenido: T) {\n        // ...\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Contenedor</code> con un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de salida. La clase <code>Caja</code> tiene un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de entrada.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#restricciones-en-genericos","title":"Restricciones en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar restricciones para limitar los tipos de datos que se pueden utilizar en clases y funciones gen\u00e9ricas. Puedes utilizar restricciones para garantizar que los tipos de datos cumplan ciertos requisitos.</p> <pre><code>fun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n\nval resultadoEntero = sumar(1, 2)\nval resultadoFlotante = sumar(1.5, 2.5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma dos par\u00e1metros de tipo <code>T</code> que deben ser subtipos de <code>Number</code>. La funci\u00f3n <code>sumar</code> devuelve la suma de los dos par\u00e1metros.</p> <p>Se llama a la funci\u00f3n <code>sumar</code> con un entero y un flotante como argumentos, y se asigna el resultado a variables de tipo <code>Int</code> y <code>Float</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-clases-y-funciones","title":"Gen\u00e9ricos en clases y funciones","text":"<p>En Kotlin, los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos. Puedes utilizar gen\u00e9ricos en clases, funciones e interfaces para crear c\u00f3digo gen\u00e9rico y flexible.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nfun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\ninterface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nfun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se muestran ejemplos de clases gen\u00e9ricas, funciones gen\u00e9ricas e interfaces gen\u00e9ricas en Kotlin. Puedes utilizar gen\u00e9ricos para escribir c\u00f3digo que sea reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#recursos-adicionales","title":"Recursos adicionales","text":"<ul> <li>Documentaci\u00f3n oficial de Kotlin sobre gen\u00e9ricos</li> <li>Tutorial de Kotlin sobre gen\u00e9ricos</li> <li>Ejemplos de gen\u00e9ricos en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html","title":"Clases selladas","text":""},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#clases-selladas-en-kotlin","title":"Clases selladas en Kotlin","text":"<p>Las clases selladas son un tipo especial de clase en Kotlin que se utilizan para representar un conjunto finito de subclases. </p> <p>Las clases selladas son \u00fatiles cuando tienes un conjunto limitado de subclases y quieres asegurarte de que todas las subclases se manejan de forma segura en un bloque <code>when</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#declaracion-de-clases-selladas","title":"Declaraci\u00f3n de clases selladas","text":"<p>En Kotlin, puedes declarar una clase sellada utilizando la palabra clave <code>sealed</code> antes de la palabra clave <code>class</code>. </p> <pre><code>sealed class Resultado {\n    data class Exito(val mensaje: String) : Resultado()\n    data class Error(val mensaje: String) : Resultado()\n}\n</code></pre> <p>En el ejemplo anterior, se declara una clase sellada <code>Resultado</code> con dos subclases: <code>Exito</code> y <code>Error</code>. Ambas subclases tienen una propiedad <code>mensaje</code> de tipo <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#uso-de-clases-selladas","title":"Uso de clases selladas","text":"<p>Las clases selladas se utilizan principalmente en expresiones <code>when</code> para manejar de forma segura todas las subclases. </p> <pre><code>fun procesarResultado(resultado: Resultado) {\n    when (resultado) {\n        is Resultado.Exito -&gt; println(\"Exito: ${resultado.mensaje}\")\n        is Resultado.Error -&gt; println(\"Error: ${resultado.mensaje}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>procesarResultado</code> que toma un par\u00e1metro de tipo <code>Resultado</code>. Dentro de la expresi\u00f3n <code>when</code>, se manejan de forma segura las subclases <code>Exito</code> y <code>Error</code> de la clase sellada <code>Resultado</code>.</p> <p>Las clases selladas son una forma segura y concisa de manejar un conjunto finito de subclases en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#ventajas-de-las-clases-selladas","title":"Ventajas de las clases selladas","text":"<ul> <li>Seguridad: Las clases selladas garantizan que todas las subclases se manejen de forma segura en un bloque <code>when</code>.</li> <li>Concisi\u00f3n: Las clases selladas permiten definir un conjunto finito de subclases de forma concisa y legible.</li> <li>Extensibilidad: Las clases selladas pueden tener subclases anidadas, lo que permite una mayor extensibilidad y modularidad en el c\u00f3digo.</li> </ul> <p>Las clases selladas son una caracter\u00edstica poderosa de Kotlin que te permite representar de forma segura un conjunto finito de subclases y manejarlas de forma concisa y legible en tu c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html","title":"Scope functions","text":""},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#scope-functions-en-kotlin","title":"Scope functions en Kotlin","text":"<p>En Kotlin, los scope functions son funciones que te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto. Estas funciones te permiten acceder a las propiedades y m\u00e9todos del objeto de forma m\u00e1s concisa y legible. </p> <p>Las scope functions en Kotlin son las siguientes: </p> <ul> <li><code>let</code></li> <li><code>run</code></li> <li><code>with</code></li> <li><code>apply</code></li> <li><code>also</code></li> </ul> <p>V\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#let","title":"<code>let</code>","text":"<p>La funci\u00f3n <code>let</code> te permite ejecutar un bloque de c\u00f3digo en el contexto de un objeto y devolver el resultado de la \u00faltima expresi\u00f3n del bloque. </p> <p>La funci\u00f3n <code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.let {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n    it.edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>let</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#run","title":"<code>run</code>","text":"<p>A diferencia de <code>let</code>, la funci\u00f3n <code>run</code> te permite acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</p> <p>La funci\u00f3n <code>run</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.run {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>run</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#with","title":"<code>with</code>","text":"<p>La funci\u00f3n <code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>with</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = with(persona) {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>with</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#apply","title":"<code>apply</code>","text":"<p>A diferencia de las funciones anteriores, la funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <p>La funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <pre><code>val resultado = persona?.apply {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad += 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>apply</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y modificar la edad increment\u00e1ndola en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#also","title":"<code>also</code>","text":"<p>La funci\u00f3n <code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>also</code> se utiliza para realizar operaciones en un objeto y devolver el objeto original.</p> <pre><code>val resultado = persona?.also {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>also</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver el objeto original.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#resumen","title":"Resumen","text":"<p>En resumen, las scope functions en Kotlin te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto y realizar operaciones en el objeto de forma m\u00e1s concisa y legible. Cada funci\u00f3n tiene un prop\u00f3sito espec\u00edfico y se utiliza en diferentes situaciones, dependiendo de tus necesidades. </p> <p>Podr\u00edamos decir que las diferencias generales son las siguientes:</p> <ul> <li><code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</li> <li><code>run</code> se utiliza para acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</li> <li><code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> <li><code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</li> <li><code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> </ul> <p>En la siguiente imagen se muestra un resumen visual de las diferencias entre las scope functions:</p> <p></p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html","title":"Arrays","text":""},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-en-kotlin","title":"Arrays en Kotlin","text":"<p>En Kotlin, puedes crear arrays utilizando la funci\u00f3n <code>arrayOf()</code>. Los arrays en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un array <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los arrays en Kotlin se crean utilizando la funci\u00f3n <code>arrayOf()</code> seguida de los valores del array entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#acceso-a-elementos-de-un-array","title":"Acceso a elementos de un array","text":"<p>Puedes acceder a elementos individuales de un array utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento del array <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#modificacion-de-elementos-de-un-array","title":"Modificaci\u00f3n de elementos de un array","text":"<p>Para modificar un elemento de un array, puedes utilizar el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas modificar.</p> <pre><code>numeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se modifica el primer elemento del array <code>numeros</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#iteracion-sobre-un-array","title":"Iteraci\u00f3n sobre un array","text":"<p>Puedes iterar sobre los elementos de un array utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del array <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-de-tipos-primitivos","title":"Arrays de tipos primitivos","text":"<p>En Kotlin, puedes utilizar arrays de tipos primitivos como <code>IntArray</code>, <code>DoubleArray</code>, <code>BooleanArray</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intArrayOf(1, 2, 3, 4, 5)\nval dobles = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanArrayOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean arrays de tipos primitivos <code>IntArray</code>, <code>DoubleArray</code> y <code>BooleanArray</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#operaciones-con-arrays","title":"Operaciones con arrays","text":"<p>Los arrays en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del array, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el array, <code>indexOf</code> para obtener el \u00edndice de un elemento en el array, etc.</p> <pre><code>val tama\u00f1o = numeros.size\nval contieneTres = numeros.contains(3)\nval indiceDeCuatro = numeros.indexOf(4)\n</code></pre> <p>En el ejemplo anterior, se obtiene el tama\u00f1o del array <code>numeros</code>, se comprueba si el array contiene el n\u00famero <code>3</code> y se obtiene el \u00edndice del n\u00famero <code>4</code> en el array.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html","title":"Listas","text":""},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-en-kotlin","title":"Listas en Kotlin","text":"<p>En Kotlin, puedes crear listas utilizando la funci\u00f3n <code>listOf()</code>. Las listas en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = listOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea una lista <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Las listas en Kotlin se crean utilizando la funci\u00f3n <code>listOf()</code> seguida de los valores de la lista entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#acceso-a-elementos-de-una-lista","title":"Acceso a elementos de una lista","text":"<p>Puedes acceder a elementos individuales de una lista utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento de la lista <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#iteracion-sobre-una-lista","title":"Iteraci\u00f3n sobre una lista","text":"<p>Puedes iterar sobre los elementos de una lista utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos de la lista <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-de-tipos-primitivos","title":"Listas de tipos primitivos","text":"<p>En Kotlin, puedes utilizar listas de tipos primitivos como <code>IntList</code>, <code>DoubleList</code>, <code>BooleanList</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intListOf(1, 2, 3, 4, 5)\nval dobles = doubleListOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanListOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean listas de tipos primitivos <code>IntList</code>, <code>DoubleList</code> y <code>BooleanList</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#modificacion-de-elementos-de-una-lista","title":"Modificaci\u00f3n de elementos de una lista","text":"<p>Las listas en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de una lista una vez que se ha creado. Si necesitas una lista mutable, puedes utilizar la funci\u00f3n <code>mutableListOf()</code>.</p> <pre><code>val numeros = mutableListOf(1, 2, 3, 4, 5)\nnumeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se crea una lista mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Se modifica el primer elemento de la lista asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#operaciones-comunes-con-listas","title":"Operaciones comunes con listas","text":"<p>Kotlin proporciona una serie de funciones de extensi\u00f3n para realizar operaciones comunes con listas, como <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>sortedBy()</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\nval suma = numeros.reduce { acc, numero -&gt; acc + numero }\nval ordenados = numeros.sortedBy { numero -&gt; numero }\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>map()</code>, <code>filter()</code>, <code>reduce()</code> y <code>sortedBy()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Est\u00e1s funciones hacen lo siguiente:</p> <ul> <li> <p><code>map()</code>: Aplica una funci\u00f3n a cada elemento de la lista y devuelve una nueva lista con los resultados.</p> </li> <li> <p><code>filter()</code>: Filtra los elementos de la lista que cumplen una condici\u00f3n dada y devuelve una nueva lista con los elementos filtrados.</p> </li> <li> <p><code>reduce()</code>: Combina los elementos de la lista en un solo valor utilizando una funci\u00f3n dada.</p> </li> <li> <p><code>sortedBy()</code>: Ordena los elementos de la lista en funci\u00f3n de una clave dada y devuelve una nueva lista ordenada.</p> </li> <li> <p><code>groupBy()</code>: Agrupa los elementos de la lista en funci\u00f3n de una clave dada y devuelve un mapa de claves y listas de elementos.</p> </li> </ul> <p>Otros ejemplos de operaciones comunes con listas son <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code>, <code>distinct()</code>, etc.</p> <pre><code>val suma = numeros.sum()\nval maximo = numeros.max()\nval minimo = numeros.min()\nval promedio = numeros.average()\nval unicos = numeros.distinct()\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code> y <code>distinct()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Su funcionalidad es la siguiente:</p> <ul> <li> <p><code>sum()</code>: Calcula la suma de los elementos de la lista.</p> </li> <li> <p><code>max()</code>: Devuelve el valor m\u00e1ximo de la lista.</p> </li> <li> <p><code>min()</code>: Devuelve el valor m\u00ednimo de la lista.</p> </li> <li> <p><code>average()</code>: Calcula el promedio de los elementos de la lista.</p> </li> <li> <p><code>distinct()</code>: Devuelve una nueva lista con los elementos \u00fanicos de la lista original.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/42-listas.html#funciones-de-extension-para-listas","title":"Funciones de extensi\u00f3n para listas","text":"<p>En Kotlin, puedes crear tus propias funciones de extensi\u00f3n para realizar operaciones espec\u00edficas con listas.</p> <pre><code>fun List&lt;Int&gt;.duplicar(): List&lt;Int&gt; {\n    return this.map { it * 2 }\n}\n\nval duplicados = numeros.duplicar()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>duplicar()</code> que duplica cada elemento de una lista de enteros. La funci\u00f3n de extensi\u00f3n se llama con la lista <code>numeros</code> y devuelve una nueva lista con los elementos duplicados.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html","title":"Maps","text":""},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-en-kotlin","title":"Maps en Kotlin","text":"<p>En Kotlin, un <code>Map</code> es una colecci\u00f3n de pares clave-valor donde cada clave est\u00e1 asociada a un valor. Los <code>Map</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = mapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Los <code>Map</code> en Kotlin se crean utilizando la funci\u00f3n <code>mapOf()</code> seguida de los pares clave-valor entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#acceso-a-elementos-de-un-map","title":"Acceso a elementos de un Map","text":"<p>Puedes acceder a elementos individuales de un <code>Map</code> utilizando la clave del elemento que deseas acceder.</p> <pre><code>val numeroUno = numeros[\"uno\"]\nval numeroDos = numeros[\"dos\"]\n</code></pre> <p>En el ejemplo anterior, se accede a los valores asociados a las claves <code>\"uno\"</code> y <code>\"dos\"</code> del <code>Map</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#iteracion-sobre-un-map","title":"Iteraci\u00f3n sobre un Map","text":"<p>Puedes iterar sobre los pares clave-valor de un <code>Map</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for ((clave, valor) in numeros) {\n    println(\"Clave: $clave, Valor: $valor\")\n}\n\nnumeros.forEach { (clave, valor) -&gt;\n    println(\"Clave: $clave, Valor: $valor\")\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los pares clave-valor del <code>Map</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-de-tipos-primitivos","title":"Maps de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Map</code> de tipos primitivos como <code>IntMap</code>, <code>DoubleMap</code>, <code>BooleanMap</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intMapOf(1 to \"uno\", 2 to \"dos\", 3 to \"tres\")\nval dobles = doubleMapOf(1.0 to \"uno\", 2.0 to \"dos\", 3.0 to \"tres\")\nval booleanos = booleanMapOf(true to \"verdadero\", false to \"falso\")\n</code></pre> <p>En el ejemplo anterior, se crean <code>Map</code> de tipos primitivos <code>IntMap</code>, <code>DoubleMap</code> y <code>BooleanMap</code> con pares clave-valor iniciales.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#modificacion-de-elementos-de-un-map","title":"Modificaci\u00f3n de elementos de un Map","text":"<p>Los <code>Map</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Map</code> una vez que se ha creado. Si necesitas un <code>Map</code> mutable, puedes utilizar la funci\u00f3n <code>mutableMapOf()</code>.</p> <pre><code>val numeros = mutableMapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\nnumeros[\"uno\"] = 10\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> mutable <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Se modifica el valor asociado a la clave <code>\"uno\"</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#operaciones-con-maps","title":"Operaciones con Maps","text":"<p>Los <code>Map</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code>, <code>filterValues()</code>, etc.</p> <pre><code>val valorUno = numeros.get(\"uno\")\nval contieneDos = numeros.containsKey(\"dos\")\nval contieneCinco = numeros.containsValue(5)\nval claves = numeros.keys\nval valores = numeros.values\nval numerosPares = numeros.filterKeys { clave -&gt; clave.length % 2 == 0 }\nval numerosImpares = numeros.filterValues { valor -&gt; valor % 2 != 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code> y <code>filterValues()</code> para realizar operaciones comunes con el <code>Map</code> <code>numeros</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>get()</code>: Obtiene el valor asociado a una clave.</li> <li><code>containsKey()</code>: Comprueba si una clave est\u00e1 presente en el <code>Map</code>.</li> <li><code>containsValue()</code>: Comprueba si un valor est\u00e1 presente en el <code>Map</code>.</li> <li><code>keys</code>: Obtiene las claves del <code>Map</code>.</li> <li><code>values</code>: Obtiene los valores del <code>Map</code>.</li> <li><code>filterKeys()</code>: Filtra los pares clave-valor del <code>Map</code> por las claves.</li> <li><code>filterValues()</code>: Filtra los pares clave-valor del <code>Map</code> por los valores.</li> </ul> <p>Los <code>Map</code> en Kotlin son una forma eficiente de almacenar y acceder a datos asociados a claves. Puedes utilizar <code>Map</code> para representar relaciones entre objetos y realizar operaciones comunes con ellos de forma sencilla y eficiente.</p> <p>Para m\u00e1s informaci\u00f3n sobre los <code>Map</code> en Kotlin, puedes consultar la documentaci\u00f3n oficial de Kotlin sobre Maps.`;</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html","title":"Sets","text":""},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-en-kotlin","title":"Sets en Kotlin","text":"<p>En Kotlin, un <code>Set</code> es una colecci\u00f3n de elementos \u00fanicos, lo que significa que no puede contener elementos duplicados. Los <code>Set</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = setOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los <code>Set</code> en Kotlin se crean utilizando la funci\u00f3n <code>setOf()</code> seguida de los valores del <code>Set</code> entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#acceso-a-elementos-de-un-set","title":"Acceso a elementos de un Set","text":"<p>Puedes acceder a elementos individuales de un <code>Set</code> utilizando la funci\u00f3n <code>contains()</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>.</p> <pre><code>val contieneTres = numeros.contains(3)\nval contieneSeis = numeros.contains(6)\n</code></pre> <p>En el ejemplo anterior, se comprueba si el <code>Set</code> <code>numeros</code> contiene los elementos <code>3</code> y <code>6</code> utilizando la funci\u00f3n <code>contains()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#iteracion-sobre-un-set","title":"Iteraci\u00f3n sobre un Set","text":"<p>Puedes iterar sobre los elementos de un <code>Set</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del <code>Set</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-de-tipos-primitivos","title":"Sets de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Set</code> de tipos primitivos como <code>IntSet</code>, <code>DoubleSet</code>, <code>BooleanSet</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intSetOf(1, 2, 3, 4, 5)\nval dobles = doubleSetOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanSetOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean <code>Set</code> de tipos primitivos <code>IntSet</code>, <code>DoubleSet</code> y <code>BooleanSet</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#modificacion-de-elementos-de-un-set","title":"Modificaci\u00f3n de elementos de un Set","text":"<p>Los <code>Set</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Set</code> una vez que se ha creado. Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code>.</p> <pre><code>val numeros = mutableSetOf(1, 2, 3, 4, 5)\nnumeros.add(6)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code> y se a\u00f1ade el valor <code>6</code> al <code>Set</code> utilizando la funci\u00f3n <code>add()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#operaciones-con-sets","title":"Operaciones con Sets","text":"<p>Los <code>Set</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del <code>Set</code>, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>, <code>union</code> para unir dos <code>Set</code>, <code>intersect</code> para obtener la intersecci\u00f3n de dos <code>Set</code>, etc.</p> <pre><code>val numerosPares = setOf(2, 4, 6, 8, 10)\nval numerosImpares = setOf(1, 3, 5, 7, 9)\n\nval union = numeros.union(numerosPares)\nval interseccion = numeros.intersect(numerosImpares)\nval diferencia = numeros.subtract(numerosPares)\nval diferenciaSimetrica = numeros.symmetricDifference(numerosPares)\nval contieneTodos = numeros.containsAll(numerosPares)\nval contieneAlguno = numeros.containsAny(numerosPares)\nval esSubconjunto = numeros.isSubset(numerosPares)\nval esSuperconjunto = numeros.isSuperset(numerosPares)\nval esDisjunto = numeros.isDisjoint(numerosPares)\nval esVacio = numeros.isEmpty()\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>union()</code> e <code>intersect()</code> para realizar operaciones comunes con los <code>Set</code> <code>numeros</code>, <code>numerosPares</code> y <code>numerosImpares</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>union()</code>: Devuelve un <code>Set</code> que contiene todos los elementos de los dos <code>Set</code>.</li> <li><code>intersect()</code>: Devuelve un <code>Set</code> que contiene los elementos comunes de los dos <code>Set</code>.</li> <li><code>subtract()</code>: Devuelve un <code>Set</code> que contiene los elementos del primer <code>Set</code> que no est\u00e1n en el segundo <code>Set</code>.</li> <li><code>symmetricDifference()</code>: Devuelve un <code>Set</code> que contiene los elementos que est\u00e1n en uno de los <code>Set</code> pero no en ambos.</li> <li><code>containsAll()</code>: Comprueba si un <code>Set</code> contiene todos los elementos de otro <code>Set</code>.</li> <li><code>containsAny()</code>: Comprueba si un <code>Set</code> contiene al menos un elemento de otro <code>Set</code>.</li> <li><code>isSubset()</code>: Comprueba si un <code>Set</code> es un subconjunto de otro <code>Set</code>.</li> <li><code>isSuperset()</code>: Comprueba si un <code>Set</code> es un superconjunto de otro <code>Set</code>.</li> <li><code>isDisjoint()</code>: Comprueba si dos <code>Set</code> son disjuntos, es decir, si no tienen elementos en com\u00fan.</li> <li><code>isEmpty()</code>: Comprueba si un <code>Set</code> est\u00e1 vac\u00edo.</li> </ul> <p>Los <code>Set</code> en Kotlin son una forma eficiente de almacenar y manipular colecciones de elementos \u00fanicos. Puedes utilizar las operaciones proporcionadas por los <code>Set</code> para realizar operaciones comunes, como unir, intersecar, restar y comparar <code>Set</code> entre s\u00ed.</p> <p>Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code> para crear un <code>Set</code> que puedas modificar. Los <code>Set</code> en Kotlin son una herramienta poderosa que te permite trabajar con colecciones de elementos \u00fanicos de forma eficiente y concisa.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html","title":"Corrutinas en Kotlin","text":""},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#corrutinas-en-kotlin","title":"Corrutinas en Kotlin","text":"<p>Las corrutinas son una caracter\u00edstica de Kotlin que permite escribir c\u00f3digo as\u00edncrono de manera m\u00e1s sencilla y legible. Las corrutinas son funciones que pueden suspenderse y reanudarse en un punto determinado, lo que permite realizar operaciones as\u00edncronas sin bloquear el hilo principal.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-sincrono","title":"C\u00f3digo s\u00edncrono","text":"<p>El c\u00f3digo s\u00edncrono es el c\u00f3digo que se ejecuta de manera secuencial, es decir, una instrucci\u00f3n se ejecuta despu\u00e9s de que la anterior haya terminado. En Kotlin, el c\u00f3digo s\u00edncrono se ejecuta en el hilo principal de la aplicaci\u00f3n.    </p> <pre><code>fun main() {\n    val resultado = obtenerDatos()\n    println(\"Datos: $resultado\")\n}\nfun obtenerDatos(): String {\n    Thread.sleep(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n s\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> llama a la funci\u00f3n <code>obtenerDatos</code> y espera a que se complete antes de imprimir los datos obtenidos.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-asincrono","title":"C\u00f3digo as\u00edncrono","text":"<p>El c\u00f3digo as\u00edncrono es el c\u00f3digo que se ejecuta de manera concurrente, es decir, varias instrucciones se pueden ejecutar al mismo tiempo. En Kotlin, el c\u00f3digo as\u00edncrono se puede escribir utilizando corrutinas.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#los-metodos-launch-y-async","title":"Los m\u00e9todos launch y async","text":"<p>En Kotlin, las funciones <code>launch</code> y <code>async</code> se utilizan para crear corrutinas. </p> <p>La principal diferencia entre ellas es que <code>launch</code> se utiliza para ejecutar una corrutina que no devuelve un valor, mientras que <code>async</code> se utiliza para ejecutar una corrutina que devuelve un valor.  </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n\nsuspend fun main() {\n    launch { obtenerDatos() }\n    println(\"Datos obtenidos\")\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. En el segundo ejemplo, se utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina sin esperar a que se complete.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#excepciones","title":"Excepciones","text":"<p>En Kotlin, las corrutinas pueden lanzar excepciones que se pueden manejar utilizando bloques <code>try-catch</code>. Las excepciones lanzadas en una corrutina se propagan a la corrutina padre y se pueden manejar en el hilo principal.  </p> <pre><code>suspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse y lanza una excepci\u00f3n. La funci\u00f3n <code>main</code> utiliza un bloque <code>try-catch</code> para manejar la excepci\u00f3n lanzada en la corrutina.</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin: La documentaci\u00f3n oficial de Kotlin sobre corrutinas, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar corrutinas en Kotlin.</li> </ul> <p>La importancia de controlar las excepciones al usar corrutinas</p> <p>Cuando se utilizan corrutinas en Kotlin, es importante controlar las excepciones que se pueden producir durante la ejecuci\u00f3n de la aplicaci\u00f3n. Las excepciones no controladas pueden provocar fallos en la aplicaci\u00f3n y afectar negativamente la experiencia del usuario.   </p> <p>Por lo tanto, es importante utilizar bloques <code>try-catch</code> para manejar las excepciones que se pueden producir en las corrutinas. Adem\u00e1s, es recomendable utilizar la funci\u00f3n <code>CoroutineExceptionHandler</code> para manejar las excepciones que se producen en las corrutinas de manera global.</p> <pre><code>val exceptionHandler = CoroutineExceptionHandler { _, exception -&gt;\n    println(\"Error: ${exception.message}\")\n}\n\nsuspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}   \n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#cancelacion","title":"Cancelaci\u00f3n","text":"<p>En Kotlin, las corrutinas se pueden cancelar utilizando la funci\u00f3n <code>cancel()</code>. La cancelaci\u00f3n de una corrutina no detiene inmediatamente su ejecuci\u00f3n, sino que la marca como cancelada y permite que se complete de manera segura. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        try {\n            obtenerDatos()\n        } catch (e: CancellationException) {\n            println(\"Corrutina cancelada\")\n        }\n    }\n    delay(500)\n    job.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. Si la corrutina es cancelada, se lanza una excepci\u00f3n <code>CancellationException</code> que se puede manejar en el bloque <code>try-catch</code>.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#la-clase-job","title":"La clase Job","text":"<p>En Kotlin, la clase <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un <code>Job</code> representa una unidad de trabajo que se puede cancelar y supervisar. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        obtenerDatos()\n    }\n    delay(500)\n    job.cancel()\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. </p> <p>El objeto <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de la corrutina y se puede utilizar para supervisar su estado. </p> <p>La importancia de Job</p> <p>Job desempe\u00f1a un papel importante para garantizar la simultaneidad estructurada, ya que administra el ciclo de vida de las corrutinas y mantiene la relaci\u00f3n de superior y secundario.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#jerarquia-de-trabajos","title":"Jerarqu\u00eda de trabajos","text":"<p>En Kotlin, la jerarqu\u00eda de trabajos se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un trabajo (Job) representa una unidad de trabajo que se puede cancelar y supervisar. Los trabajos se pueden organizar en una jerarqu\u00eda para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente. </p> <pre><code>suspend fun main() {\n    val parentJob = Job()\n    val childJob1 = Job(parentJob)\n    val childJob2 = Job(parentJob)\n\n    launch(childJob1) {\n        obtenerDatos()\n    }\n    launch(childJob2) {\n        obtenerDatos()\n    }\n\n    delay(500)\n    parentJob.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> crea un trabajo padre y dos trabajos secundarios que se ejecutan en paralelo. Despu\u00e9s de 500 milisegundos, se cancela el trabajo padre utilizando la funci\u00f3n <code>cancel()</code>, lo que cancela todos los trabajos secundarios.</p> <p></p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinescope","title":"CoroutineScope","text":"<p>En Kotlin, el <code>CoroutineScope</code> es una interfaz que define un \u00e1mbito para las corrutinas. </p> <p>Un <code>CoroutineScope</code> se utiliza para crear y gestionar corrutinas en una aplicaci\u00f3n. </p> <pre><code>class MyCoroutineScope : CoroutineScope {\n    private val job = Job()\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + job\n\n    fun cancel() {\n        job.cancel()\n    }\nsuspend fun main() {\n    val scope = MyCoroutineScope()\n    scope.launch {\n        obtenerDatos()\n    }\n    delay(500)\n    scope.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>MyCoroutineScope</code> que implementa la interfaz <code>CoroutineScope</code>. La clase <code>MyCoroutineScope</code> define un \u00e1mbito para las corrutinas utilizando la propiedad <code>coroutineContext</code>, que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>. La clase tambi\u00e9n incluye una funci\u00f3n <code>cancel()</code> que cancela todas las corrutinas en el \u00e1mbito. En la funci\u00f3n <code>main</code>, se crea una instancia de <code>MyCoroutineScope</code> y se utiliza para ejecutar una corrutina que llama a la funci\u00f3n <code>obtenerDatos</code>. Despu\u00e9s de 500 milisegundos, se cancela el \u00e1mbito utilizando la funci\u00f3n <code>cancel()</code>.  </p> <p>launch y async en CoroutineScope</p> <p>launch() y async() son funciones de extension de la interfaz <code>CoroutineScope</code> que se utilizan para crear corrutinas en un \u00e1mbito determinado. La funci\u00f3n <code>launch()</code> se utiliza para crear una corrutina que no devuelve un valor, mientras que la funci\u00f3n <code>async()</code> se utiliza para crear una corrutina que devuelve un valor. Ambas funciones se pueden utilizar en un \u00e1mbito de <code>CoroutineScope</code> para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinecontext","title":"CoroutineContext","text":"<p>En Kotlin, el <code>CoroutineContext</code> es una interfaz que define el contexto en el que se ejecuta una corrutina. </p> <p>Un <code>CoroutineContext</code> se utiliza para definir el despachador, la supervisi\u00f3n y otros elementos del contexto de una corrutina. </p> <p>Es en esencia un mapa que almacena pares clave-valor que se utilizan para definir el contexto de una corrutina. </p> <p>Estos campos no son obligatorios pero algunos de los m\u00e1s comunes son: - <code>Job</code>: Un objeto que representa una unidad de trabajo que se puede cancelar y supervisar. - <code>CoroutineName</code>: Un objeto que representa el nombre de una corrutina. - <code>CoroutineExceptionHandler</code>: Un objeto que maneja las excepciones que se producen en una corrutina.  - <code>Dispatcher</code>: Un objeto que define en qu\u00e9 hilo o grupo de hilos se ejecuta la corrutina. </p> <pre><code>suspend fun main() {\n    val context = Dispatchers.Main + Job()\n    withContext(context) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>.  </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinedispatcher","title":"CoroutineDispatcher","text":"<p>En Kotlin, el <code>CoroutineDispatcher</code> es una interfaz que define el despachador de una corrutina. </p> <p>Un <code>CoroutineDispatcher</code> se utiliza para definir en qu\u00e9 hilo o grupo de hilos se ejecuta una corrutina. </p> <p>Puede utilizar los despachadores predefinidos de Kotlin, como <code>Dispatchers.Main</code>, <code>Dispatchers.IO</code> y <code>Dispatchers.Default</code>, o crear un despachador personalizado.</p> <p>Para crear uno personalizado se puede utilizar la clase <code>ExecutorCoroutineDispatcher</code> de Kotlin. </p> <pre><code>suspend fun main() {\n    val dispatcher = Dispatchers.IO\n    withContext(dispatcher) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que utiliza el despachador <code>Dispatchers.IO</code>.  </p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html","title":"Corrutinas","text":""},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#corrutinas-en-kotlin","title":"Corrutinas en Kotlin","text":"<p>Si alguna vez has sentido que las corrutinas son complicadas, \u00a1no te preocupes! En realidad, son una herramienta fant\u00e1stica para hacer varias cosas a la vez sin que tu aplicaci\u00f3n se congele.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#1-que-es-una-corrutina-la-analogia-del-camarero","title":"1. \u00bfQu\u00e9 es una Corrutina? (La Analog\u00eda del Camarero)","text":"<p>Imagina un restaurante. - El Hilo Principal (Main Thread) es el \u00daNICO camarero que atiende las mesas. - Las Tareas son los pedidos de los clientes.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#sin-corrutinas-bloqueo","title":"Sin Corrutinas (Bloqueo)","text":"<p>Si un cliente pide un caf\u00e9 y el camarero se va a la cocina, se queda all\u00ed parado mirando la cafetera hasta que el caf\u00e9 est\u00e1 listo (5 minutos). Durante esos 5 minutos, nadie m\u00e1s es atendido. Los nuevos clientes se enfadan (la app se congela y sale el aviso de \"La aplicaci\u00f3n no responde\").</p> Pseudoc\u00f3digo Bloqueante (Malo)<pre><code>fun main() {\n    atenderMesa1() // Llega cliente mesa 1\n    // ... esperando ...\n    // \u00a1EL CAMARERO SE QUEDA PARADO EN LA COCINA! (Bloqueo)\n    // ... esperando ...\n    // Mesa 2 intenta llamar al camarero pero nadie responde (ANR)\n    servirMesa1()\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#con-corrutinas-no-bloqueo","title":"Con Corrutinas (No bloqueo)","text":"<p>El camarero toma el pedido del caf\u00e9, lo pasa a la cocina (lanza una corrutina) y vuelve inmediatamente a atender a otras mesas. Cuando la cocina avisa \"\u00a1Caf\u00e9 listo!\", el camarero lo recoge y lo sirve. \u00a1El camarero siempre est\u00e1 disponible!</p> Pseudoc\u00f3digo con Corrutinas (Bueno)<pre><code>fun main() {\n    launch { // \"Lanzamos\" la tarea en segundo plano\n        tomarPedidoMesa1()\n        suspend esperarCocina() // \u00a1PAUSA! El camarero se va a hacer otras cosas\n        // ... (5 minutos despu\u00e9s) ...\n        // La cocina avisa, el camarero vuelve y retoma aqu\u00ed\n        servirMesa1()\n    }\n\n    atenderMesa2() // \u00a1El camarero puede atender a la mesa 2 inmediatamente!\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#2-corrutinas-vs-hilos-threads","title":"2. Corrutinas vs Hilos (Threads)","text":"<p>A veces se confunden, pero hay una gran diferencia: el peso.</p> <ul> <li>Hilos (Threads): Son pesados. Cada hilo consume mucha memoria RAM del sistema. Crear uno nuevo es costoso. Si intentas crear 100.000 hilos, tu ordenador probablemente colapsar\u00e1 (Out of Memory).</li> <li>Corrutinas: Son lig\u00e9risimas. Puedes crear 100.000 corrutinas y a tu ordenador ni le importar\u00e1. Son como \"hilos virtuales\" que viven dentro de los hilos reales.</li> </ul> <p>Resumen: Las corrutinas son mucho m\u00e1s eficientes y baratas que los hilos tradicionales.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#3-funciones-de-suspension-suspend-fun","title":"3. Funciones de suspensi\u00f3n (<code>suspend fun</code>)","text":"<p>Una funci\u00f3n <code>suspend</code> es una funci\u00f3n con un superpoder: puede pausarse y reanudarse.</p> <p>Cuando llamas a una funci\u00f3n <code>suspend</code> (como <code>delay(1000)</code> o una petici\u00f3n a internet), la corrutina se \"pausa\" sin bloquear al hilo principal. El hilo queda libre para hacer otras cosas (pintar la pantalla, responder a clics). Cuando la operaci\u00f3n termina, la corrutina se \"despierta\" y contin\u00faa donde se qued\u00f3.</p> <pre><code>suspend fun pedirDatosAInternet(): String {\n    delay(2000) // Simula espera de 2 segundos. \u00a1No bloquea el hilo!\n    return \"Datos recibidos\"\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#4-builders-como-arranco-una-corrutina","title":"4. Builders: \u00bfC\u00f3mo arranco una corrutina?","text":"<p>Hay dos formas principales de iniciar una corrutina:</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#a-launch-lanzar-y-olvidar","title":"A. <code>launch</code>: \"Lanzar y olvidar\"","text":"<p>Lo usas cuando quieres hacer algo y no necesitas que te devuelva un dato directamente (o el resultado no afecta al flujo inmediato). Ejemplos: Escribir un log en un archivo, mandar una anal\u00edtica, guardar una preferencia.</p> <pre><code>scope.launch {\n    guardarEnBaseDeDatos(usuario)\n    println(\"Usuario guardado\")\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#b-async-pedir-y-esperar-resultado","title":"B. <code>async</code>: \"Pedir y esperar resultado\"","text":"<p>Lo usas cuando necesitas un valor de vuelta. <code>async</code> devuelve un <code>Deferred</code> (una promesa de que tendr\u00e1s un dato en el futuro). Usas <code>.await()</code> para obtener ese dato.</p> <pre><code>scope.launch {\n    // Pedimos dos cosas a la vez (paralelo)\n    val climaDeferred = async { obtenerClima() }\n    val noticiasDeferred = async { obtenerNoticias() }\n\n    // Esperamos a tener ambos\n    val clima = climaDeferred.await()\n    val noticias = noticiasDeferred.await()\n\n    mostrarEnPantalla(clima, noticias)\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#5-dispatchers-donde-se-ejecuta-el-trabajo","title":"5. Dispatchers: \u00bfD\u00d3NDE se ejecuta el trabajo?","text":"<p>Es crucial elegir el <code>Dispatcher</code> (Despachador) correcto para no congelar la app. Imagina que son \"carriles\" o \"departamentos\".</p> Dispatcher Uso Correcto Ejemplo Dispatchers.Main Interfaz de Usuario (UI). Solo operaciones r\u00e1pidas y ligeras. Actualizar un TextView, mostrar un Toast, animaciones. Dispatchers.IO Entrada/Salida (Input/Output). Operaciones largas que esperan datos. Leer/Escribir archivos, Bases de Datos (Room), Peticiones de Red (Retrofit). Dispatchers.Default Procesamiento CPU. Operaciones complejas de c\u00e1lculo. Procesar una imagen grande, ordenar una lista gigante, calcular algoritmos complejos. <p>Ejemplo de cambio de contexto (<code>withContext</code>):</p> <pre><code>scope.launch(Dispatchers.Main) { // 1. Empezamos en el Hilo Principal (UI)\n    mostrarCargando() \n\n    val datos = withContext(Dispatchers.IO) { // 2. Nos mudamos al hilo IO para lo pesado\n        descargarDatosDeInternet() // Esto tarda, pero no bloquea la UI\n    }\n\n    ocultarCargando() // 3. Volvemos autom\u00e1ticamente al Main\n    mostrarDatos(datos)\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#6-scopes-el-ciclo-de-vida","title":"6. Scopes: El ciclo de vida","text":"<p>Las corrutinas necesitan un \"due\u00f1o\" o un \u00e1mbito (<code>Scope</code>) para vivir. Si el due\u00f1o muere, las corrutinas deben cancelarse para no dejar basura memoria (\"zombies\").</p> <p>En Android, usamos los que ya nos dan hechos:</p> <ul> <li><code>lifecycleScope</code> (en Activities/Fragments): Las corrutinas mueren cuando se destruye la Activity/Fragment.</li> <li><code>viewModelScope</code> (en ViewModels): Las corrutinas mueren cuando se limpia el ViewModel. (El m\u00e1s usado).</li> </ul>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#7-ejemplos-realistas","title":"7. Ejemplos Realistas","text":""},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#caso-a-login-de-usuario-viewmodel","title":"Caso A: Login de Usuario (ViewModel)","text":"<pre><code>class LoginViewModel : ViewModel() {\n\n    fun realizarLogin(user: String, pass: String) {\n        // Usamos viewModelScope. Se ejecuta en Main por defecto\n        viewModelScope.launch {\n            try {\n                mostrarSpinner(true) // UI (Main)\n\n                // Nos vamos a IO para la red\n                val resultado = withContext(Dispatchers.IO) {\n                    apiService.login(user, pass)\n                }\n\n                // Volvemos a Main\n                if (resultado.isExitoso) {\n                    navegarAHome()\n                } else {\n                    mostrarError(\"Login incorrecto\")\n                }\n\n            } catch (e: Exception) {\n                mostrarError(\"Error de red: ${e.message}\")\n            } finally {\n                mostrarSpinner(false) // UI (Main)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#caso-b-cargar-datos-de-base-de-datos-room","title":"Caso B: Cargar datos de Base de Datos (Room)","text":"<pre><code>// En un repositorio o ViewModel\nfun cargarNotas() {\n    viewModelScope.launch(Dispatchers.IO) { // Empezamos directo en IO\n        val notas = database.notaDao().getAll()\n\n        // Si necesitamos pintar esto, cambiamos a Main\n        withContext(Dispatchers.Main) {\n            adapter.setNotas(notas)\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#resumen-rapido","title":"Resumen R\u00e1pido","text":"<ol> <li><code>suspend</code>: Pausa sin bloquear.</li> <li><code>Main</code>: Para pintar (UI).</li> <li><code>IO</code>: Para esperar (Red/DB).</li> <li><code>Default</code>: Para pensar (C\u00e1lculos CPU).</li> <li><code>viewModelScope</code>: Tu mejor amigo en Android para lanzar corrutinas.</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html","title":"Gradle","text":""},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#gradle-agp-y-estructura-de-proyecto-en-android","title":"Gradle, AGP y Estructura de Proyecto en Android","text":"<p>Como desarrollador Android moderno, entender Gradle y la estructura de tu proyecto es tan importante como saber Kotlin. No es solo \"magia\" que hace que el bot\u00f3n de Play funcione; es el motor que compila, prueba y empaqueta tu aplicaci\u00f3n.</p> <p>En este documento, desmitificaremos estos conceptos y veremos c\u00f3mo se organiza un proyecto profesional hoy en d\u00eda.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#1-que-son-gradle-y-agp","title":"1. \u00bfQu\u00e9 son Gradle y AGP?","text":"<p>A menudo se confunden, pero son cosas distintas que trabajan juntas.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#gradle-el-motor-de-construccion","title":"Gradle: El Motor de Construcci\u00f3n","text":"<p>Gradle es un sistema de automatizaci\u00f3n de compilaci\u00f3n de c\u00f3digo abierto. Es agn\u00f3stico a la plataforma; se usa para Java, C++, Python, etc. Piensa en Gradle como un gestor de tareas muy potente. Sabe c\u00f3mo: - Descargar librer\u00edas de internet. - Compilar c\u00f3digo fuente. - Ejecutar pruebas. - Empaquetar resultados.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#agp-android-gradle-plugin-el-copiloto","title":"AGP (Android Gradle Plugin): El Copiloto","text":"<p>Gradle por s\u00ed solo no sabe qu\u00e9 es un APK o un AndroidManifest. Aqu\u00ed entra el Android Gradle Plugin (AGP). AGP es un plugin que se \"enchufa\" a Gradle y le ense\u00f1a c\u00f3mo construir aplicaciones Android espec\u00edficamente. Le dice a Gradle: \"Hey, estos archivos <code>.xml</code> son recursos y deben procesarse as\u00ed\", o \"Este c\u00f3digo Kotlin debe convertirse en bytecode Dalvik\".</p> <p>Gradle Wrapper</p> <p>En tu proyecto ver\u00e1s archivos <code>gradlew</code> (Linux/Mac) y <code>gradlew.bat</code> (Windows). Este es el Wrapper. Siempre usa el wrapper (<code>./gradlew build</code>) en lugar de instalar Gradle globalmente. Esto garantiza que todo el equipo (y el servidor de integraci\u00f3n continua) use exactamente la misma versi\u00f3n de Gradle definida en <code>gradle/wrapper/gradle-wrapper.properties</code>.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#2-estructura-de-un-proyecto-moderno","title":"2. Estructura de un Proyecto Moderno","text":"<p>Cuando abres Android Studio, por defecto ves la vista \"Android\", que colapsa y organiza los archivos l\u00f3gicamente. Sin embargo, para entender la estructura real, a veces es \u00fatil cambiar a la vista \"Project\".</p> <p>Un proyecto moderno tiene (principalmente) dos niveles de configuraci\u00f3n: Proyecto (Root) y M\u00f3dulo (Module).</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#archivos-de-configuracion-clave","title":"Archivos de Configuraci\u00f3n Clave","text":"Archivo Nivel Prop\u00f3sito <code>settings.gradle.kts</code> Root Define qu\u00e9 m\u00f3dulos componen la app y de d\u00f3nde sacar los plugins. Se ejecuta primero. <code>build.gradle.kts</code> Root Configuraci\u00f3n global para todos los m\u00f3dulos (limpieza, plugins comunes). Suele estar casi vac\u00edo ahora. <code>build.gradle.kts</code> M\u00f3dulo (:app) La configuraci\u00f3n espec\u00edfica de tu app: versiones de SDK, dependencias, firma, etc. <code>libs.versions.toml</code> Gradle Version Catalog. El lugar centralizado para definir versiones y librer\u00edas. <code>local.properties</code> Root Configuraci\u00f3n local de TU m\u00e1quina (ruta del SDK, claves secretas). Nunca se sube a Git."},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#3-gestion-de-dependencias-version-catalogs","title":"3. Gesti\u00f3n de Dependencias: Version Catalogs","text":"<p>Desde hace poco, el est\u00e1ndar recomendado es usar Version Catalogs. En lugar de escribir versiones \"a fuego\" en cada <code>build.gradle.kts</code>, las definimos en un archivo TOML: <code>gradle/libs.versions.toml</code>.</p> <p>Este archivo act\u00faa como un inventario centralizado de todos los \"ingredientes\" (librer\u00edas y plugins) que usa tu app.</p> <p>Estructura de <code>libs.versions.toml</code>: </p><pre><code>[versions]\n# 1. Aqu\u00ed definimos los N\u00daMEROS de las versiones\nkotlin = \"1.9.0\"\ncoreKtx = \"1.10.1\"\nretrofit = \"2.9.0\"\n\n[libraries]\n# 2. Aqu\u00ed definimos las LIBRER\u00cdAS (Ingredientes b\u00e1sicos)\n# Formato: grupo:nombre:versi\u00f3n\n# 'version.ref' apunta a una variable definida arriba en [versions]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nretrofit-gson = { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"retrofit\" }\n\n[bundles]\n# 3. (Opcional) Aqu\u00ed agrupamos librer\u00edas que siempre van juntas\n# Por ejemplo, para usar Retrofit siempre necesitas el core y un convertidor\nnetworking = [\"retrofit\", \"retrofit-gson\"]\n\n[plugins]\n# 4. Aqu\u00ed definimos los PLUGINS (Herramientas de construcci\u00f3n)\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\n</code></pre><p></p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#ejemplo-practico-como-anado-una-libreria-nueva","title":"Ejemplo Pr\u00e1ctico: \u00bfC\u00f3mo a\u00f1ado una librer\u00eda nueva?","text":"<p>Imagina que quieres a\u00f1adir Coil o Glide para cargar im\u00e1genes desde internet.</p> <p>Paso 1: Buscar la coordenada Maven Buscas en Google \"Coil android library\" y encuentras que la \u00faltima versi\u00f3n es <code>2.4.0</code> y la coordenada es <code>io.coil-kt:coil:2.4.0</code>.</p> <p>Paso 2: A\u00f1adir al cat\u00e1logo (<code>libs.versions.toml</code>) Editas el archivo <code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\n...\ncoil = \"2.4.0\" # &lt;--- A\u00f1ades la versi\u00f3n\n\n[libraries]\n...\ncoil = { group = \"io.coil-kt\", name = \"coil\", version.ref = \"coil\" } # &lt;--- Defines la librer\u00eda\n</code></pre> <p>Paso 3: Sincronizar (Sync Gradle)</p> <p>Aparecer\u00e1 una barrita amarilla en Android Studio: \"Sync Now\". P\u00falsala. Esto hace que Gradle lea el nuevo cat\u00e1logo y genere las referencias.</p> <p>Paso 4: Usar en tu m\u00f3dulo (<code>app/build.gradle.kts</code>)</p> <p>Ahora vas a tu archivo de construcci\u00f3n y lo a\u00f1ades. Gracias al cat\u00e1logo, \u00a1tendr\u00e1s autocompletado!</p> <pre><code>dependencies {\n    // ... otras dependencias\n    implementation(libs.coil)\n}\n</code></pre> <p>\u00a1Y listo! Si ma\u00f1ana sale la versi\u00f3n <code>2.5.0</code> de Coil, solo tienes que cambiar el n\u00famero en <code>[versions]</code> del archivo TOML, y se actualizar\u00e1 en todos los m\u00f3dulos que lo usen.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#el-concepto-de-bom-bill-of-materials","title":"El concepto de BOM (Bill of Materials)","text":"<p>En ecosistemas complejos como Jetpack Compose o Firebase, hay muchas librer\u00edas peque\u00f1as (ui, material3, tooling, foundation...) que se actualizan independientemente pero que deben usarse en versiones compatibles entre s\u00ed. Gestionar esto a mano es una pesadilla.</p> <p>Para solucionar esto existe el BOM (Bill of Materials).</p> <p>El BOM es una \"super-librer\u00eda\" vac\u00eda que solo contiene una lista de versiones recomendadas que funcionan bien juntas. Cuando usas un BOM, no indicas la versi\u00f3n de las librer\u00edas individuales; Gradle mira el BOM para saber qu\u00e9 versi\u00f3n usar.</p> <p>Ejemplo con Compose:</p> <ol> <li>En <code>libs.versions.toml</code> defines el BOM con versi\u00f3n, y las librer\u00edas sin versi\u00f3n.</li> </ol> <pre><code>[versions]\ncomposeBom = \"2023.08.00\"\n\n[libraries]\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\n\n# F\u00edjate que aqu\u00ed NO hay 'version.ref'\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n</code></pre> <ol> <li>En <code>build.gradle.kts</code> importas el BOM como <code>platform</code> y luego las librer\u00edas.</li> </ol> <pre><code>dependencies {\n    // Importamos la PLATAFORMA (el BOM)\n    implementation(platform(libs.androidx.compose.bom))\n\n    // Importamos las librer\u00edas sin preocuparnos de la versi\u00f3n\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.material3)\n}\n</code></pre> <p>Esto garantiza que si actualizas el BOM a <code>2023.10.00</code>, todas las librer\u00edas de Compose se actualizar\u00e1n autom\u00e1ticamente a las versiones probadas y compatibles de esa release.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#que-librerias-funcionan-con-bom","title":"\u00bfQu\u00e9 librer\u00edas funcionan con BOM?","text":"<p>No todas las librer\u00edas tienen BOM.</p> <p>El BOM se usa principalmente en ecosistemas grandes donde hay m\u00faltiples m\u00f3dulos que deben coordinarse.</p> <ul> <li> <p>S\u00cd suelen tener BOM:</p> <ul> <li>Jetpack Compose: (<code>androidx.compose:compose-bom</code>) Porque tiene ui, foundation, material, animation, etc.</li> <li>Firebase: (<code>com.google.firebase:firebase-bom</code>) Porque tiene auth, firestore, analytics, crashlytics, etc.</li> <li>OkHttp / Retrofit: A veces ofrecen BOM para gestionar sus familias de dependencias.</li> <li>AWS Amplify: Otro ecosistema gigante.</li> </ul> </li> <li> <p>NO suelen tener BOM:</p> <ul> <li>Librer\u00edas individuales como Glide, Coil, Lottie, Room (aunque es parte de Jetpack, suele versionarse sola o seguir el ciclo de core).</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#como-se-si-una-libreria-tiene-bom","title":"\u00bfC\u00f3mo s\u00e9 si una librer\u00eda tiene BOM?","text":"<p>No hay una \"regla m\u00e1gica\", pero aqu\u00ed tienes 3 formas de saberlo:</p> <ol> <li>Documentaci\u00f3n Oficial (La mejor): Cuando vas a la p\u00e1gina de \"Setup\" o \"Install\" de Compose o Firebase, lo primero que te recomiendan es usar el BOM. Si la documentaci\u00f3n te da directamente la l\u00ednea <code>implementation(\"com.example:lib:1.0.0\")</code>, es que probablemente no tenga BOM.</li> <li>Maven Repository: Si buscas la librer\u00eda en Maven Central, a veces ver\u00e1s un artefacto que termina en <code>-bom</code> (ej. <code>compose-bom</code>).</li> <li>El sentido com\u00fan: Si la librer\u00eda es \"una sola cosa\" (ej. un calendario), no necesita BOM. Si es una \"plataforma\" (ej. Firebase), seguramente lo tenga.</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#resumen-mezclando-todo-en-un-mismo-proyecto","title":"Resumen: Mezclando todo en un mismo proyecto","text":"<p>En un proyecto real, siempre tendr\u00e1s una mezcla de ambas cosas. No hay conflicto, simplemente se declaran diferente en el cat\u00e1logo y se importan diferente en el <code>build.gradle.kts</code>.</p> <p>Escenario Real: Una app que usa Jetpack Compose (BOM), Firebase (BOM) y Retrofit (Normal/Sin BOM).</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#1-libsversionstoml","title":"1. <code>libs.versions.toml</code>","text":"<pre><code>[versions]\n# --- Versiones para BOMs ---\ncomposeBom = \"2023.08.00\"\nfirebaseBom = \"32.2.0\"\n\n# --- Versiones para Librer\u00edas Normales ---\nretrofit = \"2.9.0\"\ncoil = \"2.4.0\"\n\n[libraries]\n# --- BOMs ---\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nfirebase-bom = { group = \"com.google.firebase\", name = \"firebase-bom\", version.ref = \"firebaseBom\" }\n\n# --- Librer\u00edas DENTRO del BOM (SIN versi\u00f3n) ---\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nfirebase-analytics = { group = \"com.google.firebase\", name = \"firebase-analytics\" }\n\n# --- Librer\u00edas NORMALES (CON versi\u00f3n) ---\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\ncoil = { group = \"io.coil-kt\", name = \"coil\", version.ref = \"coil\" }\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#2-appbuildgradlekts","title":"2. <code>app/build.gradle.kts</code>","text":"<pre><code>dependencies {\n    // 1. Importamos las Plataformas (BOMs)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(platform(libs.firebase.bom))\n\n    // 2. Importamos las librer\u00edas del BOM (Sin versi\u00f3n)\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.material3)\n    implementation(libs.firebase.analytics)\n\n    // 3. Importamos las librer\u00edas Normales (Con versi\u00f3n en el cat\u00e1logo)\n    implementation(libs.retrofit)\n    implementation(libs.coil)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#4-proyecto-de-ejemplo-mysimpleapp","title":"4. Proyecto de Ejemplo: \"MySimpleApp\"","text":"<p>Vamos a diseccionar un proyecto real pero sencillo para ver c\u00f3mo encajan todas las piezas. Imagina una app simple con una sola pantalla.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#41-settingsgradlekts-la-entrada","title":"4.1. <code>settings.gradle.kts</code> (La entrada)","text":"<p>Este archivo le dice a Gradle c\u00f3mo arrancar.</p> <pre><code>pluginManagement {\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nrootProject.name = \"MySimpleApp\"\n\ninclude(\":app\") // &lt;--- Aqu\u00ed decimos: \"Este proyecto tiene un m\u00f3dulo llamado 'app'\"\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#42-gradlelibsversionstoml-el-catalogo","title":"4.2. <code>gradle/libs.versions.toml</code> (El cat\u00e1logo)","text":"<p>Aqu\u00ed definimos nuestros ingredientes.</p> <pre><code>[versions]\nagp = \"8.1.1\"\nkotlin = \"1.9.0\"\ncoreKtx = \"1.10.1\"\nappcompat = \"1.6.1\"\nmaterial = \"1.9.0\"\nconstraintlayout = \"2.1.4\"\njunit = \"4.13.2\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nandroidx-constraintlayout = { group = \"androidx.constraintlayout\", name = \"constraintlayout\", version.ref = \"constraintlayout\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlinAndroid = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#43-buildgradlekts-nivel-proyecto","title":"4.3. <code>build.gradle.kts</code> (Nivel Proyecto)","text":"<p>Hoy en d\u00eda es muy simple, solo registra los plugins para usarlos en los hijos.</p> <pre><code>// Build script de nivel superior (Top-level)\nplugins {\n    // Usamos 'apply false' porque solo queremos cargar las clases del plugin,\n    // pero no aplicarlas a este proyecto ra\u00edz (se aplicar\u00e1n en 'app').\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.kotlinAndroid) apply false\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#44-appbuildgradlekts-nivel-modulo","title":"4.4. <code>app/build.gradle.kts</code> (Nivel M\u00f3dulo)","text":"<p>Aqu\u00ed es donde ocurre la magia de la configuraci\u00f3n de la app.</p> <pre><code>plugins {\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.kotlinAndroid)\n}\n\nandroid {\n    namespace = \"com.example.mysimpleapp\"\n    compileSdk = 33 // Versi\u00f3n del SDK usada para compilar (headers, nuevas APIs)\n\n    defaultConfig {\n        applicationId = \"com.example.mysimpleapp\"\n        minSdk = 24 // Versi\u00f3n m\u00ednima de Android donde instalaremos la app (Android 7.0)\n        targetSdk = 33 // Versi\u00f3n para la que hemos probado y dise\u00f1ado la app\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\n        }\n    }\n\n    // Necesario para usar caracter\u00edsticas nuevas de Java/Kotlin\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n\ndependencies {\n    // Referenciamos las librer\u00edas usando el cat\u00e1logo (libs)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    implementation(libs.androidx.constraintlayout)\n\n    // Tests unitarios\n    testImplementation(libs.junit)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#resumen","title":"Resumen","text":"<p>Esta estructura modular y centralizada parece verbosa al principio para un proyecto peque\u00f1o, pero es vital cuando el proyecto crece. Mantener las versiones en un solo lugar (<code>libs.versions.toml</code>) y separar la configuraci\u00f3n del proyecto de la del m\u00f3dulo es la base del desarrollo profesional en Android.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#5-guia-de-supervivencia-conceptos-del-dia-a-dia","title":"5. Gu\u00eda de Supervivencia: Conceptos del D\u00eda a D\u00eda","text":"<p>Para terminar, aqu\u00ed tienes tres conceptos que usar\u00e1s a diario y que suelen confundir al principio.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#51-sync-vs-build-sincronizar-vs-construir","title":"5.1. \"Sync\" vs \"Build\" (Sincronizar vs Construir)","text":"<ul> <li>Sync (Sincronizar): Es r\u00e1pido. Ocurre cuando cambias un archivo <code>.gradle.kts</code> o <code>.toml</code>. Gradle lee la configuraci\u00f3n, descarga librer\u00edas nuevas y actualiza los \u00edndices de Android Studio. No compila tu c\u00f3digo Kotlin.<ul> <li>Cu\u00e1ndo hacerlo: Siempre que toques algo de la configuraci\u00f3n de Gradle. Ver\u00e1s una barrita amarilla o un elefante con flechas azules.</li> </ul> </li> <li>Build (Construir): Es lento. Compila todo tu c\u00f3digo Kotlin, procesa los recursos y genera el APK.<ul> <li>Cu\u00e1ndo hacerlo: Cuando le das al bot\u00f3n de \"Play\" (Run).</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#52-clean-rebuild-el-apagar-y-encender","title":"5.2. Clean &amp; Rebuild (El \"apagar y encender\")","text":"<p>A veces, Android Studio \"se l\u00eda\". Te marca errores en rojo en c\u00f3digo que sabes que est\u00e1 bien, o la app falla de forma rara. *   Build &gt; Clean Project: Borra la carpeta <code>build/</code> (los archivos temporales de compilaci\u00f3n). *   Build &gt; Rebuild Project: Hace un Clean y luego un Build completo desde cero.     *   Truco del experto: Si algo no tiene sentido, haz un <code>Clean Project</code>. Soluciona el 90% de los problemas \"fantasmas\".</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#53-build-variants-debug-vs-release","title":"5.3. Build Variants: Debug vs Release","text":"<p>Por defecto, cuando le das al Play, est\u00e1s instalando la variante Debug. *   Debug:     *   SE PUEDE depurar (breakpoints).     *   No est\u00e1 optimizada (es m\u00e1s lenta).     *   Se firma con una clave de prueba insegura. *   Release:     *   NO se puede depurar (normalmente).     *   Est\u00e1 optimizada y ofuscada (R8/Proguard).     *   Se firma con tu clave real para subirla a Google Play.</p> <p>Puedes cambiar de variante en la pesta\u00f1a Build Variants (normalmente a la izquierda-abajo en Android Studio). \u00a1No intentes subir una build Debug a la Play Store!</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#6-compatibilidad-y-versiones-de-java","title":"6. Compatibilidad y Versiones de Java","text":"<p>Un dolor de cabeza com\u00fan es cuando las versiones no coinciden. Gradle, el Plugin de Android (AGP) y Java tienen una relaci\u00f3n estricta.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#61-la-matriz-de-compatibilidad","title":"6.1. La Matriz de Compatibilidad","text":"<p>No puedes usar cualquier versi\u00f3n de Gradle con cualquier versi\u00f3n de AGP. *   AGP 8.0+ requiere Gradle 8.0+ y Java 17. *   AGP 7.4 requiere Gradle 7.5+ y Java 11.</p> <p>Consejo: Si actualizas Android Studio, a menudo te propondr\u00e1 actualizar el AGP y Gradle autom\u00e1ticamente. Acepta si tu equipo est\u00e1 de acuerdo, pero ten cuidado si saltas muchas versiones de golpe.</p> <p>Puedes consultar la tabla oficial siempre actualizada aqu\u00ed: Android Gradle Plugin version requirements.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#62-que-java-usa-mi-proyecto","title":"6.2. \u00bfQu\u00e9 Java usa mi proyecto?","text":"<p>Hay dos configuraciones de Java que debes distinguir:</p> <ol> <li> <p>Java para compilar tu c\u00f3digo (Target JVM):     Define qu\u00e9 caracter\u00edsticas de Java puede usar tu c\u00f3digo Kotlin/Java y en qu\u00e9 dispositivos funcionar\u00e1.     Se configura en <code>app/build.gradle.kts</code>:     </p><pre><code>android {\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n</code></pre> Nota: A partir de AGP 8, por defecto suele ser Java 17, aunque muchos proyectos siguen en 1.8 (Java 8) para m\u00e1xima compatibilidad con m\u00f3viles antiguos.<p></p> </li> <li> <p>Java para ejecutar Gradle (Gradle Daemon):     Es la versi\u00f3n de Java que usa tu ordenador para correr el proceso de construcci\u00f3n.</p> <ul> <li>C\u00f3mo cambiarlo:<ol> <li>Ve a <code>File &gt; Settings</code> (o <code>Android Studio &gt; Settings</code> en Mac).</li> <li>Busca <code>Build, Execution, Deployment &gt; Build Tools &gt; Gradle</code>.</li> <li>En Gradle JDK, selecciona la versi\u00f3n. Normalmente deber\u00edas usar la versi\u00f3n \"Embedded\" que trae Android Studio, o asegurarte de que sea al menos Java 17 para proyectos modernos.</li> </ol> </li> </ul> </li> </ol> <p>El aviso de diferentes JDKs</p> <p>A veces Android Studio te mostrar\u00e1 un aviso diciendo que \"Gradle JDK\" y el \"Project JDK\" son diferentes.</p> <p>Esto ocurre porque Android Studio intenta usar el mismo Java para indexar tu c\u00f3digo que Gradle usa para compilarlo. Si son diferentes, se desperdicia memoria (se arrancan dos m\u00e1quinas virtuales Java) y pueden surgir errores extra\u00f1os de resoluci\u00f3n de tipos.</p> <p>Soluci\u00f3n: Intenta que ambos apunten a la misma instalaci\u00f3n.</p> <ol> <li>Gradle JDK: Ve a <code>Settings &gt; Build... &gt; Build Tools &gt; Gradle</code>.</li> <li>Project SDK: Ve a <code>File &gt; Project Structure... &gt; Project Settings &gt; Project</code>.</li> <li>Aseg\u00farate de que el SDK seleccionado en el paso 2 coincide con la versi\u00f3n elegida en el paso 1 (por ejemplo, seleccionando <code>jbr-17</code> o <code>Embedded JDK</code> en ambos sitios).</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#63-donde-miro-que-versiones-tengo-instaladas","title":"6.3. \u00bfD\u00f3nde miro qu\u00e9 versiones tengo instaladas?","text":"<p>A veces te preguntar\u00e1n \"\u00bfQu\u00e9 versi\u00f3n de AGP usas?\" y no sabr\u00e1s d\u00f3nde mirar. Aqu\u00ed tienes la \"chuleta\":</p> <ul> <li>Gradle Version:<ul> <li>Mira en <code>gradle/wrapper/gradle-wrapper.properties</code>.</li> <li>Busca la l\u00ednea <code>distributionUrl=.../gradle-8.0-bin.zip</code>. El n\u00famero <code>8.0</code> es tu versi\u00f3n.</li> </ul> </li> <li>AGP Version:<ul> <li>Mira en <code>libs.versions.toml</code> bajo <code>[versions]</code>, la variable <code>agp</code>.</li> <li>O en <code>build.gradle.kts</code> (Project level) en el bloque <code>plugins</code>.</li> </ul> </li> <li>Kotlin Version:<ul> <li>Mira en <code>libs.versions.toml</code> bajo <code>[versions]</code>, la variable <code>kotlin</code>.</li> <li>O en <code>build.gradle.kts</code> (Project level) en el bloque <code>plugins</code>.</li> </ul> </li> </ul> <p>Alternativamente, en Android Studio, puedes ir a File &gt; Project Structure &gt; Project, y all\u00ed ver\u00e1s un resumen gr\u00e1fico con todas estas versiones.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html","title":"Build-gradle","text":""},{"location":"temas/00-android/00-tools/02-build-gradle.html#el-fichero-de-construccion-buildgradlekts","title":"El Fichero de Construcci\u00f3n: <code>build.gradle.kts</code>","text":"<p>En el coraz\u00f3n de la compilaci\u00f3n de tu aplicaci\u00f3n Android se encuentra el fichero <code>build.gradle.kts</code> (o <code>build.gradle</code> si usas Groovy, aunque el est\u00e1ndar moderno es Kotlin DSL).</p> <p>Este fichero define C\u00d3MO se debe construir tu aplicaci\u00f3n: desde qu\u00e9 versi\u00f3n de Android soporta, hasta qu\u00e9 librer\u00edas externas utiliza.</p> <p>Project vs Module</p> <p>Recuerda que existen dos niveles de <code>build.gradle</code>:</p> <ol> <li>Project-level (<code>build.gradle.kts</code> ra\u00edz): Define configuraci\u00f3n global para todos los m\u00f3dulos (normalmente solo plugins comunes).</li> <li>Module-level (<code>app/build.gradle.kts</code>): Es donde pasar\u00e1s el 99% del tiempo. Define la configuraci\u00f3n espec\u00edfica de tu app (o m\u00f3dulo). Nos centraremos en este.</li> </ol>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#estructura-anatomica","title":"Estructura Anat\u00f3mica","text":"<p>Un fichero <code>build.gradle.kts</code> de m\u00f3dulo t\u00edpico tiene esta estructura:</p> <pre><code>plugins {\n    // 1. Plugins\n}\n\nandroid {\n    // 2. Configuraci\u00f3n Android\n}\n\ndependencies {\n    // 3. Dependencias externas\n}\n</code></pre> <p>Vamos a diseccionar cada parte.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#1-bloque-plugins","title":"1. Bloque <code>plugins</code>","text":"<p>Los plugins son extensiones que \"ense\u00f1an\" a Gradle c\u00f3mo hacer cosas nuevas. Por defecto, Gradle no sabe qu\u00e9 es una \"App Android\". Necesitamos aplicarle el plugin de Android.</p> <pre><code>plugins {\n    // Le dice a Gradle: \"Este m\u00f3dulo es una Aplicaci\u00f3n Android\"\n    alias(libs.plugins.android.application)\n\n    // Le dice a Gradle: \"Vamos a usar Kotlin en Android\"\n    alias(libs.plugins.kotlin.android)\n}\n</code></pre> <p>Version Catalogs (<code>libs.*</code>)</p> <p>F\u00edjate en el uso de <code>alias(libs...)</code>. Esto es Version Catalogs. En lugar de escribir el ID del plugin y la versi\u00f3n \"a fuego\" (hardcoded), referenciamos una definici\u00f3n centralizada en el fichero <code>libs.versions.toml</code>. \u00a1Es mucho m\u00e1s limpio y f\u00e1cil de mantener!</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#2-bloque-android","title":"2. Bloque <code>android</code>","text":"<p>Aqu\u00ed configuramos todo lo relacionado con el SDK de Android.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#namespace-y-compilacion","title":"Namespace y Compilaci\u00f3n","text":"<pre><code>android {\n    // Identificador \u00fanico de tu paquete (sustituye al antiguo 'package' en Manifest)\n    namespace = \"com.ejemplo.miapp\"\n\n    // La versi\u00f3n del SDK que usas para COMPILAR el c\u00f3digo.\n    // Te permite usar las APIs m\u00e1s nuevas de esa versi\u00f3n en tu c\u00f3digo.\n    compileSdk = 35 \n\n    // ...\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#default-config","title":"Default Config","text":"<p>La configuraci\u00f3n base que se aplica a todas las versiones de tu app (debug, release, etc.).</p> <pre><code>    defaultConfig {\n        // ID \u00fanico de la aplicaci\u00f3n en la Play Store.\n        applicationId = \"com.ejemplo.miapp\"\n\n        // M\u00ednima versi\u00f3n de Android donde funciona tu app.\n        // Si pones 24 (Android 7.0), nadie con Android 6.0 podr\u00e1 instalarla.\n        minSdk = 24\n\n        // Versi\u00f3n objetivo. Le dice a Android: \"He probado mi app hasta esta versi\u00f3n\".\n        // Permite que el sistema active optimizaciones o comportamientos nuevos.\n        // Lo ideal es: targetSdk == compileSdk\n        targetSdk = 35\n\n        // Versionado para la tienda (interno y visible).\n        versionCode = 1\n        versionName = \"1.0\"\n\n        // Runner para los tests instrumentados\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#build-types-tipos-de-construccion","title":"Build Types (Tipos de Construcci\u00f3n)","text":"<p>Define perfiles de compilaci\u00f3n. Por defecto siempre tienes <code>debug</code> y <code>release</code>.</p> <pre><code>    buildTypes {\n        release {\n            // \u00bfActivamos minificaci\u00f3n (R8)? (Borrar c\u00f3digo no usado, ofuscar...)\n            isMinifyEnabled = false \n\n            // Reglas de ProGuard para la ofuscaci\u00f3n\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n        // El bloque 'debug' existe impl\u00edcitamente aunque no lo escribas.\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#opciones-de-compilacion","title":"Opciones de Compilaci\u00f3n","text":"<p>Configuramos la versi\u00f3n de Java que usaremos. Hoy en d\u00eda, Java 11 o 17 son el est\u00e1ndar para desarrollo Android moderno.</p> <pre><code>    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#3-bloque-dependencies","title":"3. Bloque <code>dependencies</code>","text":"<p>Aqu\u00ed listamos las librer\u00edas externas que nuestra app necesita para funcionar.</p> <pre><code>dependencies {\n    // Dependencias 'core' (se compilan y empaquetan con la app)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n\n    // Dependencias SOLO para Tests Unitarios (JUnit local)\n    // No se empaquetan en la APK final.\n    testImplementation(libs.junit)\n\n    // Dependencias puramente de Tests Instrumentados (Android)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n\n    // Herramientas de debug (solo en builds debug)\n    // debugImplementation(libs.leakcanary)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#tipos-de-dependencia-comunes","title":"Tipos de dependencia comunes","text":"<ul> <li><code>implementation</code>: La m\u00e1s com\u00fan. La librer\u00eda est\u00e1 disponible en compilaci\u00f3n y ejecuci\u00f3n.</li> <li><code>testImplementation</code>: Solo disponible dentro de <code>src/test</code> (tests unitarios locales).</li> <li><code>androidTestImplementation</code>: Solo disponible dentro de <code>src/androidTest</code> (tests en dispositivo).</li> <li><code>ksp</code> (o <code>kapt</code>): Para procesadores de anotaciones (como Room o Dagger/Hilt).</li> <li><code>debugImplementation</code>: Solo se incluye en la variante <code>debug</code>.</li> </ul> <p>Cuidado con las versiones</p> <p>Evita mezclar versiones de librer\u00edas relacionadas (como las de <code>androidx.lifecycle</code> o <code>kotlinx.coroutines</code>). Usar el Version Catalog (<code>libs.versions.toml</code>) ayuda mucho a mantener la coherencia, ya que defines la versi\u00f3n en un solo lugar.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html","title":"Fichero Manifest","text":""},{"location":"temas/00-android/00-tools/03-android-manifest.html#el-manifiesto-de-la-app-androidmanifestxml","title":"El Manifiesto de la App: <code>AndroidManifest.xml</code>","text":"<p>Si <code>build.gradle</code> es el jefe de obra que construye el edificio, el <code>AndroidManifest.xml</code> es el DNI o Pasaporte de tu aplicaci\u00f3n. </p> <p>Es la primera fuente de verdad que el sistema operativo Android consulta para saber qu\u00e9 hay dentro de tu APK/Bundle y qu\u00e9 permisos pretendes usar.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#1-permisos-y-hardware-declarando-intenciones","title":"1. Permisos y Hardware: Declarando intenciones","text":"<p>Antes de que el sistema te deje entrar en escena, debes declarar qu\u00e9 recursos del tel\u00e9fono vas a utilizar.</p> <ul> <li><code>&lt;uses-permission&gt;</code>: Solicitas permiso para acceder a datos o funciones restringidas.<ul> <li><code>INTERNET</code>: Para conectarte a servicios externos.</li> <li><code>ACCESS_FINE_LOCATION</code>: Para saber la posici\u00f3n GPS exacta del usuario.</li> <li><code>CAMERA</code>: Para tomar fotos o v\u00eddeos.</li> </ul> </li> <li><code>&lt;uses-feature&gt;</code>: Informas sobre el hardware que tu app necesita para funcionar.<ul> <li>Ejemplo: <code>&lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /&gt;</code>. </li> <li>Importante: Si marcas <code>required=\"true\"</code>, la Google Play Store ocultar\u00e1 tu app a los usuarios cuyo m\u00f3vil no tenga ese hardware.</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#2-el-bloque-application-el-contenedor-global","title":"2. El Bloque <code>&lt;application&gt;</code>: El contenedor global","text":"<p>Este bloque define las propiedades de alto nivel de toda tu aplicaci\u00f3n. Es como la configuraci\u00f3n general del sistema.</p> <pre><code>&lt;application\n    android:name=\".MyApplication\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/Theme.MiApp\"\n    android:allowBackup=\"true\"\n    android:supportsRtl=\"true\"\n    android:usesCleartextTraffic=\"false\"&gt;\n\n    &lt;!-- Componentes aqu\u00ed inside... --&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#elementos-clave-explicados","title":"Elementos clave explicados:","text":"<ul> <li><code>android:name</code>: (Opcional) Referencia a una clase Java/Kotlin que hereda de <code>Application</code>. Es el primer c\u00f3digo que se ejecuta al abrir la app, ideal para inicializar librer\u00edas globales (como bases de datos o inyecci\u00f3n de dependencias).</li> <li><code>android:theme</code>: Define la \"est\u00e9tica\" por defecto. Referencia a un fichero de estilos (normalmente en <code>res/values/themes.xml</code>). Aqu\u00ed se decide si usas Material Design 3, los colores principales de tu marca, o si tu app soporta modo oscuro de forma nativa.</li> <li><code>android:usesCleartextTraffic</code>: Si se pone en <code>false</code> (recomendado), Android bloquear\u00e1 todas las peticiones HTTP no seguras, oblig\u00e1ndote a usar HTTPS. Es vital para la seguridad actual.</li> </ul>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#3-los-4-fantasticos-los-componentes-de-android","title":"3. Los \"4 Fant\u00e1sticos\": Los Componentes de Android","text":"<p>Android no es un programa monol\u00edtico; se compone de piezas intercambiables y declarables. Hay 4 tipos principales de componentes:</p> <ol> <li><code>&lt;activity&gt;</code> (Actividades): Son las pantallas. Cada pantalla que el usuario ve debe estar declarada aqu\u00ed. Es el componente con el que el usuario interact\u00faa directamente.</li> <li><code>&lt;service&gt;</code> (Servicios): Componentes que corren en segundo plano sin interfaz de usuario. Por ejemplo, una app de m\u00fasica que sigue sonando cuando apagas la pantalla o una descarga pesada.</li> <li><code>&lt;receiver&gt;</code> (Broadcast Receivers): Son \"orejas\" que escuchan eventos del sistema. Por ejemplo, una app que se activa cuando el m\u00f3vil se conecta a un cargador o cuando termina de arrancar el sistema (<code>BOOT_COMPLETED</code>).</li> <li><code>&lt;provider&gt;</code> (Content Providers): Permiten compartir datos entre aplicaciones de forma segura. Por ejemplo, la lista de contactos del tel\u00e9fono o la galer\u00eda de fotos se exponen mediante Content Providers.</li> </ol>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#4-intent-filters-la-publicidad-de-tus-capacidades","title":"4. Intent Filters: La \"Publicidad\" de tus capacidades","text":"<p>Los <code>intent-filter</code> son etiquetas que pones a tus componentes para decirle al sistema: \"Yo s\u00e9 hacer esto\".</p> <p>No solo sirven para marcar la pantalla de inicio. Un <code>intent-filter</code> descompone en tres partes:</p> <ol> <li><code>&lt;action&gt;</code>: El qu\u00e9. \u00bfQuieres ver un dato (<code>VIEW</code>)?, \u00bfenviar algo (<code>SEND</code>)?, \u00bfeditar algo (<code>EDIT</code>)?</li> <li><code>&lt;category&gt;</code>: El contexto. \u00bfEs la puerta principal (<code>LAUNCHER</code>)?, \u00bfes algo que se abre desde el navegador (<code>BROWSABLE</code>)?</li> <li><code>&lt;data&gt;</code>: El formato. \u00bfManejas archivos PDF?, \u00bfURLs que empiecen por <code>https://miweb.com</code>?, \u00bfim\u00e1genes PNG?</li> </ol>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#ejemplo-abriendo-nuestra-app-desde-un-enlace-web-deep-linking","title":"Ejemplo: Abriendo nuestra app desde un enlace web (Deep Linking)","text":"<pre><code>&lt;activity android:name=\".ProductDetailActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n        &lt;!-- Aceptamos enlaces que sean https://www.tienda.com/productos/... --&gt;\n        &lt;data android:scheme=\"https\" android:host=\"www.tienda.com\" android:pathPrefix=\"/productos\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>Diferencia Vital</p> <p>Si declaras una Activity pero no le pones ning\u00fan <code>intent-filter</code>, la Activity sigue existiendo, pero solo podr\u00e1 ser abierta desde dentro de tu propia app. Sin filtros, el \"mundo exterior\" no sabe c\u00f3mo llegar a ella.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#5-referencias-de-documentacion-oficial","title":"5. Referencias de documentaci\u00f3n oficial","text":"<p>Para profundizar en cada etiqueta y atributo, puedes consultar la documentaci\u00f3n oficial de Android:</p> <ul> <li>Descripci\u00f3n general del manifiesto de la aplicaci\u00f3n: Conceptos b\u00e1sicos y estructura.</li> <li>Referencia del elemento <code>&lt;application&gt;</code>: Lista exhaustiva de todos los atributos configurables.</li> <li>Gu\u00eda de Intenciones y Filtros de Intenciones: C\u00f3mo funciona la comunicaci\u00f3n entre componentes.</li> <li>Referencia de permisos de Android: Diccionario de todos los permisos disponibles en el sistema.</li> </ul>"},{"location":"temas/01/index.html","title":"UT1 - Visi\u00f3n General y Entorno de desarrollo","text":""},{"location":"temas/01/index.html#ut1-evolucion-y-entornos-de-desarrollo","title":"UT1. Evoluci\u00f3n y Entornos de desarrollo","text":""},{"location":"temas/01/index.html#1-limitaciones-en-el-desarrollo-movil","title":"1. Limitaciones en el desarrollo m\u00f3vil","text":"<p>A menudo, cuando empezamos a programar, venimos de un mundo de desarrollo de escritorio o incluso web, donde los recursos parecen casi infinitos. Un ordenador de sobremesa moderno tiene gigabytes de RAM, procesadores de m\u00faltiples n\u00facleos a altas velocidades, almacenamiento masivo y una conexi\u00f3n a internet estable y r\u00e1pida. Los servidores que alojan aplicaciones web son a\u00fan m\u00e1s potentes.</p> <p>Sin embargo, el entorno m\u00f3vil es un ecosistema completamente diferente. Un smartphone, por muy avanzado que sea, es un dispositivo que llevamos en el bolsillo, alimentado por una bater\u00eda y sujeto a condiciones muy variables. Ignorar estas limitaciones no solo lleva a una mala calificaci\u00f3n en esta asignatura, sino, lo que es peor, a crear aplicaciones que los usuarios desinstalar\u00e1n por ser lentas, consumir su bater\u00eda o no funcionar cuando m\u00e1s las necesitan.</p> <p>Pensemos en un desarrollador de escritorio como el arquitecto de un gran rascacielos con cimientos profundos y acceso a la red el\u00e9ctrica principal. En cambio, un desarrollador m\u00f3vil es como el ingeniero de un coche de F\u00f3rmula 1: cada gramo de peso, cada gota de combustible y cada pieza de la aerodin\u00e1mica cuentan. La optimizaci\u00f3n no es una opci\u00f3n; es una obligaci\u00f3n.</p> <p>A continuaci\u00f3n, vamos a desglosar las principales \u00e1reas de restricci\u00f3n.</p> <ol> <li> <p>Recursos de Hardware: La eterna dieta</p> <p>A pesar de los impresionantes avances, los dispositivos m\u00f3viles operan con recursos de hardware significativamente m\u00e1s modestos que sus hom\u00f3logos de escritorio.</p> <p><code>Procesador (CPU)</code>: Las CPUs m\u00f3viles est\u00e1n dise\u00f1adas con un objetivo principal: la eficiencia energ\u00e9tica. Un procesador de escritorio puede permitirse consumir 100W o m\u00e1s y disipar el calor con grandes ventiladores. Una CPU m\u00f3vil debe operar con un consumo m\u00ednimo para no agotar la bater\u00eda en minutos y sobrecalentar el dispositivo. Esto implica velocidades de reloj m\u00e1s bajas y arquitecturas (como ARM) optimizadas para el bajo consumo, lo que se traduce en una menor capacidad de c\u00f3mputo bruto. Tareas muy intensivas, como el renderizado de v\u00eddeo o c\u00e1lculos complejos, deben ser abordadas con mucho m\u00e1s cuidado.</p> <p><code>Memoria (RAM)</code>: Mientras que un PC de gama media actual puede tener 16 GB o 32 GB de RAM, un smartphone de gama alta puede tener 8 GB o 12 GB, y los de gama media, bastante menos. Adem\u00e1s, el sistema operativo m\u00f3vil (Android o iOS) es muy agresivo a la hora de gestionar esta memoria. Si tu aplicaci\u00f3n consume demasiada RAM, el sistema no dudar\u00e1 en \"matarla\" (finalizar su proceso) sin previo aviso para liberar recursos para la aplicaci\u00f3n que est\u00e1 en primer plano. Esto contrasta con un sistema de escritorio, donde las aplicaciones pueden permanecer en memoria durante d\u00edas.</p> <p><code>Almacenamiento</code>: Aunque los dispositivos modernos ofrecen m\u00e1s almacenamiento, sigue siendo un recurso finito y, a menudo, no ampliable. Las aplicaciones deben ser ligeras. Una aplicaci\u00f3n de escritorio puede ocupar varios gigabytes sin que el usuario se preocupe, pero una app m\u00f3vil que ocupe ese espacio ser\u00e1 una candidata clara a ser eliminada cuando el usuario necesite liberar espacio para sus fotos o v\u00eddeos.</p> </li> <li> <p>La Bater\u00eda: El recurso m\u00e1s preciado</p> <p>Esta es, sin duda, la limitaci\u00f3n m\u00e1s cr\u00edtica y definitoria del desarrollo m\u00f3vil. A diferencia del desarrollo web o de escritorio, donde la alimentaci\u00f3n es constante, en el m\u00f3vil cada ciclo de CPU, cada byte enviado por la red y cada p\u00edxel encendido en la pantalla consume una porci\u00f3n de un recurso muy limitado: la bater\u00eda.</p> <p><code>Consumo energ\u00e9tico</code>: El desarrollador debe ser consciente del impacto energ\u00e9tico de su c\u00f3digo. Dejar un sensor activo (como el GPS) innecesariamente, realizar operaciones de red con demasiada frecuencia (polling) o ejecutar procesos complejos en segundo plano son los caminos m\u00e1s r\u00e1pidos para agotar la bater\u00eda del usuario y ganarse una rese\u00f1a de una estrella en la tienda de aplicaciones.</p> <p><code>Optimizaci\u00f3n del sistema</code>: Los sistemas operativos m\u00f3viles modernos implementan mecanismos muy estrictos para controlar el consumo, como Doze Mode y App Standby en Android. Estos modos ponen las aplicaciones en un estado de \"sue\u00f1o profundo\", restringiendo su acceso a la red y a la CPU cuando el dispositivo no est\u00e1 en uso. El desarrollador ya no tiene control total sobre cu\u00e1ndo se ejecuta su c\u00f3digo en segundo plano.</p> </li> <li> <p>Conectividad: Un mundo inestable y costoso</p> <p>Las aplicaciones de escritorio y web suelen asumir una conexi\u00f3n a internet permanente, r\u00e1pida y de bajo coste (Wi-Fi o Ethernet). En el mundo m\u00f3vil, la realidad es muy diferente.</p> <p><code>Variabilidad de la red</code>: La aplicaci\u00f3n debe funcionar de manera predecible en m\u00faltiples escenarios: una conexi\u00f3n Wi-Fi de alta velocidad, una red 5G, una conexi\u00f3n 4G inestable en un tren, una red 3G lenta en una zona rural, o incluso sin conexi\u00f3n alguna.</p> <p><code>Latencia y ancho de banda</code>: La latencia en redes m\u00f3viles es generalmente mayor que en redes fijas. Las transferencias de datos deben minimizarse. No puedes permitirte descargar 50 MB de datos cada vez que el usuario abre la app. Debes implementar estrategias de cach\u00e9, compresi\u00f3n de datos y sincronizaci\u00f3n inteligente.</p> <p><code>Coste de los datos</code>: A diferencia del Wi-Fi, los datos m\u00f3viles suelen tener un coste para el usuario. Una aplicaci\u00f3n que consuma una cantidad excesiva del plan de datos de un usuario ser\u00e1 desinstalada r\u00e1pidamente. Debes ofrecer opciones para limitar el uso de datos (por ejemplo, descargar contenido pesado solo con Wi-Fi).</p> </li> <li> <p>Fragmentaci\u00f3n del Ecosistema</p> <p>Mientras que en el desarrollo de escritorio se trabaja con un conjunto relativamente est\u00e1ndar de resoluciones de pantalla y capacidades, y en la web se usan t\u00e9cnicas de \"responsive design\", en el m\u00f3vil (especialmente en Android) nos enfrentamos a una fragmentaci\u00f3n extrema.</p> <p><code>Diversidad de pantallas</code>: Existen miles de modelos de dispositivos con diferentes tama\u00f1os de pantalla, densidades de p\u00edxeles (DPI), y relaciones de aspecto. Tu interfaz de usuario (UI) debe adaptarse fluidamente a todas ellas, desde un tel\u00e9fono peque\u00f1o hasta una tablet de gran formato.</p> <p><code>Variedad de Hardware</code>: M\u00e1s all\u00e1 de la pantalla, te encontrar\u00e1s con una enorme diversidad de CPUs, GPUs, cantidad de RAM y sensores disponibles (algunos tienen NFC, otros no; algunos tienen un bar\u00f3metro, la mayor\u00eda no). Tu aplicaci\u00f3n debe ser capaz de gestionar esta diversidad, ya sea adaptando su funcionalidad o informando al usuario de que una caracter\u00edstica no est\u00e1 disponible en su dispositivo.</p> <p><code>Versiones del Sistema Operativo</code>: Especialmente en Android, los usuarios tardan en actualizar sus dispositivos. No es raro tener que dar soporte a varias versiones del sistema operativo simult\u00e1neamente, cada una con sus propias APIs, caracter\u00edsticas y bugs.</p> </li> <li> <p>Ciclo de Vida de la Aplicaci\u00f3n y Restricciones del SO</p> <p>En un ordenador de escritorio, el usuario lanza una aplicaci\u00f3n y esta se ejecuta hasta que \u00e9l decide cerrarla. En un dispositivo m\u00f3vil, el ciclo de vida es mucho m\u00e1s complejo y est\u00e1 gestionado de forma estricta por el sistema operativo.</p> <p><code>Estados de la aplicaci\u00f3n</code>: Una aplicaci\u00f3n m\u00f3vil no est\u00e1 simplemente \"abierta\" o \"cerrada\". Pasa por m\u00faltiples estados (creada, iniciada, en primer plano, pausada, detenida, destruida). Por ejemplo, si entra una llamada mientras el usuario est\u00e1 usando tu app, esta pasar\u00e1 al estado de \"pausada\". Debes guardar el estado del usuario en ese momento para que, al volver, pueda continuar donde lo dej\u00f3.</p> <p><code>Procesos en segundo plano (Background)</code>: Como mencionamos antes, la ejecuci\u00f3n de c\u00f3digo en segundo plano est\u00e1 severamente restringida. No puedes simplemente iniciar un hilo que se ejecute indefinidamente. Debes usar las APIs espec\u00edficas proporcionadas por el sistema (como WorkManager en Android) que permiten al SO ejecutar tu tarea de la forma m\u00e1s eficiente posible (por ejemplo, agrupando tareas de varias apps para despertar al dispositivo una sola vez).</p> </li> </ol> <p>Desarrollar para dispositivos m\u00f3viles es un desaf\u00edo apasionante que requiere un cambio de mentalidad. No se trata de trasladar directamente las pr\u00e1cticas del desarrollo de escritorio o web, sino de abrazar las restricciones y convertirlas en una gu\u00eda para la excelencia en la ingenier\u00eda de software.</p> <p>Una aplicaci\u00f3n m\u00f3vil exitosa no es la que m\u00e1s funcionalidades tiene, sino la que ofrece una experiencia fluida, es respetuosa con los recursos del usuario (bater\u00eda, datos, almacenamiento) y funciona de manera fiable en un entorno impredecible. Recordad siempre: en el mundo m\u00f3vil, la eficiencia no es una caracter\u00edstica, es el cimiento sobre el que se construye todo lo dem\u00e1s.</p>"},{"location":"temas/01/index.html#2-desarrollo-movil-en-la-actualidad-un-ecosistema-de-opciones","title":"2. Desarrollo M\u00f3vil en la Actualidad: Un Ecosistema de Opciones","text":"<p>Hace una d\u00e9cada, las opciones eran limitadas. Hoy, nos encontramos ante un ecosistema rico y diverso con diferentes enfoques, cada uno con sus propias filosof\u00edas, ventajas y desventajas. La elecci\u00f3n de la tecnolog\u00eda es una de las decisiones m\u00e1s cr\u00edticas que tomar\u00e9is como desarrolladores o arquitectos de software, ya que impactar\u00e1 directamente en el presupuesto del proyecto, el tiempo de desarrollo, el rendimiento de la aplicaci\u00f3n y la experiencia final del usuario.</p> <p>El objetivo de este documento es proporcionaros un mapa claro de este territorio. Analizaremos las tres grandes rutas que podemos tomar para construir una aplicaci\u00f3n m\u00f3vil: el desarrollo Nativo, el H\u00edbrido y las Progressive Web Apps (PWA). \u00a1Empecemos!</p>"},{"location":"temas/01/index.html#a-desarrollo-nativo-la-via-de-la-maxima-potencia-y-experiencia","title":"A. Desarrollo Nativo: La V\u00eda de la M\u00e1xima Potencia y Experiencia","text":"<p>El desarrollo nativo consiste en construir una aplicaci\u00f3n utilizando las herramientas, lenguajes y APIs (Application Programming Interfaces) que la propia plataforma provee de forma oficial. En esencia, se crea una aplicaci\u00f3n espec\u00edfica y optimizada para un \u00fanico sistema operativo.</p> <p>\ud83d\udd25 Esto significa que si queremos que nuestra app funcione en Android y en iOS, necesitaremos desarrollar dos aplicaciones separadas, una para cada plataforma, con sus respectivos c\u00f3digos fuente.</p> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Insuperable: La aplicaci\u00f3n se compila a c\u00f3digo m\u00e1quina que se ejecuta directamente sobre el sistema operativo, sin capas intermedias. Esto garantiza la m\u00e1xima velocidad, fluidez y capacidad de respuesta. Es la opci\u00f3n ideal para juegos, aplicaciones con gr\u00e1ficos intensivos o que realicen c\u00e1lculos complejos.</p> </li> <li> <p>Acceso Total al Hardware y APIs: Tienes acceso inmediato y completo a todas las capacidades del dispositivo: GPS, c\u00e1mara, aceler\u00f3metro, NFC, ARKit (iOS), etc. Adem\u00e1s, eres el primero en poder usar las nuevas funcionalidades que se lanzan con cada actualizaci\u00f3n del sistema operativo.</p> </li> <li> <p>Experiencia de Usuario (UX) Perfecta: La interfaz de usuario (UI) se construye con los componentes nativos de la plataforma. El resultado es una aplicaci\u00f3n que se ve y se siente exactamente como el resto del sistema operativo, lo que la hace intuitiva y familiar para el usuario.</p> </li> <li> <p>Mayor Seguridad y Fiabilidad: Al operar directamente sobre la plataforma, se aprovechan todas sus capas de seguridad y optimizaciones.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Para Android:</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Kotlin: Es el lenguaje moderno, conciso y seguro que Google recomienda oficialmente desde 2019. Es interoperable al 100% con Java.</p> </li> <li> <p>Java: Fue el lenguaje original para el desarrollo en Android. Sigue siendo muy utilizado, especialmente en proyectos m\u00e1s antiguos (legacy), pero Kotlin es la opci\u00f3n preferida para nuevos desarrollos.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Android Studio. Es el IDE oficial de Google, basado en IntelliJ IDEA. Incluye todo lo necesario: editor de c\u00f3digo, depurador, emuladores, analizadores de rendimiento, etc.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Android Developers (Oficial) - El punto de partida para todo.</p> </li> <li> <p>Documentaci\u00f3n de Kotlin - Aprende el lenguaje que impulsa el desarrollo moderno de Android.</p> </li> <li> <p>Descargar Android Studio</p> </li> </ul> </li> </ul> <p>Para iOS (Ecosistema Apple)</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Swift: Es el lenguaje moderno, potente y seguro creado por Apple. Es la opci\u00f3n recomendada para cualquier aplicaci\u00f3n nueva en el ecosistema de Apple (iOS, iPadOS, macOS, watchOS).</p> </li> <li> <p>Objective-C: Es el lenguaje original de desarrollo para iOS. Aunque Swift lo ha superado en popularidad, todav\u00eda es fundamental para mantener proyectos existentes.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Xcode. Es el IDE oficial de Apple, que se ejecuta exclusivamente en macOS. Proporciona todas las herramientas para desarrollar, depurar y publicar apps para todas las plataformas de Apple.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Apple Developer (Oficial) - Tu puerta de entrada al desarrollo para iOS.</p> </li> <li> <p>Documentaci\u00f3n de Swift - La gu\u00eda oficial y completa del lenguaje Swift.</p> </li> <li> <p>Descargar Xcode</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-desarrollo-hibrido-un-codigo-para-gobernarlos-a-todos","title":"B. Desarrollo H\u00edbrido: Un C\u00f3digo para Gobernarlos a Todos","text":"<p>El desarrollo h\u00edbrido, tambi\u00e9n conocido como multiplataforma, busca resolver el principal inconveniente del desarrollo nativo: la necesidad de mantener dos bases de c\u00f3digo. La filosof\u00eda aqu\u00ed es \"escribe una vez, ejecuta en todas partes\" (write once, run anywhere).</p> <p>Se utiliza un \u00fanico lenguaje y un framework espec\u00edfico para generar aplicaciones que funcionen tanto en Android como en iOS.</p> <p>Ventajas Clave</p> <ul> <li> <p>Eficiencia en Coste y Tiempo: Es la ventaja m\u00e1s evidente. Se necesita un solo equipo de desarrollo y un \u00fanico c\u00f3digo base, lo que reduce dr\u00e1sticamente los tiempos y costes de desarrollo y mantenimiento.</p> </li> <li> <p>Lanzamiento R\u00e1pido al Mercado (Time-to-Market): Al desarrollar para ambas plataformas simult\u00e1neamente, puedes lanzar tu producto mucho m\u00e1s r\u00e1pido.</p> </li> <li> <p>Consistencia de Marca: La aplicaci\u00f3n tendr\u00e1 una apariencia muy similar en ambas plataformas, lo que puede ser beneficioso para la identidad de marca.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes_1","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Existen diferentes enfoques dentro del mundo h\u00edbrido, pero los m\u00e1s relevantes hoy en d\u00eda son:</p> <p>Flutter</p> <ul> <li> <p>Concepto: Es un toolkit de UI desarrollado por Google que ha ganado una tracci\u00f3n inmensa. Flutter no utiliza los componentes nativos de la UI, sino que trae su propio motor de renderizado (Skia) para dibujar cada p\u00edxel en la pantalla. Esto le da un control total sobre la interfaz y permite animaciones complejas a 60/120 FPS.</p> </li> <li> <p>Lenguaje: Dart. Un lenguaje moderno, orientado a objetos y optimizado para el desarrollo de UI.</p> </li> <li> <p>Ideal para: Aplicaciones con una interfaz de usuario muy personalizada, expresiva y con muchas animaciones.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Flutter (Oficial) - Descubre por qu\u00e9 es una de las tecnolog\u00edas m\u00e1s queridas por los desarrolladores.</p> </li> <li> <p>Documentaci\u00f3n de Dart - Aprende los fundamentos del lenguaje de Flutter.</p> </li> </ul> </li> </ul> <p>React Native</p> <ul> <li> <p>Concepto: Creado por Meta (Facebook), React Native permite a los desarrolladores web usar sus conocimientos de JavaScript y React para crear aplicaciones m\u00f3viles. A diferencia de Flutter, React Native utiliza un \"puente\" (bridge) para comunicarse con los componentes de la UI nativa de cada plataforma. Esto puede hacer que la app se sienta un poco m\u00e1s \"nativa\".</p> </li> <li> <p>Lenguaje: JavaScript o TypeScript (una versi\u00f3n de JavaScript con tipado est\u00e1tico, muy recomendada).</p> </li> <li> <p>Ideal para: Empresas con equipos de desarrollo web que quieran pasar al m\u00f3vil, o para aplicaciones donde el aspecto nativo sea una prioridad.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>React Native (Oficial) - La documentaci\u00f3n oficial para empezar.</li> </ul> </li> </ul> <p>.NET MAUI (Multi-platform App UI)</p> <ul> <li> <p>Concepto: Es la evoluci\u00f3n de Xamarin.Forms, impulsada por Microsoft. Permite a los desarrolladores del ecosistema .NET usar C# y XAML para crear aplicaciones para iOS, Android, Windows y macOS desde una \u00fanica base de c\u00f3digo.</p> </li> <li> <p>Lenguaje: C#.</p> </li> <li> <p>Ideal para: Organizaciones que ya tienen una fuerte inversi\u00f3n en tecnolog\u00edas de Microsoft y .NET.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>.NET MAUI (Oficial) - La plataforma multiplataforma del ecosistema .NET.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-kotlin-multiplatform-kmp-lo-mejor-de-ambos-mundos","title":"C. Kotlin Multiplatform (KMP): \u00bfLo mejor de Ambos mundos?","text":"<p>Hemos analizado el desarrollo Nativo y el H\u00edbrido como dos caminos separados. El primero nos da el m\u00e1ximo rendimiento y la mejor experiencia de usuario a costa de duplicar el trabajo. El segundo nos ofrece eficiencia y una base de c\u00f3digo \u00fanica, pero a veces con compromisos en rendimiento o en acceso a las \u00faltimas funcionalidades nativas.</p> <p>Pero, \u00bfy si existiera un enfoque que intentara combinar la eficiencia del c\u00f3digo compartido con el poder del desarrollo nativo? Aqu\u00ed es donde entra en juego Kotlin Multiplatform (KMP).</p> <p>KMP no es otro framework h\u00edbrido como Flutter o React Native. Es un enfoque radicalmente diferente.</p> <p>La L\u00f3gica Compartida, la UI Nativa</p> <p>La filosof\u00eda de Kotlin Multiplatform, impulsado por JetBrains (los creadores de Kotlin y de IntelliJ), no es \"escribe una vez, ejecuta en todas partes\", sino m\u00e1s bien \"escribe la l\u00f3gica de negocio una vez, y construye la interfaz de usuario de forma nativa\".</p> <p>KMP permite a los desarrolladores escribir c\u00f3digo en Kotlin que puede ser compilado para m\u00faltiples plataformas:</p> <ul> <li>JVM (para aplicaciones Android y de servidor).</li> <li>JavaScript (para aplicaciones web).</li> <li>Nativo (utilizando la infraestructura del compilador LLVM para generar binarios para iOS, macOS, Windows, etc.).</li> </ul> <p>La idea central es identificar el c\u00f3digo que es independiente de la interfaz de usuario ---la l\u00f3gica de negocio--- y compartirlo entre plataformas.</p>"},{"location":"temas/01/index.html#que-es-la-logica-de-negocio","title":"\u00bfQu\u00e9 es la \"L\u00f3gica de Negocio\"?","text":"<p>Piensa en todo lo que tu aplicaci\u00f3n hace \"detr\u00e1s de las c\u00e1maras\":</p> <ul> <li>Acceso a la red: Realizar llamadas a una API REST o GraphQL.</li> <li>Gesti\u00f3n de la base de datos: Guardar, leer y actualizar datos en una base de datos local (como SQLite).</li> <li>Modelos de datos: Las clases que representan la informaci\u00f3n de tu app (Usuario, Producto, etc.).</li> <li>Validaciones: Comprobar que un email tiene el formato correcto o que una contrase\u00f1a cumple los requisitos.</li> <li>Algoritmos y c\u00e1lculos: Cualquier procesamiento de datos espec\u00edfico de tu aplicaci\u00f3n.</li> </ul> <p>Todo este c\u00f3digo, que suele ser el n\u00facleo de la aplicaci\u00f3n, no depende de si el bot\u00f3n en la pantalla es redondo o cuadrado. Por lo tanto, se puede escribir una sola vez en Kotlin y compartirlo.</p>"},{"location":"temas/01/index.html#y-que-pasa-con-la-interfaz-de-usuario-ui","title":"\u00bfY qu\u00e9 pasa con la Interfaz de Usuario (UI)?","text":"<p>Aqu\u00ed es donde KMP brilla y se diferencia de los frameworks h\u00edbridos. La UI se construye de forma 100% nativa en cada plataforma:</p> <ul> <li> <p>En Android: Creas tus vistas (layouts) y gestionas el ciclo de vida de las Activities y Fragments utilizando Jetpack Compose o las vistas XML tradicionales. Desde este c\u00f3digo nativo, llamas a la l\u00f3gica de negocio compartida en Kotlin.</p> </li> <li> <p>En iOS: Desarrollas tu interfaz de usuario con SwiftUI o UIKit, exactamente como lo har\u00eda un desarrollador nativo de iOS. Desde tu c\u00f3digo en Swift, puedes invocar directamente las funciones y clases del m\u00f3dulo de Kotlin compartido.</p> </li> </ul> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Nativo: Dado que la UI y toda la interacci\u00f3n con la plataforma se gestionan con c\u00f3digo nativo, el rendimiento y la fluidez son id\u00e9nticos a los de una aplicaci\u00f3n puramente nativa. No hay \"puentes\" ni capas de abstracci\u00f3n que ralenticen la interfaz.</p> </li> <li> <p>UI/UX Perfecta: La aplicaci\u00f3n se ve, se siente y se comporta exactamente como el usuario espera en su dispositivo, ya que utilizas los componentes nativos de Android (Material Design) y de iOS (Human Interface Guidelines).</p> </li> <li> <p>Eficiencia sin Sacrificios: Compartes una parte significativa del c\u00f3digo (a menudo m\u00e1s del 50-60%), lo que reduce el tiempo de desarrollo, la duplicaci\u00f3n de esfuerzos y la probabilidad de bugs, sin renunciar a las ventajas del desarrollo nativo.</p> </li> <li> <p>Acceso Inmediato a APIs Nativas: Como est\u00e1s escribiendo c\u00f3digo nativo en la capa de UI, puedes acceder a las \u00faltimas APIs de cada sistema operativo desde el primer d\u00eda, sin esperar a que un framework de terceros a\u00f1ada soporte.</p> </li> <li> <p>Adopci\u00f3n Gradual: Puedes empezar a usar KMP en una peque\u00f1a parte de una aplicaci\u00f3n existente, tanto en Android como en iOS, sin necesidad de reescribirla por completo.</p> </li> </ul> <p>Desventajas y Consideraciones</p> <ul> <li> <p>Complejidad Inicial: La configuraci\u00f3n del proyecto puede ser m\u00e1s compleja que en otros enfoques. Requiere conocimientos tanto de desarrollo en Android (Gradle) como en iOS (Xcode, CocoaPods).</p> </li> <li> <p>Se Necesitan Habilidades Nativas: A diferencia del desarrollo h\u00edbrido puro, no basta con un solo equipo de desarrolladores. Necesitas expertos que se sientan c\u00f3modos construyendo la UI en Android (Kotlin/Compose) y en iOS (Swift/SwiftUI).</p> </li> <li> <p>Ecosistema en Crecimiento: Aunque est\u00e1 madurando r\u00e1pidamente, el ecosistema de librer\u00edas multiplataforma todav\u00eda es m\u00e1s peque\u00f1o que el de plataformas como React Native o Flutter.</p> </li> </ul>"},{"location":"temas/01/index.html#un-ecosistema-en-evolucion-compose-multiplatform","title":"Un Ecosistema en Evoluci\u00f3n: Compose Multiplatform","text":"<p>Para a\u00f1adir una capa m\u00e1s, JetBrains est\u00e1 llevando Jetpack Compose (el moderno toolkit de UI declarativa de Android) al mundo multiplataforma con Compose Multiplatform.</p> <p>Compose Multiplatform permite compartir no solo la l\u00f3gica de negocio, sino tambi\u00e9n la interfaz de usuario, utilizando el mismo c\u00f3digo declarativo en Kotlin para describir la UI en Android, iOS , escritorio (Windows, macOS, Linux) y web (Wasm).</p> <p>Esto acerca a KMP al modelo de Flutter, donde tanto la l\u00f3gica como la UI son compartidas, pero con la ventaja de estar construido sobre el lenguaje y el ecosistema de Kotlin.</p> <ul> <li> <p>Recursos para profundizar:</p> <ul> <li>Kotlin Multiplatform (Oficial) - La documentaci\u00f3n oficial y el mejor lugar para empezar.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#d-progressive-web-apps-pwa-la-web-se-viste-de-app","title":"D. Progressive Web Apps (PWA): La Web se Viste de App","text":"<p>Las PWA no son aplicaciones m\u00f3viles en el sentido tradicional. Son aplicaciones web que utilizan las tecnolog\u00edas web m\u00e1s modernas para ofrecer una experiencia muy similar a la de una aplicaci\u00f3n nativa. No se instalan desde una tienda de aplicaciones, sino que el usuario puede \"a\u00f1adirlas a la pantalla de inicio\" directamente desde el navegador.</p> <p>Ventajas Clave</p> <ul> <li> <p>Sin Tiendas de Aplicaciones: No necesitas pasar por los procesos de revisi\u00f3n y publicaci\u00f3n de la App Store de Apple o Google Play. La \"instalaci\u00f3n\" es instant\u00e1nea.</p> </li> <li> <p>Multiplataforma por Definici\u00f3n: Funcionan en cualquier dispositivo que tenga un navegador web moderno (Android, iOS, Windows, macOS, etc.). El mismo c\u00f3digo sirve para todo.</p> </li> <li> <p>Siempre Actualizadas: Al ser una web, el usuario siempre tiene la \u00faltima versi\u00f3n disponible sin necesidad de actualizar nada.</p> </li> <li> <p>Compartibles: Se puede compartir la \"app\" simplemente enviando una URL.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-clave-y-lenguajes","title":"Tecnolog\u00edas Clave y Lenguajes","text":"<p>Las PWA se construyen sobre el est\u00e1ndar de la web.</p> <ul> <li> <p>Lenguajes: HTML5, CSS3, JavaScript/TypeScript.</p> </li> <li> <p>Componentes Esenciales:</p> <ul> <li> <p>HTTPS: Es un requisito de seguridad indispensable.</p> </li> <li> <p>Service Worker: Es un script que el navegador ejecuta en segundo plano. Es la tecnolog\u00eda que permite funcionalidades como el trabajo offline (acceder a la app sin conexi\u00f3n) y las notificaciones push.</p> </li> <li> <p>Web App Manifest: Es un archivo JSON que le dice al navegador c\u00f3mo debe verse y comportarse la aplicaci\u00f3n cuando se \"instala\" (nombre, icono, pantalla de bienvenida, etc.).</p> </li> </ul> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>web.dev by Google (PWA) - Una de las mejores gu\u00edas para entender y construir PWAs.</p> </li> <li> <p>MDN Web Docs: Service Worker API - Documentaci\u00f3n t\u00e9cnica de referencia.</p> </li> </ul> </li> </ul> <p>\u00bfQu\u00e9 tecnolog\u00eda y lenguaje elegir?</p> <p></p>"},{"location":"temas/01/index.html#3-el-ciclo-de-vida-de-una-aplicacion-movil","title":"3. El Ciclo de Vida de una Aplicaci\u00f3n M\u00f3vil","text":"<p>Pensemos en una aplicaci\u00f3n no como un simple programa, sino como un producto con el que un usuario interact\u00faa a lo largo del tiempo. Este viaje, desde que oye hablar de la app hasta que decide eliminarla de su tel\u00e9fono, se conoce como su ciclo de vida. Entender cada fase nos permite tomar mejores decisiones para que nuestra app no solo sea \u00fatil, sino tambi\u00e9n exitosa.</p>"},{"location":"temas/01/index.html#a-descubrimiento-como-me-encuentran","title":"A. Descubrimiento: \"\u00bfC\u00f3mo me encuentran?\"","text":"<p>Esta es la fase de \"marketing\". Nuestra aplicaci\u00f3n ya est\u00e1 terminada y publicada, pero para el usuario, todo empieza aqu\u00ed. \u00bfC\u00f3mo llega un usuario a conocer nuestra existencia entre millones de aplicaciones?</p> <ul> <li> <p>Tiendas de Aplicaciones (App Stores): Son el principal escaparate.</p> <ul> <li> <p>Google Play Store (Android) y Apple App Store (iOS) son los mercados dominantes. Act\u00faan como gigantescos centros comerciales donde los usuarios pueden buscar, explorar categor\u00edas (juegos, productividad, etc.), ver listas de \u00e9xitos (\"Top Ventas\", \"Top Gratuitas\"), y leer rese\u00f1as y valoraciones de otros usuarios.</p> </li> <li> <p>B\u00fasqueda: La mayor\u00eda de los descubrimientos ocurren a trav\u00e9s del buscador de la tienda. Por eso, un buen nombre, un icono atractivo y una descripci\u00f3n clara (lo que se conoce como ASO - App Store Optimization) son cruciales.</p> </li> <li> <p>Recomendaciones Editoriales: Ser destacado por los equipos editoriales de Google o Apple puede catapultar una aplicaci\u00f3n a la fama.</p> </li> </ul> </li> <li> <p>Otros Canales: No todo ocurre en las tiendas.</p> <ul> <li> <p>Buscadores Web: Una b\u00fasqueda en Google puede llevar a la ficha de una aplicaci\u00f3n en la tienda.</p> </li> <li> <p>Redes Sociales y \"Boca a Boca\": Recomendaciones de amigos, influencers o publicidad en plataformas como Instagram, TikTok o X.</p> </li> <li> <p>Medios de Comunicaci\u00f3n: Art\u00edculos en blogs de tecnolog\u00eda o noticias que hablen de nuestra app.</p> </li> <li> <p>Publicidad Directa: Un c\u00f3digo QR en un cartel o un enlace en una web pueden llevar directamente a la p\u00e1gina de instalaci\u00f3n.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-instalacion-te-quiero-en-mi-movil","title":"B. Instalaci\u00f3n: \"Te quiero en mi m\u00f3vil\"","text":"<p>Una vez descubierta la app, el usuario decide \"adquirirla\". Este proceso, aunque parece simple, tiene matices importantes, sobre todo en cuanto a seguridad.</p> <ul> <li> <p>Desde Tiendas Oficiales:</p> <ul> <li> <p>Este es el m\u00e9todo seguro y recomendado.</p> </li> <li> <p>El usuario pulsa el bot\u00f3n \"Instalar\" (en Google Play) o \"Obtener\" (en la App Store).</p> </li> <li> <p>La tienda gestiona todo el proceso de forma segura: verifica la identidad del usuario, descarga el paquete de la aplicaci\u00f3n (<code>.apk</code> en Android, <code>.ipa</code> en iOS) y lo instala en el dispositivo. El sistema operativo coloca el icono de la app en la pantalla de inicio o en el caj\u00f3n de aplicaciones.</p> </li> </ul> </li> <li> <p>Desde Fuentes Externas (\"Sideloading\"):</p> <ul> <li> <p>Esta opci\u00f3n es pr\u00e1cticamente exclusiva de Android. Permite a los usuarios instalar aplicaciones descargando el archivo <code>.apk</code> directamente desde una p\u00e1gina web o una tienda de aplicaciones alternativa (como F-Droid, que se especializa en software de c\u00f3digo abierto).</p> </li> <li> <p>Riesgos de Seguridad: El \"sideloading\" es la principal v\u00eda de entrada de malware en Android. La aplicaci\u00f3n no ha pasado los controles de seguridad de Google Play, por lo que podr\u00eda contener software malicioso.</p> </li> <li> <p>Por defecto, Android bloquea estas instalaciones. El usuario debe conceder expl\u00edcitamente permiso a la aplicaci\u00f3n (por ejemplo, al navegador Chrome) para \"instalar aplicaciones desconocidas\", asumiendo el riesgo que conlleva.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-ejecucion-a-funcionar","title":"C. Ejecuci\u00f3n: \"\u00a1A funcionar!\"","text":"<p>Una vez instalada, la aplicaci\u00f3n est\u00e1 lista para ser utilizada. Al pulsar su icono por primera vez, ocurren varias cosas:</p> <ol> <li> <p>Carga en Memoria: El sistema operativo carga el c\u00f3digo de la aplicaci\u00f3n en la memoria RAM del dispositivo.</p> </li> <li> <p>Pantalla de Bienvenida (Splash Screen): A menudo se muestra una pantalla de inicio con el logo de la app mientras se cargan los recursos necesarios en segundo plano.</p> </li> <li> <p>Solicitud de Permisos: \u00a1Un paso fundamental! Las aplicaciones ya no reciben todos los permisos al instalarse. Ahora, deben solicitar acceso a funciones sensibles en tiempo de ejecuci\u00f3n, es decir, la primera vez que necesitan usarlas.</p> <ul> <li> <p>Ejemplo: Una app de mensajer\u00eda pedir\u00e1 acceso a tus contactos cuando intentes buscar a un amigo, y pedir\u00e1 acceso a la c\u00e1mara cuando pulses el bot\u00f3n para hacer una foto.</p> </li> <li> <p>El usuario puede Aceptar o Denegar cada permiso individualmente. Como desarrolladores, debemos gestionar qu\u00e9 ocurre si un usuario deniega un permiso esencial.</p> </li> </ul> </li> </ol> <p>Una vez configurada y con los permisos necesarios, la aplicaci\u00f3n se encuentra en su estado normal de uso, interactuando con el usuario.</p>"},{"location":"temas/01/index.html#d-actualizacion-mejorando-contigo","title":"D. Actualizaci\u00f3n: \"Mejorando contigo\"","text":"<p>Una aplicaci\u00f3n no es un producto est\u00e1tico. El software necesita evolucionar para seguir siendo \u00fatil y seguro.</p> <ul> <li> <p>Motivos para una Actualizaci\u00f3n:</p> <ul> <li> <p>Nuevas Funcionalidades: A\u00f1adir caracter\u00edsticas que los usuarios han pedido o que mejoran el producto.</p> </li> <li> <p>Correcci\u00f3n de Errores (Bugs): Ning\u00fan software es perfecto. Las actualizaciones solucionan fallos y problemas de estabilidad.</p> </li> <li> <p>Mejoras de Rendimiento: Optimizar el c\u00f3digo para que la app sea m\u00e1s r\u00e1pida o consuma menos bater\u00eda.</p> </li> <li> <p>Parches de Seguridad: Solucionar vulnerabilidades que podr\u00edan poner en riesgo los datos del usuario.</p> </li> </ul> </li> <li> <p>Proceso de Actualizaci\u00f3n:</p> <ul> <li> <p>Autom\u00e1ticas: Es el m\u00e9todo m\u00e1s com\u00fan. Las tiendas de aplicaciones descargan e instalan las nuevas versiones en segundo plano, generalmente cuando el dispositivo est\u00e1 conectado a una red Wi-Fi y cargando, para no molestar al usuario.</p> </li> <li> <p>Manuales: El usuario puede ir a la secci\u00f3n \"Mis aplicaciones\" de la tienda y forzar la actualizaci\u00f3n de una o todas las apps pendientes.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#e-borrado-desinstalacion-ha-sido-un-placer","title":"E. Borrado (Desinstalaci\u00f3n): \"Ha sido un placer\"","text":"<p>Llega un momento en que el usuario ya no necesita la aplicaci\u00f3n. El proceso de desinstalaci\u00f3n est\u00e1 dise\u00f1ado para ser simple, pero es importante saber qu\u00e9 se elimina y qu\u00e9 puede quedar.</p> <ul> <li> <p>Proceso Est\u00e1ndar: El usuario realiza una pulsaci\u00f3n larga sobre el icono de la app y selecciona la opci\u00f3n \"Desinstalar\" o \"Eliminar App\".</p> </li> <li> <p>\u00bfDesinstalaci\u00f3n Completa o Parcial?</p> <ul> <li> <p>Generalmente, la desinstalaci\u00f3n que realiza el usuario es completa desde el punto de vista de la aplicaci\u00f3n en s\u00ed. El sistema operativo elimina:</p> <ol> <li> <p>El paquete de la aplicaci\u00f3n (<code>.apk</code> / <code>.ipa</code>).</p> </li> <li> <p>El almacenamiento privado de la app (su \"sandbox\"). Aqu\u00ed se guardan las configuraciones, bases de datos internas, cach\u00e9 y otros archivos que la app necesita para funcionar.</p> </li> </ol> </li> <li> <p>\u00bfQu\u00e9 puede quedar (Datos Residuales)? A veces, la desinstalaci\u00f3n no elimina el 100% de los datos asociados. Esto no es una \"desinstalaci\u00f3n parcial\" que el usuario elige, sino una consecuencia de c\u00f3mo funcionan los sistemas de archivos.</p> <ul> <li> <p>Archivos en Almacenamiento Compartido: Si tu aplicaci\u00f3n de edici\u00f3n de fotos guard\u00f3 una imagen en la carpeta <code>DCIM/MisFotos</code>, ese archivo no se borrar\u00e1 al desinstalar la app. El sistema lo considera propiedad del usuario, no de la aplicaci\u00f3n.</p> </li> <li> <p>Datos en la Nube: Si el usuario cre\u00f3 una cuenta en tus servidores, esa cuenta y sus datos asociados (perfil, historial, etc.) permanecen en la nube. No se eliminan al borrar la app del tel\u00e9fono. El usuario tendr\u00eda que eliminar su cuenta expl\u00edcitamente.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#comparativa-de-ciclos-de-vida-web-vs-pwa-vs-nativa","title":"Comparativa de Ciclos de Vida -- Web vs PWA vs Nativa","text":"Fase Ciclo Vida \ud83c\udf10 Web Tradicional \ud83d\ude80 Progressive Web App (PWA) \ud83d\udcf1 Aplicaci\u00f3n 1. Descubrimiento M\u00e1xima visibilidad. A trav\u00e9s de buscadores (Google, etc.), enlaces, redes sociales. No depende de una tienda. Lo mejor de ambos mundos. Descubrible como una web (buscadores, enlaces) y potencialmente listada en tiendas de apps (ej. Google Play). Dependiente de la tienda. Principalmente a trav\u00e9s de la App Store y Google Play. El ASO es crucial. 2. Instalaci\u00f3n Sin instalaci\u00f3n. La principal ventaja. El usuario accede al instante. Cero fricci\u00f3n. Instalaci\u00f3n opcional y ligera. El usuario puede \"A\u00f1adir a la pantalla de inicio\". Es un proceso casi instant\u00e1neo y no ocupa mucho espacio. Instalaci\u00f3n obligatoria. El usuario debe ir a la tienda, descargar varios MB (o GB) y esperar a que se instale. Es el punto de mayor fricci\u00f3n. 3.  Ejecuci\u00f3n Dentro del navegador. Se ejecuta en una pesta\u00f1a, con las limitaciones de la interfaz del navegador (barra de URL, etc.). Requiere conexi\u00f3n. Como una app. Se lanza desde su propio icono en la pantalla de inicio, a pantalla completa. Puede funcionar offline gracias al Service Worker. Directamente en el SO. Se lanza desde su icono. Ofrece la m\u00e1xima integraci\u00f3n, rendimiento y acceso completo al hardware del dispositivo (c\u00e1mara, GPS, etc.). 4. Actualizaci\u00f3n Transparente e instant\u00e1nea. Cada vez que el usuario entra, recibe la \u00faltima versi\u00f3n del servidor. No hay proceso de actualizaci\u00f3n. Autom\u00e1tica y en segundo plano. El Service Worker busca y actualiza la app de forma silenciosa. El usuario tiene la nueva versi\u00f3n la pr\u00f3xima vez que la abre. Gestionada por la tienda. Puede ser autom\u00e1tica o manual. Requiere descargar de nuevo el paquete completo o una parte, y un proceso de instalaci\u00f3n. 5. Borrado No existe. El usuario simplemente cierra la pesta\u00f1a o borra el historial/cach\u00e9 del navegador. Sencillo. El usuario elimina el icono de la pantalla de inicio, igual que en una app nativa. Los datos se pueden borrar desde la configuraci\u00f3n del navegador. Proceso manual. El usuario debe realizar una desinstalaci\u00f3n expl\u00edcita (pulsaci\u00f3n larga, etc.) para liberar el espacio de almacenamiento. <p>\u26a1 An\u00e1lisis Detallado de las Diferencias</p>"},{"location":"temas/01/index.html#friccion-en-la-entrada-la-gran-diferencia","title":"Fricci\u00f3n en la Entrada: La Gran Diferencia","text":"<p>La principal ventaja de la web y las PWAs es la inmediatez. Piensa en cu\u00e1ntas veces has entrado a una web que no conoc\u00edas frente a cu\u00e1ntas apps nuevas has instalado en el \u00faltimo mes. El proceso de ir a una tienda, esperar la descarga y la instalaci\u00f3n es una barrera (fricci\u00f3n) que hace que muchos usuarios abandonen el proceso. Una PWA elimina casi por completo esa barrera, ofreciendo una experiencia similar a la nativa con la facilidad de acceso de una web.</p>"},{"location":"temas/01/index.html#capacidades-y-acceso-al-dispositivo","title":"Capacidades y Acceso al Dispositivo","text":"<p>Aqu\u00ed es donde la aplicaci\u00f3n nativa sigue siendo la reina.</p> <ul> <li> <p>Web: Est\u00e1 limitada por el \"sandbox\" (caja de arena) del navegador. Tiene acceso limitado a sensores y hardware.</p> </li> <li> <p>PWA: Mejora mucho respecto a la web. Gracias a las nuevas APIs, puede acceder a notificaciones push, ubicaci\u00f3n, c\u00e1mara y funcionamiento offline. Sin embargo, todav\u00eda tiene un acceso m\u00e1s restringido que una app nativa, especialmente en iOS.</p> </li> <li> <p>Nativa: Tiene acceso total y de m\u00e1ximo rendimiento a todas las capacidades del dispositivo: NFC, Bluetooth avanzado, sensores, archivos del sistema, etc.</p> </li> </ul>"},{"location":"temas/01/index.html#el-proceso-de-actualizacion-control-vs-inmediatez","title":"El Proceso de Actualizaci\u00f3n: Control vs. Inmediatez","text":"<ul> <li> <p>El modelo nativo da al usuario (y al desarrollador) un mayor control sobre las versiones. A veces, los usuarios deciden no actualizar una app si no les gusta la nueva versi\u00f3n.</p> </li> <li> <p>El modelo web/PWA es mucho m\u00e1s \u00e1gil. Como desarrollador, te aseguras de que todos tus usuarios est\u00e1n utilizando siempre la \u00faltima versi\u00f3n, lo que simplifica enormemente el mantenimiento y la correcci\u00f3n de errores. No tienes que dar soporte a versiones antiguas.</p> </li> </ul> <p>No hay una tecnolog\u00eda superior a las otras en todos los aspectos. La elecci\u00f3n depende enteramente del prop\u00f3sito del proyecto.</p> <ul> <li> <p>Para una herramienta que necesita el m\u00e1ximo rendimiento y una integraci\u00f3n profunda con el hardware (un juego, una app de edici\u00f3n de v\u00eddeo, una app que use Bluetooth intensivamente), el camino nativo es indiscutible.</p> </li> <li> <p>Para un blog, una tienda online o una herramienta de consulta donde la inmediatez y el alcance son lo m\u00e1s importante, una PWA es una soluci\u00f3n fant\u00e1stica, ya que combina la visibilidad de la web con una experiencia de usuario muy mejorada.</p> </li> <li> <p>Una web tradicional sigue siendo perfecta para contenido informativo simple o sitios donde la funcionalidad offline y las notificaciones no aportan un valor a\u00f1adido significativo.</p> </li> </ul>"},{"location":"temas/01/index.html#android-el-sdk-de-android-y-sus-versiones","title":"Android: El SDK de Android y sus Versiones","text":"<p>En este apartado vamos a desmontar la \"caja de herramientas\" que nos permite construir aplicaciones para Android. Hablaremos del SDK, de sus componentes y de c\u00f3mo entender el sistema de versiones de Android, que es crucial para garantizar que nuestras apps funcionen correctamente en la mayor\u00eda de dispositivos posibles.</p> <p>Pensemos en nosotros como chefs que quieren preparar un plato espec\u00edfico (nuestra app). El SDK ser\u00eda nuestra cocina profesional: no solo nos da los ingredientes (las APIs), sino tambi\u00e9n los cuchillos, los fogones y los manuales de recetas (las herramientas y la documentaci\u00f3n). Sin esta cocina, solo tendr\u00edamos ideas, pero no podr\u00edamos cocinar nada.</p>"},{"location":"temas/01/index.html#a-que-es-un-sdk-software-development-kit","title":"A. \u00bfQu\u00e9 es un SDK (Software Development Kit)?","text":"<p>Un SDK, o Kit de Desarrollo de Software, es un conjunto de herramientas de software y programas proporcionados por un fabricante de hardware o software para permitir la creaci\u00f3n de aplicaciones para una plataforma espec\u00edfica. En nuestro caso, Google nos proporciona el SDK de Android para que podamos crear apps para su sistema operativo.</p> <p>Un SDK t\u00edpicamente incluye:</p> <ul> <li> <p>Bibliotecas de c\u00f3digo (APIs): C\u00f3digo preescrito que nos da acceso a las funcionalidades del dispositivo, como la c\u00e1mara, el GPS o la interfaz de usuario.</p> </li> <li> <p>Depurador (Debugger): Una herramienta para encontrar y corregir errores en nuestro c\u00f3digo.</p> </li> <li> <p>Documentaci\u00f3n: Manuales, gu\u00edas y ejemplos que nos ense\u00f1an a usar las herramientas y las bibliotecas.</p> </li> <li> <p>Emuladores: Programas que nos permiten probar nuestra app en un dispositivo virtual sin necesidad de tener un tel\u00e9fono f\u00edsico.</p> </li> </ul> <p>En resumen, el SDK es el paquete TODO-EN-UNO indispensable para empezar a desarrollar.</p>"},{"location":"temas/01/index.html#b-los-componentes-del-sdk-de-android","title":"B. Los Componentes del SDK de Android","text":"<p>Dentro de Android Studio, el SDK se gestiona a trav\u00e9s del \"SDK Manager\" y se divide principalmente en dos pesta\u00f1as: SDK Platforms y SDK Tools. Es vital entender la diferencia.</p>"},{"location":"temas/01/index.html#sdk-platforms","title":"SDK Platforms","text":"<p>Piensa en una \"Platform\" como una versi\u00f3n espec\u00edfica y completa del sistema operativo Android empaquetada para el desarrollador. Cada \"Platform\" corresponde a un nivel de API concreto (que veremos m\u00e1s adelante).</p> <p>Cada paquete de \"SDK Platform\" incluye:</p> <ul> <li> <p>El <code>android.jar</code>: Este es el archivo clave. Contiene todas las APIs y clases de esa versi\u00f3n de Android contra las que compilaremos nuestro c\u00f3digo. Es nuestro \"diccionario\" de funcionalidades disponibles.</p> </li> <li> <p>Imagen del Sistema (System Image): Es una copia del sistema operativo Android que se usa para ejecutar los emuladores. Si quieres probar tu app en un emulador de Android 14, necesitas descargar la \"System Image\" de Android 14.</p> </li> </ul> <p>En resumen: Si quieres que tu app use funciones de Android 14 y probarla en un emulador de Android 14, necesitas descargar la \"SDK Platform\" para el nivel de API de Android 14.</p>"},{"location":"temas/01/index.html#sdk-tools","title":"SDK Tools","text":"<p>Estas son las herramientas independientes de la versi\u00f3n de Android que usamos para desarrollar, depurar y probar nuestra aplicaci\u00f3n. Son la maquinaria de nuestra cocina. No importa si cocinamos una receta de 2020 o de 2024, los fogones y cuchillos son los mismos (aunque se afilen y mejoren de vez en cuando).</p> <p>Las herramientas m\u00e1s importantes aqu\u00ed son:</p> <ul> <li> <p>Android SDK Build-Tools: Un conjunto de herramientas que toman nuestro c\u00f3digo y lo compilan y empaquetan en un archivo <code>.apk</code> o <code>.aab</code> instalable.</p> </li> <li> <p>Android Emulator: El software que nos permite crear y ejecutar dispositivos virtuales.</p> </li> <li> <p>Android SDK Platform-Tools: Incluye herramientas de l\u00ednea de comandos esenciales como:</p> <ul> <li> <p>ADB (Android Debug Bridge): El \"puente\" de comunicaci\u00f3n entre nuestro ordenador y el dispositivo (f\u00edsico o emulado). Nos permite instalar apps, depurar, ver logs, etc.</p> </li> <li> <p>Fastboot: Para flashear el firmware del dispositivo.</p> </li> </ul> </li> </ul> <p>En resumen: Las SDK Tools son las herramientas generales para construir y probar, mientras que las SDK Platforms son los \"ingredientes\" espec\u00edficos de cada versi\u00f3n de Android.</p>"},{"location":"temas/01/index.html#c-entendiendo-las-versiones-de-android-la-clave-esta-en-el-nivel-de-api","title":"C. Entendiendo las Versiones de Android: \u00a1La Clave est\u00e1 en el Nivel de API!","text":"<p>Aqu\u00ed es donde muchos estudiantes se l\u00edan. Google usa dos nombres para cada versi\u00f3n de Android, y es crucial saber cu\u00e1l es el importante para nosotros, los desarrolladores.</p>"},{"location":"temas/01/index.html#nombre-comercial-y-postre","title":"Nombre Comercial (y postre \ud83c\udf70)","text":"<p>Es el nombre p\u00fablico y de marketing que Google utiliza para cada gran lanzamiento. Suelen ser nombres de postres o dulces en orden alfab\u00e9tico (aunque esta tradici\u00f3n se ha relajado en los \u00faltimos a\u00f1os).</p> <ul> <li>Ejemplos: Android 8 (Oreo), Android 9 (Pie), Android 10, Android 11, Android 12 (Snow Cone).</li> </ul> <p>Este nombre es \u00fatil para los usuarios, pero casi irrelevante para los desarrolladores. Es una etiqueta de marketing.</p>"},{"location":"temas/01/index.html#nivel-de-api-api-level","title":"Nivel de API (API Level)","text":"<p>Este es el n\u00famero que realmente nos importa. El Nivel de API es un \u00fanico n\u00famero entero que identifica de forma inequ\u00edvoca la versi\u00f3n del framework de APIs que ofrece una plataforma Android.</p> <p>Cuando se lanzan nuevas funcionalidades para desarrolladores (por ejemplo, un nuevo tipo de notificaci\u00f3n o un permiso de privacidad), Google incrementa el Nivel de API.</p> <p>\u00bfPor qu\u00e9 es tan importante? Porque nuestro c\u00f3digo se escribe \"contra\" un nivel de API. Si usamos una funci\u00f3n que se introdujo en el API Level 33 (Android 13), nuestra aplicaci\u00f3n no funcionar\u00e1 en un dispositivo con API Level 32 (Android 12L), porque esa funci\u00f3n simplemente no existe en ese sistema operativo. \u00a1La app \"crashear\u00e1\"!</p>"},{"location":"temas/01/index.html#d-listado-de-versiones-de-android","title":"D. Listado de Versiones de Android","text":"<p>Las versiones de Android incluyen nombres de dulces y postres como\u00a0Cupcake, Donut, Eclair, Froyo, Gingerbread, Honeycomb, Ice Cream Sandwich, Jelly Bean, KitKat, Lollipop, Marshmallow, Nougat, Oreo y Pie.\u00a0Posteriormente, a partir de Android 10, se han numerado las versiones (Android 10, 11, 12, 13, 14, 15, etc.).\u00a0</p> <p>Versiones antiguas (con nombres de postres)\u00a0</p> <ul> <li>Android 1.5\u00a0- Cupcake</li> <li>Android 1.6\u00a0- Donut</li> <li>Android 2.0/2.1\u00a0- Eclair</li> <li>Android 2.2\u00a0- Froyo</li> <li>Android 2.3\u00a0- Gingerbread</li> <li>Android 3.0\u00a0- Honeycomb</li> <li>Android 4.0\u00a0- Ice Cream Sandwich</li> <li>Android 4.1 - 4.3\u00a0- Jelly Bean</li> <li>Android 4.4\u00a0- KitKat</li> <li>Android 5.0/5.1\u00a0- Lollipop</li> <li>Android 6.0\u00a0- Marshmallow</li> <li>Android 7.0/7.1\u00a0- Nougat</li> <li>Android 8.0/8.1\u00a0- Oreo</li> <li>Android 9.0\u00a0- Pie</li> </ul> <p>Versiones recientes (numeradas)\u00a0</p> <ul> <li>Android 10\u00a0- Fue la primera versi\u00f3n sin nombre de postre.</li> <li>Android 11\u00a0- Lanzada en 2020.</li> <li>Android 12\u00a0- Lanzada en 2021, con una variante optimizada para pantallas grandes llamada Android 12L.</li> <li>Android 13\u00a0- Lanzada en 2022.</li> <li>Android 14\u00a0- Lanzada en 2023.</li> <li>Android 15\u00a0- Lanzada en 2024.</li> <li>Android 16\u00a0- Lanzada en 2025.</li> </ul> <p>C\u00f3mo verificar la versi\u00f3n de Android en tu dispositivo\u00a0</p> <ul> <li>Abre la aplicaci\u00f3n Configuraci\u00f3n o Ajustes.</li> <li>Despl\u00e1zate hacia abajo y selecciona Acerca del tel\u00e9fono o Acerca de la tablet.</li> <li>Busca la opci\u00f3n Versi\u00f3n de Android para ver la informaci\u00f3n de tu sistema operativo.</li> </ul> <p>\u2139\ufe0f M\u00e1s informaci\u00f3n en: Lista de versiones de Android</p>"},{"location":"temas/02/index.html","title":"Inicio","text":""},{"location":"temas/02/index.html#ut2-programacion-de-aplicaciones-para-dispositivos-moviles-en-android","title":"UT2. Programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android","text":"<p>En este tema veremos una visi\u00f3n general de la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android, comenzando a crear las primeras aplicaciones, y entendiendo los conceptos b\u00e1sicos de la plataforma Android.</p> <p>Android permite crear aplicaciones utilizando Java o Kotlin, siendo este \u00faltimo el lenguaje recomendado por Google para el desarrollo de aplicaciones Android.</p> <ul> <li>En lenguaje Kotlin</li> </ul> <p>\u00cdndice:</p> <ul> <li>2.1 Primeros pasos</li> <li>2.2 Ciclo de vida de una aplicaci\u00f3n Android</li> <li>2.3 Primera aplicaci\u00f3n</li> <li>2.4 Gesti\u00f3n del estado</li> <li>2.5 Mejorando el c\u00f3digo</li> <li>2.6 Listas en Compose</li> </ul> <p></p>"},{"location":"temas/02/index.html#recursos","title":"\ud83d\udcc1 Recursos","text":"Android y Jetpack ComposeKotlin <ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.  </li> </ul> <ul> <li>Curso: Android con Kotlin (youtube)</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html","title":"2.1. Primeros pasos","text":""},{"location":"temas/02/2.1-primeros-pasos.html#21-primeros-pasos-con-android","title":"2.1 Primeros pasos con Android","text":"<p>En este apartado vamos a dar los primeros pasos en la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles con Android, y en este punto, la parte fundamental es conocer el entorno de desarrollo Android Studio, y entender los conceptos b\u00e1sicos de la plataforma Android.</p>"},{"location":"temas/02/2.1-primeros-pasos.html#a-instalar-y-configurar-android-studio","title":"A. Instalar y configurar Android Studio","text":"<p>Para comenzar a desarrollar aplicaciones Android, lo primero que necesitas es instalar Android Studio, que es el entorno de desarrollo oficial para Android. Puedes descargarlo desde la p\u00e1gina oficial de Android Studio: https://developer.android.com/studio.</p> <p>Una vez que hayas descargado e instalado Android Studio, sigue estos pasos para configurarlo:</p> <ol> <li>Instalar el SDK de Android: Durante la instalaci\u00f3n de Android Studio, aseg\u00farate de seleccionar la opci\u00f3n para instalar el SDK de Android. Esto es necesario para compilar y ejecutar aplicaciones Android.</li> <li>Configurar un emulador: Android Studio incluye un emulador que te permite probar tus aplicaciones en diferentes dispositivos virtuales. Configura un emulador con las caracter\u00edsticas que desees (tama\u00f1o de pantalla, versi\u00f3n de Android, etc.) desde el AVD Manager (Android Virtual Device Manager).</li> <li>Crear un nuevo proyecto: Una vez que Android Studio est\u00e9 configurado, crea un nuevo proyecto seleccionando y elige una plantilla b\u00e1sica para comenzar.</li> <li>Familiarizarse con la interfaz: T\u00f3mate un tiempo para explorar la interfaz de Android Studio, incluyendo el editor de c\u00f3digo, el dise\u00f1ador de interfaces, el panel de herramientas y la consola de logcat.</li> <li>Ejecutar la aplicaci\u00f3n: Finalmente, ejecuta tu aplicaci\u00f3n en el emulador o en un dispositivo f\u00edsico conectado para asegurarte de que todo est\u00e9 funcionando correctamente.</li> </ol> Video: Instalaci\u00f3n y configuraci\u00f3n de Android Studio <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#b-estructura-de-un-proyecto-android","title":"B. Estructura de un proyecto Android","text":"<p>Un proyecto Android tiene una estructura espec\u00edfica que incluye varios archivos y carpetas importantes. A continuaci\u00f3n, se describen las principales partes de un proyecto Android. Android Studio tiene diferentes vistas para explorar la estructura de un proyecto. La vista \"Android\" es la m\u00e1s com\u00fan y muestra una estructura simplificada y organizada del proyecto.</p> <p>Vamos a explorar las diferentes vistas disponibles en Android Studio para entender mejor la estructura de un proyecto Android en el siguiente v\u00eddeo:</p> Video: Estructura de un proyecto en Android Studio <p></p> <p>La vista m\u00e1s com\u00fan y utilizada es la vista \"Android\", que organiza los archivos y carpetas de manera l\u00f3gica para facilitar la navegaci\u00f3n y el desarrollo. A continuaci\u00f3n, se describen las principales partes de un proyecto Android en la vista \"Android\".</p> <p>Estructura de un proyecto Android</p> <p>Esta es la estructura t\u00edpica de un proyecto Android en la vista \"Android\" de Android Studio:</p> <ul> <li>app: Esta es la carpeta principal que contiene el c\u00f3digo fuente y los recursos de la aplicaci\u00f3n.<ul> <li>manifests: Contiene el archivo <code>AndroidManifest.xml</code>, que define la configuraci\u00f3n b\u00e1sica de la aplicaci\u00f3n, como las actividades, permisos y servicios.</li> <li>java: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n en lenguaje Kotlin o Java. Aqu\u00ed es donde escribir\u00e1s la l\u00f3gica de tu aplicaci\u00f3n.</li> <li>res: Contiene los recursos de la aplicaci\u00f3n, como im\u00e1genes, archivos XML de dise\u00f1o, cadenas de texto y estilos.</li> <li>drawable: Carpeta para almacenar im\u00e1genes y gr\u00e1ficos utilizados en la aplicaci\u00f3n.</li> <li>layout: Carpeta para almacenar archivos XML que definen la interfaz de usuario (UI) de las actividades y fragmentos.</li> <li>values: Carpeta para almacenar archivos XML que contienen recursos como cadenas de texto, colores y estilos.</li> </ul> </li> <li>Gradle Scripts: Contiene los archivos de configuraci\u00f3n de Gradle, que es el sistema de construcci\u00f3n utilizado por Android Studio. Aqu\u00ed puedes definir dependencias, versiones de SDK y otras configuraciones de construcci\u00f3n.</li> <li>build.gradle (Project): Archivo de configuraci\u00f3n a nivel de proyecto.</li> <li>build.gradle (Module: app): Archivo de configuraci\u00f3n a nivel de m\u00f3dulo (aplicaci\u00f3n).</li> <li>settings.gradle: Archivo que define los m\u00f3dulos del proyecto.</li> <li>local.properties: Archivo que contiene la ruta del SDK de Android en tu sistema. Este archivo no debe ser compartido en sistemas de control de versiones.</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html#c-estructura-del-buildgradle","title":"C. Estructura del build.gradle","text":"<p>El archivo <code>build.gradle</code> es un archivo de configuraci\u00f3n utilizado por Gradle, el sistema de construcci\u00f3n utilizado por Android Studio. Este archivo define c\u00f3mo se debe construir y empaquetar la aplicaci\u00f3n, as\u00ed como las dependencias necesarias para el proyecto.</p> <p>\u00bfQu\u00e9 es Gradle?</p> <p>Gradle es un sistema de automatizaci\u00f3n de construcci\u00f3n que se utiliza para compilar, probar y empaquetar aplicaciones. En el contexto de Android, Gradle se utiliza para gestionar las dependencias, configurar las variantes de construcci\u00f3n y definir tareas personalizadas.</p> <p>El archivo <code>build.gradle</code> se encuentra en la ra\u00edz del proyecto y en el m\u00f3dulo de la aplicaci\u00f3n (generalmente llamado <code>app</code>). A continuaci\u00f3n, se describen las principales secciones y configuraciones que puedes encontrar en un archivo <code>build.gradle</code> t\u00edpico para un proyecto Android.</p> <p>En el siguiente v\u00eddeo se explica la estructura del archivo <code>build.gradle</code> y c\u00f3mo configurarlo para un proyecto Android.</p> Video: Estructura del build.gradle de App <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#d-partes-de-la-interfaz-de-android-studio","title":"D. Partes de la interfaz de Android Studio","text":"<p>Android Studio es un entorno de desarrollo integrado (IDE) completo que proporciona una amplia gama de herramientas y caracter\u00edsticas para desarrollar aplicaciones Android. A continuaci\u00f3n, se describen las principales partes de la interfaz de Android Studio:</p> Video: Partes de la interfaz de Android Studio <p></p> Partes de la interfaz de Android Studio <ul> <li> <p>Barra de men\u00fa: La barra de men\u00fa en la parte superior de la ventana proporciona acceso a diversas funciones y configuraciones, como crear nuevos proyectos, abrir archivos, ejecutar aplicaciones y acceder a herramientas de desarrollo.</p> </li> <li> <p>Barra de herramientas: Justo debajo de la barra de men\u00fa, la barra de herramientas contiene botones para acciones comunes, como ejecutar y depurar aplicaciones, sincronizar el proyecto con Gradle y acceder al AVD Manager.</p> </li> <li> <p>Panel del proyecto: En el lado izquierdo de la ventana, el panel del proyecto muestra la estructura del proyecto y permite navegar por los archivos y carpetas del proyecto. Puedes cambiar entre diferentes vistas, como \"Android\", \"Project\" y \"Packages\".</p> </li> <li> <p>Editor de c\u00f3digo: El editor de c\u00f3digo ocupa la mayor parte de la ventana y es donde escribir\u00e1s y editar\u00e1s el c\u00f3digo fuente de tu aplicaci\u00f3n. El editor ofrece caracter\u00edsticas como resaltado de sintaxis, autocompletado y refactorizaci\u00f3n.</p> </li> <li> <p>Dise\u00f1ador de interfaces: Android Studio incluye un dise\u00f1ador visual que te permite crear y editar interfaces de usuario (UI) utilizando un editor gr\u00e1fico. Puedes arrastrar y soltar componentes UI desde una paleta y ajustar sus propiedades.</p> </li> <li> <p>Panel de herramientas: En el lado derecho de la ventana, el panel de herramientas proporciona acceso a diversas herramientas \u00fatiles, como el inspector de dise\u00f1o, el administrador de dispositivos virtuales (AVD Manager) y el administrador de SDK.</p> </li> <li> <p>Consola de logcat: En la parte inferior de la ventana, la consola de logcat muestra los mensajes de registro generados por la aplicaci\u00f3n en ejecuci\u00f3n. Esto es \u00fatil para depurar y solucionar problemas en tu aplicaci\u00f3n.</p> </li> <li> <p>Ventana emergente de terminal: Android Studio incluye una terminal integrada que te permite ejecutar comandos directamente desde el IDE. Puedes abrirla desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Terminal\".</p> </li> <li> <p>Ventana emergente de problemas: Esta ventana muestra advertencias y errores relacionados con el c\u00f3digo fuente y las configuraciones del proyecto. Puedes acceder a ella desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Problems\".</p> </li> <li> <p>Ventana emergente de estructura: La ventana emergente de estructura muestra una vista jer\u00e1rquica del archivo actualmente abierto en el editor. Puedes acceder a ella desde el men\u00fa \"</p> </li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html","title":"2.2. Ciclo de Vida","text":""},{"location":"temas/02/2.2-ciclo-vida-app.html#22-ciclo-de-vida-de-una-aplicacion-android","title":"2.2 Ciclo de vida de una aplicaci\u00f3n Android","text":"<p>El ciclo de vida de una aplicaci\u00f3n Android es el conjunto de estados por los que pasa una aplicaci\u00f3n desde que se inicia hasta que se detiene. Comprender el ciclo de vida de una aplicaci\u00f3n es fundamental para desarrollar aplicaciones robustas y eficientes en Android. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#a-componentes-del-ciclo-de-vida","title":"A. Componentes del ciclo de vida","text":"<p>En Android, los componentes del ciclo de vida de una aplicaci\u00f3n son actividades, fragmentos, servicios y receptores de difusi\u00f3n. Cada uno de estos componentes tiene su propio ciclo de vida y se comporta de manera diferente en funci\u00f3n de los eventos que se producen en la aplicaci\u00f3n.</p> <p>Vamos a centrarnos en las Actividades o <code>Activity</code>, que son los componentes principales de una aplicaci\u00f3n Android y representan una \u00fanica pantalla con la que el usuario puede interactuar. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#que-es-una-activity","title":"\u00bfQu\u00e9 es una Activity?","text":"<p>Una Activity es uno de los componentes fundamentales de una aplicaci\u00f3n de Android. En t\u00e9rminos simples, una Activity representa una \u00fanica pantalla con una interfaz de usuario (UI). Piensa en cualquier aplicaci\u00f3n que uses: la lista de correos en Gmail, la pantalla para redactar un nuevo email, o la pantalla de configuraci\u00f3n; cada una de estas es, generalmente, una Activity.</p> <p>Sin embargo, su funci\u00f3n va m\u00e1s all\u00e1 de ser solo un contenedor visual. Es el punto de entrada para la interacci\u00f3n del usuario y el lugar donde se aloja la l\u00f3gica de la interfaz. Cada Activity es una clase en tu c\u00f3digo que se encarga de:</p> <ul> <li> <p>Dibujar la interfaz de usuario: Infla los layouts XML que definen la apariencia y la disposici\u00f3n de los elementos en pantalla (botones, texto, im\u00e1genes, etc.).</p> </li> <li> <p>Gestionar eventos del usuario: Responde a las interacciones del usuario, como toques en botones, deslizamientos o entradas de texto.</p> </li> <li> <p>Coordinar la l\u00f3gica de la pantalla: Ejecuta el c\u00f3digo necesario para que esa pantalla funcione como se espera.</p> </li> </ul> <p>Una aplicaci\u00f3n suele estar compuesta por m\u00faltiples Activities que se comunican entre s\u00ed. Por ejemplo, una Activity puede iniciar otra para realizar una acci\u00f3n diferente. Cuando una nueva Activity se inicia, la anterior se detiene y se coloca en una pila (conocida como \"back stack\" o pila de retroceso). Esto permite al usuario navegar hacia atr\u00e1s presionando el bot\u00f3n correspondiente. </p> Video: \u00bfQu\u00e9 es una Activity en Android? <p></p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#estados-de-una-actividad","title":"Estados de una actividad","text":"<p>Las actividades en Android pueden estar en uno de los siguientes estados:</p> <ul> <li>Created: La actividad ha sido creada pero a\u00fan no es visible para el usuario.</li> <li>Started: La actividad es visible para el usuario pero no tiene el foco.</li> <li>Resumed: La actividad est\u00e1 en primer plano y tiene el foco.</li> <li>Paused: La actividad ha perdido el foco pero a\u00fan es visible para el usuario.</li> <li>Stopped: La actividad ya no es visible para el usuario.</li> <li>Destroyed: La actividad ha sido destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#metodos-del-ciclo-de-vida","title":"M\u00e9todos del ciclo de vida","text":"<p>En Android, cada actividad tiene una serie de m\u00e9todos que se invocan en funci\u00f3n de su estado en el ciclo de vida. Algunos de los m\u00e9todos m\u00e1s comunes son:</p> <ul> <li><code>onCreate()</code>: Se llama cuando la actividad se crea por primera vez.</li> <li><code>onStart()</code>: Se llama cuando la actividad se hace visible para el usuario.</li> <li><code>onResume()</code>: Se llama cuando la actividad obtiene el foco y se convierte en activa.</li> <li><code>onPause()</code>: Se llama cuando la actividad pierde el foco pero a\u00fan es visible.</li> <li><code>onStop()</code>: Se llama cuando la actividad ya no es visible para el usuario.</li> <li><code>onDestroy()</code>: Se llama cuando la actividad es destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#ejemplo-de-ciclo-de-vida-de-una-actividad","title":"Ejemplo de ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra un ejemplo del ciclo de vida de una actividad en Android:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(\"MainActivity\", \"onCreate\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        Log.d(\"MainActivity\", \"onStart\")\n    }\n\n    override fun onResume() {\n        super.onResume()\n        Log.d(\"MainActivity\", \"onResume\")\n    }\n\n    override fun onPause() {\n        super.onPause()\n        Log.d(\"MainActivity\", \"onPause\")\n    }\n\n    override fun onStop() {\n        super.onStop()\n        Log.d(\"MainActivity\", \"onStop\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"MainActivity\", \"onDestroy\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una actividad <code>MainActivity</code> con los m\u00e9todos del ciclo de vida m\u00e1s comunes. Cada m\u00e9todo imprime un mensaje de registro en la consola para indicar en qu\u00e9 estado se encuentra la actividad.</p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#imagen-del-ciclo-de-vida-de-una-actividad","title":"Imagen del ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra una imagen que representa el ciclo de vida de una actividad en Android:</p> <p></p> <p>C\u00f3mo podemos observar, el ciclo de vida de una actividad en Android consta de varios estados y transiciones entre ellos. </p> <p>Es importante comprender estos estados para gestionar correctamente el ciclo de vida de una aplicaci\u00f3n Android.</p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#la-activity-el-contenedor-principal-de-tu-pantalla","title":"La activity: El contenedor Principal de tu Pantalla","text":"<p>Imagina una aplicaci\u00f3n como una obra de teatro. La Activity ser\u00eda el escenario principal donde se desarrolla un acto completo. En t\u00e9rminos m\u00e1s t\u00e9cnicos, una <code>Activity</code> es un componente de la aplicaci\u00f3n que proporciona una pantalla con la que los usuarios pueden interactuar para hacer algo, como marcar un n\u00famero de tel\u00e9fono, tomar una foto, enviar un correo electr\u00f3nico o ver un mapa. Cada <code>Activity</code> recibe una ventana en la que puede dibujar su interfaz de usuario.</p> <p>Piensa en las aplicaciones que usas a diario. Cuando abres tu cliente de correo, la lista de correos es probablemente una <code>Activity</code>. Al hacer clic en un correo, se abre una nueva pantalla para leerlo; esa es otra <code>Activity</code>.</p> <p>Ejemplo Pr\u00e1ctico:</p> <p>Supongamos que estamos creando una aplicaci\u00f3n de notas simple. La pantalla principal que muestra la lista de todas las notas ser\u00eda nuestra <code>MainActivity</code>.</p> <pre><code>// MainActivity.kt\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // Aqu\u00ed inicializar\u00edamos la lista de notas, etc.\n    }\n}\n</code></pre> <p>Y su correspondiente layout en XML:</p> <pre><code>&lt;!-- activity_main.xml --&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;ListView\n        android:id=\"@+id/notes_list\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"temas/02/2.2-ciclo-vida-app.html#practicamos-etapas-del-ciclo-de-vida","title":"\ud83d\ude80 Pr\u00e1cticamos: Etapas del ciclo de vida","text":"<p>Para esta pr\u00e1ctica, vamos a ejecutar una App, y probar cada una de las etapas del ciclo de vida..</p> <p>Para ello, realiza el siguiente Codelab:</p> <ul> <li>Etapas del ciclo de vida de la actividad Codelab.</li> </ul> <p></p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#el-ciclo-de-vida-de-la-activity-nacer-vivir-y-morir","title":"El Ciclo de Vida de la Activity: Nacer, Vivir y Morir","text":"<p>Una <code>Activity</code> no existe de forma est\u00e1tica; pasa por diferentes estados a lo largo de su existencia, desde que se crea hasta que se destruye. Este es el famoso ciclo de vida de la Activity, y entenderlo es absolutamente crucial para construir aplicaciones robustas y evitar errores, como fugas de memoria o fallos inesperados.</p> <p>El sistema operativo Android gestiona estos estados a trav\u00e9s de una serie de m\u00e9todos que puedes sobrescribir en tu clase <code>Activity</code>:</p> <ul> <li><code>onCreate()</code>: Es el primer m\u00e9todo que se llama cuando se crea la <code>Activity</code>. Aqu\u00ed es donde debes realizar toda la inicializaci\u00f3n est\u00e1tica: crear vistas, vincular datos a listas, etc. Este m\u00e9todo recibe un <code>Bundle</code> que contiene el estado previamente guardado de la actividad, si es que existe (por ejemplo, despu\u00e9s de una rotaci\u00f3n de pantalla).</li> <li><code>onStart()</code>: Se llama cuando la <code>Activity</code> est\u00e1 a punto de hacerse visible para el usuario.</li> <li><code>onResume()</code>: Se invoca cuando la <code>Activity</code> ya es visible y el usuario puede empezar a interactuar con ella. La <code>Activity</code> permanece en este estado hasta que algo interrumpe el foco, como una llamada telef\u00f3nica entrante o la navegaci\u00f3n a otra <code>Activity</code>.</li> <li><code>onPause()</code>: Es la contraparte de <code>onResume()</code>. Se llama cuando la <code>Activity</code> est\u00e1 a punto de pasar a segundo plano, pero a\u00fan es parcialmente visible. Aqu\u00ed deber\u00edas detener operaciones que consuman muchos recursos y que no necesiten ejecutarse mientras la <code>Activity</code> no est\u00e1 en primer plano.</li> <li><code>onStop()</code>: Se llama cuando la <code>Activity</code> ya no es visible para el usuario. Esto puede ocurrir porque se ha iniciado una nueva <code>Activity</code> que la cubre por completo o porque el usuario ha vuelto a la pantalla de inicio.</li> <li><code>onRestart()</code>: Se invoca justo antes de que una <code>Activity</code> que estaba detenida (<code>onStop()</code>) vuelva a iniciarse.</li> <li><code>onDestroy()</code>: Es la llamada final antes de que la <code>Activity</code> sea destruida. Esto puede suceder porque la aplicaci\u00f3n se est\u00e1 cerrando, o porque el sistema necesita liberar memoria.</li> </ul> <p>Visual\u00edzalo como el viaje de un personaje en nuestra obra de teatro: entra en escena (<code>onCreate</code>, <code>onStart</code>, <code>onResume</code>), interact\u00faa con el p\u00fablico (<code>onResume</code>), otro personaje le quita el foco temporalmente (<code>onPause</code>), sale del escenario (<code>onStop</code>), y finalmente, termina su papel en la obra (<code>onDestroy</code>).</p> <p>\u00bfUna Activity por cada Pantalla?.</p> <p>Esta es una pregunta importante y la respuesta ha evolucionado con el tiempo.</p> <p>En los inicios de Android, la respuesta habr\u00eda sido un rotundo \"s\u00ed\". Cada pantalla completa de tu aplicaci\u00f3n se implementaba como una <code>Activity</code> separada. Por lo tanto, para una aplicaci\u00f3n con 5 pantallas, tendr\u00edas 5 archivos de <code>Activity</code> (por ejemplo, <code>LoginActivity.kt</code>, <code>HomeActivity.kt</code>, <code>ProfileActivity.kt</code>, <code>SettingsActivity.kt</code>, <code>DetailActivity.kt</code>) y 5 archivos de layout XML correspondientes.</p> <p>Sin embargo, esta no es la pr\u00e1ctica recomendada hoy en d\u00eda, ni siquiera en el mundo del XML.</p> <p>La introducci\u00f3n de los <code>Fragment</code>s cambi\u00f3 las reglas del juego. La arquitectura moderna, incluso antes de Jetpack Compose, aboga por una Arquitectura de Actividad \u00danica (Single Activity Architecture).</p> <p>Arquitectura de Actividad \u00danica (Single Activity Architecture)</p> <p>Significa que tu aplicaci\u00f3n podr\u00eda tener una \u00fanica <code>Activity</code> (por ejemplo, <code>MainActivity.kt</code>) que act\u00faa como el contenedor principal, y las \"pantallas\" diferentes ser\u00edan en realidad <code>Fragment</code>s distintos. La navegaci\u00f3n entre pantallas consistir\u00eda en reemplazar un <code>Fragment</code> por otro dentro de la misma <code>Activity</code>.</p> <p>\ud83c\udfaf Revisa el siguiente cuadro para conocer c\u00f3mo funciona el dise\u00f1o de Android antes de Jetpack compose.</p> En profundidad. Desarrollo Android antes de Compose \ud83e\udde9 <p>A: El Fragment: Piezas Modulares y Reutilizables de tu Interfaz</p> <p>Ahora, volvamos a nuestro escenario teatral. Si la <code>Activity</code> es el acto completo, un Fragment ser\u00eda un actor o un conjunto de actores con su propio guion y comportamiento. Un <code>Fragment</code> representa una porci\u00f3n reutilizable de la interfaz de usuario de tu aplicaci\u00f3n. No puede existir por s\u00ed solo; debe ser alojado por una <code>Activity</code> u otro <code>Fragment</code>.</p> <p>Piensa en una aplicaci\u00f3n de noticias en una tablet. Podr\u00edas tener una <code>Activity</code> principal que, en la parte izquierda, muestra una lista de titulares (un <code>Fragment</code>) y, en la parte derecha, muestra el contenido del titular seleccionado (otro <code>Fragment</code>). En un tel\u00e9fono, debido al menor espacio, la <code>Activity</code> podr\u00eda mostrar solo la lista de titulares. Al seleccionar uno, se reemplazar\u00eda el <code>Fragment</code> de la lista por el del contenido. \u00a1Es la misma l\u00f3gica y c\u00f3digo de <code>Fragment</code>, pero reutilizado en diferentes contextos!</p> <p>Relaci\u00f3n entre Activity y Fragment:</p> <ul> <li>Contenedor-Contenido: La <code>Activity</code> es el contenedor, y el <code>Fragment</code> es una parte de su contenido.</li> <li>Ciclo de Vida Anidado: El ciclo de vida de un <code>Fragment</code> est\u00e1 directamente ligado al de su <code>Activity</code> anfitriona. Por ejemplo, cuando la <code>Activity</code> se pausa (<code>onPause()</code>), todos los <code>Fragment</code>s dentro de ella tambi\u00e9n reciben su llamada a <code>onPause()</code>. Sin embargo, el <code>Fragment</code> tiene m\u00e9todos de ciclo de vida adicionales propios, como <code>onAttach()</code> (cuando se asocia a la <code>Activity</code>), <code>onCreateView()</code> (cuando dibuja su propia interfaz) y <code>onDetach()</code> (cuando se desvincula).</li> <li>Comunicaci\u00f3n: La <code>Activity</code> puede pasar datos a sus <code>Fragment</code>s, y los <code>Fragment</code>s pueden comunicarse con su <code>Activity</code> (y a trav\u00e9s de ella, con otros <code>Fragments</code> ) para coordinar acciones.</li> </ul> <p>Ventajas de la Arquitectura de Actividad \u00danica con Fragments</p> <ol> <li>Rendimiento y Eficiencia: Cambiar entre <code>Fragment</code>s es mucho m\u00e1s ligero y r\u00e1pido que iniciar <code>Activities</code> completamente nuevas, que son componentes m\u00e1s pesados del sistema.</li> <li>Facilidad para Compartir Datos: Es mucho m\u00e1s sencillo compartir datos y estados entre <code>Fragment</code>s que est\u00e1n en la misma <code>Activity</code> (usando un <code>ViewModel</code> compartido, por ejemplo) que pasar datos complejos entre <code>Activities</code>.</li> <li>Experiencia de Usuario Fluida: Las transiciones y animaciones entre <code>Fragment</code>s son m\u00e1s f\u00e1ciles de implementar y se sienten m\u00e1s integradas.</li> <li>Modularidad: Fomenta la creaci\u00f3n de componentes de UI reutilizables.</li> </ol> <p>Entonces, para una aplicaci\u00f3n de 5 pantallas, la aproximaci\u00f3n moderna (XML) ser\u00eda:</p> <ul> <li>1 Activity: <code>MainActivity.kt</code> con su layout. Este layout tendr\u00eda un contenedor, como un <code>FrameLayout</code> o un <code>FragmentContainerView</code>, donde se alojar\u00e1n los <code>Fragment</code>s.</li> <li>5 Fragments: Cada uno con su propio archivo de clase Kotlin y su archivo de layout. Por ejemplo, <code>LoginFragment.kt</code> con <code>fragment_login.xml</code>, <code>HomeFragment.kt</code> con <code>fragment_home.xml</code>, etc.</li> </ul> <p>B: Ciclo de Vida en la arquitectura de Actividad \u00fanica con Fragments</p> <p>\u00bfLa pregunta l\u00f3gica entonces ser\u00eda? Si solo tengo una Actividad, \u00bfc\u00faal ser\u00eda su ciclo de vida? y \u00bfc\u00f3mo afectar\u00eda si el usuario se desplaza de una pantalla a otra de la Aplicaci\u00f3n?</p> <p>La respuesta corta y fundamental es: el ciclo de vida de la <code>Activity</code> ya no se ve afectado por la navegaci\u00f3n interna de la aplicaci\u00f3n, sino \u00fanicamente por eventos que afectan a la ventana de la aplicaci\u00f3n en su totalidad.</p> <p>Vamos a desglosarlo con detalle, manteniendo nuestra analog\u00eda del teatro.</p> <p>Nuestra <code>MainActivity</code> es el teatro entero. Los <code>Fragment</code>s son los actos o escenas que ocurren en su \u00fanico escenario.</p> <p>El Rol Inmutable del Ciclo de Vida de la Activity</p> <p>En un modelo de Actividad \u00danica, los m\u00e9todos del ciclo de vida de tu <code>MainActivity</code> (<code>onCreate</code>, <code>onStart</code>, <code>onResume</code>, <code>onPause</code>, <code>onStop</code>, <code>onDestroy</code>) se seguir\u00e1n llamando, pero las razones para que se llamen son diferentes y m\u00e1s simples de predecir.</p> <p>Piensa en el ciclo de vida de la <code>Activity</code> como el estado del \"teatro\":</p> <ul> <li><code>onCreate()</code>: El teatro se construye por primera vez. Esto pasa solo una vez al iniciar la app.</li> <li><code>onStart()</code> / <code>onResume()</code>: Se abren las puertas del teatro y las luces del escenario se encienden. El espect\u00e1culo est\u00e1 en curso y el p\u00fablico (el usuario) est\u00e1 prestando atenci\u00f3n. La <code>Activity</code> est\u00e1 en primer plano y es interactiva.</li> <li><code>onPause()</code> / <code>onStop()</code>: Las luces del escenario se aten\u00faan o se apagan. El espect\u00e1culo se detiene. Esto ocurre cuando algo externo interrumpe la aplicaci\u00f3n. Por ejemplo:<ul> <li>El usuario presiona el bot\u00f3n \"Home\" del dispositivo.</li> <li>El usuario presiona el bot\u00f3n \"Recientes\" para cambiar a otra aplicaci\u00f3n.</li> <li>Recibes una llamada telef\u00f3nica que aparece sobre tu aplicaci\u00f3n.</li> <li>Aparece un di\u00e1logo de permisos del sistema.</li> </ul> </li> <li><code>onDestroy()</code>: El teatro va a ser demolido. Esto sucede cuando el usuario cierra la aplicaci\u00f3n o si el sistema operativo necesita recuperar memoria de forma agresiva.</li> </ul> <p>Como puedes ver, ninguno de estos eventos tiene que ver con cambiar de la \"pantalla de lista\" a la \"pantalla de detalle\". El cambio entre <code>Fragment</code>s es un evento interno. Para el sistema operativo, el \"teatro\" (<code>MainActivity</code>) ha permanecido abierto, con las luces encendidas y el p\u00fablico atento todo el tiempo.</p> <p>El Doble Ciclo de Vida en Acci\u00f3n: Activity vs. Fragment</p> <p>Aqu\u00ed es donde reside la magia y la clave de la pregunta. Cuando navegas de un <code>Fragment</code> a otro, est\u00e1s operando con el ciclo de vida del <code>Fragment</code>, mientras que el ciclo de vida de la <code>Activity</code> permanece estable.</p> <p>Veamos el escenario exacto:</p> <p>Tu aplicaci\u00f3n est\u00e1 en <code>HomeFragment</code> y el usuario hace clic en un elemento para ir a <code>DetailFragment</code>.</p> <ol> <li> <p>Estado Inicial:</p> <ul> <li><code>MainActivity</code>: Est\u00e1 en el estado <code>RESUMED</code> (ha pasado por <code>onCreate</code>, <code>onStart</code>, <code>onResume</code>). Su estado no va a cambiar.</li> <li><code>HomeFragment</code>: Tambi\u00e9n est\u00e1 en el estado <code>RESUMED</code> (ha pasado por su propio ciclo de vida: <code>onAttach</code>, <code>onCreate</code>, <code>onCreateView</code>, <code>onStart</code>, <code>onResume</code>).</li> </ul> </li> <li> <p>El Usuario Inicia la Navegaci\u00f3n (hace clic):</p> <ul> <li>El <code>FragmentManager</code> (o la librer\u00eda de Navegaci\u00f3n de Jetpack) recibe la orden de reemplazar <code>HomeFragment</code> con <code>DetailFragment</code>.</li> </ul> </li> <li> <p>El Ciclo de Vida de los Fragments se Activa:</p> <ul> <li> <p><code>HomeFragment</code> (el que se va): El sistema lo retira del escenario. Pasa por su ciclo de vida de \"destrucci\u00f3n de vista\":</p> <ul> <li><code>onPause()</code></li> <li><code>onStop()</code></li> <li><code>onDestroyView()</code> (\u00a1Muy importante! Su l\u00f3gica se va, pero su vista (el layout XML) es lo que se destruye).</li> <li>Si no se a\u00f1ade a la \"pila de retroceso\" (back stack), tambi\u00e9n pasar\u00e1 por <code>onDestroy()</code> y <code>onDetach()</code>. Si se a\u00f1ade, el objeto del fragmento permanece en memoria.</li> </ul> </li> <li> <p><code>DetailFragment</code> (el que llega): El sistema lo pone en el escenario. Pasa por su ciclo de vida de \"creaci\u00f3n\":</p> <ul> <li><code>onAttach()</code> (se engancha a la <code>MainActivity</code>).</li> <li><code>onCreate()</code> (se inicializa el fragmento).</li> <li><code>onCreateView()</code> (infla su layout XML para convertirse en una vista).</li> <li><code>onStart()</code></li> <li><code>onResume()</code> (ahora es visible e interactivo para el usuario).</li> </ul> </li> </ul> </li> <li> <p>Estado Final (Temporal):</p> <ul> <li><code>MainActivity</code>: Sigue en <code>RESUMED</code>. No se ha enterado del cambio a nivel de su propio ciclo de vida. Para ella, todo sigue igual.</li> <li><code>HomeFragment</code>: Su vista ha sido destruida.</li> <li><code>DetailFragment</code>: Est\u00e1 en el estado <code>RESUMED</code>.</li> </ul> </li> </ol> <p>\u00bfQu\u00e9 pasa si el usuario presiona el bot\u00f3n \"Atr\u00e1s\"? El proceso se invierte. <code>DetailFragment</code> es destruido y <code>HomeFragment</code> se vuelve a crear (pasa por <code>onCreateView</code> de nuevo) para mostrarse en pantalla. Y durante todo este proceso, <code>MainActivity</code> sigue felizmente en su estado <code>RESUMED</code>.</p> <p>Las Reglas de Oro del Ciclo de Vida en una Actividad \u00danica</p> <p>Para que te quede grabado, aqu\u00ed tienes las reglas fundamentales:</p> <ol> <li>El Ciclo de Vida de la <code>Activity</code> gestiona el estado de la ventana de la aplicaci\u00f3n. \u00bfEst\u00e1 tu app en primer plano o en segundo plano? \u00bfLa est\u00e1n interrumpiendo?</li> <li>El Ciclo de Vida del <code>Fragment</code> gestiona el estado de una porci\u00f3n de la UI dentro de la ventana de la aplicaci\u00f3n. \u00bfEst\u00e1 esta porci\u00f3n de UI visible en pantalla o no?</li> <li>La <code>Activity</code> es la directora de orquesta; el <code>Fragment</code> es un m\u00fasico. Cuando la directora (Activity) dice \"pausa\" (porque llega una llamada), todos los m\u00fasicos (Fragments activos) tambi\u00e9n pausan. Pero un m\u00fasico puede dejar de tocar y ser reemplazado por otro sin que la directora altere el tempo general de la orquesta.</li> </ol> <p>Entender esta separaci\u00f3n es la clave para dominar el desarrollo moderno de Android (incluso en Compose, donde los conceptos de ciclo de vida siguen siendo vitales) y para crear aplicaciones eficientes, r\u00e1pidas y sin fugas de memoria.</p>"},{"location":"temas/02/2.3-primera-app.html","title":"2.3. Primera aplicaci\u00f3n","text":""},{"location":"temas/02/2.3-primera-app.html#23-mi-primera-aplicacion-android","title":"2.3 Mi primera aplicaci\u00f3n Android","text":"<p>Para desarrollar una aplicaci\u00f3n Android, debemos decidir si vamos a utilizar la interfaz tradicional basada en XML o la m\u00e1s moderna basada en Jetpack Compose. En este apartado, vamos a crear una aplicaci\u00f3n sencilla utilizando ambas tecnolog\u00edas.</p>"},{"location":"temas/02/2.3-primera-app.html#1-aplicacion-con-interfaz-basada-en-xml","title":"1. Aplicaci\u00f3n con interfaz basada en XML","text":"<p>En el siguiente video, se indica de forma detallada cada uno de los componentes que conforman una aplicaci\u00f3n Android con interfaz basada en XML.</p> Video: Mi primera aplicaci\u00f3n Android con interfaz basada en XML <p></p>"},{"location":"temas/02/2.3-primera-app.html#2-aplicacion-con-interfaz-basada-en-jetpack-compose","title":"2. Aplicaci\u00f3n con interfaz basada en Jetpack Compose","text":"<p>Jetpack Compose es un moderno toolkit de UI para construir interfaces de usuario nativas en Android. Caracter\u00edsticas principales de Jetpack Compose:</p> <ul> <li>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </li> <li>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </li> <li>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </li> <li>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </li> <li>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.  </li> </ul> <p>Introducci\u00f3n a Compose</p> <p>Es fundamental leer la documentaci\u00f3n oficial para obtener m\u00e1s informaci\u00f3n. A lo largo del curso, se ir\u00e1n indicando tarjetas con puntos clave de acceso a la documentaci\u00f3n oficial.</p> Video: \u00bfPor qu\u00e9 usar Jetpack Compose? <p></p> <p>Y qu\u00e9 \u00bfdiferencias existen versus una aplicaci\u00f3n con interfaz basada en XML?. En el siguiente video os dejo un ejemplo pr\u00e1ctico comparando ambas tecnolog\u00edas.</p> Video: Aplicaci\u00f3n XML vs Jetpack Compose <p></p>"},{"location":"temas/02/2.3-primera-app.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.3-primera-app.html#proyecto-guiado-aplicacion-de-tarjeta-de-cumpleanos","title":"\ud83d\ude80 Proyecto guiado: Aplicaci\u00f3n de \"Tarjeta de cumplea\u00f1os\"","text":"<p>Para esta pr\u00e1ctica, vamos a crear una sencilla aplicaci\u00f3n de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. La aplicaci\u00f3n mostrar\u00e1 un mensaje de felicitaci\u00f3n y una imagen.</p> <p>\u2b06\ufe0f Proyecto</p> <p>Proyecto. App de tarjetas de presentaci\u00f3n. Sigue las indicaciones aqu\u00ed.</p> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li> <p>Codelab. Dise\u00f1ar una app de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. Realiza el siguiente Codelab.</p> </li> <li> <p>Codelab. Agregar im\u00e1genes a nuestra primera App. Realiza el siguiente Codelab de la plataforma oficial de Android.</p> </li> <li> <p>Codelab. Vamos tambi\u00e9n a resolver algunos problemas pr\u00e1cticas en el siguiente Codelab.</p> </li> </ol> <p></p>"},{"location":"temas/02/2.3-primera-app.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<p>Utiliza los siguientes recursos para profundizar en aspectos espec\u00edficos vistos en este apartado.</p> <ul> <li>Box, Colum y Row en Jetpack Compose</li> <li>Modifiers en Jetpack Compose</li> <li>Texto en Jetpack Compose</li> <li>Cargar im\u00e1genes e iconos en Jetpack Compose. Utilizar Coil para cargar im\u00e1genes desde Internet.</li> </ul>"},{"location":"temas/02/2.4-gestion-estado.html","title":"2.4. Gesti\u00f3n del estado","text":""},{"location":"temas/02/2.4-gestion-estado.html#24-gestion-del-estado","title":"2.4 Gesti\u00f3n del estado","text":"<p>Una aplicaci\u00f3n sin estado, es una aplicaci\u00f3n est\u00e1tica, es decir, que muestra sus elementos y estos son siempre fijos a lo largo del tiempo, ninguna acci\u00f3n puede cambiarlos.</p> <p>Importante</p> <p>dominar la gesti\u00f3n del estado en Compose no es una opci\u00f3n, es el requisito principal para construir aplicaciones que funcionen correctamente, sean f\u00e1ciles de mantener y est\u00e9n libres de errores impredecibles.</p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n de la gesti\u00f3n del estado</p>"},{"location":"temas/02/2.4-gestion-estado.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.4-gestion-estado.html#proyecto-guiados-aplicacion-app-clicks-y-calculadora-de-propinas","title":"\ud83d\ude80 Proyecto guiados: Aplicaci\u00f3n \"App Clicks\" y \"Calculadora de propinas","text":"<p>En estas pr\u00e1ctica ten\u00e9is que crear 2 aplicaciones.</p> <ul> <li> <p>\u2b06\ufe0f Proyecto</p> <p>Para esta pr\u00e1ctica, vamos a crear una aplicaci\u00f3n que nos va cambiar la imagen en base a un n\u00famero de clicks.</p> <p>Proyecto. App Clicks. Sigue las indicaciones aqu\u00ed.</p> Video: Explicaci\u00f3n paso de la realizaci\u00f3n de la Actividad <p></p> </li> </ul> <p></p> <ul> <li> <p>\u2b06\ufe0f Proyecto</p> <p>Para esta pr\u00e1ctica, vamos a crear una aplicaci\u00f3n que nos va a permitir calcular las propinas en un restaurante.</p> <p>Proyecto. Calculadora de propinas. Sigue las indicaciones aqu\u00ed.</p> Video: Explicaci\u00f3n paso de la realizaci\u00f3n de la Actividad <p> </p> </li> </ul> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>\u00bfQu\u00e9 vas a aprender?\"</p> <ul> <li>Manejo del estado</li> <li>Crear componentes reutilizables </li> <li>Para ello, vamos a realizar los siguientes proyectos guiados:</li> </ul> <ol> <li>Codelab. C\u00f3mo crear una app interactiva de \"Dice Roller\". </li> <li>Codelab. Introducci\u00f3n al estado en Compose. Realiza el siguiente Codelab.</li> </ol> <p> </p>"},{"location":"temas/02/2.4-gestion-estado.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<p>Utiliza los siguientes recursos para profundizar en aspectos espec\u00edficos vistos en este apartado.</p> <ul> <li>El estado y Jetpack Compose</li> <li>Video: Tu App Android con dise\u00f1o Material con AppBar y Scaffold</li> </ul>"},{"location":"temas/02/2.5-mejorando-codigo.html","title":"2.5. Mejorando el c\u00f3digo","text":""},{"location":"temas/02/2.5-mejorando-codigo.html#mejorar-para-reestructurar-el-codigo-en-jetpack-compose","title":"Mejorar para reestructurar el c\u00f3digo en Jetpack Compose","text":"<p>Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad tambi\u00e9n puede llevar a que el c\u00f3digo crezca r\u00e1pidamente y se vuelva desordenado.</p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-1-crea-un-composable-base-para-tu-aplicacion","title":"\u2705 Consejo 1: Crea un Composable Base para tu Aplicaci\u00f3n","text":"<p>El Problema: Ciertas configuraciones, como aplicar el tema de Material Design (<code>MaterialTheme</code>) o un color de fondo base con <code>Surface</code>, deben repetirse en cada pantalla y en cada <code>@Preview</code> para que se vean correctamente. Esto genera mucho c\u00f3digo duplicado.</p> <p>La Soluci\u00f3n: Encapsula toda esta configuraci\u00f3n com\u00fan en un \u00fanico Composable que sirva como la base para toda tu aplicaci\u00f3n y tus vistas previas.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: Tu <code>MainActivity</code> podr\u00eda verse as\u00ed, con la configuraci\u00f3n directamente en <code>setContent</code>.</li> </ul> <pre><code>class MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyMoviesTheme { // Aplicando el tema\n                // Un contenedor Surface que usa el color de fondo del tema\n                Surface(color = MaterialTheme.colors.background) {\n                    MainScreen() // La pantalla principal\n                }\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Extraemos esa l\u00f3gica a un nuevo Composable.</li> </ul> <p></p><pre><code>// Archivo: ui/MyMoviesApp.kt\n\n@Composable\nfun MyMoviesApp(content: @Composable () -&gt; Unit) {\n    MyMoviesTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            content() // Aqu\u00ed se insertar\u00e1 el contenido espec\u00edfico de cada pantalla\n        }\n    }\n}\n\n// Ahora, tu MainActivity es mucho m\u00e1s limpia:\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyMoviesApp {\n                MainScreen()\n            }\n        }\n    }\n}\n</code></pre> Ahora puedes reutilizar <code>MyMoviesApp</code> en todas tus <code>@Preview</code> para asegurar consistencia visual.<p></p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-2-divide-los-composables-grandes-en-otros-mas-pequenos","title":"\u2705 Consejo 2: Divide los Composables Grandes en Otros m\u00e1s Peque\u00f1os","text":"<p>El Problema: Una funci\u00f3n Composable puede crecer hasta tener cientos de l\u00edneas, mezclando la l\u00f3gica de una barra de navegaci\u00f3n, una lista, botones, etc. Esto dificulta la lectura y el mantenimiento.</p> <p>La Soluci\u00f3n: Aplica el principio de responsabilidad \u00fanica. Crea funciones Composable peque\u00f1as y con nombres descriptivos (sem\u00e1nticos) que hagan una sola cosa.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: La <code>TopAppBar</code> se define directamente dentro del <code>Scaffold</code>, haciendo el c\u00f3digo m\u00e1s denso.</li> </ul> <pre><code>@Composable\nfun MainScreen() {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(text = stringResource(id = R.string.app_name)) },\n                actions = {\n                    IconButton(onClick = { /* TODO */ }) {\n                        Icon(imageVector = Icons.Default.Search, contentDescription = null)\n                    }\n                    IconButton(onClick = { /* TODO */ }) {\n                        Icon(imageVector = Icons.Default.Share, contentDescription = null)\n                    }\n                }\n            )\n        }\n    ) { padding -&gt;\n        // Contenido de la pantalla\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Extraemos la <code>TopAppBar</code> a su propia funci\u00f3n.</li> </ul> <pre><code>// Archivo: ui/screens/main/MainAppBar.kt\n\n@Composable\nfun MainAppBar() {\n    TopAppBar(\n        title = { Text(text = stringResource(id = R.string.app_name)) },\n        actions = {\n            // Podr\u00edamos incluso extraer estos botones a otro Composable si fueran m\u00e1s complejos\n            IconButton(onClick = { /* TODO */ }) {\n                Icon(imageVector = Icons.Default.Search, contentDescription = null)\n            }\n            IconButton(onClick = { /* TODO */ }) {\n                Icon(imageVector = Icons.Default.Share, contentDescription = null)\n            }\n        }\n    )\n}\n\n// Ahora el Scaffold es mucho m\u00e1s legible:\n@Composable\nfun MainScreen() {\n    Scaffold(\n        topBar = { MainAppBar() }\n    ) { padding -&gt;\n        // Contenido de la pantalla\n    }\n}\n</code></pre>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-3-crea-composables-que-definan-una-pantalla-completa","title":"\u2705 Consejo 3: Crea Composables que Definan una Pantalla Completa","text":"<p>El Problema: Si tu aplicaci\u00f3n tiene varias pantallas (inicio, detalle, perfil), colocar la l\u00f3gica de todas ellas en <code>MainActivity</code> es insostenible.</p> <p>La Soluci\u00f3n: Crea un Composable de alto nivel para cada pantalla. Esta funci\u00f3n ser\u00e1 la responsable de construir la UI completa de esa pantalla, incluyendo su <code>Scaffold</code>, <code>TopAppBar</code>, etc.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: La l\u00f3gica del <code>Scaffold</code> estaba directamente en <code>setContent</code> o en un Composable base.</li> <li>Despu\u00e9s: Creamos un Composable que representa la pantalla principal.</li> </ul> <pre><code>// Archivo: ui/screens/main/MainScreen.kt\n\n@Composable\nfun MainScreen() {\n    // Scaffold define la estructura b\u00e1sica de la pantalla (barra superior, contenido, etc.)\n    Scaffold(\n        topBar = { MainAppBar() }\n    ) { padding -&gt;\n        // El contenido principal de la pantalla es una lista de medios\n        MediaList(modifier = Modifier.padding(padding))\n    }\n}\n\n// El setContent de la Activity ahora solo llama al Composable de la pantalla.\n// Cuando implementes navegaci\u00f3n, aqu\u00ed decidir\u00e1s qu\u00e9 pantalla mostrar.\nsetContent {\n    MyMoviesApp {\n        MainScreen()\n    }\n}\n</code></pre>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-4-estructura-los-paquetes-de-ui-por-pantallas","title":"\u2705 Consejo 4: Estructura los Paquetes de UI por Pantallas","text":"<p>El Problema: Tener todos los archivos Composable en un mismo paquete (<code>ui</code>) funciona para proyectos peque\u00f1os, pero se vuelve un caos a medida que la aplicaci\u00f3n crece.</p> <p>La Soluci\u00f3n: Organiza tus archivos en paquetes que reflejen la estructura de tu aplicaci\u00f3n, generalmente por funcionalidad o por pantalla.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: Todos los archivos de UI en un solo lugar.</li> </ul> <pre><code>com.antonioleiva.mymovies\n\u2514\u2500\u2500 ui\n    \u251c\u2500\u2500 MainActivity.kt\n    \u251c\u2500\u2500 MainAppBar.kt\n    \u251c\u2500\u2500 MediaList.kt\n    \u251c\u2500\u2500 MediaItem.kt\n    \u2514\u2500\u2500 theme\n        \u2514\u2500\u2500 ...\n</code></pre> <ul> <li>Despu\u00e9s: Creamos una estructura m\u00e1s organizada.</li> </ul> <pre><code>com.antonioleiva.mymovies\n\u251c\u2500\u2500 model // Clases de datos (ej. MediaItem.kt)\n\u2502   \u2514\u2500\u2500 MediaItem.kt\n\u2514\u2500\u2500 ui\n    \u251c\u2500\u2500 MainActivity.kt // La Actividad principal, punto de entrada\n    \u251c\u2500\u2500 MyMoviesApp.kt  // El Composable base\n    \u251c\u2500\u2500 screens\n    \u2502   \u251c\u2500\u2500 main        // Paquete para la pantalla principal\n    \u2502   \u2502   \u251c\u2500\u2500 MainScreen.kt\n    \u2502   \u2502   \u251c\u2500\u2500 MainAppBar.kt\n    \u2502   \u2502   \u2514\u2500\u2500 MediaList.kt\n    \u2502   \u2514\u2500\u2500 detail      // Paquete para la pantalla de detalle (futuro)\n    \u2514\u2500\u2500 theme\n        \u2514\u2500\u2500 ...\n</code></pre> <p>Esta estructura te dice de un vistazo qu\u00e9 componentes pertenecen a qu\u00e9 pantalla.</p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-5-extrae-las-dimensiones-a-recursos","title":"\u2705 Consejo 5: Extrae las Dimensiones a Recursos","text":"<p>El Problema: Escribir valores como <code>padding(16.dp)</code> o <code>height(200.dp)</code> directamente en el c\u00f3digo (hardcodear) dificulta hacer cambios globales y adaptar la UI a diferentes tama\u00f1os de pantalla (m\u00f3viles vs. tablets).</p> <p>La Soluci\u00f3n: Define todas tus dimensiones en archivos de recursos XML (<code>res/values/dimens.xml</code>) y accede a ellos desde tu c\u00f3digo Compose.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Paso 1: Crear el archivo de recursos <code>dimens.xml</code>.</li> </ul> <pre><code>&lt;!-- Archivo: app/src/main/res/values/dimens.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;dimen name=\"padding_xsmall\"&gt;2dp&lt;/dimen&gt;\n    &lt;dimen name=\"padding_medium\"&gt;16dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_min_width\"&gt;150dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_thumb_height\"&gt;200dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_play_icon_size\"&gt;92dp&lt;/dimen&gt;\n&lt;/resources&gt;\n</code></pre> <ul> <li> <p>Paso 2: Usar los recursos en el c\u00f3digo.</p> </li> <li> <p>Antes:</p> </li> </ul> <pre><code>@Composable\nfun MediaListItem(...) {\n    Column {\n        Box(modifier = Modifier.height(200.dp)) {\n            //...\n            Icon(\n                modifier = Modifier.size(92.dp),\n                //...\n            )\n        }\n        Box(modifier = Modifier.padding(16.dp)) {\n            //...\n        }\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Usamos <code>dimensionResource</code> para obtener los valores del XML.</li> </ul> <pre><code>import androidx.compose.ui.res.dimensionResource\nimport com.antonioleiva.mymovies.R // Importante importar tu clase R\n\n@Composable\nfun MediaListItem(...) {\n    Column {\n        Box(modifier = Modifier.height(dimensionResource(R.dimen.cell_thumb_height))) {\n            //...\n            Icon(\n                modifier = Modifier.size(dimensionResource(R.dimen.cell_play_icon_size)),\n                //...\n            )\n        }\n        Box(modifier = Modifier.padding(dimensionResource(R.dimen.padding_medium))) {\n            //...\n        }\n    }\n}\n</code></pre> <p>De esta forma, si necesitas cambiar un espaciado en toda la app, solo modificas el archivo <code>dimens.xml</code>.</p>"},{"location":"temas/02/2.6-mostrar-listas.html","title":"2.6. Manejo de listas","text":""},{"location":"temas/02/2.6-mostrar-listas.html#26-listas-en-compose","title":"2.6. Listas en Compose","text":"<p>Las listas son unos de los principales componentes de cualquier aplicaci\u00f3n, ya que nos van a permitir mostrar una lista de elementos. Si estos elementos son pocos, y solo ocupan parte de la pantalla, se pueden utilizar los elementos que ya conocemos como <code>Column</code> o <code>Row</code>, pero cuando son muchos los elementos necesitamos algo m\u00e1s potente, y que nos permita ser eficientes y que consuma los m\u00ednimos recursos.</p> <p>Para esto Compose nos provee los componentes <code>LazColum</code> y <code>LazyRow</code></p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n sobre listas y cuadriculas</p> <p>Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad tambi\u00e9n puede llevar a que el c\u00f3digo crezca r\u00e1pidamente y se vuelva desordenado.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#desmitificando-lazyrow-y-lazycolumn-en-jetpack-compose","title":"\ud83d\udca1Desmitificando LazyRow y LazyColumn en Jetpack Compose","text":""},{"location":"temas/02/2.6-mostrar-listas.html#1-cual-es-la-necesidad-el-problema-de-las-listas-largas","title":"1. \u00bfCu\u00e1l es la Necesidad? El Problema de las Listas Largas","text":"<p>Imaginemos una aplicaci\u00f3n com\u00fan: una red social con un feed de noticias, una tienda online con cientos de productos o una simple lista de contactos. Todas estas aplicaciones comparten un requisito: mostrar una cantidad potencialmente grande de elementos en pantalla.</p> <p>Si abord\u00e1ramos este problema de forma ingenua, utilizando los componentes b\u00e1sicos <code>Row</code> o <code>Column</code>, nos encontrar\u00edamos con un grave problema de rendimiento. Un <code>Column</code>, por ejemplo, renderizar\u00e1 todos y cada uno de sus elementos hijos de una sola vez, sin importar si son visibles en la pantalla o no. Para una lista de diez o veinte elementos, esto podr\u00eda ser aceptable. Pero, \u00bfqu\u00e9 sucede con cien, mil o una lista de longitud desconocida? La aplicaci\u00f3n intentar\u00eda componer y dibujar todos los elementos, consumiendo una cantidad masiva de memoria y ciclos de CPU. El resultado es inevitable: una interfaz que se congela, responde con lentitud (lo que conocemos como \"lag\") y, en el peor de los casos, una aplicaci\u00f3n que colapsa con un error de <code>OutOfMemoryError</code>.</p> <p>Aqu\u00ed es donde la \"pereza\" (del ingl\u00e9s \"lazy\") se convierte en nuestra mayor aliada.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#2-la-funcion-de-lazyrow-y-lazycolumn-composicion-perezosa","title":"2. La Funci\u00f3n de LazyRow y LazyColumn: Composici\u00f3n \"Perezosa\"","text":"<p><code>LazyRow</code> y <code>LazyColumn</code> son los equivalentes en Jetpack Compose al veterano <code>RecyclerView</code> del sistema de vistas tradicional de Android. Su prop\u00f3sito fundamental es mostrar de manera eficiente listas de elementos, ya sea de forma horizontal (<code>LazyRow</code>) o vertical (<code>LazyColumn</code>).</p> <p>La magia detr\u00e1s de estos componentes radica en su estrategia de composici\u00f3n y renderizado \"perezoso\". En lugar de componer todos los elementos de la lista de una vez, <code>LazyColumn</code> y <code>LazyRow</code> solo componen y dibujan los elementos que son actualmente visibles dentro del viewport (el \u00e1rea visible en la pantalla) y unos pocos m\u00e1s que est\u00e1n a punto de aparecer para garantizar un desplazamiento suave. A medida que el usuario se desplaza, los elementos que salen del viewport son descartados (liberando recursos), y nuevos elementos son compuestos justo a tiempo para ser mostrados.</p> <p>Este enfoque \"justo a tiempo\" tiene un impacto dr\u00e1stico y positivo en el rendimiento de la aplicaci\u00f3n:</p> <ul> <li>Uso de Memoria Optimizado: Al no mantener en memoria elementos que no est\u00e1n en pantalla, se reduce significativamente la huella de memoria de la aplicaci\u00f3n.</li> <li>Mejora del Rendimiento de Renderizado: La CPU y la GPU tienen mucho menos trabajo que hacer en cada frame, lo que se traduce en una interfaz de usuario fluida y receptiva, libre de \"lag\".</li> <li>Tiempos de Carga Iniciales R\u00e1pidos: La pantalla se muestra r\u00e1pidamente, ya que no es necesario procesar toda la lista de datos para la primera visualizaci\u00f3n.</li> </ul>"},{"location":"temas/02/2.6-mostrar-listas.html#3-como-funcionan-internamente","title":"3. \u00bfC\u00f3mo Funcionan Internamente?","text":"<p>A diferencia de <code>RecyclerView</code>, que se basa en un mecanismo de reciclaje de vistas (reutilizando instancias de <code>View</code> ya creadas), <code>LazyColumn</code> y <code>LazyRow</code> aprovechan el modelo de funcionamiento de Jetpack Compose.</p> <p>Cuando un elemento en una <code>LazyColumn</code> se desplaza fuera de la pantalla, su composici\u00f3n es descartada del \u00e1rbol de la UI. Cuando un nuevo elemento necesita ser mostrado, se crea una nueva composici\u00f3n para \u00e9l. Podr\u00eda pensarse que crear nuevas composiciones constantemente es costoso, pero el sistema de recomposici\u00f3n inteligente de Compose es extremadamente eficiente. Solo las partes de la UI que cambian se vuelven a componer, y la creaci\u00f3n de estos <code>Composables</code> es significativamente m\u00e1s ligera que la inflaci\u00f3n de vistas XML en el sistema tradicional.</p> <p>Para gestionar todo este proceso, estos componentes utilizan un <code>LazyListScope</code>, un DSL (Lenguaje Espec\u00edfico de Dominio) que permite definir los elementos de la lista de una manera declarativa y sencilla.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#4-puntos-imporntantes","title":"4. Puntos imporntantes","text":""},{"location":"temas/02/2.6-mostrar-listas.html#uso-utilizando-claves-de-elementos","title":"Uso utilizando claves de elementos","text":"<p>Aplica a LazyColumn y LazyRow.</p> <p>La posici\u00f3n determina el elemento pulsado o seleccionado. Esto puede dar problemas si se reordenan las listas. Para evitar este problema se pueden utilizar una clave (key) para cada elemento (como par\u00e1metro de items )</p> <pre><code>@Composable\nfun MessageList(messages: List&lt;Message&gt;) {\n    LazyColumn {\n        items(\n            items = messages,\n            key = { message -&gt;\n                // Devuelve una clave \u00fanica para el item\n                message.id\n            }\n        ) { message -&gt;\n            MessageRow(message)\n        }\n    }\n}\n</code></pre> <p>(mas detalles aqui)</p>"},{"location":"temas/02/2.6-mostrar-listas.html#padding-del-contenido","title":"Padding del contenido","text":"<p>Para a\u00f1adir espacio entre los bordes y el contenidos usamos PaddingValues con el par\u00e1metro de la funci\u00f3n <code>contentPadding</code></p> <pre><code>LazyColumn(\n    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),\n) {\n    // ...\n}\n</code></pre>"},{"location":"temas/02/2.6-mostrar-listas.html#espaciado-de-contenido","title":"Espaciado de contenido.","text":"<p>Para agregar espaciado entre elementos que forman el contenido usamos:</p> <pre><code>// solamente vertical\nLazyColumn(\n    verticalArrangement = Arrangement.spacedBy(4.dp),\n) {\n    // ...\n}\n// solamente horizontal\nLazyRow(\n    horizontalArrangement = Arrangement.spacedBy(4.dp),\n) {\n    // ...\n}\n</code></pre> <p>y en los Grid tanto horizontal como vertical:</p> <pre><code>LazyVerticalGrid(\n    columns = GridCells.Fixed(2),\n    verticalArrangement = Arrangement.spacedBy(16.dp),\n    horizontalArrangement = Arrangement.spacedBy(16.dp)\n) {\n    items(data) { item -&gt;\n        Item(item)\n    }\n}\n</code></pre> Ejemplos Pr\u00e1cticos: De lo B\u00e1sico a lo Avanzado \ud83d\udc68\u200d\ud83d\udcbb <p>Veamos c\u00f3mo se traduce todo esto en c\u00f3digo. La simplicidad de su implementaci\u00f3n es una de las grandes ventajas de Compose.</p> <p>Ejemplo 1: Una Lista Vertical Simple</p> <p>Supongamos que tenemos una lista de nombres de estudiantes que queremos mostrar verticalmente.</p> <pre><code>import androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun StudentList(students: List&lt;String&gt;) {\n    LazyColumn {\n        items(students) { studentName -&gt;\n            Text(\n                text = studentName,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(16.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>En este sencillo ejemplo, <code>LazyColumn</code> recibe una lista de <code>students</code>. El bloque <code>items</code> itera sobre esta lista y genera un <code>Composable</code> <code>Text</code> para cada estudiante. <code>LazyColumn</code> se encarga autom\u00e1ticamente de componer solo los elementos visibles.</p> <p>Ejemplo 2: Un Carrusel Horizontal de Im\u00e1genes (<code>LazyRow</code>)</p> <p>Ahora, creemos un carrusel horizontal, ideal para galer\u00edas de im\u00e1genes o categor\u00edas de productos.</p> <pre><code>import androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport com.example.myapp.R // Aseg\u00farate de tener tus recursos de imagen\n\n@Composable\nfun ImageCarousel(imageResIds: List&lt;Int&gt;) {\n    LazyRow {\n        items(imageResIds) { imageResId -&gt;\n            Image(\n                painter = painterResource(id = imageResId),\n                contentDescription = null, // Deber\u00eda ser descriptivo\n                modifier = Modifier\n                    .size(150.dp)\n                    .padding(8.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>El funcionamiento es id\u00e9ntico al de <code>LazyColumn</code>, pero la disposici\u00f3n y el desplazamiento son horizontales.</p> <p>Ejemplo 3: Lista con M\u00faltiples Tipos de Elementos</p> <p>Una de las grandes ventajas de <code>LazyColumn</code> es la facilidad para manejar listas heterog\u00e9neas. Imaginemos una lista que contiene cabeceras de secci\u00f3n y elementos de datos.</p> <pre><code>sealed class ListItem {\n    data class Header(val title: String) : ListItem()\n    data class DataItem(val content: String) : ListItem()\n}\n\n@Composable\nfun MixedList(items: List&lt;ListItem&gt;) {\n    LazyColumn {\n        items(items) { item -&gt;\n            when (item) {\n                is ListItem.Header -&gt; {\n                    Text(\n                        text = item.title,\n                        // Estilos para la cabecera\n                    )\n                }\n                is ListItem.DataItem -&gt; {\n                    Text(\n                        text = item.content,\n                        // Estilos para el item de dato\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Simplemente utilizando una estructura <code>when</code> dentro del bloque <code>items</code>, podemos emitir diferentes <code>Composables</code> seg\u00fan el tipo de dato, de una forma mucho m\u00e1s limpia que con el <code>getItemViewType</code> de <code>RecyclerView</code>.</p> <p>Ejemplo 4: Cabeceras Adhesivas (Sticky Headers)</p> <p>Con una peque\u00f1a modificaci\u00f3n, podemos hacer que nuestras cabeceras se queden \"pegadas\" en la parte superior de la pantalla mientras el contenido de su secci\u00f3n se desplaza.</p> <pre><code>@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun StickyHeaderList(sections: Map&lt;String, List&lt;String&gt;&gt;) {\n    LazyColumn {\n        sections.forEach { (headerTitle, items) -&gt;\n            stickyHeader {\n                Text(\n                    text = headerTitle,\n                    // Estilos para la cabecera adhesiva\n                )\n            }\n            items(items) { itemContent -&gt;\n                Text(\n                    text = itemContent,\n                    modifier = Modifier.padding(16.dp)\n                )\n            }\n        }\n    }\n}\n</code></pre> <p>El DSL <code>stickyHeader</code> (actualmente experimental) nos brinda esta compleja funcionalidad con una simplicidad asombrosa.</p> <p>5. La Clave del Rendimiento: <code>key</code></p> <p>Para optimizar a\u00fan m\u00e1s el rendimiento, especialmente en listas din\u00e1micas donde los elementos pueden a\u00f1adirse, eliminarse o reordenarse, es fundamental proporcionar una <code>key</code> \u00fanica y estable para cada elemento.</p> <pre><code>items(items = myItems, key = { it.id }) { item -&gt;\n    // Tu Composable para el item\n}\n</code></pre> <p>Al proporcionar una clave, ayudamos a Compose a identificar de manera \u00fanica cada elemento. Esto permite que el estado del elemento (como el estado de un <code>remember</code>) se mantenga correctamente cuando la lista cambia, y habilita animaciones de reordenamiento m\u00e1s eficientes.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#5-cuadriculas-diferidas-lazygrid","title":"5. Cuadr\u00edculas diferidas (LazyGrid)","text":"<p><code>LazyVerticalGrid</code> muestra los elementos en una cuadr\u00edcula con deslazamiento vertical que ocupa varias columnas</p> <p>La declaraci\u00f3n de LazyVerticalGrid:</p> <pre><code>@Composable\n@ComposableTarget\npublic fun LazyVerticalGrid(\n    columns: GridCells,\n    modifier: Modifier = COMPILED_CODE,\n    state: LazyGridState = COMPILED_CODE,\n    contentPadding: PaddingValues = COMPILED_CODE,\n    reverseLayout: Boolean = COMPILED_CODE,\n    verticalArrangement: Arrangement.Vertical = COMPILED_CODE,\n    horizontalArrangement: Arrangement.Horizontal = COMPILED_CODE,\n    flingBehavior: FlingBehavior = COMPILED_CODE,\n    userScrollEnabled: Boolean = COMPILED_CODE,\n    content: LazyGridScope.() -&gt; Unit\n): Unit\n</code></pre> <p>Y para los items en content:</p> <pre><code>public abstract fun items(\n    count: Int,\n    key: ((Int) -&gt; Any)? = COMPILED_CODE,\n    span: (LazyGridItemSpanScope.(Int) -&gt; GridItemSpan)? = COMPILED_CODE,\n    contentType: (Int) -&gt; Any? = COMPILED_CODE,\n    itemContent: @Composable() (LazyGridItemScope.(Int) -&gt; Unit)\n): Unit\n</code></pre> <p>Contenido adaptativo</p> <p>El par\u00e1metro <code>columns</code> en <code>LazyVerticalGrid</code> controla el modo en que se forman las celdas en columnas. En el siguiente ejemplo, se muestran elementos de una cuadr\u00edcula con <code>GridCells.Adaptive</code> para que cada columna tenga al menos 128.dp ancho:</p> <pre><code>@Composable\nfun PhotoGrid(photos: List&lt;Photo&gt;) {\n    LazyVerticalGrid(\n        columns = GridCells.Adaptive(minSize = 128.dp)\n    ) {\n        items(photos) { photo -&gt;\n            PhotoItem(photo)\n        }\n    }\n}\n</code></pre> <p>Se crearan tantas columnas como se puedan incluir en el espacio disponible con los 128.dp de cada columna.</p> <p>N\u00ba columnas fijo</p> <p>Tambi\u00e9n es posible forzar un n\u00famero de columnas fijo, adaptado el ancho , con <code>GridCells.Fixed</code>.</p> <p>Se puede personalizar el dise\u00f1o de columnas con <code>span</code> y <code>maxLineSpan</code> utilizandos con <code>item</code> e <code>items</code></p> <pre><code>LazyVerticalGrid(\n    // ...\n) {\n    item(span = {\n        // LazyGridItemSpanScope:\n        // maxLineSpan\n        GridItemSpan(maxLineSpan)\n    }) {\n        MiCard(\u201cFruits\u201d)\n    }\n    // ...\n}\n</code></pre> <p>Span</p> <ul> <li><code>span = { ... }</code>: Aqu\u00ed es donde la magia sucede.     Este bloque te permite definir cu\u00e1nto espacio en la cuadr\u00edcula ocupar\u00e1 tu elemento. </li> <li><code>GridItemSpan(maxLineSpan)</code>: Esto especifica el \"span\" de tu elemento. Por ejemplo, si tu cuadr\u00edcula tiene 4 columnas y pones GridItemSpan(2), tu elemento ocupar\u00e1 2 columnas. Si usas GridItemSpan(4), ocupar\u00e1 toda la fila. * <code>MiCard(\"Fruits\")</code>: </li> </ul> <p>Este es un ejemplo de contenido de tu elemento, puede ser cualquier composable que hayas creado, como una tarjeta que muestra una categor\u00eda.</p> <p>Lee este post para un ejemplo completo de uso de grids en Compose: Uso de Grids en Android con Jetpack Compose</p>"},{"location":"temas/02/2.6-mostrar-listas.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.6-mostrar-listas.html#proyecto-guiado-aplicacion-lista-de-cursos","title":"\ud83d\ude80 Proyecto guiado: Aplicaci\u00f3n \"Lista de cursos\"","text":"<p>Para esta pr\u00e1ctica, vamos a crear una sencilla aplicaci\u00f3n en la que vamos a mostrar en una cuadricula una lista de cursos.</p> <p>\u2b06\ufe0f Proyecto: Lista de cursos</p> <p>Proyecto. Lista de Cursos. Sigue las indicaciones aqu\u00ed.</p> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li>Codelab. Agregar una lista desplazable. Codelab.</li> <li>Codelab. C\u00f3mo cambiar el icono de la App. Codelab.</li> </ol>"},{"location":"temas/03/index.html","title":"Inicio","text":""},{"location":"temas/03/index.html#ut3-interfaz-de-usuario","title":"UT3. Interfaz de usuario","text":"<p>En este tema nos enfocaremos en el concepto de interfaz de usuario, accesibilidad, adaptaci\u00f3n a diferentes tama\u00f1os de pantalla, y exploraremos en profundidad una de las capas en cualquier arquitectura, como es la capa de UI.</p> <p>Tambi\u00e9n vamos a tratar el tema del dise\u00f1o de la interfaz de usuario, las l\u00edneas gu\u00eda que nos provee Android con su Material Design.</p> <p>\u00cdndice:</p> <ul> <li>3.1 Introducci\u00f3n a la interfaz de usuario</li> <li>3.2 Dise\u00f1o de la interfaz de usuario</li> <li>3.3 Elementos de la interfaz de usuario</li> </ul> <p></p>"},{"location":"temas/03/index.html#recursos","title":"\ud83d\udcc1 Recursos","text":"Android y Jetpack ComposeKotlin <ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.  </li> </ul> <ul> <li>Curso: Android con Kotlin (youtube)</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul>"},{"location":"temas/03/3.1-intro.html","title":"3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.1-intro.html#31-introduccion","title":"3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.1-intro.html#el-universo-de-material-design-3-en-jetpack-compose-creando-interfaces-modernas-y-personales","title":"El Universo de Material Design 3 en Jetpack Compose: Creando Interfaces Modernas y Personales","text":"<p>En el epicentro de esta revoluci\u00f3n se encuentra Material Design 3 (M3), la \u00faltima evoluci\u00f3n del lenguaje de dise\u00f1o de Google. Este documento tiene como objetivo desglosar los conceptos fundamentales de M3 y su implementaci\u00f3n en Jetpack Compose, proporcionando una gu\u00eda detallada para construir aplicaciones no solo funcionales y eficientes, sino tambi\u00e9n expresivas, adaptables y profundamente humanas.</p>"},{"location":"temas/03/3.1-intro.html#introduccion-a-los-conceptos-clave","title":"Introducci\u00f3n a los Conceptos Clave \ud83d\udda5\ufe0f","text":"<p>Para construir interfaces de usuario de alta calidad con Jetpack Compose, es imprescindible comprender los pilares sobre los que se asienta Material Design 3.</p>"},{"location":"temas/03/3.1-intro.html#que-es-material-design","title":"\u00bfQu\u00e9 es Material Design?","text":"<p>Material Design es un sistema de dise\u00f1o integral creado y mantenido por Google. Su prop\u00f3sito es unificar la experiencia de usuario a trav\u00e9s de todas las plataformas y dispositivos, proporcionando un conjunto coherente de directrices, componentes y herramientas para el dise\u00f1o de interfaces. Lejos de ser solo una gu\u00eda de estilo, es un lenguaje vivo que evoluciona para abordar las mejores pr\u00e1cticas de dise\u00f1o, usabilidad y accesibilidad. La versi\u00f3n 3, tambi\u00e9n conocida como \"Material You\", marca un cambio de paradigma hacia la personalizaci\u00f3n y la adaptabilidad.</p> <p></p> <p>La aplicaci\u00f3n de ejemplo \"Reply\" implementada enteramente con Material Design 3 en Compose.</p>"},{"location":"temas/03/3.1-intro.html#concepto-en-que-se-basa-material-design","title":"\ud83d\udd37 Concepto en que se Basa Material Design","text":"<p>El concepto central de Material Design se inspira en el mundo f\u00edsico y sus texturas, particularmente el papel y la tinta. Se basa en una \"met\u00e1fora material\" donde los elementos de la UI tienen superficies f\u00edsicas y bordes. Las sombras y la elevaci\u00f3n proporcionan pistas visuales sobre la jerarqu\u00eda y las interacciones posibles, indicando qu\u00e9 elementos se pueden tocar o mover. M3 expande esta idea con un enfoque en el movimiento expresivo y formas m\u00e1s org\u00e1nicas, haciendo que las interacciones se sientan m\u00e1s intuitivas y naturales.</p>"},{"location":"temas/03/3.1-intro.html#fundamentos","title":"\ud83d\udd37 Fundamentos","text":"<p>Los fundamentos de Material Design son los principios que sustentan todo el sistema. En M3, estos se centran en:</p> <ul> <li>Color: Un sistema de color din\u00e1mico y personalizable que puede adaptarse al fondo de pantalla del usuario.</li> <li>Tipograf\u00eda: Una escala de tipos adaptable que ajusta el tama\u00f1o de la fuente seg\u00fan el tama\u00f1o de la pantalla, mejorando la legibilidad.</li> <li>Forma: El uso de formas, como esquinas redondeadas, para transmitir personalidad y estado.</li> <li>Movimiento: Animaciones significativas que gu\u00edan al usuario y proporcionan retroalimentaci\u00f3n.</li> </ul>"},{"location":"temas/03/3.1-intro.html#diseno-adaptativo","title":"\ud83d\udd37 Dise\u00f1o Adaptativo","text":"<p>El dise\u00f1o adaptativo es la pr\u00e1ctica de crear layouts que se ajustan de manera inteligente a diferentes tama\u00f1os de pantalla, orientaciones y dispositivos. M3 no solo se enfoca en que las aplicaciones se \"vean bien\" en tel\u00e9fonos, tabletas o dispositivos plegables, sino que la experiencia de usuario sea \u00f3ptima en cada contexto. Esto se logra utilizando una combinaci\u00f3n de componentes flexibles, rejillas responsivas y patrones de dise\u00f1o espec\u00edficos.</p>"},{"location":"temas/03/3.1-intro.html#accesibilidad","title":"\ud83d\udd37 Accesibilidad","text":"<p>La accesibilidad es un pilar fundamental de Material Design. Consiste en dise\u00f1ar y construir aplicaciones que puedan ser utilizadas por personas con una amplia gama de habilidades y discapacidades (visuales, motoras, auditivas o cognitivas). M3 integra la accesibilidad desde su n\u00facleo, proporcionando componentes con el contraste de color adecuado, \u00e1reas t\u00e1ctiles de tama\u00f1o suficiente y soporte para tecnolog\u00edas de asistencia como los lectores de pantalla.</p>"},{"location":"temas/03/3.1-intro.html#colorscheme-y-sus-roles-de-color","title":"\ud83d\udd37 ColorScheme y sus Roles de Color","text":"<p>El <code>ColorScheme</code> es el coraz\u00f3n del sistema de color de Material 3 en Jetpack Compose. Es un conjunto de m\u00e1s de 20 roles de color que se utilizan para tematizar de manera consistente todos los componentes de la aplicaci\u00f3n. Lo revolucionario de M3 es que este esquema puede generarse din\u00e1micamente a partir del fondo de pantalla del usuario en Android 12 y versiones posteriores, una caracter\u00edstica clave de Material You.</p> <p>Los nombres de los roles son sem\u00e1nticos y describen su prop\u00f3sito en la UI, no un color espec\u00edfico. Esto facilita la creaci\u00f3n de temas coherentes. Los roles principales son:</p> <ul> <li>Primary: El color base de la marca, usado para componentes principales como botones prominentes y elementos activos.</li> <li>Secondary: Un color de acento que proporciona m\u00e1s formas de destacar elementos de la UI.</li> <li>Tertiary: Un color de acento contrastante que se puede usar para equilibrar los colores primarios y secundarios o para resaltar elementos de menor importancia.</li> <li>Neutral: Se utiliza para las superficies de la aplicaci\u00f3n, como los fondos y el texto.</li> <li>Neutral Variant: Una variante del color neutral, usada para elementos como bordes o divisores.</li> <li>Error: Se reserva para indicar errores, como en campos de texto con validaci\u00f3n incorrecta.</li> </ul> <p>Cada uno de estos roles principales tiene colores \"On\" (por ejemplo, <code>onPrimary</code>), que se usan para el contenido (texto, iconos) que se coloca encima de su color correspondiente, garantizando as\u00ed un contraste adecuado. Tambi\u00e9n existen colores para superficies (<code>surface</code>) y sus diferentes elevaciones.</p> <p>Los roles de color definen el prop\u00f3sito de un color en la UI. Fuente: Material Design</p>"},{"location":"temas/03/3.1-intro.html#canonical-layouts","title":"\ud83d\udd37 Canonical Layouts","text":"<p>Un \"layout\" define la estructura visual de una pantalla. En el contexto de M3 y el dise\u00f1o adaptativo, los Canonical Layouts (dise\u00f1os can\u00f3nicos) son plantillas de composici\u00f3n probadas y recomendadas que ayudan a organizar el contenido de manera efectiva en diferentes tama\u00f1os de pantalla. Estos dise\u00f1os son puntos de partida que abordan casos de uso comunes.</p> <p>Los tres dise\u00f1os can\u00f3nicos principales son:</p> <ol> <li>List-Detail: Ideal para aplicaciones que muestran una lista de elementos y el detalle de un elemento seleccionado, como una aplicaci\u00f3n de correo o un gestor de archivos. En pantallas compactas, la lista y el detalle ocupan pantallas separadas, mientras que en pantallas m\u00e1s grandes se muestran lado a lado.</li> <li>Supporting Pane: Divide la pantalla en un \u00e1rea de contenido principal y un panel secundario que ofrece informaci\u00f3n o controles contextuales. Un ejemplo ser\u00eda una aplicaci\u00f3n de calendario con la vista principal del mes y un panel lateral que muestra los detalles de un evento seleccionado.</li> <li>Feed: Organiza el contenido en una cuadr\u00edcula configurable, perfecta para explorar grandes cantidades de elementos equivalentes, como en una galer\u00eda de fotos o un feed de noticias.</li> </ol> <ul> <li> <p> </p><p>Feed Layout</p><p></p> </li> <li> <p> </p><p>Layout lista-detalle</p><p></p> </li> <li> <p> </p><p>Supporting Panel</p><p></p> </li> </ul> <p>De izquierda a derecha: Feed, List-Detail, Supporting Pane. Fuente: Material Design</p>"},{"location":"temas/03/3.1-intro.html#usabilidad","title":"\ud83d\udd37 Usabilidad","text":"<p>La usabilidad se refiere a la facilidad con la que un usuario puede interactuar con una aplicaci\u00f3n para alcanzar sus objetivos. Material Design promueve una alta usabilidad a trav\u00e9s de:</p> <ul> <li>Claridad: Interfaces limpias, jerarqu\u00eda visual clara y llamadas a la acci\u00f3n evidentes.</li> <li>Eficiencia: Permite a los usuarios realizar tareas de manera r\u00e1pida e intuitiva.</li> <li>Retroalimentaci\u00f3n: Proporciona respuestas visuales claras a las interacciones del usuario a trav\u00e9s de estados (ondulaciones al tocar, cambios de color) y movimiento.</li> </ul> <p>Importante</p> <p>En Jetpack Compose, estos principios se materializan a trav\u00e9s de componentes pre-construidos que ya incorporan estas mejores pr\u00e1cticas, permitiendo a los desarrolladores crear aplicaciones altamente usables con menos esfuerzo.</p> <p>Ejemplos Did\u00e1cticos en Jetpack Compose</p> <p>Veamos c\u00f3mo aplicar estos conceptos en el c\u00f3digo.</p> <p>Ejemplo 1: Aplicando un <code>ColorScheme</code> Din\u00e1mico</p> <p>Para que tu aplicaci\u00f3n adopte los colores del fondo de pantalla del usuario (en Android 12+), el c\u00f3digo es sorprendentemente simple.</p> <pre><code>@Composable\nfun MyAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -&gt; Unit\n) {\n    val context = LocalContext.current\n    val colorScheme = when {\n        // Soporte para color din\u00e1mico en Android 12+\n        Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            if (darkTheme) dynamicDarkColorScheme(context)\n            else dynamicLightColorScheme(context)\n        }\n        // Fallback a un tema personalizado para versiones anteriores\n        darkTheme -&gt; darkColorScheme(\n            primary = /* Tu color oscuro primario */,\n            secondary = /* Tu color oscuro secundario */\n            /* ... otros colores ... */\n        )\n        else -&gt; lightColorScheme(\n            primary = /* Tu color claro primario */,\n            secondary = /* Tu color claro secundario */\n            /* ... otros colores ... */\n        )\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = /* Tu tipograf\u00eda definida */,\n        content = content\n    )\n}\n</code></pre> <p>Al envolver tu UI con <code>MyAppTheme</code>, componentes como <code>Button</code>, <code>FloatingActionButton</code> o <code>Card</code> usar\u00e1n autom\u00e1ticamente los colores correctos del <code>colorScheme</code> (<code>primary</code> para el bot\u00f3n, <code>surface</code> para la tarjeta, etc.) sin necesidad de especificarlos manualmente.</p> <p>Ejemplo 2: Usando Roles de Color y Tipograf\u00eda</p> <p>Dentro de tus <code>Composables</code>, puedes acceder f\u00e1cilmente a los roles definidos en tu tema.</p> <pre><code>@Composable\nfun ProductCard(productName: String, productDescription: String) {\n    Card(\n        modifier = Modifier,\n        colors = CardDefaults.cardColors(\n            containerColor = MaterialTheme.colorScheme.surfaceVariant,\n        )\n    ) {\n        Text(\n            text = productName,\n            style = MaterialTheme.typography.titleLarge,\n            color = MaterialTheme.colorScheme.onSurface\n        )\n        Text(\n            text = productDescription,\n            style = MaterialTheme.typography.bodyMedium,\n            color = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n    }\n}\n</code></pre> <p>En este ejemplo, la tarjeta (<code>Card</code>) usa el color <code>surfaceVariant</code> para su fondo, y los textos usan <code>onSurface</code> y <code>onSurfaceVariant</code> respectivamente, asegurando la legibilidad. La tipograf\u00eda tambi\u00e9n se obtiene del tema, garantizando consistencia.</p> <p>Ejemplo 3: Componente Accesible - <code>Button</code> con Icono</p> <p>Material Design y Compose facilitan la creaci\u00f3n de componentes accesibles. Un bot\u00f3n con solo un icono debe tener una descripci\u00f3n de texto para los lectores de pantalla.</p> <pre><code>@Composable\nfun AddItemButton() {\n    IconButton(onClick = { /* Acci\u00f3n al hacer clic */ }) {\n        Icon(\n            imageVector = Icons.Filled.Add,\n            contentDescription = stringResource(R.string.add_item_description) // Descripci\u00f3n para accesibilidad\n        )\n    }\n}\n</code></pre> <p>El par\u00e1metro <code>contentDescription</code> es crucial. No es visible en la pantalla, pero proporciona a las herramientas de accesibilidad el contexto necesario para describir la funci\u00f3n del bot\u00f3n al usuario.</p> <p> </p> <p>Enlaces a la Documentaci\u00f3n Oficial:</p> <ul> <li>Introducci\u00f3n a Material Design 3: https://m3.material.io/</li> <li>Material Design 3 para Jetpack Compose: https://developer.android.com/jetpack/compose/design-systems/material3</li> <li>El Sistema de Color de M3: https://m3.material.io/styles/color/the-color-system</li> <li>Layouts Can\u00f3nicos: https://m3.material.io/foundations/layout/canonical-layouts</li> <li>Gu\u00eda de Accesibilidad: https://m3.material.io/foundations/accessibility</li> </ul>"},{"location":"temas/03/3.2-temas.html","title":"3.2. Temas","text":""},{"location":"temas/03/3.2-temas.html#32-temas-en-material-design-con-jetpack-compose","title":"3.2. Temas en Material Design con Jetpack Compose","text":""},{"location":"temas/03/3.2-temas.html#theming-en-jetpack-compose-con-material-design-3-una-arquitectura-de-estilo","title":"Theming en Jetpack Compose con Material Design 3: Una Arquitectura de Estilo","text":"<p>En el ecosistema de Android con Jetpack Compose, el pilar de esta coherencia es el sistema de Theming de Material Design 3. Un \"Theme\" (tema) es mucho m\u00e1s que una simple paleta de colores; es un sistema completo que define la apariencia y el comportamiento de tu aplicaci\u00f3n, encapsulando el color, la tipograf\u00eda y la forma para crear una identidad de marca \u00fanica y una experiencia de usuario consistente.</p> <p>En este punto se profundiza en c\u00f3mo aplicar y personalizar temas en Jetpack Compose, desde los conceptos b\u00e1sicos hasta la generaci\u00f3n de paletas de colores din\u00e1micas que dan vida a la filosof\u00eda de \"Material You\".</p>"},{"location":"temas/03/3.2-temas.html#1-la-anatomia-de-un-tema-en-compose","title":"\u2728 1. La Anatom\u00eda de un Tema en Compose","text":"<p>Cuando creas un nuevo proyecto de Jetpack Compose en Android Studio, se genera autom\u00e1ticamente un paquete <code>ui.theme</code> que contiene los tres pilares de tu tema:</p> <ul> <li><code>Color.kt</code>: Define los valores de color est\u00e1ticos que usar\u00e1s para construir tus esquemas de color.</li> <li><code>Type.kt</code>: Define la escala tipogr\u00e1fica de tu aplicaci\u00f3n, es decir, los diferentes estilos de texto (t\u00edtulos, cuerpos, etiquetas, etc.).</li> <li><code>Theme.kt</code>: Es el coraz\u00f3n del sistema. Aqu\u00ed es donde se unen el color, la tipograf\u00eda y la forma para crear el tema completo que se aplicar\u00e1 a tu aplicaci\u00f3n.</li> </ul> <p>El componente central es el composable <code>MaterialTheme</code>, que utiliza tres par\u00e1metros principales para configurar el tema:</p> <ol> <li><code>colorScheme</code>: Un esquema de color de Material 3 que asigna roles de color sem\u00e1nticos (como <code>primary</code>, <code>surface</code>, <code>onError</code>) a valores de color espec\u00edficos.</li> <li><code>typography</code>: Una escala de tipos que define el estilo para cada rol de texto (<code>displayLarge</code>, <code>bodyMedium</code>, <code>labelSmall</code>, etc.).</li> <li><code>shapes</code>: Define los atributos de forma, espec\u00edficamente el radio de las esquinas para componentes peque\u00f1os, medianos y grandes.</li> </ol> <p>Al envolver la UI de tu aplicaci\u00f3n con <code>MaterialTheme</code>, todos los componentes de Material que utilices dentro de \u00e9l (como <code>Button</code>, <code>Card</code>, <code>Scaffold</code>) heredar\u00e1n y aplicar\u00e1n autom\u00e1ticamente estos estilos, garantizando una consistencia visual sin esfuerzo.</p> <pre><code>// En tu Actividad principal o Composable ra\u00edz\nMyAppTheme { // Tu tema personalizado que configura MaterialTheme\n    Scaffold(...) {\n        // Todo el contenido aqu\u00ed dentro usar\u00e1 los colores,\n        // tipograf\u00eda y formas definidas en MyAppTheme\n    }\n}\n</code></pre>"},{"location":"temas/03/3.2-temas.html#12-colorscheme-o-esquema-de-color","title":"\ud83c\udfa8 1.2 ColorScheme o Esquema de Color","text":"<p>Imaginad que est\u00e1is pintando un cuadro. No usar\u00edais colores al azar, \u00bfverdad? Elegir\u00edais una paleta de colores que funcionen bien juntos para transmitir una emoci\u00f3n o un estilo. En el dise\u00f1o de interfaces, un esquema de color es exactamente eso: un conjunto de colores seleccionados cuidadosamente que se utilizan de manera coherente en toda la aplicaci\u00f3n.</p> <p>Este esquema define qu\u00e9 colores usar para los fondos, los botones, el texto, los iconos, etc. Un buen esquema de color ayuda a:</p> <ul> <li>Crear Jerarqu\u00eda Visual: Gu\u00eda la atenci\u00f3n del usuario hacia los elementos m\u00e1s importantes.[1]</li> <li>Mejorar la Usabilidad: Asegura que el texto sea legible y que los elementos interactivos se distingan.[3]</li> <li>Transmitir la Personalidad de la Marca: Los colores evocan emociones y pueden reforzar la identidad de vuestra aplicaci\u00f3n</li> <li>Proporcionar Coherencia: Ofrece una experiencia unificada y profesional al usuario.</li> </ul> <p>Material Design 3 y el Color Din\u00e1mico (\"Material You\")</p> <p>Con la llegada de Material Design 3, tambi\u00e9n conocido como Material You, el concepto de esquema de color ha evolucionado significativamente. La caracter\u00edstica estrella es el color din\u00e1mico.</p> <p>En dispositivos con Android 12 y versiones posteriores, el sistema puede extraer colores del fondo de pantalla del usuario para generar una paleta de colores \u00fanica y personalizada que se aplica a todo el sistema y a las aplicaciones compatibles. Esto crea una experiencia profundamente personal y cohesiva para el usuario. Como desarrolladores, Jetpack Compose nos facilita enormemente la implementaci\u00f3n de estos temas din\u00e1micos.</p> <p>Fundamental: Leer sobre Color Scheme y Color Roles</p> <p>Fundamental leer para entender conceptos como \"Color Schema\", \"Color Roles\"</p>"},{"location":"temas/03/3.2-temas.html#2-personalizando-tu-tema","title":"\ud83c\udf08 2. Personalizando tu Tema","text":"<p>La verdadera potencia del sistema de Theming reside en su facilidad de personalizaci\u00f3n. Veamos c\u00f3mo ajustar cada uno de los pilares.</p>"},{"location":"temas/03/3.2-temas.html#personalizar-el-color","title":"Personalizar el Color","text":"<p>La personalizaci\u00f3n del color se realiza en los archivos <code>Color.kt</code> y <code>Theme.kt</code>.</p> <ol> <li> <p>Define tus colores base en <code>Color.kt</code>: </p><pre><code>// ui/theme/Color.kt\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n</code></pre><p></p> </li> <li> <p>Asigna esos colores a los roles del <code>ColorScheme</code> en <code>Theme.kt</code>:     Material 3 proporciona las funciones <code>lightColorScheme</code> y <code>darkColorScheme</code> para construir tus paletas. Solo necesitas asignar tus colores base a los roles que desees.</p> <p></p><pre><code>// ui/theme/Theme.kt\nprivate val DarkColorScheme = darkColorScheme(\n    primary = Purple80,\n    secondary = PurpleGrey80,\n    tertiary = Pink80,\n    background = Color(0xFF1C1B1F),\n    surface = Color(0xFF1C1B1F)\n    // ... puedes personalizar todos los dem\u00e1s roles\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40,\n    background = Color(0xFFFFFBFE),\n    surface = Color(0xFFFFFBFE)\n    // ... otros colores\n)\n</code></pre> La clave aqu\u00ed es usar los roles de color sem\u00e1nticamente. Por ejemplo, <code>primary</code> se usar\u00e1 para elementos prominentes como botones principales, mientras que <code>surface</code> se usar\u00e1 para el fondo de componentes como <code>Card</code> o <code>Dialog</code>.<p></p> </li> </ol>"},{"location":"temas/03/3.2-temas.html#personalizar-la-tipografia","title":"Personalizar la Tipograf\u00eda \ud83d\udccf","text":"<p>La tipograf\u00eda se define en <code>Type.kt</code>. Puedes ajustar la familia de fuentes, el grosor, el tama\u00f1o y otros atributos para cada estilo de la escala.</p> <ol> <li>Agrega tus fuentes: Coloca tus archivos de fuentes (por ejemplo, <code>.ttf</code> u <code>.otf</code>) en la carpeta <code>res/font</code>.</li> <li>Define la <code>FontFamily</code>: <pre><code>// ui/theme/Type.kt\nval Montserrat = FontFamily(\n    Font(R.font.montserrat_regular),\n    Font(R.font.montserrat_bold, FontWeight.Bold)\n)\n</code></pre></li> <li> <p>Crea tu objeto <code>Typography</code>: Asigna tu <code>FontFamily</code> personalizada a los estilos de la escala tipogr\u00e1fica.</p> <p></p><pre><code>// ui/theme/Type.kt\nval Typography = Typography(\n    bodyLarge = TextStyle(\n        fontFamily = Montserrat,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n        lineHeight = 24.sp,\n        letterSpacing = 0.5.sp\n    ),\n    titleLarge = TextStyle(\n        fontFamily = Montserrat,\n        fontWeight = FontWeight.Bold,\n        fontSize = 22.sp,\n        lineHeight = 28.sp,\n        letterSpacing = 0.sp\n    )\n    /* Define otros estilos de texto que necesites */\n)\n</code></pre> Luego, en tu composable de tema (<code>Theme.kt</code>), simplemente pasa este objeto <code>Typography</code> al par\u00e1metro <code>typography</code> de <code>MaterialTheme</code>.<p></p> </li> </ol>"},{"location":"temas/03/3.2-temas.html#personalizar-la-forma","title":"Personalizar la Forma \ud83d\udcd0","text":"<p>Las formas de los componentes se personalizan a trav\u00e9s del objeto <code>Shapes</code> en <code>Theme.kt</code>. Puedes definir el radio de las esquinas para las tres categor\u00edas de tama\u00f1o.</p> <p></p><pre><code>// ui/theme/Theme.kt (o un archivo Shapes.kt dedicado)\nval Shapes = Shapes(\n    small = RoundedCornerShape(4.dp),\n    medium = RoundedCornerShape(8.dp),\n    large = RoundedCornerShape(16.dp)\n)\n</code></pre> Componentes como <code>Button</code> y <code>TextField</code> usar\u00e1n por defecto <code>Shapes.small</code> o <code>Shapes.medium</code>, mientras que un <code>ModalBottomSheet</code> podr\u00eda usar <code>Shapes.large</code>. Esta jerarqu\u00eda de formas ayuda a crear una coherencia visual en toda la aplicaci\u00f3n.<p></p>"},{"location":"temas/03/3.2-temas.html#3-generando-un-tema-completo-desde-un-unico-color","title":"\ud83c\udfa8 3. Generando un Tema Completo desde un \u00danico Color","text":"<p>La caracter\u00edstica m\u00e1s destacada de Material You es su capacidad para generar una paleta de colores rica y accesible a partir de un \u00fanico color semilla (seed color). Esto no solo es la base para el color din\u00e1mico (que se adapta al fondo de pantalla del usuario), sino que tambi\u00e9n es una herramienta incre\u00edblemente poderosa para los desarrolladores para crear temas de marca personalizados.</p> <p>La herramienta oficial para esto es el Material Theme Builder, disponible tanto en la web como en Figma.</p>"},{"location":"temas/03/3.2-temas.html#pasos-para-generar-y-aplicar-tu-tema","title":"Pasos para Generar y Aplicar tu Tema:","text":"<ol> <li>Abre el Material Theme Builder: Navega a la herramienta web oficial.</li> <li>Elige tu Color Semilla: En la secci\u00f3n \"Primary\", introduce el c\u00f3digo hexadecimal de tu color de marca principal.</li> <li>Observa la Magia: La herramienta genera instant\u00e1neamente una paleta tonal completa para los colores primarios, secundarios, terciarios</li> </ol>"},{"location":"temas/03/3.2-temas.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/03/3.2-temas.html#a-practicar-aplicacion-superheroes-y-30-dias","title":"\ud83d\ude80 A pr\u00e1cticar: Aplicaci\u00f3n \"Superh\u00e9roes\" y \"30 d\u00edas\"","text":"<p>Para aprender los conceptos, vamos a trabajar con dos proyectos pr\u00e1cticos.</p> <ul> <li> <p>\u2b06\ufe0f Pr\u00e1ctica 1:</p> <p>Proyecto. App de Superh\u00e9roes. Sigue las indicaciones aqu\u00ed.</p> </li> </ul> <p></p> <ul> <li> <p>\u2b06\ufe0f Pr\u00e1ctica 2:</p> <p>Proyecto. 30 d\u00edas. Sigue las indicaciones aqu\u00ed.</p> </li> </ul> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li>Codelab. Temas de Material con Compose. Codelab.</li> <li>Codelab. Animaci\u00f3n simple con Compose. Codelab.</li> </ol>"},{"location":"temas/03/3.3-arquitectura.html","title":"3.3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.3-arquitectura.html#33-arquitectura","title":"3.3 Arquitectura","text":"<p>En Android, la arquitectura de una aplicaci\u00f3n se refiere a la estructura y organizaci\u00f3n de sus componentes, como las actividades, fragmentos, servicios y otros elementos que la componen.</p> <p>Una buena arquitectura es fundamental para crear aplicaciones robustas, escalables y f\u00e1ciles de mantener.</p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n de concepto de arquitectura</p>"},{"location":"temas/03/3.3-arquitectura.html#331-principios-de-arquitectura","title":"3.3.1 Principios de Arquitectura","text":"<p>El dise\u00f1o de la arquitectura de una aplicaci\u00f3n define los l\u00edmites y las responsabilidades de sus partes. Para construir una aplicaci\u00f3n robusta que pueda crecer y adaptarse a diversos factores de forma, se deben seguir los siguientes principios:</p> <ol> <li> <p>Separaci\u00f3n de Problemas (El Principio Fundamental): </p> <p>Este es el principio m\u00e1s importante. Consiste en evitar escribir todo el c\u00f3digo en clases basadas en la IU, como <code>Activity</code> o <code>Fragment</code>. Estas clases solo deben contener la l\u00f3gica relacionada con las interacciones de la IU y del sistema operativo. Al mantenerlas limpias, se mitigan los problemas relacionados con su ciclo de vida vol\u00e1til, ya que el SO puede destruirlas en cualquier momento.</p> </li> <li> <p>Controlar la IU a partir de modelos de datos: </p> <p>La interfaz de usuario debe ser impulsada por modelos de datos, que idealmente deben ser persistentes. Estos modelos son independientes de la IU y del ciclo de vida de los componentes, lo que mejora la solidez y la capacidad de prueba de la aplicaci\u00f3n.</p> </li> <li> <p>Dise\u00f1os Adaptables: </p> <p>La aplicaci\u00f3n debe manejar correctamente los cambios de configuraci\u00f3n (como la orientaci\u00f3n vertical/horizontal y los diferentes tama\u00f1os de pantalla) para proporcionar una experiencia de usuario \u00f3ptima en m\u00faltiples factores de forma.</p> </li> </ol>"},{"location":"temas/03/3.3-arquitectura.html#arquitectura-moderna-de-apps","title":"Arquitectura moderna de Apps","text":"<p>La arquitectura moderna de apps promueve t\u00e9cnicas espec\u00edficas que se implementan en las capas anteriores para asegurar la robustez del sistema:</p> <ol> <li>Arquitectura adaptable y en capas.</li> <li>Flujo unidireccional de datos (UDF) en todas las capas.</li> <li>Uso de contenedores de estado en la capa de la IU para administrar la complejidad.</li> <li>Uso de Corrutinas y Flows (Flujos) para operaciones as\u00edncronas.</li> <li>Uso de las mejores pr\u00e1cticas para la inserci\u00f3n de dependencias (DI). Google recomienda seguir estos patrones y usar la biblioteca Hilt para construir autom\u00e1ticamente objetos y proporcionar verificaci\u00f3n de dependencias en tiempo de compilaci\u00f3n.</li> </ol>"},{"location":"temas/03/3.3-arquitectura.html#arquitectura-recomendada-en-android","title":"Arquitectura recomendada en Android","text":"<p>La arquitectura de aplicaciones recomendada por Android est\u00e1 dise\u00f1ada para gestionar las condiciones de lanzamiento variables y las restricciones de recursos de los dispositivos m\u00f3viles. Considerando los principios comunes, toda aplicaci\u00f3n debe tener al menos dos capas: la Capa de la IU y la Capa de Datos. Una tercera capa, la Capa de Dominio, es opcional.</p> <p>estructura jer\u00e1rquica de la aplicaci\u00f3n</p> <p>Diagrama de arquitectura de una app</p> <p>arquitectura de app t\u00edpica muestra la estructura jer\u00e1rquica de la aplicaci\u00f3n, donde las flechas representan las dependencias entre las clases. Por ejemplo, la Capa de Dominio depende de las clases de la Capa de Datos.</p>"},{"location":"temas/03/3.3-arquitectura.html#1-capa-de-la-iu-capa-de-presentacion","title":"1. Capa de la IU (Capa de Presentaci\u00f3n)","text":"<p><code>Funci\u00f3n:</code> Mostrar los datos de la aplicaci\u00f3n en la pantalla y actualizar la IU cuando los datos cambian, ya sea por interacci\u00f3n del usuario o entrada externa (como una respuesta de red). Sus elementos clave son:</p> <ul> <li> <p>Elementos de la IU: Componentes que renderizan los datos. Se pueden compilar con Vistas o con las funciones de Jetpack Compose. Ambas opciones admiten dise\u00f1os adaptables.</p> </li> <li> <p>Contenedores de estados (State holders): Clases (como ViewModel) que retienen los datos, los exponen a la IU y controlan la l\u00f3gica de la IU.</p> </li> </ul> <p>El rol de la capa de la IU en la arquitectura de la app.</p> <p></p>"},{"location":"temas/03/3.3-arquitectura.html#2-capa-de-datos","title":"2. Capa de Datos","text":"<p><code>Funci\u00f3n:</code> Contener la l\u00f3gica empresarial de la aplicaci\u00f3n, es decir, las reglas que determinan c\u00f3mo se crean, almacenan y modifican los datos de la aplicaci\u00f3n.</p> <p>Estructura: Est\u00e1 compuesta por Repositorios, que administran las Fuentes de Datos.</p> <p>Repositorios</p> <p>Las clases de repositorio son responsables de las siguientes tareas:</p> <ul> <li>Exponer datos al resto de la app</li> <li>Centralizar los cambios en los datos</li> <li>Resolver conflictos entre m\u00faltiples fuentes de datos</li> <li>Abstraer fuentes de datos del resto de la app</li> <li>Contener la l\u00f3gica empresarial</li> </ul> <ul> <li> <p>Repositorios: Debe haber una clase de repositorio para cada tipo de dato que se administre (por ejemplo, <code>MoviesRepository</code> o <code>PaymentsRepository</code>).</p> </li> <li> <p>Responsabilidades: Exponer datos al resto de la app, centralizar los cambios en los datos, resolver conflictos entre m\u00faltiples fuentes, abstraer las fuentes de datos y contener la l\u00f3gica empresarial.</p> </li> <li> <p>Fuentes de Datos: Cada fuente de datos es responsable de trabajar con una sola fuente de datos (una red, un archivo o una base de datos local).</p> </li> </ul> <p>El rol de la capa de la IU en la arquitectura de la app.</p> <p>La imagen ilusta el rol de la capa de datos en la arquitectura de la app10. Esta capa es vital para la solidez, pues fomenta una arquitectura que prioriza la condici\u00f3n sin conexi\u00f3n (offline first), donde la fuente de informaci\u00f3n de la aplicaci\u00f3n suele ser una base de datos.</p> <p></p>"},{"location":"temas/03/3.3-arquitectura.html#3-capa-de-dominio-opcional","title":"3. Capa de Dominio (Opcional)","text":"<ul> <li>Funci\u00f3n: Encapsular la l\u00f3gica empresarial compleja o la l\u00f3gica simple que se reutiliza en varios <code>ViewModels</code>.</li> <li>Naturaleza: Es una capa opcional que se utiliza \u00fanicamente cuando se necesita administrar la complejidad o favorecer la reutilizaci\u00f3n, ubic\u00e1ndose entre la capa de IU y la de datos.</li> <li>Estructura: Las clases de esta capa se conocen como casos de uso (use cases) o interactores13. Cada caso de uso debe enfocarse en una funcionalidad \u00fanica (ejemplo: una clase <code>GetTimeZoneUseCase</code> si varios ViewModels necesitan consultar la zona horaria).</li> </ul> <p>El rol de la capa de la dominio en la arquitectura de la app.</p> <p>La imagen muestra el rol de la capa de dominio en la arquitectura de la app, sirviendo como un mediador para la l\u00f3gica compleja antes de que los datos lleguen a la capa de presentaci\u00f3n.</p>"},{"location":"temas/03/3.3-elementos-menus.html","title":"3.3. Elementos Tipo Menus","text":""},{"location":"temas/03/3.3-elementos-menus.html#33-elementos-tipo-menus","title":"3.3. Elementos Tipo Menus","text":"<p>Se incluye:</p> <ul> <li>Scaffold</li> <li>Menu</li> <li>TopAppBar</li> <li>BottomBar</li> <li>FloatingActionButton</li> <li>Drawer</li> </ul> <p>El componente de layout usado con estos componentes es Scaffold</p>"},{"location":"temas/03/3.3-elementos-menus.html#1-scaffold","title":"1. Scaffold","text":"<p>Piensa en Scaffold como el esqueleto b\u00e1sico de tu interfaz de usuario en una aplicaci\u00f3n Compose. Proporciona una estructura est\u00e1ndar para implementar la mayor\u00eda de las interfaces de usuario comunes.</p> <p>Estructura de Scaffold:</p> <ul> <li> <p><code>slots</code> para diferentes partes de la interfaz, como la barra de aplicaciones (app bar), el contenido principal, un drawer (men\u00fa lateral), FABs (Floating Action Buttons), y barras de navegaci\u00f3n o snackbar.</p> </li> <li> <p>Barra de Aplicaciones: Scaffold te permite agregar f\u00e1cilmente una barra de aplicaciones en la parte superior de la pantalla, donde generalmente colocas el t\u00edtulo de la pantalla, men\u00fas, y otras acciones.</p> </li> <li>Contenido Principal: Aqu\u00ed es donde colocas el contenido principal de tu pantalla. Scaffold se encarga de posicionar este contenido de manera que no se superponga con otros elementos como la barra de aplicaciones o el FAB.</li> <li>Drawer (Cajon): men\u00fa lateral (como el men\u00fa de hamburguesa), Scaffold tiene un slot para esto. Es \u00fatil para la navegaci\u00f3n en la app.</li> <li>Floating Action Button (FAB): Para acciones primarias en tu pantalla, puedes usar un FAB. Scaffold te permite agregarlo en un lugar adecuado, generalmente en la esquina inferior derecha.</li> <li>Bottom Bar y Snackbar: Si necesitas una barra de navegaci\u00f3n en la parte inferior o mostrar mensajes temporales (snackbars), Scaffold tambi\u00e9n te ofrece espacios para ellos.</li> </ul> <p>Revisa la documentaci\u00f3n oficial:</p> <p>La documentaci\u00f3n oficial siempre es el mejor lugar para profundizar en los detalles y ver ejemplos actualizados. Aqu\u00ed tienes algunos enlaces \u00fatiles:</p> <ul> <li>Scaffold en Jetpack Compose</li> </ul> <p>El componente <code>Scaffold</code> es un contenedor que proporciona una estructura b\u00e1sica para la aplicaci\u00f3n. Incluye \u00e1reas para el <code>TopAppBar</code>, <code>BottomBar</code>, <code>FloatingActionButton</code> y el contenido principal de la pantalla.</p> <p>Ejemplo scaffold</p> <pre><code>@Composable\nfun ScaffoldExample() {\n    var presses by remember { mutableIntStateOf(0) }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                colors = topAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primaryContainer,\n                    titleContentColor = MaterialTheme.colorScheme.primary,\n                ),\n                title = {\n                    Text(\"Top app bar\")\n                }\n            )\n        },\n        bottomBar = {\n            BottomAppBar(\n                containerColor = MaterialTheme.colorScheme.primaryContainer,\n                contentColor = MaterialTheme.colorScheme.primary,\n            ) {\n                Text(\n                    modifier = Modifier\n                        .fillMaxWidth(),\n                    textAlign = TextAlign.Center,\n                    text = \"Bottom app bar\",\n                )\n            }\n        },\n        floatingActionButton = {\n            FloatingActionButton(onClick = { presses++ }) {\n                Icon(Icons.Default.Add, contentDescription = \"Add\")\n            }\n        }\n    ) { innerPadding -&gt;\n        Column(\n            modifier = Modifier\n                .padding(innerPadding),\n            verticalArrangement = Arrangement.spacedBy(16.dp),\n        ) {\n            Text(\n                modifier = Modifier.padding(8.dp),\n                text =\n                \"\"\"\n                    This is an example of a scaffold. It uses the Scaffold composable's parameters to create a screen with a simple top app bar, bottom app bar, and floating action button.\n\n                    It also contains some basic inner content, such as this text.\n\n                    You have pressed the floating action button $presses times.\n                \"\"\".trimIndent(),\n            )\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, se incluyen otros componentes como:</p> <ul> <li>TopAppBar y CenterAlignedTopAppBar Es el equivalente b\u00e1sico de una toolbar. Puedes personalizar el t\u00edtulo, los botones de acci\u00f3n, y el estilo en general. Por ejemplo -BottomAppBar: Este no es exactamente una toolbar, pero se utiliza para una barra de navegaci\u00f3n en la parte inferior de la pantalla. Es com\u00fan en aplicaciones modernas, ofreciendo accesos directos a las funciones principales.</li> <li>Custom AppBar: Puedes crear tu propia AppBar personalizada usando Row o cualquier otro layout combinado con los componentes de Material Design como IconButton, Text, etc. Esto te da libertad total para dise\u00f1ar algo \u00fanico.</li> <li>FloatingActionButton : Este bot\u00f3n flotante es ideal para acciones principales en tus pantallas, como agregar un nuevo elemento, iniciar una nueva conversaci\u00f3n, etc.</li> <li>Drawer: caj\u00f3n lateral para navegaci\u00f3n adicional o configuraciones.</li> </ul> <p>Lee este post para un ejemplo completo de uso de Scaffold en Compose: Scaffold en Jetpack Compose: Estructura b\u00e1sica para tu UI</p>"},{"location":"temas/03/3.3-elementos-menus.html#2-menus","title":"2. Menus","text":"<p>Los men\u00fas son componentes de interfaz de usuario que permiten a los usuarios seleccionar opciones o acciones de una lista desplegable. En Jetpack Compose, puedes crear men\u00fas utilizando la funci\u00f3n <code>DropdownMenu</code> y <code>ExposedDropdownMenuBox</code>.</p> <p>Revisa la documentaci\u00f3n oficial:</p> <p>Documentaci\u00f3n oficial para profundizar en los detalles y ver ejemplos actualizados:</p> <ul> <li>Menus en Jetpack Compose</li> <li>Menus en Material Design</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#21-menu-desplegable-dropdownmenu","title":"2.1. Men\u00fa desplegable (DropdownMenu)","text":"<p>En este punto vamos a ver el uso de men\u00fas en Compose, con el fin de desplegar una lista de opciones en superficies que aparecen temporalmente hasta que el usuario selecciona una de ellas, o cancela la selecci\u00f3n.</p> <p>Tipos de men\u00fas en Material Design</p> <p>Existen dos tipos de men\u00fas: Dropdown Menu y Exposed Dropdown Menu. </p> <p>La siguiente es una tabla con m\u00e1s detalle sobre el contenido de la lecci\u00f3n:</p> <p>Dropdown Menu en Compose</p> <p>La funci\u00f3n composable <code>DropdownMenu</code> muestra un men\u00fa desplegable que aparece al hacer clic en un bot\u00f3n o cualquier otro elemento interactivo. Este men\u00fa puede contener varias opciones que el usuario puede seleccionar.</p> <pre><code>@Composable\nfun DropdownMenu(\n    expanded: Boolean!,\n    onDismissRequest: (() -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    offset: DpOffset! = DpOffset(0.dp, 0.dp),\n    properties: PopupProperties! = PopupProperties(focusable = true),\n    content: (@Composable @ExtensionFunctionType ColumnScope.() -&gt; Unit)?\n): Unit\n</code></pre> <p>Donde:</p> <ul> <li><code>expanded</code>: Indica si el men\u00fa est\u00e1 expandido (visible) o no.</li> <li><code>onDismissRequest</code>: Callback que se llama cuando el men\u00fa debe cerrarse.</li> <li><code>modifier</code>: Modificador para personalizar el men\u00fa.</li> <li><code>offset</code>: Desplazamiento del men\u00fa desde su posici\u00f3n predeterminada.</li> <li><code>properties</code>: Propiedades del popup que contiene el men\u00fa.</li> <li><code>content</code>: Contenido del men\u00fa, generalmente una lista de <code>DropdownMenuItem</code>.</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#agregar-elementos-al-menu","title":"Agregar elementos al men\u00fa","text":"<p>Dentro del contenido del <code>DropdownMenu</code>, puedes agregar elementos utilizando la funci\u00f3n <code>DropdownMenuItem</code>. Cada elemento representa una opci\u00f3n en el men\u00fa.</p> <pre><code>@Composable\nfun DropdownMenuItem(\n    onClick: (() -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    enabled: Boolean! = true,\n    contentPadding: PaddingValues! = PaddingValues(16.dp),\n    leadingIcon: (@Composable () -&gt; Unit)? = null,\n    trailingIcon: (@Composable () -&gt; Unit)? = null,\n    text: (@Composable () -&gt; Unit)?\n): Unit\n</code></pre> <p>Donde: - <code>onClick</code>: Callback que se llama cuando el elemento es seleccionado. - <code>modifier</code>: Modificador para personalizar el elemento. - <code>enabled</code>: Indica si el elemento est\u00e1 habilitado o deshabilitado. - <code>contentPadding</code>: Padding alrededor del contenido del elemento. - <code>leadingIcon</code>: Icono que aparece antes del texto. - <code>trailingIcon</code>: Icono que aparece despu\u00e9s del texto. - <code>text</code>: Contenido de texto del elemento.</p> DropdownMenu simple <p></p> <p>Ejemplo de Dropdown Menu</p> <p></p> <p>Supongamos que tenemos una App de tareas y deseamos incluir en su vista de lista un men\u00fa para realizar las siguientes acciones:</p> <ul> <li>Cambiar nombre</li> <li>Enviar por email</li> <li>Copiar enlace</li> <li>Ocultar subtareas completas</li> <li>Eliminar</li> </ul> <p>Para crear el men\u00fa debemos:</p> <ol> <li>Definir la expansi\u00f3n del men\u00fa como estado</li> <li>Declarar la lista de opciones</li> <li>Invocar a <code>DropdownMenu</code></li> <li>A\u00f1adir cinco elementos <code>DropdownMenuItem</code></li> </ol> <p>El c\u00f3digo de la soluci\u00f3n lo encuentras en la funci\u00f3n <code>TaskMenu()</code></p> <p></p><pre><code>@Composable\nfun TaskMenu(\n    expanded: Boolean, // (1)\n    onItemClick: (String) -&gt; Unit,\n    onDismiss: () -&gt; Unit\n) {\n\n    val options = listOf( // (2)\n        \"Cambiar nombre\",\n        \"Enviar por email\",\n        \"Copiar enlace\",\n        \"Ocultar subtareas completas\",\n        \"Eliminar\"\n    )\n\n    DropdownMenu( // (3)\n        expanded = expanded,\n        onDismissRequest = onDismiss\n    ) {\n        options.forEach { option -&gt;\n            DropdownMenuItem( // (4)\n                onClick = {\n                    onItemClick(option)\n                    onDismiss()\n                }\n            ) {\n                Text(text = option)\n            }\n        }\n    }\n}\n</code></pre> Como ves, hemos elevado el estado de la expansi\u00f3n y las funciones ejecutadas al clickear un \u00edtem y al descartar el men\u00fa. Estos valores son prove\u00eddos desde la funci\u00f3n TasksUi(), la cual se encarga de dibujar la tarea y el icono que muestra al men\u00fa:<p></p> <p></p><pre><code>@Composable\nfun TasksUi() {\n    var taskMenuOpen by remember { mutableStateOf(false) }\n    var action by remember { mutableStateOf(\"Ninguna\") }\n\n    Box(\n        Modifier\n            .border(width = 1.dp, shape = RectangleShape, color = Color.LightGray)\n            .padding(horizontal = 16.dp)\n            .fillMaxWidth()\n            .height(56.dp)\n\n    ) {\n        Row(\n            Modifier\n                .fillMaxWidth()\n                .align(Alignment.CenterStart),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Checkbox(\n                checked = false,\n                onCheckedChange = {},\n                modifier = Modifier\n                    .size(24.dp)\n            )\n            Spacer(modifier = Modifier.width(16.dp))\n            Column {\n\n                Text(\n                    text = \"Limpiar alacena\"\n                )\n                Text(text = \"Acci\u00f3n: $action\", style = MaterialTheme.typography.caption)\n            }\n\n        }\n        IconButton(\n            onClick = { taskMenuOpen = true },\n            modifier = Modifier\n                .size(24.dp)\n                .align(Alignment.CenterEnd)\n        ) {\n            Icon(\n                imageVector = Icons.Filled.MoreVert,\n                contentDescription = \"Acciones para tarea\"\n            )\n            TaskMenu(\n                expanded = taskMenuOpen,\n                onItemClick = { action = it },\n                onDismiss = {\n                    taskMenuOpen = false\n                }\n            )\n        }\n    }\n}\n</code></pre> Al ejecutar la aplicaci\u00f3n, veremos el siguiente resultado:<p></p> <p></p> <p>TaskUI() en acci\u00f3n</p> <p></p> Ejemplo: Item con icono, item deshabilitado y divisor <p></p> <p>DropdownMenu con \u00edtems personalizados</p> <p></p> <p>Probemos con un caso donde podamos personalizar los \u00edtems como el que se muestra en la imagen anterior.</p> <p>Consideremos una App donde permitamos al usuario desplegar un men\u00fa para un imagen que visualiza, cuando hace clic prolongado. Las opciones asociadas y las decoraciones son:</p> <ul> <li>Previsualizar (Icono)</li> <li>Compartir (Icono)</li> <li>Copiar Enlace (Icono)</li> <li>Descargar (Icono + Deshabilitado)</li> <li>Denunciar (Icono + Divisor)</li> </ul> <p>\u00bfC\u00f3mo enfrentar estos requerimientos de interfaz?</p> <ol> <li>Iconos: Usa el componente <code>Icon</code> en el par\u00e1metro <code>content</code> de los \u00edtems. Recuerda que este tiene un recibidor tipo <code>RowScope</code>, por lo que no es necesario a\u00f1adir un elemento <code>Row</code></li> <li>Estado Deshabilitado: Usa el par\u00e1metro <code>enabled</code> con el valor de <code>false</code> para deshabilitar un \u00edtem</li> <li>Divisor: Invoca al componente <code>Divider</code> entre los \u00edtems donde deseas visualizarlo. En nuestro caso es antes de \u00abDescargar\u00bb</li> </ol> <p>Los elementos previos podemos agruparlos en una clase de datos llamada <code>Option</code>. Adem\u00e1s, como deseamos tratar al divisor como otro \u00edtem, podemos crear una interfaz sellada <code>MenuItem</code> que contenga ambos tipos</p> <p></p><pre><code>sealed interface MenuItem {\n\n    data class Option(\n        val name: String,\n        val icon: ImageVector?,\n        val enabled: Boolean = true\n    ) : MenuItem\n\n    object Divider : MenuItem\n}\n</code></pre> Teniendo en cuenta lo anterior, te ser\u00e1 f\u00e1cil comprender la funci\u00f3n de ejemplo ImageMenu():<p></p> <pre><code>@Composable\nfun ImageMenu(\n    expanded: Boolean,\n    onItemClick: (Option) -&gt; Unit, // (1)\n    onDismiss: () -&gt; Unit\n) {\n    val options = listOf( // (2)\n        Option(\n            \"Previsualizar\",\n            ImageVector.vectorResource(R.drawable.ic_visibility)\n        ),\n        Option(\"Compartir\", Icons.Filled.Share),\n        Option(\"Copiar Enlace\", ImageVector.vectorResource(R.drawable.ic_link)),\n        Option(\"Descargar\", ImageVector.vectorResource(R.drawable.ic_file_download), false),\n        Divider,\n        Option(\"Denunciar\", ImageVector.vectorResource(R.drawable.ic_flag)),\n    )\n\n    DropdownMenu(\n        expanded = expanded,\n        onDismissRequest = onDismiss,\n        offset = DpOffset(50.dp, 250.dp),\n        modifier = Modifier.width(192.dp)\n    ) {\n        options.forEach { option -&gt;\n            when (option) { // (3)\n                is Option -&gt; {\n                    DropdownMenuItem(\n                        enabled = option.enabled,\n                        onClick = {\n                            onItemClick(option)\n                            onDismiss()\n                        }\n                    ) {\n                        option.icon?.let { // (4)\n                            val values = LocalContentAlpha provides\n                                    if (option.enabled)\n                                        ContentAlpha.medium\n                                    else ContentAlpha.disabled\n                            CompositionLocalProvider(values) {\n                                Icon(it, contentDescription = null)\n                            }\n                        }\n\n                        Spacer(Modifier.width(24.dp))\n\n                        Text(text = option.name)\n                    }\n                }\n                Divider -&gt; Divider() // (5)\n            }\n\n        }\n    }\n}\n</code></pre> <p>El en acci\u00f3n se ve as\u00ed:</p> <p></p> <p>ImageUI en acci\u00f3n</p> <p></p> <p> </p>"},{"location":"temas/03/3.3-elementos-menus.html#22-exposed-dropdown-menu","title":"2.2. Exposed Dropdown Menu","text":"<p>Exposed Dropdown Menu en Compose</p> <p>Usa la funci\u00f3n componible <code>ExposedDropdownMenuBox()</code> para mostrar un men\u00fa desplegable expuesto, con el objetivo de mantener visible la selecci\u00f3n actual por encima de las dem\u00e1s opciones.</p> <p>Esta es la firma de la funci\u00f3n:</p> <pre><code>@ExperimentalMaterialApi\n@Composable\nfun ExposedDropdownMenuBox(\n    expanded: Boolean!,\n    onExpandedChange: ((Boolean) -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    content: (@Composable @ExtensionFunctionType ExposedDropdownMenuBoxScope.() -&gt; Unit)?\n): Unit\n</code></pre> <p>Nota: Como ves, en el momento que escribo este tutorial, a\u00fan est\u00e1 marcada como experimental.</p> <p>Sus par\u00e1metros son similares a <code>DropdownMenu</code>, salvo <code>onExpandedChange</code> que es una lambda que se ejecuta cuando el usuario hace clic sobre el men\u00fa.</p> Ejemplo: Expanded Dropdown Menu Simple <p></p> <p>Ejemplo de Exposed Dropdown Menu</p> <p></p> <p>Tomemos como ilustraci\u00f3n un men\u00fa expuesto que permite seleccionar el tipo de tel\u00e9fono que ser\u00e1 asociado a un contacto (figura 7), donde las posibles opciones son:</p> <ul> <li>Fijo</li> <li>M\u00f3vil</li> <li>Trabajo</li> <li>Otro</li> </ul> <p>\u00bfC\u00f3mo abordar este simple escenario?</p> <ol> <li>Declarar la lista de tipos de n\u00famero de tel\u00e9fonos</li> <li>Declarar estados tanto para la apertura del men\u00fa como para la selecci\u00f3n actual</li> <li>Invocar a <code>ExpandedDropdownMenuBox</code></li> <li>A\u00f1adir un <code>[TextField](https://www.develou.com/android-textfield-en-compose/)</code></li> <li>A\u00f1adir un <code>DropdownMenu</code> con los items</li> </ol> <p>La funci\u00f3n componible <code>PhoneNumberTypeMenu()</code> es la encargada de aplicar las tareas anteriores:</p> <pre><code>@OptIn(ExperimentalMaterialApi::class)\n@Composable\nfun PhoneNumberTypeMenu() {\n    val types = listOf(\"Fijo\", \"M\u00f3vil\", \"Trabajo\", \"Otro\")\n    val default = 0\n\n    var expanded by remember { mutableStateOf(false) }\n    var selectedType by remember { mutableStateOf(types[default]) } // (1)\n\n    ExposedDropdownMenuBox(\n        expanded = expanded,\n        onExpandedChange = {\n            expanded = !expanded // (2)\n        },\n        modifier = Modifier.width(150.dp)\n    ) {\n        TextField(\n            readOnly = true, // (3)\n            value = selectedType, // (4)\n            onValueChange = { },\n            label = { Text(\"Tipo\") },\n            trailingIcon = {\n                ExposedDropdownMenuDefaults.TrailingIcon( // (5)\n                    expanded = expanded\n                )\n            },\n            colors = ExposedDropdownMenuDefaults.textFieldColors()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            onDismissRequest = {\n                expanded = false\n            }\n        ) {\n            types.forEach { selectionOption -&gt;\n                DropdownMenuItem(\n                    onClick = {\n                        selectedType = selectionOption\n                        expanded = false\n                    }\n                ) {\n                    Text(text = selectionOption)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Puntos a tener en cuenta del c\u00f3digo preliminar:</p> <ol> <li>Es necesario recordar como estado la selecci\u00f3n actual del <code>TextField</code></li> <li>Modificamos el estado de expansi\u00f3n del men\u00fa desde <code>onExpandedChange</code></li> <li>Como no deseamos recibir texto, marcamos al <code>TextField</code> como solo lectura</li> <li>El valor del campo de texto es definido por la selecci\u00f3n actual</li> <li>El icono del final del campo de texto es prove\u00eddo por <code>ExposedDropdownMenuDefaults.TrailingIcon()</code>. Si revisas su implementaci\u00f3n, ver\u00e1s que se cambia la rotaci\u00f3n del icono de expansi\u00f3n seg\u00fan el valor pasado como par\u00e1metro</li> </ol> <p>Al previsualizar en modo de interacci\u00f3n el resultado es:</p> <p></p> <p><code>PhoneNumberTypeMenu()</code> en acci\u00f3n</p> <p></p>"},{"location":"temas/03/3.3-elementos-menus.html#3-topappbar-bottombar-y-floatingactionbutton","title":"3. TopAppBar, BottomBar y FloatingActionButton","text":""},{"location":"temas/03/3.3-elementos-menus.html#31-topappbar","title":"3.1. TopAppBar","text":"<p>La barra de aplicaciones superior (TopAppBar) es un componente clave en la interfaz de usuario de muchas aplicaciones. Proporciona un espacio para el t\u00edtulo de la pantalla, acciones y navegaci\u00f3n.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>TopAppBar en Jetpack Compose</li> <li>TopAppBar en Material Design</li> <li>TopAppBar playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#32-bottombar","title":"3.2. BottomBar","text":"<p>La barra inferior (BottomBar) es otro componente importante que se utiliza para la navegaci\u00f3n y las acciones en la parte inferior de la pantalla.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>BottomBar en Jetpack Compose</li> <li>BottomBar en Material Design</li> <li>BottomBar playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#33-floatingactionbutton","title":"3.3. FloatingActionButton","text":"<p>El bot\u00f3n de acci\u00f3n flotante (FloatingActionButton o FAB) es un componente que representa la acci\u00f3n principal en una pantalla. Suele ser un bot\u00f3n circular que flota sobre el contenido.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>Documentaci\u00f3n Jetpack Compose</li> <li>Material Design</li> <li>Playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#34-drawer","title":"3.4. Drawer","text":"<p>El drawer (caj\u00f3n) es un componente de navegaci\u00f3n que se desliza desde el borde de la pantalla para mostrar opciones de navegaci\u00f3n adicionales.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>Drawer en Jetpack Compose</li> <li>Drawer en Material Design</li> <li>Drawer playgroud</li> </ul>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html","title":"3.3.2 arquitectura.capa ui","text":""},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#332-capa-ui-arquitectura","title":"3.3.2 \ud83e\uddf1 Capa UI. Arquitectura","text":"<p>La capa de UI es la parte de tu aplicaci\u00f3n con la que el usuario interact\u00faa directamente. Su principal responsabilidad es mostrar los datos de la aplicaci\u00f3n en la pantalla y, a su vez, ser el punto de entrada para las acciones del usuario (clics, escritura, etc.).</p> <p>Piensa en ella como la cabina de un avi\u00f3n \u2708\ufe0f. El piloto (usuario) ve los instrumentos (la pantalla) y acciona los controles (botones, gestos). La cabina no sabe c\u00f3mo funciona el motor; solo muestra la velocidad y env\u00eda la orden \"acelerar\" a las capas internas.</p> <p>Esta capa se compone fundamentalmente de dos tipos de elementos:</p> <ol> <li> <p>Elementos de la UI (UI Elements): Son los componentes visuales que dibujan la pantalla. En Jetpack Compose, estos son tus funciones <code>@Composable</code>. Su \u00fanica misi\u00f3n es transformar un estado en una interfaz gr\u00e1fica. Son \"tontos\" por dise\u00f1o: reciben un estado y lo pintan. No toman decisiones de l\u00f3gica de negocio.</p> </li> <li> <p>Contenedores de Estado (State Holders): Son clases responsables de contener el estado, gestionar la l\u00f3gica de la UI y exponer los datos a los Elementos de la UI. La clase m\u00e1s com\u00fan para esto es el <code>ViewModel</code>. Este es el \"cerebro\" \ud83e\udde0 de la pantalla.</p> </li> </ol>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#el-flujo-de-datos-unidireccional-udf","title":"\u21aa\ufe0f El Flujo de Datos Unidireccional (UDF)","text":"<p>Para que todo funcione de forma ordenada y predecible, la comunicaci\u00f3n entre estos dos componentes sigue un patr\u00f3n estricto llamado Flujo de Datos Unidireccional (Unidirectional Data Flow o UDF).</p> <p>Es muy simple de entender:</p> <ul> <li> <p>El Estado fluye hacia abajo (State flows down) \ud83d\udc47: El <code>ViewModel</code> expone el estado (usando un <code>StateFlow</code>). El Composable lo recoge y se dibuja bas\u00e1ndose en \u00e9l.</p> </li> <li> <p>Los Eventos fluyen hacia arriba (Events flow up) \ud83d\udc46: El Composable no modifica el estado directamente. Cuando el usuario hace clic en un bot\u00f3n, el Composable notifica al <code>ViewModel</code> de este \"evento\" (ej: <code>viewModel.onIncrementarClick()</code>). El <code>ViewModel</code> es quien decide qu\u00e9 hacer y, si es necesario, actualiza su estado.</p> </li> </ul> <p>UDF: Flujo de datos unidireccional.</p> <p>Este ciclo crea un bucle predecible: <code>Evento -&gt; Actualizar Estado -&gt; Mostrar Nuevo Estado</code>.</p> <p>El flujo de datos unidireccional (UDF) es una t\u00e9cnica que se utiliza principalmente en la programaci\u00f3n reactiva funcional. Tambi\u00e9n se conoce como flujo de datos unidireccional, lo que significa que los datos solo pueden transferirse de una manera a otras partes de la aplicaci\u00f3n.</p> <p>La unidireccionalidad significa que no obtenemos nuestros datos solicit\u00e1ndolos directamente. La \u00fanica forma de obtenerlos es activando una acci\u00f3n desde nuestra vista a nuestra capa de datos. El efecto secundario de esta acci\u00f3n es actualizar el estado de nuestros datos.</p> <p>La vista es el resultado del estado de la aplicaci\u00f3n. El estado solo puede cambiar al activar acciones. Cuando se realizan acciones, el estado se actualiza.</p> <p>Acci\u00f3n del estado sobre la vista.</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#como-definir-el-estado-de-la-ui","title":"\u00bfC\u00f3mo definir el estado de la UI?","text":"<p>La IU es lo que ve el usuario, el estado de la IU es lo que la app dice que deber\u00eda ver. Al igual que dos caras de una moneda, la IU es la representaci\u00f3n visual del estado de la IU. Cualquier cambio en el estado de la IU se refleja de inmediato en la IU.</p> <p>La IU es el resultado de la vinculaci\u00f3n de sus elementos en la pantalla con el estado correspondiente..</p> <pre><code>data class NewsUiState(\n    val isSignedIn: Boolean = false,\n    val isPremium: Boolean = false,\n    val newsItems: List&lt;NewsItemUiState&gt; = listOf(),\n    val userMessages: List&lt;Message&gt; = listOf()\n)\n\ndata class NewsItemUiState(\n    val title: String,\n    val body: String,\n    val bookmarked: Boolean = false,\n    ...\n)\n</code></pre> <p>Inmutabilidad</p> <p>La inmutabilidad del estado significa que la UI tiene prohibido modificar los datos que recibe. Su \u00fanica misi\u00f3n es actuar como un espejo, reflejando fielmente el estado actual.</p> <p>Para realizar un cambio, no se \"edita\" el estado viejo, sino que se reemplaza por completo con una instancia nueva y actualizada.</p> <p>Esto impone un orden estricto, garantizando una \u00fanica fuente de verdad. As\u00ed se eliminan los errores impredecibles que ocurren cuando distintas partes del c\u00f3digo intentan modificar los mismos datos a la vez, resultando en una app mucho m\u00e1s estable y predecible.</p> <p>Inmutablidad de forma simple</p> <p>La inmutabilidad en Compose es crucial porque convierte el estado de tu pantalla en una fotograf\u00eda perfecta e inalterable de un momento concreto.</p> <p>Pi\u00e9nsalo con esta analog\u00eda:</p> <ul> <li>El Estado Inmutable es como un plano de una casa \ud83c\udfe0 sellado y firmado por el arquitecto.</li> <li>Jetpack Compose es el equipo de construcci\u00f3n \ud83d\udc77.</li> <li>El ViewModel es el arquitecto \ud83d\udcd0.</li> </ul> <p>Ahora, analicemos por qu\u00e9 esto es tan importante:</p> <ol> <li> <p>Claridad y Previsibilidad</p> <p>El equipo de construcci\u00f3n (Compose) recibe el plano (el objeto de estado) y su \u00fanica tarea es construir la casa exactamente como dice el plano. No tienen que adivinar nada. Saben que el plano que tienen en sus manos es la verdad absoluta en ese momento. Esto hace que su trabajo sea simple y predecible.</p> <p>Esto es lo que el texto quiere decir con: \"los objetos inmutables proporcionan garant\u00edas sobre el estado de la aplicaci\u00f3n en un momento determinado\".</p> </li> <li> <p>Evitar el Caos y los Errores</p> <p>Imagina que el estado fuera mutable (que se pudiera cambiar). Ser\u00eda como si, mientras los obreros construyen, \u00a1cualquiera de ellos pudiera coger un l\u00e1piz y modificar el plano sobre la marcha!</p> <ul> <li>\u00bfD\u00f3nde ir\u00eda esa pared ahora?</li> <li>\u00bfEl electricista estar\u00eda trabajando con el plano antiguo o con el nuevo que acaba de cambiar un fontanero?</li> </ul> <p>Ser\u00eda un caos absoluto. Tendr\u00edas varias versiones de la \"verdad\" al mismo tiempo, lo que llevar\u00eda a errores de construcci\u00f3n (bugs en tu app) muy dif\u00edciles de encontrar.</p> <p>Esto es a lo que se refiere el texto con: \"Infringir este principio genera varias fuentes ver\u00eddicas para la misma informaci\u00f3n, lo que genera inconsistencias en los datos y errores leves\".</p> </li> <li> <p>\u00bfC\u00f3mo se hacen los cambios entonces?</p> <p>Cuando el arquitecto (ViewModel) quiere hacer un cambio (por ejemplo, a\u00f1adir una ventana), no borra y redibuja sobre el plano viejo. Lo que hace es crear un plano completamente nuevo con la ventana a\u00f1adida y se lo entrega al equipo de construcci\u00f3n.</p> <p>El equipo de construcci\u00f3n ve el nuevo plano, lo compara con el anterior y de forma muy eficiente solo construye la parte nueva: la ventana.</p> </li> </ol> <p>Contenedores de estado</p> <p>Un State Holder (o \"contenedor de estado\") es simplemente una clase responsable de guardar y gestionar los datos que tu UI necesita para mostrar en pantalla.</p> <p>Su principal objetivo es separar la l\u00f3gica del dise\u00f1o visual. De esta forma, tus componentes de UI (<code>Composables</code>) se dedican \u00fanicamente a \"pintar\" el estado que reciben, mientras que el State Holder act\u00faa como el \"cerebro\" \ud83e\udde0 que procesa las acciones del usuario y decide qu\u00e9 datos se deben mostrar.</p> <p>En resumen, es el lugar donde vive el estado y la l\u00f3gica de tu pantalla, manteniendo tu c\u00f3digo de UI limpio, simple y f\u00e1cil de probar. El <code>ViewModel</code> es el tipo de State Holder m\u00e1s com\u00fan y recomendado en Android.</p> <p>Punto clave \ud83d\udca1</p> <p>El ViewModel es la implementaci\u00f3n recomendada para administrar el estado de la IU a nivel de pantalla con acceso a la capa de datos. Adem\u00e1s, sobrevive autom\u00e1ticamente a los cambios de configuraci\u00f3n. Las clases ViewModel definen la l\u00f3gica que se aplica a los eventos en la app y, como resultado, producen un estado actualizado.</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#mvvm-el-patron-arquitectonico-por-excelencia","title":"\ud83e\uddee MVVM: El Patr\u00f3n Arquitect\u00f3nico por Excelencia","text":"<p>MVVM son las siglas de Model-View-ViewModel. Es un patr\u00f3n de dise\u00f1o arquitect\u00f3nico que se adapta como un guante a los principios de la capa de UI y el flujo de datos unidireccional. Su objetivo es separar las responsabilidades de forma muy clara.</p> <p>Vamos a desglosar sus tres componentes:</p> <ol> <li> <p>Model (Modelo)</p> <ul> <li>\u00bfQu\u00e9 es? Es la capa de datos de tu aplicaci\u00f3n. Contiene la l\u00f3gica de negocio y es la fuente de la verdad.  </li> <li>\u00bfQu\u00e9 hace? Es responsable de obtener y manipular los datos, ya sea desde una base de datos local (Room), una API de red (Retrofit) o cualquier otra fuente.</li> <li>Componentes: Clases de datos (data classes), Repositorios, Casos de Uso, Fuentes de Datos (Data Sources).    </li> </ul> </li> <li> <p>View (Vista)</p> <ul> <li>\u00bfQu\u00e9 es? Es la interfaz de usuario (UI). Lo que el usuario ve y con lo que interact\u00faa.  </li> <li>\u00bfQu\u00e9 hace? Su \u00fanica responsabilidad es observar los datos expuestos por el ViewModel y dibujarse a s\u00ed misma. Captura las interacciones del usuario y las notifica al ViewModel como eventos.</li> <li>Componentes: En Android tradicional, eran los <code>Activities</code> y <code>Fragments</code> con XML. En el mundo moderno, son tus funciones <code>@Composable</code> en Jetpack Compose.</li> </ul> </li> <li> <p>ViewModel (Vista-Modelo)</p> <ul> <li>\u00bfQu\u00e9 es? Es el intermediario entre el Modelo y la Vista.  </li> <li>\u00bfQu\u00e9 hace? No tiene ninguna referencia a la Vista (\u00a1muy importante!), lo que lo hace f\u00e1cil de testear. Solicita datos al Modelo, aplica la l\u00f3gica de presentaci\u00f3n necesaria y expone el estado listo para ser consumido por la Vista (a trav\u00e9s de <code>StateFlow</code>). Tambi\u00e9n recibe los eventos de la Vista y decide qu\u00e9 acci\u00f3n pedirle al Modelo.</li> <li>Componentes: Clases que heredan de <code>androidx.lifecycle.ViewModel</code>.</li> </ul> </li> </ol> <p>Diagrama que ilustra el ciclo de eventos y datos en el flujo unidireccional de datos</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#tipos-de-logica","title":"Tipos de L\u00f3gica","text":"<p>La \"l\u00f3gica\" se refiere de manera general a las instrucciones, reglas y procesos algor\u00edtmicos que dictan el comportamiento de una aplicaci\u00f3n de software.</p> <p>El texto distingue principalmente entre dos tipos de l\u00f3gica esenciales en el desarrollo de aplicaciones: la l\u00f3gica empresarial y la l\u00f3gica de la Interfaz de Usuario (IU), a veces llamada l\u00f3gica de comportamiento de la IU.</p> <ul> <li> <p>L\u00f3gica Empresarial</p> <p>Representa la aplicaci\u00f3n de las reglas y requerimientos funcionales fundamentales del producto directamente sobre los datos de la aplicaci\u00f3n. Su prop\u00f3sito es definir qu\u00e9 debe hacer la aplicaci\u00f3n con la informaci\u00f3n para cumplir con sus objetivos de valor.</p> <ul> <li><code>Ubicaci\u00f3n:</code> Generalmente reside en las capas de dominio o datos, asegurando que est\u00e9 desacoplada de c\u00f3mo se presenta la informaci\u00f3n. </li> <li><code>Principio Clave:</code> Nunca debe ubicarse en la capa de la Interfaz de Usuario (IU).</li> </ul> </li> <li> <p>L\u00f3gica de la Interfaz de Usuario (IU) o Comportamiento de la IU</p> <p>Determina c\u00f3mo se manifiestan los cambios de estado o las acciones en la pantalla para el usuario. Se encarga de la gesti\u00f3n de la presentaci\u00f3n visual y la interacci\u00f3n.</p> <ul> <li> <p><code>Funci\u00f3n:</code> Incluye la preparaci\u00f3n de elementos para su visualizaci\u00f3n, la navegaci\u00f3n entre vistas como respuesta a interacciones, y la gesti\u00f3n de retroalimentaci\u00f3n visual al usuario (como mensajes temporales).</p> </li> <li> <p><code>Ubicaci\u00f3n:</code> Debe encontrarse en la capa de la IU (la Vista). Si esta l\u00f3gica se vuelve compleja, puede delegarse a una clase auxiliar dentro de la propia IU para mejorar la separaci\u00f3n de responsabilidades y la capacidad de prueba, manteniendo su v\u00ednculo al ciclo de vida de la IU.</p> </li> </ul> </li> </ul>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#aplicando-todo-ejemplos","title":"Aplicando todo. Ejemplos","text":"<p>El el \"Ejemplo 1\" tenemos una aplicaci\u00f3n simple \"Contador\", con un bot\u00f3n que incrementa un n\u00famero al darle click al Bot\u00f3n. El estado \"vive\" dentro del componente \"CounterScreen\".</p> Ejemplo 1: App contador simple <pre><code>// 1. Contador Simple (Estado Local)\n// El estado y la l\u00f3gica residen en el mismo Composable.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n// Funci\u00f3n de entrada para la aplicaci\u00f3n (simulando una actividad/main)\n@Composable\nfun CounterApp1() {\n    MaterialTheme {\n        CounterScreen()\n    }\n}\n\n@Composable\nfun CounterScreen(modifier: Modifier = Modifier) {\n    // 1. Definici\u00f3n del Estado: 'remember' conserva el valor, 'mutableStateOf' lo hace observable.\n    var count by remember { mutableStateOf(0) } // Estado del contador\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\"Estado: LOCAL\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Card(\n            modifier = Modifier.width(200.dp),\n            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)\n        ) {\n            Column(\n                modifier = Modifier\n                    .padding(24.dp)\n                    .fillMaxWidth(),\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\n                    text = \"Contador \u00danico\",\n                    style = MaterialTheme.typography.headlineSmall\n                )\n                Spacer(modifier = Modifier.height(16.dp))\n\n                // Muestra el valor del estado\n                Text(\n                    text = \"$count\",\n                    style = MaterialTheme.typography.displayLarge,\n                    color = MaterialTheme.colorScheme.primary\n                )\n                Spacer(modifier = Modifier.height(24.dp))\n\n                // Bot\u00f3n que modifica el estado directamente\n                Button(\n                    onClick = { count++ },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Text(\"Aumentar (+1)\")\n                }\n                Spacer(modifier = Modifier.height(8.dp))\n\n                // Bot\u00f3n para reiniciar el estado\n                OutlinedButton(\n                    onClick = { count = 0 },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Text(\"Reiniciar a 0\")\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>En esta ejemplo 2, la complejidad aumenta. Ahora tenemos tres piezas de estado (count1, count2, generalCount) y toda la l\u00f3gica que las conecta reside en el mismo componente CounterApp2.</p> Ejemplo 2: App 2 contadores <pre><code>// 2. Contadores M\u00faltiples y General (Todo Local)\n// Todos los estados (individuales y general) y la l\u00f3gica de negocio combinada residen\n// en el mismo componente ra\u00edz.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun CounterApp2() {\n    MaterialTheme {\n        CounterScreenWithCombinedState()\n    }\n}\n\n@Composable\nfun CounterScreenWithCombinedState(modifier: Modifier = Modifier) {\n    // Estados Individuales\n    var count1 by remember { mutableStateOf(0) }\n    var count2 by remember { mutableStateOf(0) }\n\n    // Estado General: Se mantiene localmente y se actualiza junto con los otros.\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: M\u00faltiples Estados LOCALES\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // L\u00f3gica para el Contador 1\n            CounterCard(\n                title = \"Contador #1\",\n                currentCount = count1,\n                onIncrement = {\n                    count1++\n                    generalCount++ // L\u00f3gica de negocio dentro de este Composable\n                },\n                onReset = { count1 = 0 },\n                modifier = Modifier.weight(1f)\n            )\n\n            // L\u00f3gica para el Contador 2\n            CounterCard(\n                title = \"Contador #2\",\n                currentCount = count2,\n                onIncrement = {\n                    count2++\n                    generalCount++ // L\u00f3gica de negocio dentro de este Composable\n                },\n                onReset = { count2 = 0 },\n                modifier = Modifier.weight(1f)\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        Button(onClick = {\n            count1 = 0\n            count2 = 0\n            generalCount = 0\n        }) {\n            Text(\"Reiniciar TODO\")\n        }\n    }\n}\n\n// Componente Reutilizable Simple (UI Pura)\n@Composable\nfun CounterCard(\n    title: String,\n    currentCount: Int,\n    onIncrement: () -&gt; Unit,\n    onReset: () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Spacer(modifier = Modifier.height(8.dp))\n            Text(\n                text = \"$currentCount\",\n                style = MaterialTheme.typography.headlineLarge,\n                color = MaterialTheme.colorScheme.primary\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(onClick = onIncrement, modifier = Modifier.fillMaxWidth()) {\n                Text(\"Aumentar (+1)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n            OutlinedButton(onClick = onReset, modifier = Modifier.fillMaxWidth()) {\n                Text(\"Reiniciar\")\n            }\n        }\n    }\n}\n</code></pre> <p>En esta ejemplo 3, es la versi\u00f3n m\u00e1s importante para entender la arquitectura.</p> <p>El estado que afecta a varios componentes se \"eleva\" al componente padre com\u00fan m\u00e1s cercano. El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.</p> Ejemplo 3: App 2 contadores con Elevaci\u00f3n del Estado (State Hoisting) <pre><code>// 3. Elevaci\u00f3n de Estado (State Hoisting)\n// El estado que afecta a varios componentes se \"eleva\" al componente padre com\u00fan m\u00e1s cercano.\n// El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun CounterApp3() {\n    MaterialTheme {\n        ParentCounterScreen()\n    }\n}\n\n// 1. Componente Padre: Responsable de los estados COMPARTIDOS\n@Composable\nfun ParentCounterScreen(modifier: Modifier = Modifier) {\n    // Estado General: Se define y gestiona en el padre porque afecta a toda la pantalla.\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ELEVACI\u00d3N DE ESTADO (State Hoisting)\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General (gestionada por el padre)\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por PADRE)\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // Contador 1 (Hijo): El padre pasa la funci\u00f3n callback\n            IndividualCounter(\n                title = \"Contador #1 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Cuando el hijo se incrementa, el padre reacciona.\n                onIncremented = { generalCount++ } \n            )\n\n            // Contador 2 (Hijo): El padre pasa la funci\u00f3n callback\n            IndividualCounter(\n                title = \"Contador #2 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Cuando el hijo se incrementa, el padre reacciona.\n                onIncremented = { generalCount++ }\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        // Bot\u00f3n global que el padre gestiona\n        Button(onClick = { generalCount = 0 }) {\n            Text(\"Reiniciar Contador General (El padre no puede resetear al hijo)\")\n        }\n    }\n}\n\n// 2. Componente Hijo: Responsable de su estado INDIVIDUAL\n@Composable\nfun IndividualCounter(\n    title: String,\n    onIncremented: () -&gt; Unit, // Callback para notificar al padre\n    modifier: Modifier = Modifier\n) {\n    // Estado Individual: El hijo gestiona su propio 'count'.\n    var count by remember { mutableStateOf(0) }\n\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $count\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                onClick = {\n                    count++ // 1. Actualiza su estado local\n                    onIncremented() // 2. Llama al callback para notificar al padre\n                }, \n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+1)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = { count = 0 },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo 4, le agregamos un TextField para permitir al usuario indicar la cantidad a incrementar.</p> Ejemplo 4: App 4. Contador con incremento por TextField <pre><code>// 4. Elevaci\u00f3n de Estado con Input (TextField)\n// El componente hijo gestiona su estado local (count y amount) y notifica al padre\n// la cantidad exacta que se ha a\u00f1adido para que el padre pueda actualizar el contador general.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.ui.text.input.KeyboardType\n\n@Composable\nfun CounterApp4() {\n    MaterialTheme {\n        ParentCounterScreenWithInput()\n    }\n}\n\n// 1. Componente Padre: Mantiene el estado COMPARTIDO (General Count)\n@Composable\nfun ParentCounterScreenWithInput(modifier: Modifier = Modifier) {\n    // Estado General: Se define y gestiona en el padre\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ELEVACI\u00d3N DE ESTADO con Input\", style = MaterialTheme.typography.titleMedium)\n        Text(\"El Hijo notifica al Padre la cantidad sumada.\", style = MaterialTheme.typography.bodySmall)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por PADRE)\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // Contador 1 (Hijo): El callback ahora recibe la cantidad sumada\n            IndividualCounterWithInput(\n                title = \"Contador #1 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Recibe la 'amount' y la suma al estado general\n                onIncremented = { amount -&gt; generalCount += amount } \n            )\n\n            // Contador 2 (Hijo)\n            IndividualCounterWithInput(\n                title = \"Contador #2 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Recibe la 'amount' y la suma al estado general\n                onIncremented = { amount -&gt; generalCount += amount }\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        Button(onClick = { generalCount = 0 }) {\n            Text(\"Reiniciar Contador General\")\n        }\n    }\n}\n\n// 2. Componente Hijo: Ahora gestiona dos estados locales (count y incrementAmount)\n@Composable\nfun IndividualCounterWithInput(\n    title: String,\n    onIncremented: (amount: Int) -&gt; Unit, // Callback ahora espera un par\u00e1metro Int\n    modifier: Modifier = Modifier\n) {\n    // Estado 1: Valor actual del contador\n    var count by remember { mutableStateOf(0) }\n    // Estado 2: Valor del TextField (cantidad a incrementar)\n    var incrementAmountText by remember { mutableStateOf(\"1\") }\n\n    // Calcula la cantidad real a incrementar (parsea el texto a Int)\n    val incrementAmount = incrementAmountText.toIntOrNull() ?: 0 // Usa 0 si no es v\u00e1lido\n\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $count\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            // TextField para modificar la cantidad\n            OutlinedTextField(\n                value = incrementAmountText,\n                onValueChange = { newValue -&gt;\n                    // Solo permite n\u00fameros enteros positivos en el estado\n                    if (newValue.all { it.isDigit() } || newValue.isEmpty()) {\n                        incrementAmountText = newValue\n                    }\n                },\n                label = { Text(\"Aumentar en\") },\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),\n                modifier = Modifier.fillMaxWidth()\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                // Deshabilita si el input no es un n\u00famero v\u00e1lido &gt; 0\n                enabled = incrementAmount &gt; 0, \n                onClick = {\n                    count += incrementAmount // 1. Actualiza su estado local\n                    onIncremented(incrementAmount) // 2. Llama al padre con la cantidad\n                }, \n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+ $incrementAmount)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = { \n                    count = 0 \n                },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p>Ejemplo 5, versi\u00f3n final. Agregamos el ViewModel (VM)</p> Ejemplo 5: App 5. Contador con VM Explicaci\u00f3nC\u00f3digo <p>La aplicaci\u00f3n se divide en tres capas bien definidas:</p> <ol> <li> <p>La Capa de Estado (Data Layer)</p> <p>Aqu\u00ed es donde se define qu\u00e9 son los datos de la UI.</p> <ul> <li><code>data class CounterState</code>: Define el estado de un \u00fanico contador. No solo almacena el <code>count</code> (el n\u00famero actual), sino tambi\u00e9n el <code>amountText</code> (el texto que el usuario ve en el <code>TextField</code>) y el <code>incrementAmount</code> (el valor entero ya parseado).</li> <li> <p><code>data class CountersScreenState</code>: Es el contenedor de todo el estado que necesita la pantalla. Es una \u00fanica fuente de verdad que incluye:</p> <ul> <li><code>counter1</code>: El estado del primer contador (<code>CounterState</code>).        </li> <li><code>counter2</code>: El estado del segundo contador (<code>CounterState</code>).</li> <li><code>generalCount</code>: El estado del contador general.</li> </ul> </li> </ul> </li> <li> <p>La Capa de L\u00f3gica (ViewModel)</p> <p>Aqu\u00ed es donde se define c\u00f3mo cambian los datos.</p> <ul> <li> <p><code>class CounterViewModel : ViewModel()</code>:</p> <ul> <li> <p>Contiene el Estado Mutable: Utiliza <code>private val _state = MutableStateFlow(CountersScreenState())</code>. Este es el estado interno y mutable que solo el <code>ViewModel</code> puede modificar.</p> </li> <li> <p>Expone el Estado Observado: Utiliza <code>val state: StateFlow&lt;CountersScreenState&gt; = _state</code>. Este es el estado que la UI (los Composable) observa; es de solo lectura.</p> </li> <li> <p>Define los Eventos (L\u00f3gica de Negocio): Las funciones p\u00fablicas (<code>incrementCounter</code>, <code>setIncrementAmount</code>, <code>resetAll</code>) son los eventos o intenciones que la UI env\u00eda al <code>ViewModel</code>.</p> <ul> <li>Seguridad y Centralizaci\u00f3n: Cuando la UI llama a <code>incrementCounter</code>, el <code>ViewModel</code> usa <code>_state.update { ... }</code> para calcular el nuevo estado a partir del estado actual. Esto garantiza que toda la l\u00f3gica (incrementar el contador individual, validar el texto, y sumar al contador general) ocurre en un solo lugar, de forma segura.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>La Capa de Presentaci\u00f3n (Composable / UI)</p> <p>Aqu\u00ed es donde se define c\u00f3mo se muestra el estado y qu\u00e9 eventos se env\u00edan.</p> <ul> <li> <p><code>CounterScreenWithViewModel()</code>:</p> <ul> <li>Observaci\u00f3n: Usa <code>val state = viewModel.state.collectAsState().value</code> para leer el estado emitido por el <code>ViewModel</code>.      </li> <li>UI Pura: Toda la estructura de la pantalla es una funci\u00f3n pura de la variable <code>state</code>. Si <code>state</code> cambia, la UI se recompone.</li> <li>Delegaci\u00f3n: No contiene ninguna l\u00f3gica de <code>remember { mutableStateOf(...) }</code> ni de negocio. Simplemente llama a las funciones del <code>ViewModel</code> cuando hay interacci\u00f3n (ej: <code>Button(onClick = { viewModel.incrementCounter(1) })</code>).</li> </ul> </li> <li> <p><code>IndividualCounterWithInput_VM()</code> (Componente Hijo):</p> <ul> <li>Este es un componente completamente pasivo.</li> <li>Solo recibe el estado a trav\u00e9s de sus par\u00e1metros (<code>currentCount</code>, <code>incrementAmountText</code>).</li> <li>Solo emite eventos (callbacks) a su componente padre (<code>onIncrement</code>, <code>onAmountChange</code>). En este caso, el padre es el <code>CounterScreenWithViewModel</code>, que a su vez pasa la llamada al <code>ViewModel</code>.</li> </ul> </li> </ul> </li> </ol> <pre><code>// 5. Versi\u00f3n Final: Implementaci\u00f3n con ViewModel y StateFlow\n// Esta es la arquitectura recomendada: L\u00f3gica en el ViewModel, UI observando el estado.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.ViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.update // Import necesario para actualizar el StateFlow de forma segura\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.lifecycle.viewmodel.compose.viewModel \n\n// ========== DATOS y VIEWMODEL (La capa de L\u00f3gica y Estado) ==========\n\n// 1. Definir el estado de un Contador individual\ndata class CounterState(\n    val count: Int = 0,\n    val incrementAmount: Int = 1,\n    val amountText: String = \"1\"\n)\n\n// 2. Definir el estado global de la Pantalla (Contenedor de todos los estados de la UI)\ndata class CountersScreenState(\n    val counter1: CounterState = CounterState(),\n    val counter2: CounterState = CounterState(),\n    val generalCount: Int = 0 \n)\n\n// 3. Implementar el ViewModel (Lugar de la L\u00d3GICA DE NEGOCIO)\nclass CounterViewModel : ViewModel() { // Clase renombrada\n    // StateFlow privado y mutable\n    private val _state = MutableStateFlow(CountersScreenState())\n    // StateFlow p\u00fablico (solo lectura)\n    val state: StateFlow&lt;CountersScreenState&gt; = _state\n\n    /**\n    * L\u00f3gica para incrementar un contador y el contador general.\n    * TODA la actualizaci\u00f3n del estado ocurre aqu\u00ed.\n    * @param counterId El ID del contador (1 o 2).\n    */\n    fun incrementCounter(counterId: Int) {\n        _state.update { currentState -&gt;\n            // 1. Determinar el valor de incremento y el nuevo estado del contador individual\n            val (newCounterState, incrementValue) = when (counterId) {\n                1 -&gt; {\n                    val amount = currentState.counter1.amountText.toIntOrNull() ?: 0\n                    Pair(currentState.counter1.copy(count = currentState.counter1.count + amount), amount)\n                }\n                2 -&gt; {\n                    val amount = currentState.counter2.amountText.toIntOrNull() ?: 0\n                    Pair(currentState.counter2.copy(count = currentState.counter2.count + amount), amount)\n                }\n                else -&gt; Pair(CounterState(), 0)\n            }\n\n            // 2. Retornar el nuevo estado de la pantalla\n            currentState.copy(\n                counter1 = if (counterId == 1) newCounterState else currentState.counter1,\n                counter2 = if (counterId == 2) newCounterState else currentState.counter2,\n                generalCount = currentState.generalCount + incrementValue // Actualiza el general\n            )\n        }\n    }\n\n    /**\n    * L\u00f3gica para actualizar el valor del TextField.\n    * @param counterId El ID del contador.\n    * @param amountText El nuevo texto ingresado.\n    */\n    fun setIncrementAmount(counterId: Int, amountText: String) {\n        // Validaci\u00f3n b\u00e1sica: solo permitir d\u00edgitos o cadena vac\u00eda\n        if (amountText.all { it.isDigit() } || amountText.isEmpty()) {\n            _state.update { currentState -&gt;\n                val newAmount = amountText.toIntOrNull() ?: 0\n                when (counterId) {\n                    1 -&gt; currentState.copy(\n                        counter1 = currentState.counter1.copy(\n                            amountText = amountText,\n                            incrementAmount = newAmount\n                        )\n                    )\n                    2 -&gt; currentState.copy(\n                        counter2 = currentState.counter2.copy(\n                            amountText = amountText,\n                            incrementAmount = newAmount\n                        )\n                    )\n                    else -&gt; currentState\n                }\n            }\n        }\n    }\n\n    /**\n    * L\u00f3gica para resetear todos los contadores.\n    */\n    fun resetAll() {\n        // Al resetear al estado inicial, se resetea toda la UI autom\u00e1ticamente.\n        _state.value = CountersScreenState()\n    }\n}\n\n\n// ========== COMPOSABLES (La capa de Presentaci\u00f3n/UI) ==========\n\n@Composable\nfun CounterApp_ViewModel() { // Funci\u00f3n principal renombrada\n    MaterialTheme {\n        // 4. Obtener el ViewModel. Compose se encarga de su ciclo de vida.\n        val viewModel: CounterViewModel = viewModel() // Renombrado aqu\u00ed\n        CounterScreenWithViewModel(viewModel)\n    }\n}\n\n@Composable\nfun CounterScreenWithViewModel(viewModel: CounterViewModel, modifier: Modifier = Modifier) {\n    // 5. Observar el estado. Transforma el StateFlow en un Compose State.\n    // La UI se recompone cuando el estado cambia.\n    val state = viewModel.state.collectAsState().value\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ViewModel &amp; StateFlow\", style = MaterialTheme.typography.titleMedium)\n        Text(\"La UI solo LEE el estado y ENV\u00cdA eventos al ViewModel.\", style = MaterialTheme.typography.bodySmall)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por ViewModel)\", style = MaterialTheme.typography.headlineSmall)\n                // 6. Mostrar el estado general\n                Text(\"${state.generalCount}\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // 7. Usar un componente puro (Hijo)\n            // Se le pasa el estado espec\u00edfico (state.counter1) y los callbacks (que llaman al VM)\n            IndividualCounterWithInput_VM(\n                title = \"Contador #1 (VM)\",\n                currentCount = state.counter1.count,\n                incrementAmountText = state.counter1.amountText,\n                onIncrement = { viewModel.incrementCounter(1) },\n                onAmountChange = { newText -&gt; viewModel.setIncrementAmount(1, newText) },\n                onReset = { viewModel.resetAll() }, \n                modifier = Modifier.weight(1f)\n            )\n\n            IndividualCounterWithInput_VM(\n                title = \"Contador #2 (VM)\",\n                currentCount = state.counter2.count,\n                incrementAmountText = state.counter2.amountText,\n                onIncrement = { viewModel.incrementCounter(2) },\n                onAmountChange = { newText -&gt; viewModel.setIncrementAmount(2, newText) },\n                onReset = { viewModel.resetAll() },\n                modifier = Modifier.weight(1f)\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        // 8. Llamar a la funci\u00f3n del ViewModel para resetear todo\n        Button(onClick = { viewModel.resetAll() }) {\n            Text(\"Reiniciar TODO (Llamando a VM)\")\n        }\n    }\n}\n\n// Componente Puro de UI: Solo recibe ESTADO y CALLBACKS (no tiene l\u00f3gica 'remember')\n@Composable\nfun IndividualCounterWithInput_VM(\n    title: String,\n    currentCount: Int,\n    incrementAmountText: String,\n    onIncrement: () -&gt; Unit,\n    onAmountChange: (String) -&gt; Unit,\n    onReset: () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    // La l\u00f3gica de c\u00e1lculo del 'incrementAmount' pasa al ViewModel.\n    val incrementAmount = incrementAmountText.toIntOrNull() ?: 0\n\n    Card(\n        modifier = modifier.padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier.padding(16.dp).fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $currentCount\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            OutlinedTextField(\n                value = incrementAmountText,\n                onValueChange = onAmountChange, // Llama al callback que va al ViewModel\n                label = { Text(\"Aumentar en\") },\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),\n                modifier = Modifier.fillMaxWidth()\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                enabled = incrementAmount &gt; 0,\n                onClick = onIncrement, // Llama al callback que va al ViewModel\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+ $incrementAmount)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = onReset, // Llama al callback que va al ViewModel\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html","title":"3.3.3. Capas Datos/Dominio","text":""},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#333-capas-de-dominio-y-datos-el-cerebro-y-la-memoria","title":"3.3.3 \ud83e\udde0 Capas de Dominio y Datos. El Cerebro y la Memoria","text":"<p>Si la capa de UI es la \"cara bonita\" de la aplicaci\u00f3n, las capas de Dominio y Datos son el cerebro y la memoria que hacen que todo funcione. Sin ellas, nuestra app ser\u00eda una c\u00e1scara vac\u00eda.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#la-capa-de-datos-data-layer","title":"\ud83e\uddf1 La Capa de Datos (Data Layer)","text":"<p>Es la base de la pir\u00e1mide. Su responsabilidad es manejar los datos de la aplicaci\u00f3n. \u00bfDe d\u00f3nde vienen los datos? \u00bfC\u00f3mo se guardan? \u00bfQu\u00e9 pasa si no hay internet? La UI no deber\u00eda preocuparse por nada de esto; esa es tarea exclusiva de la Capa de Datos.</p> <p>Se compone de dos piezas clave:</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#1-data-sources-fuentes-de-datos","title":"1. Data Sources (Fuentes de Datos)","text":"<p>Son las clases de \"bajo nivel\" que saben hablar con una fuente espec\u00edfica.</p> <ul> <li>Remote Data Source: Sabe hablar con internet (APIs REST, Firebase, GraphQl).</li> <li>Local Data Source: Sabe hablar con el almacenamiento del tel\u00e9fono (Base de Datos Room, DataStore, Archivos).</li> </ul>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#2-repositorios-repositories","title":"2. Repositorios (Repositories)","text":"<p>Son los gestores o mediadores. Es la parte m\u00e1s importante de esta capa. El resto de la aplicaci\u00f3n (el Dominio o la UI) NUNCA deber\u00eda hablar directamente con un Data Source. Siempre deben pedirle los datos al Repositorio.</p> <p>\ud83d\udcda La Analog\u00eda del Bibliotecario</p> <p>Imagina que vas a una biblioteca a por un libro (\"Los Datos\"). T\u00fa no vas al almac\u00e9n del s\u00f3tano ni llamas a la editorial. T\u00fa hablas con el Bibliotecario (Repositorio).</p> <ul> <li>T\u00fa le pides el libro.</li> <li>El bibliotecario mira si lo tiene a mano en el mostrador (Cach\u00e9 en memoria).</li> <li>Si no, baja al archivo a buscarlo (Base de datos Local).</li> <li>Si no est\u00e1, llama a la editorial para pedir una copia (Red/API).</li> </ul> <p>A ti te da igual de d\u00f3nde lo haya sacado. T\u00fa solo quer\u00edas el libro y el bibliotecario te lo ha conseguido.</p> <p>Esta estrategia se llama Single Source of Truth (\u00danica Fuente de Verdad). El repositorio centraliza los datos para que nadie m\u00e1s tenga que adivinar de d\u00f3nde vienen.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#la-capa-de-dominio-domain-layer","title":"\ud83e\udde0 La Capa de Dominio (Domain Layer)","text":"<p>Nota: Esta capa es opcional en apps muy sencillas, pero recomendada en cuanto la app crece.</p> <p>Es la capa que contiene la L\u00f3gica de Negocio Pura. Son las reglas del juego que hacen que tu app sea \u00fanica, independientemente de si los botones son azules o rojos, o si los datos vienen de una API o de un Excel.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#casos-de-uso-use-cases-interactors","title":"Casos de Uso (Use Cases / Interactors)","text":"<p>Son clases que encapsulan una \u00fanica acci\u00f3n o tarea de negocio. Su nombre debe describir exactamente lo que hacen (verbo + sustantivo + UseCase).</p> <p>Ejemplos:</p> <ul> <li><code>LoginUserUseCase</code></li> <li><code>FormatDateUseCase</code></li> <li><code>GetLatestNewsUseCase</code></li> </ul> <p>\u00bfPor qu\u00e9 usarlos?</p> <ol> <li>Reutilizaci\u00f3n: Si varios ViewModels necesitan la misma l\u00f3gica (ej: formatear una fecha), no copias y pegas c\u00f3digo. Llamas al mismo UseCase.</li> <li>Legibilidad: Al abrir la carpeta de \"Dominio\", ves una lista de todo lo que HACE tu app (\"Code screams architecture\").</li> <li>Independencia: Los UseCases no saben nada de Android (ni de Views, ni de JSONs). Son c\u00f3digo Kotlin puro.</li> </ol>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#ejemplo-practico-app-de-noticias","title":"\ud83d\ude80 Ejemplo Pr\u00e1ctico: App de Noticias","text":"<p>Vamos a ver c\u00f3mo se conectan todas las piezas, desde que el dato sale de internet hasta que llega al ViewModel. Imagina una pantalla que muestra una lista de noticias recientes.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#1-data-source-el-especialista","title":"1. Data Source (El especialista)","text":"<p>Primero, necesitamos alguien que sepa descargar datos de la API. </p><pre><code>// Data Source (Retrofit)\ninterface NewsApiService {\n    @GET(\"news\")\n    suspend fun fetchNews(): List&lt;NewsDto&gt; // Devuelve datos \"feos\" (DTOs) de la red\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#2-repository-el-bibliotecario","title":"2. Repository (El bibliotecario)","text":"<p>El repositorio coordina. En este caso simple, solo llama a la API, pero podr\u00eda guardar en base de datos si quisi\u00e9ramos modo offline. </p><pre><code>class NewsRepository(\n    private val api: NewsApiService\n) {\n    // Devuelve listas del Dominio (News), no DTOs de red. Limpia los datos.\n    suspend fun getNews(): List&lt;News&gt; {\n        return try {\n            val apiData = api.fetchNews()\n            apiData.map { it.toDomain() } // Mapea a objetos limpios\n        } catch (e: Exception) {\n            emptyList() // O manejar el error\n        }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#3-use-case-la-logica-de-negocio","title":"3. Use Case (La l\u00f3gica de negocio)","text":"<p>Queremos mostrar noticias, pero una regla de negocio dice: \"Solo mostrar noticias de las \u00faltimas 24h y ordenadas por fecha\". El ViewModel no deber\u00eda saber calcular esto. </p><pre><code>class GetRecentNewsUseCase(\n    private val repository: NewsRepository\n) {\n    // El operador 'invoke' permite llamar a la clase como si fuera una funci\u00f3n\n    suspend operator fun invoke(): List&lt;News&gt; {\n        val allNews = repository.getNews()\n\n        // APLICAMOS L\u00d3GICA DE NEGOCIO AQU\u00cd\n        return allNews\n            .filter { it.date &gt; ayer() }\n            .sortedByDescending { it.date }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#4-viewmodel-el-consumidor","title":"4. ViewModel (El consumidor)","text":"<p>El ViewModel es mucho m\u00e1s simple ahora. Solo llama al UseCase y actualiza el estado. </p><pre><code>class NewsViewModel(\n    private val getRecentNewsUseCase: GetRecentNewsUseCase // Inyectamos el UseCase\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(NewsUiState())\n    val uiState = _uiState.asStateFlow()\n\n    fun loadNews() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n\n            // \u00a1Magia! Solo llamamos al caso de uso.\n            // No sabemos si viene de red, base de datos o si se ha filtrado.\n            val news = getRecentNewsUseCase() \n\n            _uiState.update { \n                it.copy(isLoading = false, news = news) \n            }\n        }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#resumen-del-flujo-de-datos","title":"Resumen del Flujo de Datos","text":"<ol> <li>UI (Composable): \"Usuario pulsa bot\u00f3n 'Recargar'\". Llama a <code>viewModel.loadNews()</code>.</li> <li>ViewModel: Llama a <code>GetRecentNewsUseCase()</code>.</li> <li>UseCase: Pide datos al <code>Repository</code> y aplica filtro de fecha.</li> <li>Repository: Pide datos al <code>NetworkDataSource</code> (API).</li> <li>Data Source: Descarga el JSON.</li> </ol> <p>\u00a1Y el camino de vuelta es igual pero con los datos ya procesados! \ud83d\udd04</p>"},{"location":"temas/04/4.0-persistencia.html","title":"Introducci\u00f3n","text":""},{"location":"temas/04/4.0-persistencia.html#40-persistencia-de-datos-en-android","title":"4.0 Persistencia de Datos en Android","text":"<p>En Android, \"persistencia\" significa guardar datos para que no se pierdan cuando el usuario cierra la aplicaci\u00f3n o reinicia el tel\u00e9fono.</p> <p>Elegir la herramienta correcta es vital para el rendimiento de la app. No es lo mismo guardar un simple \"Modo Oscuro: Activado\" que guardar una lista de 5,000 pel\u00edculas con su sinopsis.</p>"},{"location":"temas/04/4.0-persistencia.html#guia-rapida-de-eleccion","title":"\ud83d\udcca Gu\u00eda R\u00e1pida de Elecci\u00f3n","text":"Herramienta Tipo de Datos Caso de Uso Ideal Jetpack DataStore Clave-Valor (Simples) Preferencias de usuario, flags, tokens de sesi\u00f3n. Room Estructurados (Relacionales) Listas de objetos, datos complejos, cach\u00e9 offline. Ficheros Datos binarios/grandes Fotos, PDFs, audio, logs largos. SharedPreferences Clave-Valor (Legacy) Obsoleto. Usar solo en proyectos antiguos."},{"location":"temas/04/4.0-persistencia.html#1-jetpack-datastore-el-estandar-moderno","title":"1. \ud83d\ude80 Jetpack DataStore (El Est\u00e1ndar Moderno)","text":"<p>DataStore es la soluci\u00f3n moderna para guardar pares clave-valor (como <code>settings: true</code>). Est\u00e1 construido desde cero usando Corrutinas y Flow, lo que garantiza que las operaciones de disco nunca bloqueen el Hilo Principal (UI Thread).</p>"},{"location":"temas/04/4.0-persistencia.html#por-que-sustituye-a-sharedpreferences","title":"\u00bfPor qu\u00e9 sustituye a SharedPreferences?","text":"<ul> <li>\u2705 As\u00edncrono: Todo funciona con <code>suspend</code> y <code>Flow</code>.</li> <li>\u2705 Seguro: Maneja los errores de I/O por ti.</li> <li>\u2705 Transaccional: Las operaciones son at\u00f3micas (todo o nada).</li> </ul>"},{"location":"temas/04/4.0-persistencia.html#implementacion-preferences-datastore","title":"Implementaci\u00f3n (Preferences DataStore)","text":""},{"location":"temas/04/4.0-persistencia.html#a-dependencias-y-creacion","title":"A. Dependencias y Creaci\u00f3n","text":"<p>A\u00f1ade la librer\u00eda en <code>build.gradle.kts</code> e instancia el DataStore. Lo ideal es tener una sola instancia para toda la app (Singleton o Extensi\u00f3n global).</p> <pre><code>// En tu fichero de dependencias (libs.versions.toml) o build.gradle\n// implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n\n// En un fichero Kotlin (ej: DataStoreModule.kt)\nval Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = \"settings\")\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#b-guardar-datos-escritura","title":"B. Guardar datos (Escritura)","text":"<p>Usamos <code>edit</code> dentro de una corrutina. </p><pre><code>suspend fun guardarToken(context: Context, token: String) {\n    val TOKEN_KEY = stringPreferencesKey(\"auth_token\")\n\n    context.dataStore.edit { preferences -&gt;\n        preferences[TOKEN_KEY] = token\n    }\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#c-leer-datos-lectura","title":"C. Leer datos (Lectura)","text":"<p>DataStore expone los datos como un <code>Flow</code>. Esto significa que si el dato cambia, la UI se actualiza autom\u00e1ticamente. </p><pre><code>val TOKEN_KEY = stringPreferencesKey(\"auth_token\")\n\nval tokenFlow: Flow&lt;String?&gt; = context.dataStore.data\n    .map { preferences -&gt;\n        preferences[TOKEN_KEY] // Devuelve null si no existe\n    }\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#2-room-base-de-datos-robusta","title":"2. \ud83c\udfdb\ufe0f Room (Base de Datos Robusta)","text":"<p>Room es una librer\u00eda que nos facilita enormemente el uso de bases de datos SQLite en Android. En lugar de escribir SQL crudo y manejar cursores manualmente (propenso a errores), Room nos permite usar Objetos Kotlin.</p> <p>Room verifica tus consultas SQL en tiempo de compilaci\u00f3n. Si escribes mal el nombre de una tabla, la app no compilar\u00e1 (\u00a1lo cual es genial!).</p> <p>Consta de 3 componentes principales:</p>"},{"location":"temas/04/4.0-persistencia.html#a-la-entidad-entity","title":"A. La Entidad (<code>@Entity</code>)","text":"<p>Representa una tabla en la base de datos. </p><pre><code>@Entity(tableName = \"usuarios\")\ndata class Usuario(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"nombre_completo\") val nombre: String,\n    val edad: Int\n)\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#b-el-dao-data-access-object-dao","title":"B. El DAO (Data Access Object) (<code>@Dao</code>)","text":"<p>Define c\u00f3mo accedemos a los datos. Es una interfaz donde declaramos nuestros m\u00e9todos. Room genera el c\u00f3digo por nosotros. </p><pre><code>@Dao\ninterface UsuarioDao {\n    // Lectura reactiva: Si la tabla cambia, emite una nueva lista autom\u00e1ticamente\n    @Query(\"SELECT * FROM usuarios ORDER BY nombre ASC\")\n    fun getAllUsuarios(): Flow&lt;List&lt;Usuario&gt;&gt;\n\n    // Operaci\u00f3n as\u00edncrona simple\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(usuario: Usuario)\n\n    @Delete\n    suspend fun delete(usuario: Usuario)\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#c-la-base-de-datos-database","title":"C. La Base de Datos (<code>@Database</code>)","text":"<p>El punto de entrada principal. Debe ser abstracta y extender <code>RoomDatabase</code>. </p><pre><code>@Database(entities = [Usuario::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun usuarioDao(): UsuarioDao\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#3-sharedpreferences-legacy","title":"3. \ud83d\uddc4\ufe0f SharedPreferences (Legacy)","text":"<p>Era la forma antigua de guardar datos simples. Aunque sigue funcionando, Google recomienda migrar a DataStore.</p> <ul> <li>Problema principal: Su m\u00e9todo <code>apply()</code> es as\u00edncrono pero no seguro, y <code>commit()</code> es s\u00edncrono y puede bloquear la UI. Adem\u00e1s, al iniciar la app, carga TODO el fichero en memoria de golpe, lo que puede causar lag.</li> </ul> <pre><code>// Ejemplo r\u00e1pido (OBSOLETO - Solo referencia)\nval sharedPref = activity?.getPreferences(Context.MODE_PRIVATE) ?: return\nwith (sharedPref.edit()) {\n    putInt(\"puntuacion_alta\", 500)\n    apply()\n}\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#4-ficheros-almacenamiento-crudo","title":"4. \ud83d\udcc1 Ficheros (Almacenamiento Crudo)","text":"<p>A veces necesitas guardar un PDF, una imagen editada o un audio. Para esto usamos el sistema de ficheros de Android.</p> <ul> <li>Almacenamiento Interno (<code>filesDir</code>): Privado de tu app. Nadie m\u00e1s puede verlo. Si el usuario desinstala la app, se borra.</li> <li>Almacenamiento Externo / Cach\u00e9: Para datos temporales o p\u00fablicos.</li> </ul> <pre><code>// Escribir un fichero en almacenamiento interno\nfun guardarTexto(context: Context, nombreFichero: String, contenido: String) {\n    context.openFileOutput(nombreFichero, Context.MODE_PRIVATE).use {\n        it.write(contenido.toByteArray())\n    }\n}\n\n// Leer un fichero\nfun leerTexto(context: Context, nombreFichero: String): String {\n    return context.openFileInput(nombreFichero).bufferedReader().useLines { lines -&gt;\n        lines.fold(\"\") { some, text -&gt; \"$some\\n$text\" }\n    }\n}\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#resumen-cual-uso","title":"Resumen: \u00bfCu\u00e1l uso?","text":"<ol> <li>\u00bfEs un ajuste? (ej: \"Sonido on/off\") -&gt; DataStore.</li> <li>\u00bfSon mis datos principales? (ej: \"Notas\", \"Tareas\") -&gt; Room.</li> <li>\u00bfEs una foto o archivo descargado? -&gt; Ficheros.</li> </ol>"},{"location":"temas/04/4.1-room.html","title":"4.1. Room","text":""},{"location":"temas/04/4.1-room.html#41-room-base-de-datos-sql-en-android","title":"4.1 Room: Base de Datos SQL en Android","text":"<p>Room es una de las librer\u00edas m\u00e1s importantes de Android Jetpack. Act\u00faa como una capa de abstracci\u00f3n sobre SQLite, permiti\u00e9ndote usar toda la potencia de una base de datos relacional pero con una sintaxis fluida en Kotlin y verificaci\u00f3n de errores en tiempo de compilaci\u00f3n.</p> VIDEO: Bases de datos con Room | Persistencia de datos en Android con Kotlin y Jetpack Compose <p></p>"},{"location":"temas/04/4.1-room.html#que-es-room","title":"\u00bfQu\u00e9 es Room?","text":"<p>Room es una biblioteca de persistencia de datos que forma parte de Jetpack, el conjunto de bibliotecas y herramientas recomendadas por Google para el desarrollo de aplicaciones Android. Room proporciona una capa de abstracci\u00f3n sobre SQLite, la base de datos relacional integrada en Android, y facilita el acceso a la base de datos y la gesti\u00f3n de los datos de la aplicaci\u00f3n.</p> <p>Room se compone de tres componentes principales:</p> <ul> <li> <p>Database: Representa la base de datos de la aplicaci\u00f3n y contiene la l\u00f3gica para crear y acceder a las tablas de la base de datos.</p> </li> <li> <p>Entity: Representa una tabla de la base de datos y contiene la definici\u00f3n de las columnas y los tipos de datos de la tabla.</p> </li> <li> <p>DAO (Data Access Object): Define las operaciones de acceso a la base de datos, como la inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos.</p> </li> </ul> <p></p>"},{"location":"temas/04/4.1-room.html#implementacion-de-room-en-jetpack-compose","title":"Implementaci\u00f3n de Room en Jetpack Compose","text":""},{"location":"temas/04/4.1-room.html#1-agregar-las-dependencias-de-room","title":"1. Agregar las dependencias de Room[","text":"<p>Para utilizar Room en una aplicaci\u00f3n Android con Jetpack Compose, primero debemos agregar las dependencias necesarias en el archivo <code>build.gradle.kts</code> del proyecto y del m\u00f3dulo de la aplicaci\u00f3n:</p> <p>build.gradle.kts (Project) </p><pre><code>plugins {\n    // Add this line\n    id(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre><p></p> <p>build.gradle.kts (Module) </p><pre><code>plugins {\n    // Add this line\n    id(\"com.google.devtools.ksp\")\n}\n\ndependencies {\n    //Room (add the following dependencies)\n    implementation(libs.androidx.room.runtime)\n    implementation(libs.androidx.room.ktx)\n    ksp(libs.androidx.room.compiler)\n}\n</code></pre><p></p> <p>KSP es una API simple y potente para analizar las anotaciones de Kotlin.</p> <p>Hay que tener en cuenta que la versi\u00f3n utilizada de KSP debe ser compatible con la versi\u00f3n de Kotlin que se est\u00e9 utilizando en el proyecto, la compatibilidad entre las diferentes versiones puede consultarse en la documentaci\u00f3n.</p> <p>La versi\u00f3n utilizada en el ejemplo es compatible con la versi\u00f3n 2.0.21 de Kotlin.</p>"},{"location":"temas/04/4.1-room.html#2-definir-la-entidad","title":"2. Definir la entidad","text":"<p>La clase <code>Entity</code> representa una tabla de la base de datos y contiene la definici\u00f3n de las columnas y los tipos de datos de la tabla. Para definir una entidad en Room, debemos crear una clase que anote con <code>@Entity</code> y que contenga las propiedades correspondientes a las columnas de la tabla. Por ejemplo, la siguiente clase <code>User</code> representa una entidad de usuario con las columnas <code>id</code>, <code>name</code> y <code>email</code>:</p> <pre><code>@Entity(tableName = \"users\")data class User(    @PrimaryKey val id: Int,    val name: String,    val email: String)\n</code></pre> <p>En este ejemplo, la clase <code>User</code> representa una tabla de la base de datos con las columnas <code>id</code>, <code>name</code> y <code>email</code>. La propiedad <code>id</code> se anota con <code>@PrimaryKey</code> para indicar que es la clave primaria de la tabla.</p> <p></p> <p>Anotaciones de Room</p> <p>Room proporciona varias anotaciones que se pueden utilizar para personalizar la definici\u00f3n de la entidad, como <code>@Entity</code>, <code>@PrimaryKey</code>, <code>@ColumnInfo</code>, <code>@Ignore</code>, <code>@ForeignKey</code>, entre otras.</p> <p>Las anotaciones tienen los siguientes significados:</p> <ul> <li><code>@Entity</code>: Indica que la clase es una entidad de la base de datos.</li> <li><code>@PrimaryKey</code>: Indica que la propiedad es la clave primaria de la tabla.</li> <li><code>@ColumnInfo</code>: Permite personalizar el nombre de la columna en la tabla.</li> <li><code>@Ignore</code>: Indica que la propiedad no se debe incluir en la tabla.</li> <li><code>@ForeignKey</code>: Permite definir una clave for\u00e1nea en la tabla.</li> </ul> <p>Ejemplo de ForeignKey</p> <pre><code>@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String,\n    @ForeignKey(entity = Company::class, parentColumns = [\"id\"], childColumns = [\"company_id\"])\n    val companyId: Int\n)\n</code></pre> <p>En este ejemplo, la propiedad <code>companyId</code> se anota con <code>@ForeignKey</code> para indicar que es una clave for\u00e1nea que hace referencia a la tabla <code>Company</code> y a la columna <code>id</code>.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Entity Es recomendable tener las clases Entity en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#3-definir-el-dao","title":"3. Definir el DAO","text":"<p>La interfaz <code>DAO</code> (Data Access Object) define las operaciones de acceso a la base de datos, como la inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos.</p> <p>El Data Access Object (DAO) es un patr\u00f3n de dise\u00f1o que permite separar la l\u00f3gica de acceso a los datos de la l\u00f3gica de negocio de una aplicaci\u00f3n.</p> <p>La funci\u00f3n del DAO es ocultar todas las complejidades relacionadas con las operaciones de acceso a los datos, como la conexi\u00f3n a la base de datos, la creaci\u00f3n de consultas SQL y la gesti\u00f3n de transacciones.</p> <p>Esto nos permite intercambiar f\u00e1cilmente la fuente de datos subyacente sin tener que modificar la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> <p></p> <p>Para definir un DAO en Room, debemos crear una interfaz que anote con <code>@Dao</code> y que contenga las operaciones de acceso a la base de datos.</p> <p>Por ejemplo, la siguiente interfaz <code>UserDao</code> define las operaciones de acceso a la tabla de usuarios:</p> <pre><code>@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;\n\n    @Insert\n    suspend fun insertUser(user: User)\n\n    @Update\n    suspend fun updateUser(user: User)\n\n    @Delete\n    suspend fun deleteUser(user: User)\n}\n</code></pre> <p>En este ejemplo, la interfaz <code>UserDao</code> define las operaciones <code>getUsers()</code>, <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> para acceder a la tabla de usuarios.</p> <p>Como se puede obversar, antes de cada funci\u00f3n se anota con la operaci\u00f3n que se va a realizar, ya sea <code>@Query</code>, <code>@Insert</code>, <code>@Update</code> o <code>@Delete</code>.</p> <p>Estas operaciones definen las consultas SQL que se ejecutar\u00e1n en la base de datos para realizar las operaciones correspondientes:</p> <ul> <li><code>@Query</code>: Permite definir una consulta SQL personalizada para recuperar datos de la base de datos.</li> <li><code>@Insert</code>: Permite definir una operaci\u00f3n de inserci\u00f3n de datos en la base de datos.</li> <li><code>@Update</code>: Permite definir una operaci\u00f3n de actualizaci\u00f3n de datos en la base de datos.</li> <li><code>@Delete</code>: Permite definir una operaci\u00f3n de eliminaci\u00f3n de datos en la base de datos.</li> </ul> <p>\ud83d\udca1Ubicaci\u00f3n del archivo DAO Es recomendable tener las interfaces DAO en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#4-definir-la-base-de-datos","title":"4. Definir la base de datos","text":"<p>La clase <code>Database</code> representa la base de datos de la aplicaci\u00f3n y contiene la l\u00f3gica para crear y acceder a las tablas de la base de datos.</p> <p>Para definir una base de datos en Room, debemos crear una clase que extienda de <code>RoomDatabase</code> y que contenga las definiciones de las entidades y los DAOs de la base de datos.</p> <p>Por ejemplo, la siguiente clase <code>AppDatabase</code> define una base de datos con la tabla de usuarios y el DAO correspondiente:</p> <pre><code>@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n</code></pre> <p>En este ejemplo, la clase <code>AppDatabase</code> representa una base de datos con la tabla de usuarios y el DAO <code>UserDao</code>.</p> <p>La anotaci\u00f3n <code>@Database</code> se utiliza para indicar que la clase es una base de datos de Room y para especificar las entidades y la versi\u00f3n de la base de datos.</p> <p>La clase <code>AppDatabase</code> debe ser abstracta y extender de <code>RoomDatabase</code>. Tambi\u00e9n debe contener una funci\u00f3n abstracta que devuelva el DAO correspondiente a la tabla de usuarios.</p> <p>Si queremos que no se conserven copias de seguridad del historial de versiones podemos a\u00f1adir <code>exportSchema = false</code> a la anotaci\u00f3n <code>@Database</code>.</p> <p>Adem\u00e1s, es interesante definir un <code>companion object</code> para obtener una instancia de la base de datos de forma segura y eficiente:</p> <pre><code>@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                ).build()\n                .also { INSTANCE = it }\n                instance\n            }\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, el <code>companion object</code> de la clase <code>AppDatabase</code> define una funci\u00f3n <code>getDatabase()</code> que devuelve una instancia de la base de datos de forma segura y eficiente.</p> <p>La funci\u00f3n <code>getDatabase()</code> utiliza una variable <code>INSTANCE</code> para almacenar la instancia de la base de datos y la inicializa si es <code>null</code>.</p> <p>La funci\u00f3n <code>getDatabase()</code> tambi\u00e9n utiliza la funci\u00f3n <code>databaseBuilder()</code> para crear una instancia de la base de datos con el contexto de la aplicaci\u00f3n, la clase de la base de datos y el nombre de la base de datos.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Database Es recomendable tener la clase Database en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el mismo paquete que las clases Entity y DAO o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>\ud83d\udca1Sobre la anotaci\u00f3n @Volatile La anotaci\u00f3n <code>@Volatile</code> se utiliza para indicar que la variable <code>INSTANCE</code> es vol\u00e1til y que su valor puede cambiar en cualquier momento. Esto garantiza que la variable <code>INSTANCE</code> siempre se lea desde la memoria principal y no desde la cach\u00e9 de un subprocesos, lo que evita problemas de concurrencia.</p> <p>En general, las variables vol\u00e1tiles se utilizan para garantizar la coherencia de la memoria en entornos multiproceso o multihilo.</p> <p>En este caso, la variable <code>INSTANCE</code> se utiliza para almacenar la instancia de la base de datos y garantizar que solo se cree una instancia de la base de datos en la aplicaci\u00f3n.</p> <p>Esto se utiliza adem\u00e1s en un bloque <code>synchronized</code> para garantizar que solo se cree una instancia de la base de datos en entornos multiproceso o multihilo.</p>"},{"location":"temas/04/4.1-room.html#5-implementar-un-repositorio","title":"5. Implementar un repositorio","text":"<p>El repositorio es una capa intermedia entre la capa de datos y la capa de presentaci\u00f3n de la aplicaci\u00f3n.</p> <p>El repositorio se encarga de gestionar la obtenci\u00f3n de datos de la base de datos y de proporcionar los datos a la capa de presentaci\u00f3n de la aplicaci\u00f3n.</p> <p>El repositorio tambi\u00e9n puede realizar operaciones de red, almacenamiento en cach\u00e9 y otras operaciones relacionadas con la obtenci\u00f3n y el almacenamiento de datos.</p> <p>Para implementar un repositorio en Room, debemos crear una clase que contenga las operaciones de acceso a la base de datos y que proporcione los datos a la capa de presentaci\u00f3n.</p> <p>Para este ejemplo, crearemos una interfaz <code>UserRepository</code> que defina las operaciones de acceso a la tabla de usuarios, es decir, las operaciones del DAO <code>UserDao</code>:</p> <pre><code>import kotlinx.coroutines.flow.Flowinterface UserRepository {    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;    suspend fun insertUser(user: User)    suspend fun updateUser(user: User)    suspend fun deleteUser(user: User)}\n</code></pre> <p>Debajo de la declaraci\u00f3n de la interfaz <code>UserRepository</code>, creamos una clase <code>UserRepositoryImpl</code> que implementa la interfaz <code>UserRepository</code> y que contiene las operaciones de acceso a la base de datos:</p> <pre><code>class MyApplication : Application() {\n    val appContainer by lazy { AppContainer(this) }\n\n    override fun onCreate() {\n        super.onCreate()\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserRepositoryImpl</code> implementa la interfaz <code>UserRepository</code> y contiene las operaciones <code>getUsers()</code>, <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> que acceden a la tabla de usuarios a trav\u00e9s del DAO <code>UserDao</code>.</p> <p>La clase <code>UserRepositoryImpl</code> recibe una instancia de <code>UserDao</code> como par\u00e1metro en su constructor y utiliza el DAO para realizar las operaciones de acceso a la base de datos.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Repository Es recomendable tener la clase Repository en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete <code>data</code> o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#6-implementar-la-clase-appcontainer","title":"6. Implementar la clase AppContainer","text":"<p>La clase <code>AppContainer</code> es una clase de contenedor que se utiliza para proporcionar instancias de las dependencias de la aplicaci\u00f3n a las clases que las necesitan.</p> <p>La clase <code>AppContainer</code> se utiliza para gestionar la creaci\u00f3n y la inyecci\u00f3n de dependencias en la aplicaci\u00f3n y para garantizar que las dependencias se creen y se proporcionen de forma segura y eficiente.</p> <p>Para implementar la clase <code>AppContainer</code>, debemos crear una clase que contenga las instancias de las dependencias de la aplicaci\u00f3n y que proporcione m\u00e9todos para obtener las instancias de las dependencias.</p> <p>Por ejemplo, la siguiente clase <code>AppContainer</code> define las instancias de la base de datos, el DAO y el repositorio de la aplicaci\u00f3n:</p> <pre><code>class AppContainer(context: Context) {    private val appDatabase = AppDatabase.getDatabase(context)    private val userDao = appDatabase.userDao()    private val userRepository = UserRepositoryImpl(userDao)    fun provideUserRepository(): UserRepository {        return userRepository    }}\n</code></pre> <p>En este ejemplo, la clase <code>AppContainer</code> define las instancias de la base de datos, el DAO y el repositorio de la aplicaci\u00f3n y proporciona un m\u00e9todo <code>provideUserRepository()</code> para obtener la instancia del repositorio.</p> <p>La clase <code>AppContainer</code> recibe el contexto de la aplicaci\u00f3n como par\u00e1metro en su constructor y utiliza el contexto para crear la instancia de la base de datos y el DAO.</p> <p>La clase <code>AppContainer</code> tambi\u00e9n utiliza la instancia del DAO para crear la instancia del repositorio y proporcionarla a las clases que la necesitan.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo AppContainer Es recomendable tener la clase AppContainer en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete <code>data</code> o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#7-inyectar-dependencias-en-la-aplicacion","title":"7. Inyectar dependencias en la aplicaci\u00f3n","text":"<p>Una vez que hemos definido las entidades, los DAOs, la base de datos, el repositorio y la clase <code>AppContainer</code>, podemos inyectar las dependencias en la aplicaci\u00f3n para acceder a los datos de la base de datos.</p> <p>Para inyectar las dependencias en la aplicaci\u00f3n, debemos crear una instancia de la clase <code>AppContainer</code> en la clase de aplicaci\u00f3n de la aplicaci\u00f3n y utilizarla para obtener las instancias de las dependencias.</p> <p>Por ejemplo, la siguiente clase <code>MyApplication</code> define una instancia de la clase <code>AppContainer</code> y la utiliza para obtener la instancia del repositorio de usuarios:</p> <pre><code>class MyApplication : Application() {\n    val appContainer by lazy { AppContainer(this) }\n\n    override fun onCreate() {\n        super.onCreate()\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>MyApplication</code> define una instancia de la clase <code>AppContainer</code> utilizando la funci\u00f3n <code>lazy()</code> para crear la instancia de forma diferida.</p> <p>La clase <code>MyApplication</code> utiliza la instancia de <code>AppContainer</code> para obtener la instancia del repositorio de usuarios a trav\u00e9s del m\u00e9todo <code>provideUserRepository()</code>.</p> <p>La clase <code>MyApplication</code> tambi\u00e9n puede utilizar la instancia de <code>AppContainer</code> para obtener otras instancias de dependencias, como la base de datos y el DAO.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Application Es recomendable tener la clase Application en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete application o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>\u2139\ufe0fSobre la funci\u00f3n lazy() La funci\u00f3n lazy() se utiliza para crear una instancia de una clase de forma diferida, es decir, la instancia se crea solo cuando se accede por primera vez a ella. Esto permite inicializar las dependencias de la aplicaci\u00f3n de forma segura y eficiente, ya que las dependencias se crean solo cuando se necesitan y no antes. En este caso, la funci\u00f3n lazy() se utiliza para crear la instancia de la clase AppContainer de forma diferida y para garantizar que la instancia se cree solo cuando se accede a ella por primera vez. Esto es \u00fatil para evitar la creaci\u00f3n innecesaria de instancias de dependencias en la aplicaci\u00f3n y para mejorar el rendimiento de la aplicaci\u00f3n.</p> <p>Tambi\u00e9n se podr\u00eda crear el contenedor con lateinit:</p> <pre><code>class MyApplication : Application() {\n    private lateinit var appContainer: AppContainer\n\n    override fun onCreate() {\n        super.onCreate()\n        appContainer = AppContainer(this)\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este caso, se inicializa la variable <code>appContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y se utiliza para obtener la instancia del repositorio de usuarios.</p> <p>Esta forma de inicializaci\u00f3n es \u00fatil cuando se necesita inicializar la instancia de la clase <code>AppContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y no antes.</p> <p>\u2139\ufe0f Sobre lateinit La palabra clave <code>lateinit</code> se utiliza para indicar que una variable se inicializar\u00e1 m\u00e1s tarde, es decir, que su valor se asignar\u00e1 en alg\u00fan momento antes de que se acceda a ella por primera vez. Esto permite diferir la inicializaci\u00f3n de la variable y garantizar que se inicialice solo cuando sea necesario. En este caso, la palabra clave <code>lateinit</code> se utiliza para inicializar la variable <code>appContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y para garantizar que la instancia de la clase <code>AppContainer</code> se cree solo cuando se acceda a ella por primera vez. Esto es \u00fatil para evitar la inicializaci\u00f3n innecesaria de la variable <code>appContainer</code> y para mejorar el rendimiento de la aplicaci\u00f3n.</p>"},{"location":"temas/04/4.1-room.html#8-acceder-a-los-datos-de-la-base-de-datos-desde-un-viewmodel","title":"8. Acceder a los datos de la base de datos desde un ViewModel","text":"<p>Una vez que hemos inyectado las dependencias en la aplicaci\u00f3n, podemos acceder a los datos de la base de datos desde un ViewModel de Jetpack Compose.</p> <p>Para acceder a los datos de la base de datos desde un ViewModel, debemos crear una clase que extienda de <code>ViewModel</code> y que contenga las operaciones de acceso a los datos.</p> <p>Por ejemplo, la siguiente clase <code>UserViewModel</code> define un ViewModel que accede a los datos de la base de datos a trav\u00e9s del repositorio de usuarios:</p> <pre><code>class UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n    val users: Flow&lt;List&lt;User&gt;&gt; = usersRepository.getUsers().asFlow()\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserViewModel</code> define un ViewModel que accede a los datos de la base de datos a trav\u00e9s del repositorio de usuarios y proporciona los datos a la capa de presentaci\u00f3n.</p> <p>La clase <code>UserViewModel</code> recibe una instancia del repositorio de usuarios como par\u00e1metro en su constructor y utiliza el repositorio para obtener los datos de la base de datos.</p> <p>La clase <code>UserViewModel</code> tambi\u00e9n define una propiedad <code>users</code> que contiene los datos de los usuarios como un flujo de datos (<code>Flow</code>) y que se puede observar desde la capa de UI.</p> <p>\ud83d\udca1 Ubicaci\u00f3n del archivo ViewModel Es recomendable tener la clase ViewModel en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete ui o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>Si quisieramos tambi\u00e9n implementar la funcionalidad para insertar, borrar o actualizar un usuario, podr\u00edamos hacerlo de la siguiente manera:</p> <pre><code>class UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n    val users: Flow&lt;List&lt;User&gt;&gt; = usersRepository.getUsers().asFlow()\n\n    fun insertUser(user: User) {\n        viewModelScope.launch {\n            userRepository.insertUser(user)\n        }\n    }\n\n    fun updateUser(user: User) {\n        viewModelScope.launch {\n            userRepository.updateUser(user)\n        }\n    }\n\n    fun deleteUser(user: User) {\n        viewModelScope.launch {\n            userRepository.deleteUser(user)\n        }\n    }\n}\n</code></pre> <p>En este caso, se han a\u00f1adido las funciones <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> al ViewModel para insertar, actualizar y eliminar un usuario en la base de datos.</p> <p>Sobre los datos a guardar, borrar o actualizar en la base de datos</p> <p>Es importante tener en cuenta que las operaciones de inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos en la base de datos deben realizarse en un hilo de fondo para evitar bloquear el hilo principal de la aplicaci\u00f3n.</p> <p>Adem\u00e1s, estas operaciones deben realizarse dentro de un bloque <code>viewModelScope.launch</code> para garantizar que se realicen de forma segura y eficiente.</p> <p>En general, es recomendable utilizar corutinas para realizar operaciones as\u00edncronas en la base de datos y para garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>Tambi\u00e9n es importante comprobar que los datos introducidos en la base de datos sean v\u00e1lidos y est\u00e9n correctamente formateados antes de realizar las operaciones de inserci\u00f3n, actualizaci\u00f3n o eliminaci\u00f3n.</p> <p>Para ello, se pueden utilizar validaciones y comprobaciones de datos en el ViewModel o en el repositorio antes de realizar las operaciones en la base de datos.</p>"},{"location":"temas/04/4.1-room.html#9-observar-los-datos-en-la-capa-de-ui","title":"9. Observar los datos en la capa de UI","text":"<p>Una vez que hemos definido el ViewModel y hemos accedido a los datos de la base de datos, podemos observar los datos en la capa de UI de Jetpack Compose.</p> <p>Para observar los datos en la capa de UI, debemos utilizar la funci\u00f3n collectAsState() para convertir el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI.</p> <p>Por ejemplo, la siguiente funci\u00f3n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel:</p> <pre><code>@Composable\nfun UserListScreen(userViewModel: UserViewModel) {\n    val users by userViewModel.users.collectAsState(emptyList())\n\n    LazyColumn {\n        items(users) { user -&gt;\n            UserItem(user = user)\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel a trav\u00e9s de la propiedad users.</p> <p>La propiedad users se convierte en un estado que se puede observar desde la capa de UI utilizando la funci\u00f3n collectAsState().</p> <p>La funci\u00f3n collectAsState() convierte el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambian los datos.</p> <p>Esto permite mostrar los datos de la base de datos en la pantalla y actualizar la pantalla autom\u00e1ticamente cuando cambian los datos.</p> <p>Si quisieramos crear un peque\u00f1o formulario para insertar un usuario, podr\u00edamos hacerlo de la siguiente manera:</p> <pre><code>@Composable\nfun AddUserScreen(userViewModel: UserViewModel) {\n    var name by remember { mutableStateOf(\"\") }\n    var email by remember { mutableStateOf(\"\") }\n\n    Column {\n        TextField(\n            value = name,\n            onValueChange = { name = it },\n            label = { Text(\"Name\") }\n        )\n        TextField(\n            value = email,\n            onValueChange = { email = it },\n            label = { Text(\"Email\") }\n        )\n        Button(onClick = { \n            userViewModel.insertUser(User(name = name, email = email))\n        }) {\n            Text(\"Add User\")\n        }\n    }\n}\n</code></pre> <p>En este caso, se han definido dos variables name y email para almacenar el nombre y el email del usuario introducidos en el formulario.</p> <p>Sobre las variables en la UI</p> <p>Aclarar que en este ejemplo, por hacerlo m\u00e1s ameno, no se han inclu\u00eddo las variables <code>name</code> y <code>email</code> en un ViewModel, lo cual ser\u00eda lo recomendable para mantener la l\u00f3gica de la aplicaci\u00f3n separada de la capa de UI.</p> <p>En general, es recomendable utilizar un ViewModel para gestionar la l\u00f3gica de la aplicaci\u00f3n y para mantener la capa de UI lo m\u00e1s simple y desacoplada posible.</p> <p>La funci\u00f3n <code>TextField</code> se utiliza para mostrar los campos de texto para introducir el nombre y el email del usuario y para actualizar las variables <code>name</code> y <code>email</code> cuando se introducen los datos.</p> <p>La funci\u00f3n <code>Button</code> se utiliza para mostrar un bot\u00f3n que permite insertar un usuario en la base de datos cuando se hace clic en \u00e9l.</p> <p>Tambi\u00e9n podr\u00edamos a\u00f1adir a la lista de usuarios un bot\u00f3n para eliminar un usuario:</p> <pre><code>@Composable\nfun UserItem(user: User, onDeleteUser: (User) -&gt; Unit) {\n    Row {\n        Text(text = user.name)\n        Text(text = user.email)\n        Button(onClick = { onDeleteUser(user) }) {\n            Text(\"Delete\")\n        }\n    }\n}\n</code></pre> <p>En este caso, se ha a\u00f1adido un bot\u00f3n a la lista de usuarios que permite eliminar un usuario de la base de datos cuando se hace clic en \u00e9l.</p> <p>La funci\u00f3n <code>UserItem</code> recibe un par\u00e1metro <code>onDeleteUser</code> que es una funci\u00f3n de tipo <code>(User) -&gt; Unit</code> que se llama cuando se hace clic en el bot\u00f3n de eliminar.</p> <p>La funci\u00f3n <code>onDeleteUser</code> se utiliza para eliminar un usuario de la base de datos a trav\u00e9s del ViewModel.</p> <p>Sobre la eliminaci\u00f3n de un usuario</p> <p>Es importante tener en cuenta que la eliminaci\u00f3n de un usuario de la base de datos debe realizarse de forma segura y eficiente para evitar problemas de integridad de los datos.</p> <p>Antes de eliminar un usuario de la base de datos, es recomendable comprobar que el usuario existe y que los datos son v\u00e1lidos y est\u00e1n correctamente formateados.</p> <p>Tambi\u00e9n es importante tener en cuenta que la eliminaci\u00f3n de un usuario de la base de datos puede afectar a otras tablas relacionadas, por lo que es importante gestionar las relaciones entre las tablas de forma adecuada.</p> <p>En general, es recomendable utilizar corutinas para realizar operaciones as\u00edncronas en la base de datos y para garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>La lambda que le pasar\u00edamos a la funci\u00f3n UserItem ser\u00eda la siguiente:</p> <pre><code>@Composable\nfun UserListScreen(userViewModel: UserViewModel) {\n    val users by userViewModel.users.collectAsState(emptyList())\n\n    LazyColumn {\n        items(users) { user -&gt;\n            UserItem(user = user) {\n                userViewModel.deleteUser(it)\n            }\n        }\n    }\n}\n</code></pre> <p>En este caso, se ha pasado una lambda a la funci\u00f3n UserItem que llama a la funci\u00f3n deleteUser() del ViewModel cuando se hace clic en el bot\u00f3n de eliminar.</p> <p>La lambda recibe un par\u00e1metro it que es el usuario que se va a eliminar de la base de datos.</p>"},{"location":"temas/04/4.1-room.html#consultar-el-contenido-de-las-bases-de-datos-con-el-inspector-en-android-studio","title":"Consultar el contenido de las bases de datos con el inspector en Android Studio","text":"<p>Para consultar el contenido de las bases de datos de Room en Android Studio, podemos utilizar el inspector de bases de datos integrado en Android Studio.</p> <p>El inspector de bases de datos permite ver y modificar los datos de las tablas de la base de datos, ejecutar consultas SQL personalizadas y realizar otras operaciones relacionadas con la base de datos.</p> <p>Para abrir el inspector de bases de datos en Android Studio, debemos seguir los siguientes pasos:</p> <ol> <li>Abrir el panel de herramientas de Android Studio.</li> <li>Seleccionar la pesta\u00f1a <code>Device File Explorer</code>.</li> <li>Navegar a la carpeta <code>/data/data/&lt;nombre del paquete de la aplicaci\u00f3n&gt;/databases/</code>.</li> <li>Hacer clic con el bot\u00f3n derecho en el archivo de la base de datos y seleccionar <code>Database Inspector</code>.</li> </ol>"},{"location":"temas/04/4.1-room.html#guardado-de-preferencias-con-datastore","title":"Guardado de preferencias con DataStore","text":"<p>DataStore es una biblioteca de Jetpack que proporciona una forma sencilla y eficiente de almacenar y recuperar datos de preferencias en una aplicaci\u00f3n Android.</p> <p>DataStore reemplaza a SharedPreferences como la forma recomendada de almacenar y recuperar datos de preferencias en una aplicaci\u00f3n Android y proporciona una API reactiva y segura para trabajar con datos de preferencias.</p> <p>A diferencia de los datos guardados con Room, que tienden a ser m\u00e1s complejos y pesados, DataStore es m\u00e1s ligero y est\u00e1 pensado para guardar datos de preferencias de forma sencilla y eficiente.</p> <p>Es decir, utilizaremos las preferencias para guardar datos simples como configuraciones de la aplicaci\u00f3n, preferencias del usuario, etc.</p> <p>DataStore tiene dos implmenetaciones:</p> <ul> <li>Preferences DataStore: Almacena y recupera datos de preferencias clave-valor de forma as\u00edncrona y reactiva.<ul> <li>Los datos almacenados con preferencias solo pueden ser de tipo primitivo o String.</li> <li>No se pueden almacenar ocnjuntos de datos complejos.</li> <li>No se requiere un esquema predeterminado.</li> </ul> </li> <li>Proto DataStore: Almacena y recupera datos de preferencias en formato de mensajes protobuf de forma as\u00edncrona y reactiva.<ul> <li>Permite almacenar y recuperar datos de preferencias m\u00e1s complejos.</li> <li>Requiere un esquema definido.</li> </ul> </li> </ul> <p>Para utilizar DataStore en una aplicaci\u00f3n Android, debemos agregar las dependencias necesarias en el archivo <code>build.gradle.kts</code> del m\u00f3dulo de la aplicaci\u00f3n:</p> <pre><code>dependencies {\n    // DataStore\n    implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n}\n</code></pre> <p>Para implementar las preferencias empezaremos creando una nueva clase en el paquete <code>data</code> llamada <code>UserPreferencesRepository</code>.</p> <p>En esta clase definiremos una propiedad privada para representar una instancia de DataStore de tipo Preferences.</p> <p>Este objeto almacenar\u00e1 pares clave-valor. Para ello, debemos definir una clave, crearemos un objeto companion y usaremos las funciones <code>stringPreferencesKey()</code> e <code>intPreferencesKey()</code> para definir las claves de las preferencias.</p> <p>Tamnbi\u00e9n crearemos una funci\u00f3n una funci\u00f3n <code>writeUserPreferences()</code> para escribir las preferencias del usuario y dos flujos de datos para observar los cambios en las preferencias del usuario.</p> <pre><code>class UserPreferencesRepository(\n    private val dataStore: DataStore&lt;Preferences&gt;\n) {\n    private companion object {\n        val USER_NAME_KEY = stringPreferencesKey(\"user_name\")\n        val USER_AGE_KEY = intPreferencesKey(\"user_age\")\n    }\n\n    val userNameFlow: Flow&lt;String&gt; = dataStore.data.map { preferences -&gt;\n        preferences[USER_NAME_KEY] ?: \"\"\n    }\n\n    val userAgeFlow: Flow&lt;Int&gt; = dataStore.data.map { preferences -&gt;\n        preferences[USER_AGE_KEY] ?: 0\n    }\n\n    suspend fun writeUserPreferences(userName: String, userAge: Int) {\n        dataStore.edit { preferences -&gt;\n            preferences[USER_NAME_KEY] = userName\n            preferences[USER_AGE_KEY] = userAge\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserPreferencesRepository</code> define una propiedad <code>dataStore</code> que representa una instancia de DataStore de tipo Preferences y que se utiliza para almacenar y recuperar los datos de preferencias del usuario.</p> <p>Al utilizar archivos de preferencias estamos interactuando con el sistema de archivos, y esto puede darnos alg\u00fan que otro problema.</p> <p>Para lidiar con los posibles problemas es recomendable capturar las posibles excepciones que puedan surgir al interactuar con el sistema de archivos.</p> <p>Podemos usar el operador catch para capturar las excepciones y manejarlas de forma adecuada.</p> <pre><code>val userNameFlow: Flow&lt;String&gt; = dataStore.data\n    .catch { exception -&gt;\n        if (exception is IOException) {\n            emit(emptyPreferences())\n        } else {\n            throw exception\n        }\n    }\n    .map { preferences -&gt;\n        preferences[USER_NAME_KEY] ?: \"\"\n    }\n</code></pre> <p>En este ejemplo, se ha a\u00f1adido un bloque <code>catch</code> al flujo de datos <code>userNameFlow</code> para capturar las excepciones de tipo <code>IOException</code> que puedan surgir al interactuar con el sistema de archivos.</p> <p>Si se produce una excepci\u00f3n de tipo <code>IOException</code>, se emite un valor predeterminado (<code>emptyPreferences()</code>) en el flujo de datos para evitar que la aplicaci\u00f3n se bloquee o se cierre.</p> <p>Esto permite manejar las excepciones de forma adecuada y garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>Para utilizar el <code>UserPreferencesRepository</code> en la aplicaci\u00f3n, debemos crear una instancia de la clase en la clase de aplicaci\u00f3n y utilizarla para acceder a los datos de preferencias del usuario.</p> <pre><code>private const val USER_PREFERENCES_NAME = \"user_preferences\"\nprivate val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = USER_PREFERENCES_NAME)\n\nclass MyApplication : Application() {\n    lateinit var userPreferencesRepository: UserPreferencesRepository\n\n    override fun onCreate() {\n        super.onCreate()\n        userPreferencesRepository = UserPreferencesRepository(dataStore)\n    }\n}\n</code></pre> <p>Actualizar archivo AndroidManifest.xml</p> <p>Para poder utilizar la clase <code>MyApplication</code> como clase de aplicaci\u00f3n, debemos actualizar el archivo <code>AndroidManifest.xml</code> y a\u00f1adir la propiedad <code>android:name</code> al elemento <code>&lt;application&gt;</code> para indicar la clase de aplicaci\u00f3n.</p> <pre><code>&lt;application\n    android:name=\".MyApplication\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\"&gt;\n    ...\n&lt;/application&gt;\n</code></pre> <p>Una vez hecho esto ya podemos proporcionar el <code>UserPreferencesRepository</code> a las clases que lo necesiten, como por ejemplo un ViewModel.</p> <p>Haremos que este repositorio sea una propiedad del constructor del ViewModel y crearemos una funci\u00f3n para escribir las preferencias del usuario.</p> <p>Adem\u00e1s, tambi\u00e9n crearemos un companion object para obtener una instancia de la clase de forma segura y eficiente.</p> <pre><code>class UserViewModel(\n    private val userPreferencesRepository: UserPreferencesRepository\n) : ViewModel() {\n    val userNameFlow: Flow&lt;String&gt; = userPreferencesRepository.userNameFlow\n    val userAgeFlow: Flow&lt;Int&gt; = userPreferencesRepository.userAgeFlow\n\n    fun writeUserPreferences(userName: String, userAge: Int) {\n        viewModelScope.launch {\n            userPreferencesRepository.writeUserPreferences(userName, userAge)\n        }\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = viewModelFactory {\n            initializer  {\n                val application = (this[APLICATION_KEY] as MyApplication)\n                UserViewModel(application.userPreferencesRepository)\n            }\n        }\n    }\n}\n</code></pre> <p>Para leer la preferencia podemos crear un uiState en el ViewModel para reflejar el flujo de datos de la preferencia.</p> <pre><code>val uiState: StateFlow&lt;UiState&gt; = \n    userPreferencesRepository.userName.map {\n        UiState(userName = it)\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5_000),\n        initialValue = UiState()\n    )\n</code></pre> <p>Sobre funci\u00f3n StateIn</p> <p>La funci\u00f3n <code>stateIn()</code> se utiliza para convertir un flujo de datos en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambian los datos.</p> <p>La funci\u00f3n <code>stateIn()</code> toma varios par\u00e1metros, como el \u00e1mbito de la corutina, el tiempo de inicio, el valor inicial y otros par\u00e1metros, para configurar el estado y garantizar que se actualice de forma segura y eficiente.</p> <p>En este caso, la funci\u00f3n <code>stateIn()</code> se utiliza para convertir el flujo de datos <code>userName</code> en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambia el nombre de usuario.</p> <p>Esto permite mostrar el nombre de usuario en la pantalla y actualizar la pantalla autom\u00e1ticamente cuando cambia el nombre de usuario.</p> <p>Los par\u00e1metros sirven para lo siguiente:</p> <ul> <li><code>scope</code>: El \u00e1mbito de la corutina en el que se ejecutar\u00e1 el estado.</li> <li><code>started</code>: El tiempo de inicio del estado.</li> <li><code>initialValue</code>: El valor inicial del estado.</li> </ul>"},{"location":"temas/04/4.2-conexion-internet.html","title":"4.2. Conexi\u00f3n a Internet","text":""},{"location":"temas/04/4.2-conexion-internet.html#42-conexion-a-internet","title":"4.2 Conexi\u00f3n a internet","text":"Corrutinas en Android <p>Las corutinas en Android son una forma de escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y concisa. Las corutinas te permiten ejecutar tareas en segundo plano de forma eficiente y reactiva, sin bloquear el hilo principal de la aplicaci\u00f3n. Las corutinas en Android se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona, como una petici\u00f3n HTTP o una consulta a la base de datos.</p> <p>Las corutinas en Android se utilizan principalmente para realizar operaciones as\u00edncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Las corutinas te permiten escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas en Android se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona.</p> <p>Para implementar una clase que se ejecute en segundo plano debe crearse una suspend function, que es una funci\u00f3n que puede pausar su ejecuci\u00f3n. Para ello, se utiliza la palabra clave <code>suspend</code> antes de la declaraci\u00f3n de la funci\u00f3n.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un objeto que comienza un conteo en segundo plano y lo actualiza cada segundo:</p> <pre><code>object Timer {\n    suspend fun start(callback: (Int) -&gt; Unit) {\n        var count = 0\n        while (true) {\n            delay(1000)\n            count++\n            callback(count)\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n <code>start</code> es una suspend function que inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.</p> <p>La funci\u00f3n <code>delay</code> se utiliza para pausar la ejecuci\u00f3n de la tarea durante un segundo.</p> <p>Para llamar a una suspend function desde una funci\u00f3n principal, se utiliza la funci\u00f3n <code>runBlocking</code>, que crea un bloque de c\u00f3digo que ejecuta la tarea de forma s\u00edncrona. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo llamar a la funci\u00f3n <code>start</code> desde una funci\u00f3n principal:</p> <pre><code>fun main() {\n    runBlocking {\n        Timer.start { count -&gt;\n            println(\"Count: $count\")\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n <code>main</code> llama a la funci\u00f3n <code>start</code> de forma s\u00edncrona utilizando <code>runBlocking</code>. La funci\u00f3n <code>start</code> inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.</p> <p>Las corutinas en Android te permiten escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona.</p> <p></p> <p>\ud83d\udca1 La palabra clave suspend La palabra clave suspend en kotlin se utiliza para marcar una funci\u00f3n que puede pausar su ejecuci\u00f3n y reanudarla m\u00e1s tarde. Las funciones suspendidas se utilizan en las corutinas para realizar operaciones as\u00edncronas de forma reactiva y eficiente.</p>"},{"location":"temas/04/4.2-conexion-internet.html#launchedeffect-para-ejecutar-tareas-en-segundo-plano-en-jetpack-compose","title":"LaunchedEffect para ejecutar tareas en segundo plano en Jetpack Compose","text":"<p>LaunchedEffect es una funci\u00f3n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu\u00eda de composici\u00f3n.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que muestra un contador que se actualiza cada segundo:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        while (true) {\n            delay(1000)\n            count++\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> muestra un contador que se actualiza cada segundo. La funci\u00f3n <code>LaunchedEffect</code> se utiliza para iniciar un bucle infinito que actualiza el contador cada segundo. La funci\u00f3n <code>delay</code> se utiliza para pausar la ejecuci\u00f3n del bucle durante un segundo.</p>"},{"location":"temas/04/4.2-conexion-internet.html#alcance-de-las-corutinas-en-jetpack-compose","title":"Alcance de las corutinas en Jetpack Compose","text":"<p>En Jetpack Compose, las corutinas se ejecutan en el alcance de un composable, lo que significa que una corutina se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. Esto garantiza que las corutinas se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina cuando se coloca en la jerarqu\u00eda de composici\u00f3n y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        while (true) {\n            delay(1000)\n            count++\n        }\n    }\n\n    DisposableEffect(Unit) {\n        onDispose {\n            // Cancela la corutina cuando el composable se elimina\n            coroutineContext.cancel()\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina cuando se coloca en la jerarqu\u00eda de composici\u00f3n utilizando <code>LaunchedEffect</code> y la cancela cuando se elimina utilizando <code>DisposableEffect</code>. La funci\u00f3n <code>onDispose</code> se utiliza para realizar tareas de limpieza cuando el composable se elimina, como cancelar la corutina.</p>"},{"location":"temas/04/4.2-conexion-internet.html#coroutinescope-en-jetpack-compose","title":"CoroutineScope en Jetpack Compose","text":"<p>En Jetpack Compose, puedes utilizar <code>coroutineScope</code> para crear un alcance de corutina que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. <code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina utilizando <code>coroutineScope</code> y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    coroutineScope {\n        launch {\n            while (true) {\n                delay(1000)\n                count++\n            }\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina utilizando <code>coroutineScope</code> y la cancela autom\u00e1ticamente cuando el composable se elimina. La funci\u00f3n <code>launch</code> se utiliza para iniciar una corutina en el alcance de <code>coroutineScope</code> que actualiza el contador cada segundo.</p> <p><code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina. <code>coroutineScope</code> es \u00fatil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.</p>"},{"location":"temas/04/4.2-conexion-internet.html#coroutinescope-en-un-launchedeffect","title":"CoroutineScope en un LaunchedEffect","text":"<p>En Jetpack Compose, puedes utilizar <code>coroutineScope</code> en un <code>LaunchedEffect</code> para crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. <code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina utilizando <code>coroutineScope</code> en un <code>LaunchedEffect</code> y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        coroutineScope {\n            launch {\n                while (true) {\n                    delay(1000)\n                    count++\n                }\n            }\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina utilizando <code>coroutineScope</code> en un <code>LaunchedEffect</code> y la cancela autom\u00e1ticamente cuando el composable se elimina. La funci\u00f3n <code>launch</code> se utiliza para iniciar una corutina en el alcance de <code>coroutineScope</code> que actualiza el contador cada segundo.</p> <p><code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina. <code>coroutineScope</code> es \u00fatil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.</p> <p>Un ejemplo de uso podemos encontrarlo en el siguiente Codelab en el que se implemmenta una carrera ficticia entre dos jugadores:</p> <p>Codelab: Carrera de coches ficticia</p> <p>\u2139\ufe0f CoroutineContext El contexto de la corrutina es un objeto que proporciona informaci\u00f3n sobre la corutina, como su alcance, su trabajo y su estado. El contexto de la corutina se utiliza para gestionar la ejecuci\u00f3n de la corutina y proporcionar informaci\u00f3n sobre su estado y progreso.</p> <p>\ud83d\udca1LaunchedEffect LaunchedEffect es una funci\u00f3n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu\u00eda de composici\u00f3n. LaunchedEffect es \u00fatil para realizar operaciones as\u00edncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Una de las principales ventajas del uso de LaunchedEffect es que se ejecuta en el alcance de un composable, lo que significa que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. Esto garantiza que las tareas en segundo plano se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento. Esto hace que no sea necesario preocuparse por la cancelaci\u00f3n manual de las tareas en segundo plano, ya que Jetpack Compose se encarga de ello de forma autom\u00e1tica. Tampoco debemos preocuparnos de proporcionar un componente Dispatcher de forma expl\u00edcita, ya que LaunchedEffect utiliza el Dispatcher predeterminado de la corrutina para ejecutar la tarea en segundo plano.</p>"},{"location":"temas/04/4.2-conexion-internet.html#formas-de-conectarse-a-internet-desde-una-app","title":"Formas de conectarse a internet desde una app","text":"<p>Para conectarse a internet en una aplicaci\u00f3n Android con Jetpack Compose, puedes utilizar las siguientes opciones (existen m\u00e1s opciones, pero estas son las m\u00e1s comunes):</p> <ul> <li> <p>Retrofit: Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi\u00f3n a servicios web RESTful. Puedes utilizar Retrofit para realizar peticiones HTTP a un servidor y obtener los datos necesarios para tu aplicaci\u00f3n.</p> </li> <li> <p>Ktor: Ktor es un framework de cliente y servidor web en Kotlin que te permite crear aplicaciones web</p> </li> <li> <p>Volley: Volley es una biblioteca de red que facilita la conexi\u00f3n a servicios web en Android. Puedes utilizar Volley para realizar peticiones HTTP y gestionar las respuestas de forma sencilla.</p> </li> </ul> <p>Vamos a centrarnos en la primera opci\u00f3n, Retrofit, que es una de las bibliotecas m\u00e1s utilizadas para conectarse a servicios web en Android.</p> <p></p>"},{"location":"temas/04/4.2-conexion-internet.html#que-es-retrofit","title":"\u00bfQu\u00e9 es Retrofit?","text":"<p>Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi\u00f3n a servicios web RESTful. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio, como las peticiones GET, POST, PUT y DELETE. Retrofit se encarga de convertir las respuestas del servidor en objetos Java/Kotlin y de gestionar la comunicaci\u00f3n con el servidor de forma eficiente.</p> <p>Tipos de peticiones habituales HTTP</p> <ul> <li>GET: Se utiliza para obtener datos del servidor. Por ejemplo, puedes utilizar una petici\u00f3n GET para obtener una lista de usuarios de un servidor.</li> <li>POST: Se utiliza para enviar datos al servidor. Por ejemplo, puedes utilizar una petici\u00f3n POST para enviar un formulario con los datos de un nuevo usuario al servidor.</li> <li>PUT: Se utiliza para actualizar datos en el servidor. Por ejemplo, puedes utilizar una petici\u00f3n PUT para actualizar los datos de un usuario existente en el servidor.</li> <li>DELETE: Se utiliza para eliminar datos del servidor. Por ejemplo, puedes utilizar una petici\u00f3n DELETE para eliminar un usuario del servidor.</li> </ul> <p> </p>"},{"location":"temas/04/4.2-conexion-internet.html#implementacion-de-retrofit-en-jetpack-compose","title":"Implementaci\u00f3n de Retrofit en Jetpack Compose","text":"<p>Para implementar Retrofit en una aplicaci\u00f3n Android con Jetpack Compose, puedes seguir los siguientes pasos:</p> <ol> <li> <p>Definir la interfaz de servicio web: Define una interfaz que contenga las operaciones disponibles en el servicio web y an\u00f3tala con las anotaciones de Retrofit, como <code>@GET</code>, <code>@POST</code>, <code>@PUT</code> y <code>@DELETE</code>. Por ejemplo, puedes definir una interfaz <code>ApiService</code> que contenga m\u00e9todos para obtener y enviar datos al servidor.</p> </li> <li> <p>Crear una instancia de Retrofit: Crea una instancia de Retrofit utilizando el constructor de <code>Retrofit.Builder</code> y configura la URL base del servicio web y el convertidor de JSON. Por ejemplo, puedes crear una instancia de Retrofit que se conecte a un servidor en <code>https://api.example.com</code> y utilice el convertidor de JSON de Gson.</p> </li> <li> <p>Crear una instancia del servicio web: Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit. Por ejemplo, puedes crear una instancia del servicio web a partir de la interfaz <code>ApiService</code> y la instancia de Retrofit.</p> </li> <li> <p>Realizar peticiones HTTP: Utiliza la instancia del servicio web para realizar peticiones HTTP al servidor y obtener los datos necesarios para tu aplicaci\u00f3n. Por ejemplo, puedes utilizar el m\u00e9todo <code>getUsers()</code> de la interfaz <code>ApiService</code> para obtener una lista de usuarios del servidor.</p> </li> </ol> <p> </p>"},{"location":"temas/04/4.2-conexion-internet.html#ejemplo-sencillo-de-implementacion","title":"Ejemplo sencillo de implementaci\u00f3n","text":"<p>A continuaci\u00f3n, se muestra un ejemplo de implementaci\u00f3n de Retrofit en una aplicaci\u00f3n Android con Jetpack Compose:</p> <pre><code>// Define la interfaz de servicio web con las operaciones disponibles\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List&lt;User&gt;\n}\n\n// Crea una instancia de Retrofit con la URL base y el convertidor de JSON\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()\n\n// Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit\nval apiService = retrofit.create(ApiService::class.java)\n\n// Realiza una petici\u00f3n HTTP al servidor para obtener una lista de usuarios\nval users = apiService.getUsers()\n</code></pre> <p>En este ejemplo, se define una interfaz <code>ApiService</code> con el m\u00e9todo <code>getUsers()</code> que realiza una petici\u00f3n GET al servidor para obtener una lista de usuarios. Se crea una instancia de Retrofit con la URL base <code>https://api.example.com</code> y el convertidor de JSON de Gson. A continuaci\u00f3n, se crea una instancia del servicio web a partir de la interfaz <code>ApiService</code> y la instancia de Retrofit. Por \u00faltimo, se utiliza la instancia del servicio web para realizar una petici\u00f3n HTTP al servidor y obtener una lista de usuarios.</p> <p>Con Retrofit, puedes conectarte a servicios web RESTful de forma sencilla y eficiente en una aplicaci\u00f3n Android con Jetpack Compose. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio y gestionar la comunicaci\u00f3n con el servidor de forma autom\u00e1tica.</p> <p>Todo este c\u00f3digo suele ordenarse y distribuirse en diferentes archivos y paquetes para mantener una estructura limpia y organizada. A continuaci\u00f3n veremos cada uno de estos pasos en detalle.</p>"},{"location":"temas/04/4.2-conexion-internet.html#implementacion-de-retrofit-en-android","title":"Implementaci\u00f3n de Retrofit en Android\u200b","text":""},{"location":"temas/04/4.2-conexion-internet.html#permiso-de-internet","title":"Permiso de Internet","text":"<p>Para conectarse a internet en una aplicaci\u00f3n Android, debes a\u00f1adir el permiso de internet al archivo <code>AndroidManifest.xml</code> de la aplicaci\u00f3n. Puedes hacerlo a\u00f1adiendo la siguiente l\u00ednea al archivo <code>AndroidManifest.xml</code>:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre> <p>Este permiso permite que la aplicaci\u00f3n se conecte a internet y realice peticiones HTTP al servidor. Sin este permiso, la aplicaci\u00f3n no podr\u00e1 conectarse a internet y no podr\u00e1 realizar peticiones HTTP al servidor.</p>"},{"location":"temas/04/4.2-conexion-internet.html#importar-las-dependencias-de-retrofit","title":"Importar las dependencias de Retrofit","text":"<p>Para utilizar Retrofit en una aplicaci\u00f3n Android, primero debes importar las dependencias de Retrofit en el archivo <code>build.gradle</code> del m\u00f3dulo de la aplicaci\u00f3n. Puedes hacerlo a\u00f1adiendo las siguientes l\u00edneas al archivo <code>build.gradle</code>:</p> <pre><code>dependencies {\n    // Retrofit\n    implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n    // Retrofit with Scalar Converter\n    implementation(\"com.squareup.retrofit2:converter-scalars:2.9.0\")\n}\n</code></pre> <p>Estas l\u00edneas importan las dependencias de Retrofit y el convertidor de escalares en la aplicaci\u00f3n. El convertidor de escalares se utiliza para convertir las respuestas del servidor en cadenas de texto.</p>"},{"location":"temas/04/4.2-conexion-internet.html#definir-la-interfaz-de-servicio-web","title":"Definir la interfaz de servicio web","text":"<p>A continuaci\u00f3n, debes definir una interfaz de servicio web que contenga las operaciones disponibles en el servicio. Puedes hacerlo creando una interfaz en un archivo Kotlin y anot\u00e1ndola con las anotaciones de Retrofit, como <code>@GET</code>, <code>@POST</code>, <code>@PUT</code> y <code>@DELETE</code>. Por ejemplo, puedes definir una interfaz <code>ApiService</code> que contenga m\u00e9todos para obtener y enviar datos al servidor:</p> <pre><code>import retrofit2.http.GET\n\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List&lt;User&gt;\n}\n</code></pre> <p>En este ejemplo, la interfaz ApiService contiene un m\u00e9todo getUsers() que realiza una petici\u00f3n GET al servidor para obtener una lista de usuarios.</p> <p>\ud83d\udca1Ubicaci\u00f3n de la interfaz de servicio web. La interfaz de servicio web suele ubicarse en un paquete de datos, network o servicios del proyecto para mantener una estructura limpia y organizada. \u27a1\ufe0f Anotaciones de Retrofit. Las anotaciones de Retrofit se utilizan para describir las operaciones disponibles en el servicio web. Por ejemplo, la anotaci\u00f3n @GET se utiliza para realizar una petici\u00f3n GET al servidor, la anotaci\u00f3n @POST se utiliza para realizar una petici\u00f3n POST al servidor, y as\u00ed sucesivamente</p>"},{"location":"temas/04/4.4-Injeccion-dependencias.html","title":"4.4 Injeccion dependencias","text":""}]}