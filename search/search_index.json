{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Inicio","text":""},{"location":"index.html#programacion-multimedia-y-dispositivos-moviles-pmdm","title":"Programaci\u00f3n multimedia y dispositivos m\u00f3viles (PMDM)","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n multimedia y dispositivos m\u00f3viles, que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 160 horas lectivas, a raz\u00f3n de 4 horas semanales, y se desarrolla a lo largo de los dos primeros trimestres del curso. Se ha planificado bas\u00e1ndose en 2 sesiones de 2 horas lectivas por semana.</p> <p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso. </p> <p>Esta p\u00e1gina servir\u00e1 b\u00e1sicamente de gu\u00eda y contendr\u00e1 ejemplos, enlaces a otros repositorios con proyectos y ejercicios que iremos viendo en clase, o peque\u00f1os tutoriales y codelabs para ir aprendiendo diferentes conceptos.</p> <p>El m\u00f3dulo est\u00e1 dividido en dos grandes bloques, un primer bloque en d\u00f3nde aprender\u00e9is sobre desarrollo de aplicaciones Android usando Kotlin como lenguaje de programaci\u00f3n y Jetpack Compose para el desarrollo de la UI de las mismas.</p> <p>El segundo bloque trata sobre el desarrollo de videojuegos, para lo cual usaremos el motor de videojuegos Unity y el lenguaje C#.</p>"},{"location":"index.html#recursos","title":"Recursos","text":"Recursos del m\u00f3dulo Documentaci\u00f3nAndroid Code LabsSoftwareCursos <ul> <li>Documentaci\u00f3n oficial de Android</li> <li>Documentaci\u00f3n oficial de Kotlin</li> <li>Documentaci\u00f3n oficial de Jetpack Compose</li> </ul> <ul> <li> <p>Principales</p> <ul> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ul> </li> </ul> <ul> <li>IDEs<ul> <li>Android Studio</li> </ul> </li> </ul> <ul> <li>Pildoras inform\u00e1ticas<ul> <li>Curso Android &amp; Kotlin</li> <li>Curso de Android (java) con Android Studio</li> </ul> </li> </ul>"},{"location":"temas/00-android/index.html","title":"Inicio","text":""},{"location":"temas/00-android/index.html#desarrollo-de-aplicaciones-android-con-kotlin-y-jetpack-compose","title":"Desarrollo de aplicaciones Android con Kotlin y Jetpack Compose","text":"<p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso de la parte de Android.</p> <p>P\u00e1gina de descarga de Android Studio</p> <p>Kotlin Playground</p> <p>Repositorio con respuestas a algunas dudas habituales</p>"},{"location":"temas/00-android/index.html#apartados-del-curso","title":"Apartados del curso","text":"<ol> <li> <p>Introducci\u00f3n Kotlin</p> </li> <li> <p>Jetpack Compose</p> <ol> <li> <p>Composable functions</p> </li> <li> <p>State management</p> </li> <li> <p>Listas y cuadr\u00edculas</p> </li> <li> <p>Navegaci\u00f3n y rutas</p> </li> <li> <p>Material Design</p> </li> </ol> </li> <li> <p>Ciclo de vida de una app</p> </li> <li> <p>Arquitecturas en Android</p> </li> <li> <p>La capa de UI</p> </li> <li> <p>Conexi\u00f3n a internet</p> </li> <li> <p>Conversi\u00f3n JSON a objetos</p> </li> <li> <p>Persistencia de datos</p> </li> <li> <p>Ejercicios: Enunciados y soluciones</p> </li> <li> <p>Documentaci\u00f3n extra y recursos externos</p> </li> </ol>"},{"location":"temas/00-android/index.html#codelabs-primordiales","title":"Codelabs primordiales","text":"<ol> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ol>"},{"location":"temas/00-android/02-arquitectura.html","title":"Arquitectura en Android","text":""},{"location":"temas/00-android/02-arquitectura.html#arquitectura-en-android","title":"Arquitectura en Android","text":"<p>En Android, la arquitectura de una aplicaci\u00f3n se refiere a la estructura y organizaci\u00f3n de sus componentes, como las actividades, fragmentos, servicios y otros elementos que la componen. Una buena arquitectura es fundamental para crear aplicaciones robustas, escalables y f\u00e1ciles de mantener.</p> <p>En este documento, veremos los principios b\u00e1sicos de la arquitectura en Android y c\u00f3mo puedes aplicarlos en tus propias aplicaciones. Tambi\u00e9n veremos algunas de las arquitecturas m\u00e1s comunes en Android, como MVC, MVP, MVVM y Clean Architecture, y c\u00f3mo puedes elegir la mejor arquitectura para tu proyecto.</p>"},{"location":"temas/00-android/02-arquitectura.html#principios-basicos-de-la-arquitectura-en-android","title":"Principios b\u00e1sicos de la arquitectura en Android","text":"<p>Al dise\u00f1ar la arquitectura de una aplicaci\u00f3n Android, es importante tener en cuenta los siguientes principios b\u00e1sicos:  </p> <ul> <li> <p>Separaci\u00f3n de responsabilidades: Divide tu aplicaci\u00f3n en capas o componentes que tengan responsabilidades claras y bien definidas. Por ejemplo, separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y de acceso a datos. </p> </li> <li> <p>Escalabilidad: Dise\u00f1a tu arquitectura de manera que puedas agregar nuevas funcionalidades o componentes sin tener que reescribir todo el c\u00f3digo.  </p> </li> <li> <p>Mantenibilidad: Haz que tu c\u00f3digo sea f\u00e1cil de entender, modificar y depurar. Utiliza patrones de dise\u00f1o y buenas pr\u00e1cticas de programaci\u00f3n para mantener tu c\u00f3digo limpio y organizado.  </p> </li> <li> <p>Pruebas unitarias: Dise\u00f1a tu arquitectura de manera que puedas escribir pruebas unitarias para cada componente de tu aplicaci\u00f3n. Las pruebas unitarias te permiten validar el comportamiento de tu c\u00f3digo de forma automatizada y garantizar su calidad.  </p> </li> <li> <p>Reactividad: Dise\u00f1a tu arquitectura de manera que puedas responder de forma r\u00e1pida y eficiente a los eventos y cambios en tu aplicaci\u00f3n. Utiliza patrones de dise\u00f1o reactivos para crear interfaces de usuario din\u00e1micas y reactivas. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#arquitecturas-comunes-en-android","title":"Arquitecturas comunes en Android","text":"<p>En Android, existen varias arquitecturas comunes que puedes utilizar para dise\u00f1ar tu aplicaci\u00f3n. Algunas de las arquitecturas m\u00e1s populares son las siguientes: </p> <ul> <li> <p>MVC (Modelo-Vista-Controlador): En el patr\u00f3n MVC, la vista es responsable de mostrar la interfaz de usuario, el controlador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos.  </p> </li> <li> <p>MVP (Modelo-Vista-Presentador): En el patr\u00f3n MVP, la vista es responsable de mostrar la interfaz de usuario, el presentador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El presentador act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>MVVM (Modelo-Vista-ViewModel): En el patr\u00f3n MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>Clean Architecture: La Clean Architecture es una arquitectura en capas que separa la aplicaci\u00f3n en capas de dominio, aplicaci\u00f3n e infraestructura. Cada capa tiene responsabilidades claras y bien definidas, lo que facilita la escalabilidad y mantenibilidad de la aplicaci\u00f3n. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#eleccion-de-la-arquitectura-adecuada","title":"Elecci\u00f3n de la arquitectura adecuada","text":"<p>A la hora de elegir la arquitectura para tu aplicaci\u00f3n Android, es importante tener en cuenta varios factores, como el tama\u00f1o y complejidad de la aplicaci\u00f3n, el equipo de desarrollo, los requisitos de rendimiento y escalabilidad, y la experiencia previa con las arquitecturas disponibles.    </p> <p>Algunos consejos para elegir la arquitectura adecuada son los siguientes:   </p> <ul> <li> <p>Eval\u00faa tus necesidades: Analiza los requisitos de tu aplicaci\u00f3n y elige la arquitectura que mejor se adapte a ellos. Por ejemplo, si tu aplicaci\u00f3n es peque\u00f1a y sencilla, puedes optar por una arquitectura MVC o MVP. Si tu aplicaci\u00f3n es grande y compleja, puedes optar por una arquitectura MVVM o Clean Architecture.    </p> </li> <li> <p>Prueba diferentes arquitecturas: Experimenta con diferentes arquitecturas y eval\u00faa sus ventajas y desventajas en funci\u00f3n de tus necesidades. No tengas miedo de probar nuevas arquitecturas y adaptarlas a tus necesidades espec\u00edficas.   </p> </li> <li> <p>Consulta la comunidad: Busca en la comunidad de desarrolladores de Android y consulta ejemplos, tutoriales y buenas pr\u00e1cticas sobre arquitectura. La comunidad de desarrolladores es una gran fuente de informaci\u00f3n y te puede ayudar a elegir la arquitectura adecuada para tu proyecto. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#la-arquitectura-que-vamos-a-utilizar-en-este-curso-es-mvvm","title":"La arquitectura que vamos a utilizar en este curso es MVVM","text":"<p>En este curso, vamos a utilizar la arquitectura MVVM (Modelo-Vista-ViewModel) para dise\u00f1ar nuestras aplicaciones Android. La arquitectura MVVM es una arquitectura moderna y escalable que separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y acceso a datos.   </p> <p>En la arquitectura MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo, lo que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo. </p> <p>La arquitectura MVVM es una arquitectura popular en Android y es compatible con las bibliotecas y herramientas de Jetpack, como LiveData, ViewModel y Room. Utilizaremos estas bibliotecas y herramientas en nuestro curso para crear aplicaciones Android modernas y eficientes.   </p> <p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/02-arquitectura.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Android: La documentaci\u00f3n oficial de Android, que incluye gu\u00edas, tutoriales y ejemplos para aprender a desarrollar aplicaciones Android.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio Lista de la compra - Enunciado - Soluci\u00f3n</p> </li> <li> <p>App de Carta Alta - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/03-capa-ui.html","title":"Capa de UI","text":""},{"location":"temas/00-android/03-capa-ui.html#capa-de-ui","title":"Capa de UI","text":"<p>En esta secci\u00f3n vamos a ver c\u00f3mo implementar la capa de UI en una arquitectura MVVM (Model-View-ViewModel) en una aplicaci\u00f3n Android con Jetpack Compose.</p>"},{"location":"temas/00-android/03-capa-ui.html#que-es-mvvm","title":"\u00bfQu\u00e9 es MVVM?","text":"<p>MVVM es un patr\u00f3n de arquitectura de software que se utiliza para separar la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio en una aplicaci\u00f3n. En MVVM, la capa de UI se divide en tres componentes principales:</p> <ul> <li> <p>Model: Representa los datos y la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> </li> <li> <p>View: Representa la interfaz de usuario de la aplicaci\u00f3n.</p> </li> <li> <p>ViewModel: Act\u00faa como un intermediario entre el Model y la View. Se encarga de manejar la l\u00f3gica de presentaci\u00f3n y de exponer los datos necesarios para que la View pueda mostrarlos. </p> </li> </ul> <p>MVVM es un patr\u00f3n muy utilizado en el desarrollo de aplicaciones Android, ya que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo.  </p>"},{"location":"temas/00-android/03-capa-ui.html#implementacion-de-la-capa-de-ui-en-mvvm","title":"Implementaci\u00f3n de la capa de UI en MVVM","text":"<p>Para implementar la capa de UI en una arquitectura MVVM en una aplicaci\u00f3n Android con Jetpack Compose, puedes seguir los siguientes pasos:  </p> <ol> <li> <p>Definir el Model: Define las clases y estructuras de datos que representan los datos y la l\u00f3gica de negocio de tu aplicaci\u00f3n. Por ejemplo, puedes definir una clase <code>User</code> que represente un usuario de la aplicaci\u00f3n.</p> </li> <li> <p>Definir el ViewModel: Define una clase que extienda <code>ViewModel</code> y que contenga la l\u00f3gica de presentaci\u00f3n de tu aplicaci\u00f3n. Por ejemplo, puedes definir un ViewModel que contenga la l\u00f3gica para cargar los datos de un usuario.</p> </li> <li> <p>Definir la View: Define la interfaz de usuario de tu aplicaci\u00f3n utilizando Jetpack Compose. Por ejemplo, puedes definir una funci\u00f3n componible que muestre los datos de un usuario en la pantalla.</p> </li> <li> <p>Conectar el ViewModel con la View: Conecta el ViewModel con la View para que la View pueda mostrar los datos del ViewModel. Puedes utilizar <code>rememberViewModel</code> para crear una instancia del ViewModel en la View y <code>viewModel</code> para acceder a los datos del ViewModel.</p> </li> </ol>"},{"location":"temas/00-android/03-capa-ui.html#ejemplo-de-implementacion","title":"Ejemplo de implementaci\u00f3n","text":"<p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/03-capa-ui.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html","title":"Introducci\u00f3n","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-compose/index.html#jetpack-compose","title":"Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.    </p>"},{"location":"temas/00-android/00-compose/index.html#caracteristicas-de-jetpack-compose","title":"Caracter\u00edsticas de Jetpack Compose","text":"<ul> <li> <p>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </p> </li> <li> <p>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </p> </li> <li> <p>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </p> </li> <li> <p>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </p> </li> <li> <p>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.    </p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html#apartados","title":"Apartados","text":"<ul> <li> <p>Composable functions: Aprende a crear funciones componibles en Jetpack Compose y a componerlas para crear interfaces de usuario complejas.</p> </li> <li> <p>State management: Descubre c\u00f3mo gestionar el estado de tu aplicaci\u00f3n en Jetpack Compose y c\u00f3mo hacer que tu interfaz de usuario sea reactiva.</p> </li> <li> <p>Listas y cuadr\u00edculas: Aprende a mostrar listas y cuadr\u00edculas de elementos en Jetpack Compose y a personalizar su apariencia.</p> </li> <li> <p>Navegaci\u00f3n y rutas: Descubre c\u00f3mo implementar la navegaci\u00f3n entre pantallas en Jetpack Compose y c\u00f3mo definir rutas para tu aplicaci\u00f3n.</p> </li> <li> <p>Material Design: Aprende a implementar los principios de Material Design en Jetpack Compose y a personalizar los estilos de tus componentes.</p> </li> </ul> <p>Video Creaci\u00f3n de un proyecto Android y sus partes</p> <p></p> <p>Video L\u00f3gica de actividades e introducci\u00f3n al ciclo de vida</p> <p></p>"},{"location":"temas/00-android/00-compose/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.  </p> </li> <li> <p>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html","title":"Funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#funciones-componibles-en-jetpack-compose","title":"Funciones componibles en Jetpack Compose","text":"<p>En Jetpack Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#crear-una-funcion-componible","title":"Crear una funci\u00f3n componible","text":"<p>Para crear una funci\u00f3n componible en Jetpack Compose, utiliza la anotaci\u00f3n <code>@Composable</code> antes de la definici\u00f3n de la funci\u00f3n. Una funci\u00f3n componible puede tener par\u00e1metros y devolver un \u00e1rbol de elementos de la interfaz de usuario utilizando las funciones de composici\u00f3n proporcionadas por Compose.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Greeting</code> que toma un par\u00e1metro <code>name</code> de tipo <code>String</code> y devuelve un elemento de texto <code>Text</code> que muestra un saludo personalizado.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#componer-funciones-componibles","title":"Componer funciones componibles","text":"<p>Puedes componer funciones componibles para crear interfaces de usuario m\u00e1s complejas. Utiliza las funciones de composici\u00f3n proporcionadas por Compose, como <code>Column</code>, <code>Row</code>, <code>Box</code>, <code>Spacer</code>, etc., para organizar y dise\u00f1ar los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>GreetingList</code> que toma una lista de nombres y muestra un saludo personalizado para cada nombre utilizando la funci\u00f3n componible <code>Greeting</code>.</p> <p>Video introducci\u00f3n a Compose</p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#actualizacion-de-funciones-componibles","title":"Actualizaci\u00f3n de funciones componibles","text":"<p>Las funciones componibles en Jetpack Compose son reactivas, lo que significa que se vuelven a ejecutar autom\u00e1ticamente cuando cambian los datos de entrada. Esto permite que la interfaz de usuario se actualice de forma din\u00e1mica en respuesta a los cambios en los datos.</p> <pre><code>@Composable\nfun Counter(count: Int) {\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Counter</code> que muestra el recuento actual. Cuando cambia el recuento, la funci\u00f3n componible se vuelve a ejecutar autom\u00e1ticamente para reflejar el nuevo valor.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#columnas-y-filas-en-jetpack-compose","title":"Columnas y filas en Jetpack Compose+","text":"<p>Jetpack Compose proporciona las funciones <code>Column</code> y <code>Row</code> para organizar elementos de la interfaz de usuario en columnas y filas respectivamente. Puedes anidar columnas y filas para crear dise\u00f1os m\u00e1s complejos y reutilizables.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Spacer(modifier = Modifier.height(8.dp))\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical. Se a\u00f1ade un <code>Spacer</code> entre cada saludo para separarlos visualmente.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificadores-en-jetpack-compose","title":"Modificadores en Jetpack Compose","text":"<p>Jetpack Compose utiliza modificadores para aplicar estilos y comportamientos a los elementos de la interfaz de usuario. Puedes utilizar modificadores para cambiar el tama\u00f1o, la posici\u00f3n, el color, la forma, etc., de los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier\n            .padding(16.dp)\n            .background(Color.Blue)\n            .clickable { /* Acci\u00f3n al hacer clic */ }\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un relleno alrededor del texto, el modificador <code>background</code> para cambiar el color de fondo del texto, y el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p> <p>!!! info \"Video Modificadores y uso del tema]     </p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#recursos-en-jetpack-compose","title":"Recursos en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de recursos de Android para gestionar los recursos de la interfaz de usuario, como cadenas, colores, dimensiones, etc. Puedes acceder a los recursos utilizando la funci\u00f3n <code>stringResource()</code>, <code>colorResource()</code>, <code>dimenResource()</code>, etc.</p> <pre><code>@Composable\nfun Greeting() {\n    Text(\n        text = stringResource(id = R.string.hello),\n        color = colorResource(id = R.color.primary),\n        fontSize = dimenResource(id = R.dimen.text_size)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>stringResource()</code> para obtener una cadena de recursos, la funci\u00f3n <code>colorResource()</code> para obtener un color de recursos, y la funci\u00f3n <code>dimenResource()</code> para obtener una dimensi\u00f3n de recursos.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#temas-en-jetpack-compose","title":"Temas en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de temas de Android para aplicar estilos coherentes a la interfaz de usuario. Puedes definir un tema personalizado utilizando la funci\u00f3n <code>provideAppTheme()</code> y aplicarlo a tu aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p> <pre><code>@Composable\nfun MyApp() {\n    MaterialTheme(\n        colors = lightColors(),\n        typography = Typography,\n        shapes = Shapes\n    ) {\n        Greeting()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado con colores, tipograf\u00eda y formas personalizadas, y se aplica a la aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplos-de-funciones-componibles","title":"Ejemplos de funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-row","title":"Ejemplo de funci\u00f3n con Row","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Row</code> para organizar el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-box","title":"Ejemplo de funci\u00f3n con Box","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Box(\n        modifier = Modifier\n            .background(Color.Blue)\n            .padding(16.dp)\n    ) {\n        Text(text = \"Hello, $name!\", color = Color.White)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Box</code> para colocar el texto en un cuadro azul con un relleno de 16 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-column","title":"Ejemplo de funci\u00f3n con Column","text":"<pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Divider(color = Color.Gray, thickness = 1.dp)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical con una l\u00ednea divisoria entre cada saludo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#como-anadir-imagenes-usando-image-y-painterresource","title":"C\u00f3mo a\u00f1adir im\u00e1genes usando Image y painterResource","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Image(\n            painter = painterResource(id = R.drawable.ic_launcher_foreground),\n            contentDescription = null,\n            modifier = Modifier.size(48.dp)\n        )\n        Spacer(modifier = Modifier.width(8.dp))\n        Text(text = \"Hello, $name!\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Image</code> para a\u00f1adir una imagen a la interfaz de usuario utilizando un recurso de imagen.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#previews-en-jetpack-compose","title":"Previews en Jetpack Compose","text":"<p>Jetpack Compose proporciona una funci\u00f3n <code>@Preview</code> que te permite previsualizar tus funciones componibles en tiempo real en Android Studio. Puedes definir previsualizaciones para tus funciones componibles y ver c\u00f3mo se ven en diferentes configuraciones y estados.</p> <pre><code>@Preview\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una previsualizaci\u00f3n <code>GreetingPreview</code> para la funci\u00f3n componible <code>Greeting</code> con el nombre \"World\". Puedes ver la previsualizaci\u00f3n en Android Studio y ajustarla seg\u00fan sea necesario.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-previsualizacion","title":"Opciones de previsualizaci\u00f3n","text":"<p>Jetpack Compose proporciona varias opciones de previsualizaci\u00f3n que te permiten personalizar la apariencia de tus previsualizaciones. Puedes definir diferentes configuraciones, tama\u00f1os, orientaciones, temas, etc., para tus previsualizaciones y ver c\u00f3mo se ven en diferentes contextos.</p> <pre><code>@Preview(\n    showBackground = true,\n    name = \"Greeting Preview\",\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    widthDp = 320,\n    heightDp = 240\n)\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>Las opciones de previsualizaci\u00f3n son las siguientes:</p> <ul> <li><code>showBackground</code>: Muestra un fondo en la previsualizaci\u00f3n.</li> <li><code>name</code>: Nombre de la previsualizaci\u00f3n.</li> <li><code>uiMode</code>: Modo de interfaz de usuario (claro, oscuro, etc.).</li> <li><code>widthDp</code>: Ancho de la previsualizaci\u00f3n en dp.</li> <li><code>heightDp</code>: Alto de la previsualizaci\u00f3n en dp.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-en-jetpack-compose","title":"Opciones de alineaci\u00f3n en Jetpack Compose","text":"<p>Jetpack Compose proporciona opciones de alineaci\u00f3n que te permiten alinear los elementos de la interfaz de usuario de forma horizontal y vertical. Puedes utilizar las opciones de alineaci\u00f3n para controlar la posici\u00f3n de los elementos en la pantalla y crear dise\u00f1os m\u00e1s precisos y coherentes.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier.align(Alignment.CenterHorizontally)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro de la pantalla.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-horizontal","title":"Opciones de alineaci\u00f3n horizontal","text":"<p>Las opciones de alineaci\u00f3n horizontal en Jetpack Compose son las siguientes:</p> <ul> <li><code>start</code>: Alinea el elemento al principio del eje horizontal.</li> <li><code>centerHorizontally</code>: Alinea el elemento en el centro del eje horizontal.</li> <li><code>end</code>: Alinea el elemento al final del eje horizontal.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-vertical","title":"Opciones de alineaci\u00f3n vertical","text":"<p>Las opciones de alineaci\u00f3n vertical en Jetpack Compose son las siguientes:</p> <ul> <li><code>top</code>: Alinea el elemento en la parte superior del eje vertical.</li> <li><code>centerVertically</code>: Alinea el elemento en el centro del eje vertical.</li> <li><code>bottom</code>: Alinea el elemento en la parte inferior del eje vertical.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-personalizadas","title":"Opciones de alineaci\u00f3n personalizadas","text":"<p>Adem\u00e1s de las opciones de alineaci\u00f3n predefinidas, Jetpack Compose te permite crear opciones de alineaci\u00f3n personalizadas utilizando la funci\u00f3n <code>Alignment</code>.</p> <pre><code>val CustomAlignment = Alignment(0.25f, 0.75f)\n</code></pre> <p>En el ejemplo anterior, se define una opci\u00f3n de alineaci\u00f3n personalizada <code>CustomAlignment</code> con un desplazamiento horizontal del 25% y un desplazamiento vertical del 75%.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#uso-de-opciones-de-alineacion-en-column-y-row","title":"Uso de opciones de alineaci\u00f3n en Column y Row","text":"<p>Puedes utilizar las opciones de alineaci\u00f3n en las funciones <code>Column</code> y <code>Row</code> para alinear los elementos de la interfaz de usuario de forma horizontal y vertical.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.SpaceEvenly\n    ) {\n        Text(text = \"Hello, $name!\")\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la opci\u00f3n de alineaci\u00f3n vertical <code>Alignment.CenterVertically</code> y la disposici\u00f3n horizontal <code>Arrangement.SpaceEvenly</code> para alinear el texto y el icono en una fila horizontal.</p> <p>Las diferentes opciones de alineaci\u00f3n y disposici\u00f3n te permiten crear dise\u00f1os flexibles y personalizados en Jetpack Compose.</p> <p>Para el Arrangement existen las siguientes opciones:</p> <ul> <li><code>SpaceAround</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos.</li> <li><code>SpaceBetween</code>: Distribuye el espacio entre los elementos de forma uniforme, sin espacio adicional alrededor de los elementos.</li> <li><code>SpaceEvenly</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos y en los extremos.</li> <li><code>Center</code>: Centra los elementos en el espacio disponible.</li> <li><code>Start</code>: Coloca los elementos al principio del espacio disponible.</li> <li><code>End</code>: Coloca los elementos al final del espacio disponible.</li> </ul> <p>En las siguientes im\u00e1genes animadas se muestran ejemplos de alineaci\u00f3n horizontal y vertical en Jetpack Compose:</p> <p></p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#mas-ejemplos-de-modificaciones","title":"M\u00e1s ejemplos de modificaciones","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tamano","title":"Modificador de tama\u00f1o","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.size(48.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>size</code> para cambiar el tama\u00f1o del texto a 48 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-altura-y-anchura","title":"Modificador de altura y anchura","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.width(100.dp).height(50.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utilizan los modificadores <code>width</code> y <code>height</code> para cambiar la anchura del texto a 100 dp y la altura a 50 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tipografia","title":"Modificador de tipograf\u00eda","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", style = TextStyle(fontWeight = FontWeight.Bold))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>style</code> para cambiar el peso de la fuente del texto a negrita.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-alineacion","title":"Modificador de alineaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.align(Alignment.CenterHorizontally))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-margen","title":"Modificador de margen","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.padding(16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un margen de 16 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-color-de-fondo","title":"Modificador de color de fondo","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.background(Color.Blue))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>background</code> para cambiar el color de fondo del texto a azul.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-borde","title":"Modificador de borde","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.border(1.dp, Color.Black))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>border</code> para a\u00f1adir un borde de 1 dp de grosor alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-clic","title":"Modificador de clic","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ })\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-forma","title":"Modificador de forma","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clip(RoundedCornerShape(4.dp)))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clip</code> para aplicar una forma redondeada con un radio de 4 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-rotacion","title":"Modificador de rotaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.rotate(45f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>rotate</code> para rotar el texto 45 grados.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-escala","title":"Modificador de escala","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.scale(1.5f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>scale</code> para escalar el texto a 1.5 veces su tama\u00f1o original.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desplazamiento","title":"Modificador de desplazamiento","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.offset(x = 16.dp, y = 16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>offset</code> para desplazar el texto 16 dp hacia la derecha y 16 dp hacia abajo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-sombra","title":"Modificador de sombra","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.shadow(4.dp, shape = CircleShape))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>shadow</code> para a\u00f1adir una sombra de 4 dp alrededor del texto con una forma circular.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desenfoque","title":"Modificador de desenfoque","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.blur(4.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>blur</code> para aplicar un efecto de desenfoque al texto con un radio de 4 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#otros-ejemplos-de-funciones-componibles-de-interes","title":"Otros ejemplos de funciones componibles de inter\u00e9s","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#el-uso-de-spacer","title":"El uso de Spacer","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Spacer</code> para a\u00f1adir un espacio entre el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html","title":"Gesti\u00f3n del estado","text":""},{"location":"temas/00-android/00-compose/22-state-management.html#gestion-de-estado-en-jetpack-compose","title":"Gesti\u00f3n de estado en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#estado-en-jetpack-compose","title":"Estado en Jetpack Compose","text":"<p>En Jetpack Compose, el estado es una parte fundamental de la arquitectura de tu aplicaci\u00f3n. </p> <p>El estado representa la informaci\u00f3n que puede cambiar a lo largo del tiempo y que afecta a la apariencia y el comportamiento de tu interfaz de usuario. </p> <p>Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva en Compose.</p> <p>!!! info \"Video introducci\u00f3n al manejo del estado en Compose]     </p>"},{"location":"temas/00-android/00-compose/22-state-management.html#definicion-de-estado","title":"Definici\u00f3n de estado","text":"<p>Puedes definir el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>mutableStateOf()</code> de Compose.</p> <pre><code>val contador = mutableStateOf(0)\n</code></pre> <p>En el ejemplo anterior, se define un estado <code>contador</code> con un valor inicial de <code>0</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-estado","title":"Observaci\u00f3n de estado","text":"<p>Puedes observar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>observeAsState()</code> de Compose.</p> <pre><code>val contadorState = contador.observeAsState()\nval contador = contadorState.value\n</code></pre> <p>En el ejemplo anterior, se observa el estado <code>contador</code> y se obtiene su valor actual.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#actualizacion-de-estado","title":"Actualizaci\u00f3n de estado","text":"<p>Puedes actualizar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>value</code> de Compose.</p> <pre><code>contador.value++\n</code></pre> <p>En el ejemplo anterior, se incrementa en uno el valor del estado <code>contador</code>.</p> <p>\u00a1Importante!</p> <p>El estado en Compose es inmutable, por lo que debes utilizar la funci\u00f3n <code>value</code> para actualizar el estado.</p> <p>Para que haya recomposici\u00f3n, la actualizaci\u00f3n del estado debe realizarse dentro de un evento de un componente <code>@Composable</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-completo","title":"Ejemplo completo","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#tipos-de-estado","title":"Tipos de estado","text":"<p>En Jetpack Compose, puedes utilizar diferentes tipos de estado para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <ul> <li><code>mutableStateOf()</code>: Crea un estado mutable que puede cambiar a lo largo del tiempo.</li> <li><code>remember</code>: Crea un estado que se mantiene entre recomposiciones.</li> <li><code>derivedStateOf()</code>: Crea un estado derivado a partir de otros estados.</li> </ul>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remember","title":"Uso de remember","text":"<p>La funci\u00f3n <code>remember</code> de Compose te permite crear un estado que se mantiene entre recomposiciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>remember</code> para crear un estado <code>contador</code> que se mantiene entre recomposiciones.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remembersaveable","title":"Uso de rememberSaveable","text":"<p>La funci\u00f3n <code>rememberSaveable</code> de Compose te permite crear un estado que se mantiene entre configuraciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = rememberSaveable { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>rememberSaveable</code> para crear un estado <code>contador</code> que se mantiene entre configuraciones.</p> <p>Remember vs RememberSaveable</p> <p>La diferencia entre <code>remember</code> y <code>rememberSaveable</code> es que <code>rememberSaveable</code> guarda el estado en el <code>Bundle</code> de la actividad para que se pueda restaurar despu\u00e9s de una recreaci\u00f3n de la actividad.</p> <p>Esto es \u00fatil para guardar el estado de la aplicaci\u00f3n cuando la actividad se destruye y se vuelve a crear, por ejemplo, al girar la pantalla.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-derivedstateof","title":"Uso de derivedStateOf","text":"<p>La funci\u00f3n <code>derivedStateOf</code> de Compose te permite crear un estado derivado a partir de otros estados.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val doble = derivedStateOf { contador.value * 2 }\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contador.value}, Doble: ${doble.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>derivedStateOf</code> para crear un estado <code>doble</code> que es el doble del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-kotlin","title":"Flows en Kotlin","text":"<p>En Kotlin, un <code>Flow</code> es una secuencia de valores que se emiten de forma as\u00edncrona y reactiva. Los <code>Flow</code> te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla.</p> <p>Puedes crear un <code>Flow</code> utilizando la funci\u00f3n <code>flowOf()</code> de Kotlin.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Flow</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-flows","title":"Observaci\u00f3n de Flows","text":"<p>Puedes observar un <code>Flow</code> utilizando la funci\u00f3n <code>collect()</code> de Kotlin.</p> <pre><code>numeros.collect { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se observa el <code>Flow</code> <code>numeros</code> y se imprime cada valor que se emite.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#transformacion-de-flows","title":"Transformaci\u00f3n de Flows","text":"<p>Puedes transformar un <code>Flow</code> utilizando operadores como <code>map</code>, <code>filter</code>, <code>flatMap</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan los operadores <code>map</code> y <code>filter</code> para transformar el <code>Flow</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-jetpack-compose","title":"Flows en Jetpack Compose","text":"<p>En Jetpack Compose, puedes utilizar Flows para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <p>Puedes convertir un <code>Flow</code> en un estado observable utilizando la funci\u00f3n <code>collectAsState()</code> de Compose.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\nval numerosState = numeros.collectAsState()\n</code></pre> <p>En el ejemplo anterior, se convierte el <code>Flow</code> <code>numeros</code> en un estado observable <code>numerosState</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#elevacion-del-estado","title":"Elevaci\u00f3n del estado","text":"<p>En Jetpack Compose, puedes elevar el estado de un componente para compartirlo con otros componentes.</p> <p>Esto te permite gestionar el estado de tu aplicaci\u00f3n de forma centralizada y compartirlo entre diferentes partes de tu interfaz de usuario.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    ContadorBoton(contador)\n    ContadorTexto(contador)\n}\n\n@Composable\nfun ContadorBoton(contador: MutableState&lt;Int&gt;) {\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Incrementar\")\n    }\n}\n\n@Composable\nfun ContadorTexto(contador: MutableState&lt;Int&gt;) {\n    Text(text = \"Contador: ${contador.value}\")\n}\n</code></pre> <p>En el ejemplo anterior, se eleva el estado <code>contador</code> del componente <code>Contador</code> para compartirlo con los componentes <code>ContadorBoton</code> y <code>ContadorTexto</code>.</p> <p>De esta forma, el estado <code>contador</code> se gestiona de forma centralizada en el componente <code>Contador</code> y se comparte con los componentes hijos. Y ambos se recomponen cuando el estado cambia.</p> <p>Esto tambi\u00e9n facilita la reutilizaci\u00f3n de los componentes y la separaci\u00f3n de las preocupaciones en tu aplicaci\u00f3n. Adem\u00e1s de facilitar la prueba y el mantenimiento del c\u00f3digo.</p> <p>!!! info \"Elevaci\u00f3n del estado vs. Inyecci\u00f3n de dependencias]     La elevaci\u00f3n del estado es una t\u00e9cnica com\u00fan en Jetpack Compose para compartir el estado entre componentes.</p> <pre><code>Otra t\u00e9cnica com\u00fan es la inyecci\u00f3n de dependencias, que consiste en pasar el estado como argumento a los componentes que lo necesitan.\n\nAmbas t\u00e9cnicas tienen sus ventajas y desventajas, y la elecci\u00f3n entre ellas depende del dise\u00f1o y la arquitectura de tu aplicaci\u00f3n.\n</code></pre>"},{"location":"temas/00-android/00-compose/22-state-management.html#conclusion","title":"Conclusi\u00f3n","text":"<p>La gesti\u00f3n de estado es una parte fundamental de la arquitectura de tu aplicaci\u00f3n en Jetpack Compose.</p> <p>Con Compose, puedes definir, observar y actualizar el estado de tu aplicaci\u00f3n de forma reactiva y declarativa.</p> <p>Los Flows te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla en Kotlin.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-de-gestion-del-estado-basica-en-una-app-de-contador","title":"Ejemplo de gesti\u00f3n del estado b\u00e1sica en una app de Contador","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</p> </li> <li> <p>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.   </p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> </ul>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html","title":"Listas","text":""},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#listas-en-compose","title":"Listas en Compose","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos utilizando los componentes <code>LazyColumn</code> y <code>LazyRow</code>. Estos componentes te permiten mostrar una lista de elementos de forma eficiente y reactiva.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazycolumn","title":"LazyColumn","text":"<p>El componente <code>LazyColumn</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyColumn</code> para mostrar una lista de elementos verticales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaVertical() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaVertical</code> que muestra una lista de 100 elementos verticales utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p> <p>Video Listas y LazyColumn</p> <p></p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazyrow","title":"LazyRow","text":"<p>El componente <code>LazyRow</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyRow</code> para mostrar una lista de elementos horizontales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaHorizontal() {\n    LazyRow {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaHorizontal</code> que muestra una lista de 100 elementos horizontales utilizando <code>LazyRow</code>. El m\u00e9todo <code>items()</code> de <code>LazyRow</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#scroll-infinito","title":"Scroll infinito","text":"<p>Puedes implementar el scroll infinito en las listas de Compose utilizando el m\u00e9todo <code>items()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando una lista infinita como argumento. Esto te permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ScrollInfinito() {\n    val elementos = remember { mutableStateListOf&lt;String&gt;() }\n\n    LazyColumn {\n        items(elementos) { elemento -&gt;\n            Text(text = elemento)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ScrollInfinito</code> que muestra una lista de elementos utilizando <code>LazyColumn</code>. Se utiliza un estado mutable <code>mutableStateListOf</code> para almacenar los elementos de la lista, y se pasa esta lista como argumento al m\u00e9todo <code>items()</code> de <code>LazyColumn</code>. Esto permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El manejo del scroll infinito en Compose es similar al manejo del scroll infinito en otras bibliotecas de UI, como RecyclerView en Android. Puedes utilizar t\u00e9cnicas como la paginaci\u00f3n y la carga perezosa para cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El estado mutable <code>mutableStateListOf</code> se utiliza para almacenar los elementos de la lista y notificar a Compose cuando se actualizan los elementos. Esto permite que Compose vuelva a renderizar la lista con los nuevos elementos.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#elementos-personalizados","title":"Elementos personalizados","text":"<p>Puedes utilizar elementos personalizados en las listas de Compose para mostrar elementos m\u00e1s complejos. Para ello, puedes utilizar el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasar un componente personalizado como argumento.</p> <pre><code>@Composable\nfun ListaPersonalizada() {\n    LazyColumn {\n        items(100) { index -&gt;\n            ElementoPersonalizado(index)\n        }\n    }\n}\n\n@Composable\nfun ElementoPersonalizado(index: Int) {\n    Text(text = \"Elemento $index\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaPersonalizada</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices, y se pasa un componente personalizado <code>ElementoPersonalizado</code> como argumento.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#escuchadores-de-eventos","title":"Escuchadores de eventos","text":"<p>Puedes a\u00f1adir escuchadores de eventos a los elementos de la lista para responder a las interacciones del usuario. Por ejemplo, puedes a\u00f1adir un escuchador de clics a un elemento de la lista para realizar una acci\u00f3n cuando el usuario haga clic en \u00e9l.</p> <pre><code>@Composable\nfun ListaConClics() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(\n                text = \"Elemento $index\",\n                modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ }\n            )\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConClics</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un escuchador de clics al elemento de la lista utilizando el modificador <code>clickable</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#separadores","title":"Separadores","text":"<p>Puedes a\u00f1adir separadores entre los elementos de la lista utilizando el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando un componente separador como argumento.</p> <pre><code>@Composable\nfun ListaConSeparadores() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Column {\n                ElementoPersonalizado(index)\n                Divider()\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConSeparadores</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un separador <code>Divider()</code> entre cada elemento de la lista.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#filtrado-y-ordenacion","title":"Filtrado y ordenaci\u00f3n","text":"<p>Puedes filtrar y ordenar los elementos de la lista utilizando funciones de extensi\u00f3n como <code>filter()</code> y <code>sortedBy()</code>. Estas funciones te permiten realizar operaciones comunes con las listas de forma sencilla y eficiente.</p> <pre><code>@Composable\nfun ListaFiltrada() {\n    val numeros = (0..100).toList()\n\n    LazyColumn {\n        items(numeros.filter { it % 2 == 0 }) { numero -&gt;\n            Text(text = \"N\u00famero $numero\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaFiltrada</code> que muestra una lista de n\u00fameros pares del 0 al 100 utilizando <code>LazyColumn</code>. Se filtran los n\u00fameros pares utilizando la funci\u00f3n de extensi\u00f3n <code>filter()</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#porque-usar-lazycolumn-y-lazyrow-en-lugar-de-column-y-row","title":"Porqu\u00e9 usar LazyColumn y LazyRow en lugar de Column y Row","text":"<p><code>LazyColumn</code> y <code>LazyRow</code> son componentes optimizados para mostrar listas de elementos de forma eficiente y reactiva. A diferencia de <code>Column</code> y <code>Row</code>, que renderizan todos los elementos de la lista de forma inmediata, <code>LazyColumn</code> y <code>LazyRow</code> renderizan solo los elementos visibles en la pantalla y los elementos que est\u00e1n cerca de la zona visible.</p> <p>Esto hace que <code>LazyColumn</code> y <code>LazyRow</code> sean m\u00e1s eficientes en t\u00e9rminos de rendimiento y consumo de recursos, especialmente cuando se trabaja con listas grandes o infinitas.</p> <p>Por lo tanto, es recomendable utilizar <code>LazyColumn</code> y <code>LazyRow</code> para mostrar listas de elementos en Jetpack Compose, ya que proporcionan una experiencia de usuario m\u00e1s fluida y eficiente.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#cuadriculsa-o-grids","title":"Cuadr\u00edculsa o Grids","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos en forma de cuadr\u00edculas utilizando el componente <code>LazyVerticalGrid</code> o <code>LazyHorizontalGrid</code>. Estos componentes te permiten mostrar una cuadr\u00edcula de elementos de forma eficiente y reactiva.</p> <pre><code>@Composable\nfun CuadriculaVertical() {\n    LazyVerticalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaVertical</code> que muestra una cuadr\u00edcula de 100 elementos en 3 columnas utilizando <code>LazyVerticalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyVerticalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p> <pre><code>@Composable\nfun CuadriculaHorizontal() {\n    LazyHorizontalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaHorizontal</code> que muestra una cuadr\u00edcula de 100 elementos en 3 filas utilizando <code>LazyHorizontalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyHorizontalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html","title":"Navegaci\u00f3n Rutas","text":""},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-y-rutas-en-jetpack-compose","title":"Navegaci\u00f3n y rutas en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#configuracion-de-la-navegacion","title":"Configuraci\u00f3n de la navegaci\u00f3n","text":"<p>Para administrar la navegaci\u00f3n en Jetpack Compose, necesitas agregar la dependencia de <code>navigation-compose</code> a tu archivo <code>build.gradle</code> y definir las rutas y destinos de tu aplicaci\u00f3n en un archivo de configuraci\u00f3n de navegaci\u00f3n.</p> build.gradle.kts<pre><code>dependencies {\n    val nav_version = \"2.8.5\"\n\n    implementation(\"androidx.navigation:navigation-compose:$nav_version\")\n}\n</code></pre> <p>Video ejemplo de uso de Navegaci\u00f3n</p> <p></p> <p>Video ejemplo de Splash Screen personalizada</p> <p></p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-en-jetpack-compose","title":"Navegaci\u00f3n en Jetpack Compose","text":"<p>En Jetpack Compose, puedes implementar la navegaci\u00f3n entre pantallas utilizando el componente <code>NavHost</code>. <code>NavHost</code> es un contenedor que muestra las pantallas de tu aplicaci\u00f3n en funci\u00f3n de las rutas definidas.</p> <pre><code>@Composable\nfun MyApp() {\n    val navController = rememberNavController()\n\n    NavHost(navController = navController, startDestination = \"pantalla1\") {\n        composable(\"pantalla1\") {\n            Pantalla1()\n        }\n        composable(\"pantalla2\") {\n            Pantalla2()\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MyApp</code> que utiliza <code>NavHost</code> para implementar la navegaci\u00f3n entre dos pantallas: <code>Pantalla1</code> y <code>Pantalla2</code>. <code>NavHost</code> toma un <code>NavController</code> como argumento y define las rutas de las pantallas utilizando el m\u00e9todo <code>composable</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#definicion-de-rutas","title":"Definici\u00f3n de rutas","text":"<p>Puedes definir las rutas de tu aplicaci\u00f3n utilizando el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Cada ruta tiene un nombre \u00fanico que se utiliza para identificar la pantalla correspondiente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1()\n    }\n    composable(\"pantalla2\") {\n        Pantalla2()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se definen dos rutas: <code>pantalla1</code> y <code>pantalla2</code>, que corresponden a las pantallas <code>Pantalla1</code> y <code>Pantalla2</code>, respectivamente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas","title":"Navegaci\u00f3n entre pantallas","text":"<p>Puedes navegar entre pantallas en Jetpack Compose utilizando el <code>NavController</code> y el m\u00e9todo <code>navigate</code>.</p> <pre><code>Button(onClick = { navController.navigate(\"pantalla2\") }) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>navigate</code> del <code>NavController</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#paso-de-datos-entre-pantallas","title":"Paso de datos entre pantallas","text":"<p>Puedes pasar datos entre pantallas en Jetpack Compose utilizando el m\u00e9todo <code>navigate</code> y el argumento <code>arguments</code>.</p> <pre><code>Button(onClick = {\n    navController.navigate(\"pantalla2\") {\n        launchSingleTop = true\n        popUpTo(\"pantalla1\") { inclusive = true }\n        arguments = bundleOf(\"dato\" to \"Hola, mundo!\")\n    }\n}) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> y pasa el dato <code>\"Hola, mundo!\"</code> como argumento.</p> <p>El argumento <code>arguments</code> se utiliza para pasar datos entre pantallas. Puedes utilizar <code>bundleOf</code> para crear un <code>Bundle</code> con los datos que deseas pasar.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recuperacion-de-datos-en-la-pantalla-de-destino","title":"Recuperaci\u00f3n de datos en la pantalla de destino","text":"<p>Puedes recuperar los datos pasados como argumentos en la pantalla de destino utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p> <pre><code>val navBackStackEntry by navController.currentBackStackEntryAsState()\nval dato = navBackStackEntry?.arguments?.getString(\"dato\")\n</code></pre> <p>En el ejemplo anterior, se recupera el dato pasado como argumento en la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas-usando-lambdas","title":"Navegaci\u00f3n entre pantallas usando lambdas","text":"<p>En Jetpack Compose, puedes utilizar lambdas para definir la navegaci\u00f3n entre pantallas de forma m\u00e1s concisa.</p> <p>La definici\u00f3n de estas lambdas puede hacerse en el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Esto nos ayuda a mantener un c\u00f3digo m\u00e1s limpio y legible.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1 {\n            navController.navigate(\"pantalla2\")\n        }\n    }\n    composable(\"pantalla2\") {\n        Pantalla2 {\n            navController.navigate(\"pantalla1\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define la navegaci\u00f3n entre las pantallas <code>Pantalla1</code> y <code>Pantalla2</code> utilizando lambdas en el m\u00e9todo <code>composable</code> de <code>NavHost</code>.</p> <p>De esta forma, al definir la navegaci\u00f3n en el propio componente, se mantiene un c\u00f3digo m\u00e1s limpio y legible.</p> <p>Por ejemplo, el composable <code>Pantalla1</code> recibe una lambda que navega a la pantalla <code>Pantalla2</code>, y el composable <code>Pantalla2</code> recibe una lambda que navega a la pantalla <code>Pantalla1</code>.</p> <pre><code>@Composable\nfun Pantalla1(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 2\")\n    }\n}\n\n@Composable\nfun Pantalla2(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 1\")\n    }\n}\n</code></pre> <p>En los componibles <code>Pantalla1</code> y <code>Pantalla2</code>, se define un bot\u00f3n que, al hacer clic en \u00e9l, ejecuta la lambda recibida como argumento, que navega a la pantalla correspondiente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#para-la-definicion-de-los-nombres-de-las-pantallas","title":"Para la definici\u00f3n de los nombres de las pantallas","text":"<p>Es importante definir nombres significativos para las pantallas de tu aplicaci\u00f3n. Los nombres de las pantallas deben reflejar claramente el prop\u00f3sito y la funcionalidad de cada pantalla.</p> <p>Por ejemplo, si tienes una pantalla de inicio y una pantalla de perfil, puedes nombrarlas <code>pantallaInicio</code> y <code>pantallaPerfil</code>, respectivamente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantallaInicio\") {\n    composable(\"pantallaInicio\") {\n        PantallaInicio()\n    }\n    composable(\"pantallaPerfil\") {\n        PantallaPerfil()\n    }\n}\n</code></pre> <p>Estos nombres pueden definirse en un archivo de constantes o en un objeto de compa\u00f1ero para mantener un c\u00f3digo m\u00e1s organizado y legible. Existen varias opciones para definir los nombres de las pantallas, como objetos de compa\u00f1ero, constantes o enumeraciones. </p> <p> </p><pre><code>object Rutas {\n    const val PANTALLA_INICIO = \"pantallaInicio\"\n    const val PANTALLA_PERFIL = \"pantallaPerfil\"\n}\n</code></pre> <pre><code>const val PANTALLA_INICIO = \"pantallaInicio\"\nconst val PANTALLA_PERFIL = \"pantallaPerfil\"\n</code></pre> <pre><code>enum class Rutas {\n    PANTALLA_INICIO,\n    PANTALLA_PERFIL\n}\n</code></pre> <pre><code>sealed class Rutas {\n    object PANTALLA_INICIO : Rutas()\n    object PANTALLA_PERFIL : Rutas()\n}\n</code></pre> <p></p> <p>En el ejemplo anterior, se definen los nombres de las pantallas <code>PANTALLA_INICIO</code> y <code>PANTALLA_PERFIL</code> utilizando un objeto an\u00f3nimo, constantes, enumeraciones y clases selladas.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose Navigation: La documentaci\u00f3n oficial de Jetpack Compose Navigation, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar la navegaci\u00f3n en Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio navegaci\u00f3n - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/00-compose/25-material-design.html","title":"Material Design","text":""},{"location":"temas/00-android/00-compose/25-material-design.html#material-design-en-jetpack-compose","title":"Material Design en Jetpack Compose","text":"<p>Material Design es un sistema de dise\u00f1o desarrollado por Google que ayuda a los desarrolladores a crear interfaces de usuario atractivas y coherentes en aplicaciones Android. Con Jetpack Compose, puedes implementar los principios de Material Design de forma sencilla y eficiente.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#temas-y-estilos","title":"Temas y estilos","text":"<p>Jetpack Compose incluye un conjunto de widgets y estilos basados en Material Design que puedes utilizar para crear interfaces de usuario modernas y atractivas. Puedes personalizar los colores, tipograf\u00edas y formas de tus componentes para adaptarlos a la identidad visual de tu aplicaci\u00f3n.</p> <pre><code>@Composable\nfun MiApp() {\n    MaterialTheme {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MiApp</code> que utiliza <code>MaterialTheme</code> para aplicar los estilos de Material Design a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#widgets-de-material-design","title":"Widgets de Material Design","text":"<p>Jetpack Compose incluye una amplia variedad de widgets de Material Design que puedes utilizar para crear interfaces de usuario complejas y atractivas. Algunos de los widgets m\u00e1s comunes son:</p> <ul> <li><code>Button</code>: Un bot\u00f3n interactivo que el usuario puede pulsar para realizar una acci\u00f3n.</li> <li><code>TextField</code>: Un campo de texto que el usuario puede utilizar para introducir texto.</li> <li><code>Checkbox</code>: Una casilla de verificaci\u00f3n que el usuario puede marcar o desmarcar.</li> <li><code>RadioButton</code>: Un bot\u00f3n de opci\u00f3n que el usuario puede seleccionar entre varias opciones.</li> <li><code>Switch</code>: Un interruptor que el usuario puede activar o desactivar.</li> </ul> <p>Puedes utilizar estos widgets y muchos m\u00e1s para crear interfaces de usuario modernas y atractivas en tus aplicaciones Android con Jetpack Compose.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#personalizacion-de-estilos","title":"Personalizaci\u00f3n de estilos","text":"<p>Puedes personalizar los estilos de Material Design en Jetpack Compose para adaptarlos a la identidad visual de tu aplicaci\u00f3n. Puedes definir tus propios temas y estilos utilizando el componente <code>MaterialTheme</code> y los objetos <code>Typography</code>, <code>Colors</code> y <code>Shapes</code>.</p> <pre><code>val MiTema = lightColors(\n    primary = Color(0xFF6200EE),\n    primaryVariant = Color(0xFF3700B3),\n    secondary = Color(0xFF03DAC6)\n)\n\n@Composable\nfun MiApp() {\n    MaterialTheme(colors = MiTema) {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado <code>MiTema</code> con colores personalizados y se utiliza <code>MaterialTheme</code> para aplicar este tema a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Material Design: La documentaci\u00f3n oficial de Material Design, que incluye gu\u00edas, tutoriales y ejemplos para aprender a dise\u00f1ar interfaces de usuario con Material Design.</p> </li> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a crear interfaces de usuario con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/00-android/00-kotlin/index.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/index.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html","title":"01 sobre kotlin","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html","title":"Variables","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-variables-y-datos-en-kotlin","title":"Tipos de variables y datos en Kotlin","text":"<p>En Kotlin las variables pueden declararse de dos formas, de forma expl\u00edcita o de forma impl\u00edcita. En el caso de las variables expl\u00edcitas, se debe indicar el tipo de dato que almacenar\u00e1 la variable, mientras que en las variables impl\u00edcitas, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <p>Sobre la inferencia de tipos</p> <p>Que el tipo de dato se infiera autom\u00e1ticamente no quiere decir que Kotlin sea un lenguaje de tipado din\u00e1mico, ya que una vez que se asigna un tipo de dato a una variable, no se puede cambiar.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-explicitas","title":"Variables expl\u00edcitas","text":"<p>Para declarar una variable de forma expl\u00edcita en Kotlin, se debe indicar el tipo de dato que almacenar\u00e1 la variable seguido del nombre de la variable y opcionalmente de su valor inicial.</p> <pre><code>val nombre: String = \"Ejemplo\"\nval edad: Int = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma expl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-implicitas","title":"Variables impl\u00edcitas","text":"<p>Para declarar una variable de forma impl\u00edcita en Kotlin, se debe utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre de la variable y opcionalmente de su valor inicial. En este caso, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <pre><code>val nombre = \"Ejemplo\"\nval edad = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma impl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-primitivos","title":"Tipos de datos primitivos","text":"<p>En Kotlin, los tipos de datos primitivos son los mismos que en Java, pero con algunas diferencias en la forma en que se declaran.</p> <ul> <li>Byte: Almacena n\u00fameros enteros de 8 bits.</li> <li>Short: Almacena n\u00fameros enteros de 16 bits.</li> <li>Int: Almacena n\u00fameros enteros de 32 bits.</li> <li>Long: Almacena n\u00fameros enteros de 64 bits.</li> <li>Float: Almacena n\u00fameros de punto flotante de 32 bits.</li> <li>Double: Almacena n\u00fameros de punto flotante de 64 bits.</li> <li>Char: Almacena caracteres Unicode de 16 bits.</li> <li>Boolean: Almacena valores booleanos (<code>true</code> o <code>false</code>).</li> </ul> <pre><code>val entero: Int = 10\nval flotante: Float = 10.5f\nval caracter: Char = 'A'\nval booleano: Boolean = true\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-compuestos","title":"Tipos de datos compuestos","text":"<p>Adem\u00e1s de los tipos de datos primitivos, Kotlin tambi\u00e9n tiene tipos de datos compuestos que permiten almacenar colecciones de datos.</p> <ul> <li>Array: Almacena una colecci\u00f3n de elementos del mismo tipo.</li> <li>List: Almacena una colecci\u00f3n de elementos ordenados.</li> <li>Set: Almacena una colecci\u00f3n de elementos \u00fanicos.</li> <li>Map: Almacena una colecci\u00f3n de pares clave-valor.</li> </ul> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\nval nombres = listOf(\"Juan\", \"Mar\u00eda\", \"Pedro\")\nval colores = setOf(\"Rojo\", \"Verde\", \"Azul\")\nval edades = mapOf(\"Juan\" to 25, \"Mar\u00eda\" to 30, \"Pedro\" to 35)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#conversion-de-tipos","title":"Conversi\u00f3n de tipos","text":"<p>En Kotlin, la conversi\u00f3n de tipos se realiza de forma segura y expl\u00edcita utilizando funciones espec\u00edficas para cada tipo de dato.</p> <pre><code>val numero: Int = 10\nval texto: String = numero.toString()\n\nval texto: String = \"10\"\nval numero: Int = texto.toInt()\n</code></pre> <p>En el primer ejemplo, se convierte un n\u00famero entero a una cadena de texto utilizando la funci\u00f3n <code>toString()</code>. En el segundo ejemplo, se convierte una cadena de texto a un n\u00famero entero utilizando la funci\u00f3n <code>toInt()</code>.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-mutables-e-inmutables","title":"Sobre las variables mutables e inmutables","text":"<p>En Kotlin, las variables se pueden declarar como <code>val</code> (inmutables) o <code>var</code> (mutables). Las variables inmutables no pueden cambiar su valor una vez asignado, mientras que las variables mutables pueden cambiar su valor en cualquier momento.</p> <pre><code>val nombre: String = \"Ejemplo\" // Variable inmutable\nvar edad: Int = 25 // Variable mutable\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es inmutable, por lo que su valor no puede cambiar una vez asignado. La variable <code>edad</code>, en cambio, es mutable, por lo que su valor puede cambiar en cualquier momento.    </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-la-mutabilidad-y-la-inmutabilidad","title":"Sobre la mutabilidad y la inmutabilidad","text":"<p>La inmutabilidad es una caracter\u00edstica importante en Kotlin, ya que ayuda a prevenir los errores de programaci\u00f3n al evitar que los valores de las variables cambien de forma inesperada. Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s seguro y predecible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.   </p> <p>Cu\u00e1ndo trabajamos con listas o arrays, podemos modificar los elementos de la lista, pero no podemos cambiar la referencia de la lista. </p> <pre><code>val lista = mutableListOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Modifica el elemento en la posici\u00f3n 0\nlista = mutableListOf(6, 7, 8, 9, 10) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se modifica el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero no se puede cambiar la referencia de la lista. Si se intenta asignar una nueva lista a la variable <code>lista</code>, se produce un error de compilaci\u00f3n.</p> <p>Podemos ver tambi\u00e9n un ejemplo de lista mutable pero cuyo contenido no puede ser modificado.</p> <pre><code>val lista = listOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta modificar el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero como la lista es inmutable, se produce un error de compilaci\u00f3n.</p> <p>Esto nos deja claro que la inmutabilidad no solo se refiere a la variable en s\u00ed, sino tambi\u00e9n a los elementos que contiene la variable.</p> <p>Podemos entonces tener cuatro situaciones posibles:</p> <ul> <li>Variable inmutable y elementos inmutables: No se puede cambiar ni la variable ni los elementos.</li> <li>Variable inmutable y elementos mutables: No se puede cambiar la variable, pero s\u00ed los elementos.</li> <li>Variable mutable y elementos inmutables: Se puede cambiar la variable, pero no los elementos.</li> <li>Variable mutable y elementos mutables: Se puede cambiar tanto la variable como los elementos.</li> </ul> <p>Las variables inmutables y la programaci\u00f3n funcional</p> <p>Las variables inmutables son una caracter\u00edstica fundamental de la programaci\u00f3n funcional, ya que permiten escribir c\u00f3digo m\u00e1s seguro y predecible al evitar los efectos secundarios y las mutaciones de estado. </p> <p>Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s conciso, legible y mantenible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-nulas","title":"Sobre las variables nulas","text":"<p>En Kotlin, las variables pueden ser nulas si se declara con el operador <code>?</code>. Esto permite que una variable pueda contener un valor nulo en lugar de un valor no nulo.</p> <pre><code>val nombre: String? = null\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> se declara como nula utilizando el operador <code>?</code>. Esto significa que la variable <code>nombre</code> puede contener un valor nulo en lugar de un valor no nulo.</p> <p>Sobre la seguridad de nulos en Kotlin</p> <p>El manejo de nulos en Kotlin es una de las caracter\u00edsticas m\u00e1s importantes del lenguaje, ya que ayuda a prevenir los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n.</p> <p>M\u00e1s adelante veremos c\u00f3mo manejar los valores nulos de forma segura en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-declaradas-como-const","title":"Sobre las variables declaradas como const","text":"<p>En Kotlin, las variables se pueden declarar como <code>const</code> para indicar que su valor es constante en tiempo de compilaci\u00f3n. Las variables <code>const</code> deben ser de tipo <code>val</code> y deben estar en el \u00e1mbito de un objeto o de un compa\u00f1ero de clase.</p> <pre><code>const val PI = 3.14159\n</code></pre> <p>En el ejemplo anterior, se declara una constante <code>PI</code> con un valor de <code>3.14159</code>. Esta constante es accesible en tiempo de compilaci\u00f3n y su valor no puede cambiar en tiempo de ejecuci\u00f3n.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-strings-en-kotlin","title":"Sobre las Strings en Kotlin","text":"<p>En Kotlin, las cadenas de texto se pueden declarar utilizando comillas simples (<code>'</code>) o comillas dobles (<code>\"</code>). Las cadenas de texto declaradas con comillas simples son de tipo <code>Char</code>, mientras que las declaradas con comillas dobles son de tipo <code>String</code>.</p> <pre><code>val caracter: Char = 'A'\nval texto: String = \"Ejemplo\"\n</code></pre> <p>En el ejemplo anterior, se declara una variable <code>caracter</code> de tipo <code>Char</code> con el valor <code>'A'</code> y una variable <code>texto</code> de tipo <code>String</code> con el valor <code>\"Ejemplo\"</code>.</p> <p>Las Strings en Kotlin se pueden comparar utilizando el operador <code>==</code> para comparar el contenido de las cadenas y el operador <code>===</code> para comparar las referencias de las cadenas.</p> <pre><code>val texto1 = \"Hola\"\nval texto2 = \"Hola\"\n\nprintln(texto1 == texto2) // true\nprintln(texto1 === texto2) // true\n</code></pre> <p>En el ejemplo anterior, se comparan dos cadenas de texto <code>texto1</code> y <code>texto2</code> utilizando los operadores <code>==</code> y <code>===</code>. Ambas comparaciones devuelven <code>true</code> ya que las cadenas son iguales en contenido y referencia. </p> <p>A diferencia de Java, en Kotlin las cadenas de texto son inmutables, lo que significa que una vez que se crea una cadena de texto, no se puede modificar su contenido. Para modificar una cadena de texto en Kotlin, se debe crear una nueva cadena con el contenido modificado.</p> <pre><code>val texto = \"Hola\"\nval nuevoTexto = texto + \" Mundo\"\n</code></pre> <p>En el ejemplo anterior, se crea una nueva cadena de texto <code>nuevoTexto</code> concatenando la cadena <code>texto</code> con la cadena <code>\" Mundo\"</code>. La cadena <code>texto</code> no se modifica, sino que se crea una nueva cadena con el contenido modificado.    </p> <p>Sin embargo, si comparamos una string con un caracter, Kotlin no permite la comparaci\u00f3n directa, ya que son tipos de datos diferentes.</p> <pre><code>val texto = \"H\"\nval caracter = 'H'\n\nprintln(texto == caracter) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta comparar una cadena de texto <code>texto</code> con un caracter <code>caracter</code>, lo cual produce un error de compilaci\u00f3n ya que los tipos de datos son diferentes.   </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html","title":"Expresiones vs Sentencias","text":""},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones-vs-sentencias","title":"Expresiones vs sentencias","text":"<p>En Kotlin, las expresiones y las sentencias son dos conceptos fundamentales que se utilizan para definir el flujo de control y la l\u00f3gica de un programa. Aunque ambos se utilizan para realizar operaciones y tomar decisiones en un programa, existen diferencias importantes entre ellos que es importante comprender.    </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones","title":"Expresiones","text":"<p>En Kotlin, una expresi\u00f3n es una combinaci\u00f3n de valores, variables, operadores y funciones que se eval\u00faa para producir un resultado. Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor. </p> <p>Las expresiones en Kotlin pueden tener un valor de retorno, lo que significa que pueden ser utilizadas en cualquier lugar donde se espere un valor, como en la inicializaci\u00f3n de una variable, en una sentencia de control de flujo o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nval resultado = numero * 2\n</code></pre> <p>En el ejemplo anterior, la expresi\u00f3n <code>numero * 2</code> se eval\u00faa para producir un resultado que se asigna a la variable <code>resultado</code>. La expresi\u00f3n <code>numero * 2</code> es una expresi\u00f3n aritm\u00e9tica que multiplica el valor de la variable <code>numero</code> por <code>2</code> y devuelve el resultado.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#sentencias","title":"Sentencias","text":"<p>En Kotlin, una sentencia es una instrucci\u00f3n que realiza una acci\u00f3n en un programa. Las sentencias pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo que toma decisiones basadas en condiciones.    </p> <p>Las sentencias en Kotlin no tienen un valor de retorno, lo que significa que no pueden ser utilizadas en lugares donde se espere un valor, como en la inicializaci\u00f3n de una variable o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nif (numero &gt; 0) {\n    println(\"El n\u00famero es positivo\")\n} else {\n    println(\"El n\u00famero es negativo\")\n}\n</code></pre> <p>En el ejemplo anterior, la sentencia <code>if (numero &gt; 0) { ... } else { ... }</code> es una estructura de control de flujo que toma una decisi\u00f3n basada en la condici\u00f3n <code>numero &gt; 0</code>. La sentencia <code>if</code> eval\u00faa la condici\u00f3n y ejecuta el bloque de c\u00f3digo correspondiente si la condici\u00f3n es verdadera.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#diferencias-entre-expresiones-y-sentencias","title":"Diferencias entre expresiones y sentencias","text":"<p>Las principales diferencias entre expresiones y sentencias en Kotlin son las siguientes:</p> <ul> <li> <p>Valor de retorno: Las expresiones tienen un valor de retorno y pueden ser utilizadas en lugares donde se espere un valor, mientras que las sentencias no tienen un valor de retorno y no pueden ser utilizadas en lugares donde se espere un valor.</p> </li> <li> <p>Complejidad: Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor, mientras que las sentencias realizan acciones en un programa y pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo.</p> </li> <li> <p>Uso: Las expresiones se utilizan para realizar operaciones y producir resultados, mientras que las sentencias se utilizan para realizar acciones en un programa, como asignar valores a variables, tomar decisiones basadas en condiciones o repetir bloques de c\u00f3digo.</p> </li> </ul> <p>La ventaja de las expresiones en la programaci\u00f3n funcional</p> <p>En la programaci\u00f3n funcional, se fomenta el uso de expresiones en lugar de sentencias, ya que las expresiones son m\u00e1s concisas, legibles y f\u00e1ciles de entender. </p> <p>Al utilizar expresiones en lugar de sentencias, se puede escribir menos c\u00f3digo y hacer m\u00e1s cosas.</p> <p>Esto es especialmente \u00fatil en Kotlin, que es un lenguaje de programaci\u00f3n funcional que fomenta el uso de expresiones para realizar operaciones y producir resultados de forma concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#ejemplo-de-una-funcion-que-usa-sentencias-statement-y-expresiones-expression","title":"Ejemplo de una funci\u00f3n que usa sentencias (statement) y expresiones (expression)","text":"<p>Pongamos el ejemplo de una funci\u00f3n que dictamina si una persona es mayor de edad o no. </p> Versi\u00f3n con sentencias<pre><code>fun esMayorDeEdad(edad: Int): Boolean {\n    if (edad &gt;= 18) {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza sentencias para tomar una decisi\u00f3n basada en la edad de la persona y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> Versi\u00f3n con expresiones<pre><code>fun esMayorDeEdad(edad: Int): Boolean = edad &gt;= 18\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza una expresi\u00f3n para evaluar si la edad de la persona es mayor o igual a <code>18</code> y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> <p>C\u00f3mo se puede observar, la versi\u00f3n con expresiones es m\u00e1s concisa y legible que la versi\u00f3n con sentencias, ya que utiliza una expresi\u00f3n para realizar la misma operaci\u00f3n de forma m\u00e1s eficiente y clara.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html","title":"Funciones y lambdas","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-y-lambdas-en-kotlin","title":"Funciones y lambdas en Kotlin","text":"<p>En Kotlin, las funciones son ciudadanos de primera clase, lo que significa que puedes tratarlas como cualquier otro tipo de dato, como un <code>Int</code> o un <code>String</code>. Esto te permite pasar funciones como argumentos a otras funciones, devolver funciones de otras funciones y almacenar funciones en variables. </p> <p>Las funciones en Kotlin se definen utilizando la palabra clave <code>fun</code>, seguida del nombre de la funci\u00f3n, los par\u00e1metros de entrada y el tipo de retorno. </p> <pre><code>fun suma(a: Int, b: Int): Int {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n suma los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-orden-superior","title":"Funciones de orden superior","text":"<p>En Kotlin, puedes pasar funciones como argumentos a otras funciones. Estas funciones se conocen como funciones de orden superior y te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable. </p> <pre><code>fun operacion(a: Int, b: Int, funcion: (Int, Int) -&gt; Int): Int {\n    return funcion(a, b)\n}\n\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun resta(a: Int, b: Int): Int {\n    return a - b\n}\n\nval resultadoSuma = operacion(10, 5, ::suma)\nval resultadoResta = operacion(10, 5, ::resta)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>operacion</code> que toma dos par\u00e1metros de tipo <code>Int</code> y una funci\u00f3n de orden superior que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n <code>operacion</code> aplica la funci\u00f3n de orden superior a los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda","title":"Funciones lambda","text":"<p>En Kotlin, puedes definir funciones an\u00f3nimas conocidas como funciones lambda. Las funciones lambda son funciones sin nombre que puedes pasar como argumentos a otras funciones. </p> <pre><code>val suma = { a: Int, b: Int -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n\nval resultadoSuma = suma(10, 5)\nval resultadoResta = resta(10, 5)\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. Las funciones lambda se asignan a variables y se pueden utilizar como cualquier otra funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#los-parametros-en-kotlin","title":"Los par\u00e1metros en Kotlin","text":"<p>A diferencia de Java, en Kotlin los par\u00e1metros de una funci\u00f3n son inmutables por defecto, lo que significa que no se pueden modificar dentro de la funci\u00f3n. Si necesitas modificar un par\u00e1metro dentro de una funci\u00f3n, debes declararlo como una variable <code>var</code>.</p> <pre><code>fun duplicar(numero: Int): Int {\n    var resultado = numero\n    resultado *= 2\n    return resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>duplicar</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. El par\u00e1metro <code>numero</code> se declara como una variable <code>var</code> para poder modificar su valor dentro de la funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-con-valores-por-defecto","title":"Par\u00e1metros con valores por defecto","text":"<p>Los par\u00e1metros de una funci\u00f3n en Kotlin pueden tener valores por defecto, lo que te permite llamar a la funci\u00f3n sin proporcionar todos los argumentos.</p> <pre><code>fun saludar(nombre: String = \"Mundo\") {\n    println(\"Hola, $nombre!\")\n}\n\nsaludar() // Hola, Mundo!\nsaludar(\"Juan\") // Hola, Juan!\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>saludar</code> que toma un par\u00e1metro de tipo <code>String</code> con un valor por defecto de <code>\"Mundo\"</code>. Si no se proporciona un argumento al llamar a la funci\u00f3n, se utiliza el valor por defecto.</p> <p>Funciones con valores por defecto y su no obligatoriedad, su uso en Compose</p> <p>Las funciones con valores por defecto son muy \u00fatiles en Jetpack Compose, ya que te permiten definir componentes con valores por defecto y llamar a esos componentes sin proporcionar todos los argumentos.</p> <p>Por ejemplo, puedes definir un bot\u00f3n con un texto por defecto y un color por defecto, y luego llamar a ese bot\u00f3n sin proporcionar el texto o el color si deseas utilizar los valores por defecto.</p> <pre><code>@Composable\nfun Boton(texto: String = \"Aceptar\", color: Color = Color.Blue) {\n    Button(onClick = { /* Acci\u00f3n al hacer clic */ }) {\n        Text(texto, color = color)\n    }\n}\n\nBoton() // Bot\u00f3n con texto \"Aceptar\" y color azul\nBoton(\"Cancelar\", Color.Red) // Bot\u00f3n con texto \"Cancelar\" y color rojo\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-de-una-funcion-lambda","title":"Par\u00e1metros de una funci\u00f3n lambda","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes especificar los tipos de los par\u00e1metros de entrada o dejar que el compilador infiera los tipos autom\u00e1ticamente.</p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. En la funci\u00f3n lambda <code>suma</code>, se especifican los tipos de los par\u00e1metros de entrada, mientras que en la funci\u00f3n lambda <code>resta</code>, se deja que el compilador infiera los tipos autom\u00e1ticamente.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#la-palabra-reservada-it","title":"La palabra reservada <code>it</code>","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar la palabra reservada <code>it</code> para referirte al \u00fanico par\u00e1metro de entrada si la funci\u00f3n lambda tiene un solo par\u00e1metro.</p> <pre><code>val cuadrado: (Int) -&gt; Int = { it * it }\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>cuadrado</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. </p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>La palabra reservada <code>it</code> se utiliza para referirse al \u00fanico par\u00e1metro de entrada de la funci\u00f3n lambda.</p> <p>Esto es \u00fatil cuando la funci\u00f3n lambda tiene un solo par\u00e1metro y quieres hacer el c\u00f3digo m\u00e1s conciso.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda-con-multiples-lineas","title":"Funciones lambda con m\u00faltiples l\u00edneas","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar m\u00faltiples l\u00edneas de c\u00f3digo si es necesario. </p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt;\n    val resultado = a + b\n    println(\"La suma de $a y $b es $resultado\")\n    resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n lambda realiza la suma de los dos par\u00e1metros y muestra un mensaje por consola con el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#numero-variable-de-argumentos","title":"N\u00famero variable de argumentos","text":"<p>En Kotlin, puedes definir funciones que toman un n\u00famero variable de argumentos utilizando el operador <code>vararg</code>.</p> <pre><code>fun sumar(vararg numeros: Int): Int {\n    var suma = 0\n    for (numero in numeros) {\n        suma += numero\n    }\n    return suma\n}\n\nval resultado = sumar(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma un n\u00famero variable de argumentos de tipo <code>Int</code> utilizando el operador <code>vararg</code>. La funci\u00f3n suma todos los n\u00fameros pasados como argumentos y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-extension-extension-functions","title":"Funciones de extensi\u00f3n (Extension Functions)","text":"<p>En Kotlin, puedes agregar nuevas funciones a las clases existentes sin heredar de ellas. </p> <p>Estas funciones se conocen como funciones de extensi\u00f3n y te permiten extender la funcionalidad de las clases sin modificar su c\u00f3digo fuente.</p> <pre><code>fun String.invertir(): String {\n    return this.reversed()\n}\n\nval texto = \"Hola, mundo!\"\nval textoInvertido = texto.invertir()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>invertir</code> para la clase <code>String</code> que invierte el contenido de la cadena de texto. La funci\u00f3n de extensi\u00f3n se llama como si fuera un m\u00e9todo de la clase <code>String</code>.</p> <p>Funciones de extensi\u00f3n y funciones de orden superior</p> <p>Las funciones de extensi\u00f3n y las funciones de orden superior son dos caracter\u00edsticas poderosas de Kotlin que te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable.</p> <p>Las funciones de extensi\u00f3n te permiten agregar nuevas funciones a las clases existentes sin heredar de ellas, mientras que las funciones de orden superior te permiten pasar funciones como argumentos a otras funciones.</p> <p>Al combinar estas dos caracter\u00edsticas, puedes escribir c\u00f3digo m\u00e1s flexible y expresivo en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html","title":"Null safety","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#null-safety-en-kotlin","title":"Null safety en Kotlin","text":"<p>En Kotlin, el manejo de nulos es una parte fundamental del lenguaje. </p> <p>Kotlin est\u00e1 dise\u00f1ado para evitar los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n, como Java. </p> <p>En Kotlin, los tipos de datos pueden ser nulos o no nulos, lo que te permite expresar de forma segura si un valor puede ser nulo o no.  </p> <p>Diferencia con Java</p> <p>En Java, todos los tipos de datos pueden ser nulos, lo que puede llevar a errores de referencia nula si no se manejan correctamente. </p> <p>En Kotlin, los tipos de datos no nulos deben ser manejados de forma expl\u00edcita, lo que ayuda a prevenir los errores de referencia nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#tipos-de-datos-nulos","title":"Tipos de datos nulos","text":"<p>En Kotlin, los tipos de datos pueden ser nulos o no nulos.</p> <ul> <li> <p>Tipos de datos no nulos: Los tipos de datos no nulos no pueden contener valores nulos y deben ser inicializados con un valor no nulo.</p> </li> <li> <p>Tipos de datos nulos: Los tipos de datos nulos pueden contener valores nulos y deben ser inicializados con un valor nulo o con la funci\u00f3n <code>null</code>.</p> </li> </ul> <pre><code>val nombre: String = \"Juan\" // Tipo de dato no nulo\n\nval apellido: String? = null // Tipo de dato nulo\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String</code> no nulo, por lo que no puede contener un valor nulo. La variable <code>apellido</code>, en cambio, es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#operadores-de-seguridad-de-nulos","title":"Operadores de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar operadores de seguridad de nulos para manejar los valores nulos de forma segura.</p> <ul> <li> <p>Operador de llamada segura (<code>?.</code>): El operador de llamada segura <code>?.</code> te permite acceder a las propiedades de un objeto nulo sin lanzar una excepci\u00f3n de referencia nula.</p> </li> <li> <p>Operador de elvis (<code>?:</code>): El operador de elvis <code>?:</code> te permite proporcionar un valor predeterminado en caso de que una expresi\u00f3n sea nula.</p> </li> <li> <p>Operador de no nulo (<code>!!</code>): El operador de no nulo <code>!!</code> te permite forzar la ejecuci\u00f3n de una expresi\u00f3n nula, lo que puede lanzar una excepci\u00f3n de referencia nula si la expresi\u00f3n es nula.</p> </li> </ul> <pre><code>val nombre: String? = null\n\nval longitud = nombre?.length // null\n\nval longitud = nombre?.length ?: 0 // 0\n\nval longitud = nombre!!.length // Lanza una excepci\u00f3n de referencia nula\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p> <ul> <li> <p>En la primera l\u00ednea, se utiliza el operador de llamada segura <code>?.</code> para acceder a la propiedad <code>length</code> de la variable <code>nombre</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length</code> devuelve <code>null</code>.</p> </li> <li> <p>En la segunda l\u00ednea, se utiliza el operador de elvis <code>?:</code> para proporcionar un valor predeterminado de <code>0</code> en caso de que la expresi\u00f3n <code>nombre?.length</code> sea nula. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length ?: 0</code> devuelve <code>0</code>.</p> </li> <li> <p>En la tercera l\u00ednea, se utiliza el operador de no nulo <code>!!</code> para forzar la ejecuci\u00f3n de la expresi\u00f3n <code>nombre!!.length</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre!!.length</code> lanza una excepci\u00f3n de referencia nula.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#funciones-de-extension-de-seguridad-de-nulos","title":"Funciones de extensi\u00f3n de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar funciones de extensi\u00f3n para agregar funcionalidades a los tipos de datos nulos.</p> <pre><code>fun String?.oLongitud(): Int {\n    return this?.length ?: 0\n}\n\nval nombre: String? = null\n\nval longitud = nombre.oLongitud() // 0\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>oLongitud</code> para el tipo de dato <code>String?</code>. La funci\u00f3n <code>oLongitud</code> devuelve la longitud de la cadena si no es nula, o <code>0</code> si es nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#conclusiones","title":"Conclusiones","text":"<p>El manejo de nulos en Kotlin es una parte fundamental del lenguaje que te permite expresar de forma segura si un valor puede ser nulo o no.</p> <p>Al utilizar tipos de datos nulos y operadores de seguridad de nulos, puedes prevenir los errores de referencia nula y escribir c\u00f3digo m\u00e1s robusto y seguro.</p> <p>Recursos</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin sobre seguridad de nulos</li> <li>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</li> <li>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</li> </ul>"},{"location":"temas/00-android/00-kotlin/21-poo.html","title":"POO","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#programacion-orientada-a-objetos-en-kotlin","title":"Programaci\u00f3n orientada a objetos en Kotlin","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se basa en el concepto de \"objetos\", que pueden contener datos en forma de campos (tambi\u00e9n conocidos como atributos) y c\u00f3digo en forma de procedimientos (tambi\u00e9n conocidos como m\u00e9todos).    </p> <p>En Kotlin, puedes crear clases y objetos para modelar entidades del mundo real y encapsular datos y comportamientos relacionados. Kotlin es un lenguaje de programaci\u00f3n orientado a objetos y admite todas las caracter\u00edsticas tradicionales de la programaci\u00f3n orientada a objetos, como la herencia, el polimorfismo, la encapsulaci\u00f3n y la abstracci\u00f3n.  </p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#clases-y-objetos","title":"Clases y objetos","text":"<p>En Kotlin, puedes definir una clase utilizando la palabra clave <code>class</code> seguida del nombre de la clase y el cuerpo de la clase entre llaves <code>{}</code>. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con valores predeterminados.</p> <p>Para crear un objeto de una clase en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#propiedades-y-metodos","title":"Propiedades y m\u00e9todos","text":"<p>En Kotlin, puedes definir propiedades y m\u00e9todos en una clase utilizando la palabra clave <code>var</code> o <code>val</code> seguida del nombre de la propiedad o el m\u00e9todo y el tipo de dato de la propiedad o el m\u00e9todo.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y un m\u00e9todo <code>saludar</code> que imprime un mensaje de saludo con el nombre de la persona.</p> <p>Para acceder a las propiedades y m\u00e9todos de un objeto en Kotlin, puedes utilizar el operador de acceso <code>.</code> seguido del nombre de la propiedad o el m\u00e9todo.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. Luego, se llama al m\u00e9todo <code>saludar</code> en el objeto <code>persona</code> para imprimir un mensaje de saludo con el nombre de la persona.</p> <p>Diferencias con Java</p> <p>A diferencia de Java, en Kotlin, las propiedades y los m\u00e9todos de una clase son p\u00fablicos por defecto, lo que significa que se pueden acceder desde cualquier parte del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>En Kotlin, puedes encapsular propiedades y m\u00e9todos en una clase utilizando los modificadores de acceso <code>public</code>, <code>protected</code>, <code>private</code> y <code>internal</code>.</p> <ul> <li><code>public</code>: Las propiedades y m\u00e9todos p\u00fablicos son accesibles desde cualquier parte del c\u00f3digo.</li> <li><code>protected</code>: Las propiedades y m\u00e9todos protegidos son accesibles desde la clase actual y las clases derivadas.</li> <li><code>private</code>: Las propiedades y m\u00e9todos privados son accesibles solo desde la clase actual.</li> <li><code>internal</code>: Las propiedades y m\u00e9todos internos son accesibles desde el m\u00f3dulo actual.</li> </ul> <pre><code>class Persona {\n    var nombre: String = \"\"\n        private set\n    var edad: Int = 0\n        private set\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que se han encapsulado con el modificador de acceso <code>private</code>. Esto significa que las propiedades <code>nombre</code> y <code>edad</code> solo se pueden acceder y modificar dentro de la clase <code>Persona</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. </p> <p>Sin embargo, al intentar modificar las propiedades <code>nombre</code> y <code>edad</code> desde fuera de la clase <code>Persona</code>, se produce un error de compilaci\u00f3n debido a que las propiedades est\u00e1n encapsuladas con el modificador de acceso <code>private</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#setters-y-getters-personalizados","title":"Setters y Getters personalizados","text":"<p>En Kotlin, puedes definir setters y getters personalizados para las propiedades de una clase utilizando la palabra clave <code>set</code> y <code>get</code> seguida de la l\u00f3gica personalizada para establecer y obtener el valor de la propiedad.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n        set(value) {\n            field = value.capitalize()\n        }\n    var edad: Int = 0\n        set(value) {\n            field = if (value &gt;= 0) value else 0\n        }\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que tienen setters personalizados. El setter de la propiedad <code>nombre</code> capitaliza el valor de la propiedad, y el setter de la propiedad <code>edad</code> establece el valor de la propiedad en <code>0</code> si es menor que <code>0</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"juan\"\npersona.edad = -10\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores","title":"Constructores","text":"<p>En Kotlin, puedes definir un constructor primario utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <p>Sin embargo, en Kotlin, puedes omitir la palabra clave <code>constructor</code> y definir los par\u00e1metros del constructor directamente en la declaraci\u00f3n de la clase.</p> <pre><code>class Persona(nombre: String, edad: Int) {\n    var nombre: String = nombre\n    var edad: Int = edad\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor primario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor.</p> <p>Para crear un objeto de una clase con un constructor primario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor primario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores-secundarios","title":"Constructores secundarios","text":"<p>En Kotlin, puedes definir constructores secundarios utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    constructor(nombre: String, edad: Int) {\n        this.nombre = nombre\n        this.edad = edad\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor secundario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor secundario.</p> <p>Para crear un objeto de una clase con un constructor secundario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor secundario de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor secundario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#herencia","title":"Herencia","text":"<p>En Kotlin, puedes crear una clase que herede de otra clase utilizando la palabra clave <code>:</code> seguida del nombre de la clase base.</p> <pre><code>open class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n\nclass Empleado : Persona() {\n    var salario: Double = 0.0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y agrega una propiedad <code>salario</code>.</p> <p>Para crear un objeto de una clase derivada en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase derivada.</p> <pre><code>val empleado = Empleado()\nempleado.nombre = \"Juan\"\nempleado.edad = 30\nempleado.salario = 1000.0\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se inicializan las propiedades <code>nombre</code>, <code>edad</code> y <code>salario</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#polimorfismo","title":"Polimorfismo","text":"<p>En Kotlin, puedes utilizar el polimorfismo para tratar un objeto de una clase derivada como un objeto de la clase base.</p> <pre><code>open class Persona {\n    open fun saludar() {\n        println(\"Hola, soy una persona\")\n    }\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y sobrescribe el m\u00e9todo <code>saludar</code>.</p> <p>La palabra reservada open</p> <p>La palabra reservada <code>open</code> se utiliza para marcar una clase o un miembro de una clase como \"sobrese\u00edble\", lo que significa que puede ser heredado y sobrescrito por clases derivadas. </p> <p>Para utilizar el polimorfismo en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#abstraccion","title":"Abstracci\u00f3n","text":"<p>En Kotlin, puedes utilizar la abstracci\u00f3n para definir una clase base con m\u00e9todos abstractos que deben ser implementados por las clases derivadas.</p> <pre><code>abstract class Persona {\n    abstract fun saludar()\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo abstracto <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> e implementa el m\u00e9todo <code>saludar</code>.</p> <p>Para utilizar la abstracci\u00f3n en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html","title":"Objetos an\u00f3nimos","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#objetos-anonimos-en-kotlin","title":"Objetos an\u00f3nimos en Kotlin","text":"<p>En Kotlin, puedes crear objetos an\u00f3nimos utilizando la palabra clave <code>object</code>. </p> <p>Los objetos an\u00f3nimos son instancias de una clase an\u00f3nima que no tienen un nombre y se utilizan para definir una clase de forma concisa y reutilizable.</p> <pre><code>val persona = object {\n    val nombre = \"Juan\"\n    val edad = 25\n}\n\nprintln(persona.nombre) // Juan\nprintln(persona.edad) // 25\n</code></pre> <p>En el ejemplo anterior, se crea un objeto an\u00f3nimo que tiene dos propiedades <code>nombre</code> y <code>edad</code>. </p> <p>El objeto an\u00f3nimo se asigna a la variable <code>persona</code> y se puede acceder a sus propiedades utilizando la notaci\u00f3n de punto.</p> <p>Los objetos an\u00f3nimos son \u00fatiles cuando necesitas crear una instancia de una clase de forma r\u00e1pida y concisa sin tener que definir una clase con nombre.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#uso-de-objetos-anonimos","title":"Uso de objetos an\u00f3nimos","text":"<p>Los objetos an\u00f3nimos se utilizan en Kotlin para:</p> <ul> <li>Crear instancias de una clase de forma r\u00e1pida y concisa.</li> <li>Definir clases de forma reutilizable sin tener que definir una clase con nombre.</li> <li>Implementar interfaces y clases abstractas de forma an\u00f3nima.</li> </ul> <p>Los objetos an\u00f3nimos son una caracter\u00edstica poderosa de Kotlin que te permite escribir c\u00f3digo de forma m\u00e1s concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-de-interfaces-con-objetos-anonimos","title":"Implementaci\u00f3n de interfaces con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar interfaces de forma an\u00f3nima utilizando objetos an\u00f3nimos. Esto te permite definir una clase que implementa una interfaz sin tener que definir una clase con nombre.</p> <pre><code>interface Saludable {\n    fun saludar()\n}\n\nval persona = object : Saludable {\n    override fun saludar() {\n        println(\"Hola, soy una persona saludable!\")\n    }\n}\n\npersona.saludar() // Hola, soy una persona saludable!\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Saludable</code> con un m\u00e9todo <code>saludar</code>.</p> <p>Se crea un objeto an\u00f3nimo que implementa la interfaz <code>Saludable</code> y se asigna a la variable <code>persona</code>.</p> <p>El objeto an\u00f3nimo define la implementaci\u00f3n del m\u00e9todo <code>saludar</code> y se puede llamar al m\u00e9todo utilizando la notaci\u00f3n de punto.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-del-patron-singleton-con-objetos-anonimos","title":"Implementaci\u00f3n del patr\u00f3n Singleton con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos. El patr\u00f3n Singleton garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <pre><code>object Configuracion {\n    val servidor = \"localhost\"\n    val puerto = 8080\n}\n\nprintln(Configuracion.servidor) // localhost\nprintln(Configuracion.puerto) // 8080\n</code></pre> <p>En el ejemplo anterior, se define un objeto an\u00f3nimo <code>Configuracion</code> que tiene dos propiedades <code>servidor</code> y <code>puerto</code>.</p> <p>El objeto an\u00f3nimo se utiliza para almacenar la configuraci\u00f3n de la aplicaci\u00f3n y garantiza que solo haya una instancia de la configuraci\u00f3n en toda la aplicaci\u00f3n.</p> <p>Caracter\u00edsticas de los objetos an\u00f3nimos</p> <p>Los objetos an\u00f3nimos en Kotlin tienen las siguientes caracter\u00edsticas:</p> <ul> <li>No tienen un nombre y se crean utilizando la palabra clave <code>object</code>.</li> <li>Pueden tener propiedades, m\u00e9todos y constructores.</li> <li>Se utilizan para definir clases de forma concisa y reutilizable.</li> <li>Se pueden utilizar para implementar interfaces y clases abstractas de forma an\u00f3nima.</li> <li>Se pueden utilizar para implementar el patr\u00f3n Singleton y almacenar configuraciones globales.</li> </ul> <p>Sobre el patr\u00f3n Singleton</p> <p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o que garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos, que garantizan que solo haya una instancia de la clase en toda la aplicaci\u00f3n.</p> <p>Usos comunes del patr\u00f3n Singleton incluyen la creaci\u00f3n de objetos de configuraci\u00f3n, conexiones a bases de datos y puntos de acceso a servicios globales.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html","title":"Data classes","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#data-classes-en-kotlin","title":"Data classes en Kotlin","text":"<p>En Kotlin, puedes crear clases de datos utilizando la palabra clave <code>data</code>. Las clases de datos son una forma concisa de definir clases que contienen datos y no tienen l\u00f3gica adicional.</p> <pre><code>data class Persona(val nombre: String, val edad: Int)\n</code></pre> <p>En el ejemplo anterior, se define una clase de datos <code>Persona</code> que tiene dos propiedades <code>nombre</code> y <code>edad</code>. La clase de datos se crea utilizando la palabra clave <code>data</code> seguida del nombre de la clase y las propiedades de la clase.</p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>v\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#propiedades-de-las-clases-de-datos","title":"Propiedades de las clases de datos","text":"<p>Las clases de datos en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Propiedades de solo lectura: Las propiedades de una clase de datos son de solo lectura y no se pueden modificar una vez que se han inicializado.</p> </li> <li> <p>M\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente los m\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code> a partir de las propiedades de la clase.</p> </li> <li> <p>M\u00e9todos <code>componentN()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente m\u00e9todos <code>componentN()</code> que te permiten desestructurar objetos de la clase en variables individuales.</p> </li> <li> <p>M\u00e9todo <code>copy()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente un m\u00e9todo <code>copy()</code> que te permite crear copias de objetos de la clase con propiedades modificadas.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#creacion-de-objetos-de-clases-de-datos","title":"Creaci\u00f3n de objetos de clases de datos","text":"<p>Para crear un objeto de una clase de datos en Kotlin, puedes utilizar la palabra clave <code>data</code> seguida del nombre de la clase y los valores de las propiedades.</p> <pre><code>val persona = Persona(\"Juan\", 25)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto de la clase de datos <code>Persona</code> con el nombre <code>Juan</code> y la edad <code>25</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#desestructuracion-de-objetos-de-clases-de-datos","title":"Desestructuraci\u00f3n de objetos de clases de datos","text":"<p>En Kotlin, puedes desestructurar objetos de clases de datos en variables individuales utilizando la notaci\u00f3n de desestructuraci\u00f3n.</p> <pre><code>val (nombre, edad) = persona\n</code></pre> <p>En el ejemplo anterior, se desestructura el objeto <code>persona</code> en las variables <code>nombre</code> y <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#copia-de-objetos-de-clases-de-datos","title":"Copia de objetos de clases de datos","text":"<p>En Kotlin, puedes crear copias de objetos de clases de datos utilizando el m\u00e9todo <code>copy()</code>.</p> <pre><code>val persona2 = persona.copy(edad = 30)\n</code></pre> <p>En el ejemplo anterior, se crea una copia del objeto <code>persona</code> con la edad modificada a <code>30</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html","title":"Enum classes","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#enum-classes-en-kotlin","title":"Enum classes en Kotlin","text":"<p>En Kotlin, puedes crear enumeraciones utilizando la palabra clave <code>enum class</code>.</p> <p>Las enumeraciones son una forma de definir un conjunto fijo de constantes que representan valores espec\u00edficos. Cada constante en una enumeraci\u00f3n tiene un nombre y un valor asociado.</p> <pre><code>enum class Color {\n    ROJO, VERDE, AZUL\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con tres constantes <code>ROJO</code>, <code>VERDE</code> y <code>AZUL</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-de-las-enumeraciones","title":"Propiedades de las enumeraciones","text":"<p>Las enumeraciones en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Constantes: Las enumeraciones contienen un conjunto fijo de constantes que representan valores espec\u00edficos.</p> </li> <li> <p>Propiedades y m\u00e9todos: Las enumeraciones pueden tener propiedades y m\u00e9todos asociados con cada constante.</p> </li> <li> <p>Constructores: Las enumeraciones pueden tener constructores personalizados para inicializar las constantes con valores espec\u00edficos.</p> </li> <li> <p>Implementaci\u00f3n de interfaces: Las enumeraciones pueden implementar interfaces y heredar de clases.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#acceso-a-las-constantes-de-una-enumeracion","title":"Acceso a las constantes de una enumeraci\u00f3n","text":"<p>Puedes acceder a las constantes de una enumeraci\u00f3n utilizando la notaci\u00f3n de punto.</p> <pre><code>val color = Color.ROJO\n</code></pre> <p>En el ejemplo anterior, se accede a la constante <code>ROJO</code> de la enumeraci\u00f3n <code>Color</code> y se asigna a la variable <code>color</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-y-metodos-de-una-enumeracion","title":"Propiedades y m\u00e9todos de una enumeraci\u00f3n","text":"<p>Puedes definir propiedades y m\u00e9todos en una enumeraci\u00f3n para agregar funcionalidades a las constantes.</p> <pre><code>enum class Color(val rgb: Int) {\n    ROJO(0xFF0000),\n    VERDE(0x00FF00),\n    AZUL(0x0000FF);\n\n    fun nombreEnMayusculas(): String {\n        return name.toUpperCase()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con una propiedad <code>rgb</code> y un m\u00e9todo <code>nombreEnMayusculas</code> que devuelve el nombre de la constante en may\u00fasculas.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#implementacion-de-interfaces-con-enumeraciones","title":"Implementaci\u00f3n de interfaces con enumeraciones","text":"<p>Las enumeraciones en Kotlin pueden implementar interfaces para agregar funcionalidades a las constantes.</p> <pre><code>interface Describible {\n    fun describir(): String\n}\n\nenum class DiaSemana : Describible {\n    LUNES {\n        override fun describir(): String {\n            return \"Primer d\u00eda de la semana\"\n        }\n    },\n    MARTES {\n        override fun describir(): String {\n            return \"Segundo d\u00eda de la semana\"\n        }\n    },\n    MIERCOLES {\n        override fun describir(): String {\n            return \"Tercer d\u00eda de la semana\"\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Describible</code> con un m\u00e9todo <code>describir</code>.</p> <p>Se crea una enumeraci\u00f3n <code>DiaSemana</code> que implementa la interfaz <code>Describible</code> y define la implementaci\u00f3n del m\u00e9todo <code>describir</code> para cada constante.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#uso-de-enumeraciones-en-kotlin","title":"Uso de enumeraciones en Kotlin","text":"<p>Las enumeraciones son \u00fatiles en Kotlin para:</p> <ul> <li>Definir un conjunto fijo de constantes que representan valores espec\u00edficos.</li> <li>Agregar propiedades y m\u00e9todos a las constantes para agregar funcionalidades.</li> <li>Implementar interfaces y heredar de clases para agregar funcionalidades a las constantes.</li> </ul>"},{"location":"temas/00-android/00-kotlin/25-genericos.html","title":"Gen\u00e9ricos","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-kotlin","title":"Gen\u00e9ricos en Kotlin","text":"<p>En Kotlin, puedes utilizar gen\u00e9ricos para crear clases, funciones e interfaces que trabajen con tipos de datos de forma gen\u00e9rica. Los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p> <p>Video explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#clases-genericas","title":"Clases gen\u00e9ricas","text":"<p>En Kotlin, puedes crear clases gen\u00e9ricas utilizando la palabra clave <code>class</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la clase puede manejar.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval cajaCadena = Caja(\"Hola\")\n\nval entero: Int = cajaEntero.obtenerContenido()\nval cadena: String = cajaCadena.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una clase gen\u00e9rica <code>Caja</code> que tiene un par\u00e1metro de tipo <code>T</code>. La clase <code>Caja</code> tiene una propiedad <code>contenido</code> de tipo <code>T</code> y un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido de la caja.</p> <p>Se crean dos instancias de la clase <code>Caja</code> con tipos de datos diferentes: una con un entero y otra con una cadena. Se obtiene el contenido de cada caja y se asigna a variables de tipo <code>Int</code> y <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#funciones-genericas","title":"Funciones gen\u00e9ricas","text":"<p>En Kotlin, puedes crear funciones gen\u00e9ricas utilizando la palabra clave <code>fun</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la funci\u00f3n puede manejar.</p> <pre><code>fun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\nimprimirElemento(10)\nimprimirElemento(\"Hola\")\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n gen\u00e9rica <code>imprimirElemento</code> que toma un par\u00e1metro de tipo <code>T</code> y lo imprime en la consola. La funci\u00f3n <code>imprimirElemento</code> se llama dos veces con un entero y una cadena como argumentos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#interfaces-genericas","title":"Interfaces gen\u00e9ricas","text":"<p>En Kotlin, puedes crear interfaces gen\u00e9ricas utilizando la palabra clave <code>interface</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la interfaz puede manejar.</p> <pre><code>interface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;T&gt;(val contenido: T) : Contenedor&lt;T&gt; {\n    override fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval entero: Int = cajaEntero.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una interfaz gen\u00e9rica <code>Contenedor</code> que tiene un par\u00e1metro de tipo <code>T</code>. La interfaz <code>Contenedor</code> define un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido del contenedor.</p> <p>Se crea una clase <code>Caja</code> que implementa la interfaz <code>Contenedor</code> con un tipo de dato <code>T</code>. Se crea una instancia de la clase <code>Caja</code> con un entero y se obtiene el contenido de la caja.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#variance-en-genericos","title":"Variance en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar la anotaci\u00f3n <code>in</code> y <code>out</code> para especificar la variabilidad de los par\u00e1metros de tipo en clases y funciones gen\u00e9ricas.</p> <ul> <li><code>in</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de entrada (como par\u00e1metros de m\u00e9todos).</li> <li><code>out</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de salida (como valores de retorno de m\u00e9todos).</li> </ul> <pre><code>interface Contenedor&lt;out T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;in T&gt;(val contenido: T) {\n    fun ponerContenido(nuevoContenido: T) {\n        // ...\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Contenedor</code> con un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de salida. La clase <code>Caja</code> tiene un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de entrada.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#restricciones-en-genericos","title":"Restricciones en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar restricciones para limitar los tipos de datos que se pueden utilizar en clases y funciones gen\u00e9ricas. Puedes utilizar restricciones para garantizar que los tipos de datos cumplan ciertos requisitos.</p> <pre><code>fun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n\nval resultadoEntero = sumar(1, 2)\nval resultadoFlotante = sumar(1.5, 2.5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma dos par\u00e1metros de tipo <code>T</code> que deben ser subtipos de <code>Number</code>. La funci\u00f3n <code>sumar</code> devuelve la suma de los dos par\u00e1metros.</p> <p>Se llama a la funci\u00f3n <code>sumar</code> con un entero y un flotante como argumentos, y se asigna el resultado a variables de tipo <code>Int</code> y <code>Float</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-clases-y-funciones","title":"Gen\u00e9ricos en clases y funciones","text":"<p>En Kotlin, los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos. Puedes utilizar gen\u00e9ricos en clases, funciones e interfaces para crear c\u00f3digo gen\u00e9rico y flexible.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nfun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\ninterface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nfun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se muestran ejemplos de clases gen\u00e9ricas, funciones gen\u00e9ricas e interfaces gen\u00e9ricas en Kotlin. Puedes utilizar gen\u00e9ricos para escribir c\u00f3digo que sea reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#recursos-adicionales","title":"Recursos adicionales","text":"<ul> <li>Documentaci\u00f3n oficial de Kotlin sobre gen\u00e9ricos</li> <li>Tutorial de Kotlin sobre gen\u00e9ricos</li> <li>Ejemplos de gen\u00e9ricos en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html","title":"Clases selladas","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#clases-selladas-en-kotlin","title":"Clases selladas en Kotlin","text":"<p>Las clases selladas son un tipo especial de clase en Kotlin que se utilizan para representar un conjunto finito de subclases. </p> <p>Las clases selladas son \u00fatiles cuando tienes un conjunto limitado de subclases y quieres asegurarte de que todas las subclases se manejan de forma segura en un bloque <code>when</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#declaracion-de-clases-selladas","title":"Declaraci\u00f3n de clases selladas","text":"<p>En Kotlin, puedes declarar una clase sellada utilizando la palabra clave <code>sealed</code> antes de la palabra clave <code>class</code>. </p> <pre><code>sealed class Resultado {\n    data class Exito(val mensaje: String) : Resultado()\n    data class Error(val mensaje: String) : Resultado()\n}\n</code></pre> <p>En el ejemplo anterior, se declara una clase sellada <code>Resultado</code> con dos subclases: <code>Exito</code> y <code>Error</code>. Ambas subclases tienen una propiedad <code>mensaje</code> de tipo <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#uso-de-clases-selladas","title":"Uso de clases selladas","text":"<p>Las clases selladas se utilizan principalmente en expresiones <code>when</code> para manejar de forma segura todas las subclases. </p> <pre><code>fun procesarResultado(resultado: Resultado) {\n    when (resultado) {\n        is Resultado.Exito -&gt; println(\"Exito: ${resultado.mensaje}\")\n        is Resultado.Error -&gt; println(\"Error: ${resultado.mensaje}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>procesarResultado</code> que toma un par\u00e1metro de tipo <code>Resultado</code>. Dentro de la expresi\u00f3n <code>when</code>, se manejan de forma segura las subclases <code>Exito</code> y <code>Error</code> de la clase sellada <code>Resultado</code>.</p> <p>Las clases selladas son una forma segura y concisa de manejar un conjunto finito de subclases en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#ventajas-de-las-clases-selladas","title":"Ventajas de las clases selladas","text":"<ul> <li>Seguridad: Las clases selladas garantizan que todas las subclases se manejen de forma segura en un bloque <code>when</code>.</li> <li>Concisi\u00f3n: Las clases selladas permiten definir un conjunto finito de subclases de forma concisa y legible.</li> <li>Extensibilidad: Las clases selladas pueden tener subclases anidadas, lo que permite una mayor extensibilidad y modularidad en el c\u00f3digo.</li> </ul> <p>Las clases selladas son una caracter\u00edstica poderosa de Kotlin que te permite representar de forma segura un conjunto finito de subclases y manejarlas de forma concisa y legible en tu c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html","title":"Scope functions","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#scope-functions-en-kotlin","title":"Scope functions en Kotlin","text":"<p>En Kotlin, los scope functions son funciones que te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto. Estas funciones te permiten acceder a las propiedades y m\u00e9todos del objeto de forma m\u00e1s concisa y legible. </p> <p>Las scope functions en Kotlin son las siguientes: </p> <ul> <li><code>let</code></li> <li><code>run</code></li> <li><code>with</code></li> <li><code>apply</code></li> <li><code>also</code></li> </ul> <p>V\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#let","title":"<code>let</code>","text":"<p>La funci\u00f3n <code>let</code> te permite ejecutar un bloque de c\u00f3digo en el contexto de un objeto y devolver el resultado de la \u00faltima expresi\u00f3n del bloque. </p> <p>La funci\u00f3n <code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.let {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n    it.edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>let</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#run","title":"<code>run</code>","text":"<p>A diferencia de <code>let</code>, la funci\u00f3n <code>run</code> te permite acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</p> <p>La funci\u00f3n <code>run</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.run {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>run</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#with","title":"<code>with</code>","text":"<p>La funci\u00f3n <code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>with</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = with(persona) {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>with</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#apply","title":"<code>apply</code>","text":"<p>A diferencia de las funciones anteriores, la funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <p>La funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <pre><code>val resultado = persona?.apply {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad += 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>apply</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y modificar la edad increment\u00e1ndola en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#also","title":"<code>also</code>","text":"<p>La funci\u00f3n <code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>also</code> se utiliza para realizar operaciones en un objeto y devolver el objeto original.</p> <pre><code>val resultado = persona?.also {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>also</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver el objeto original.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#resumen","title":"Resumen","text":"<p>En resumen, las scope functions en Kotlin te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto y realizar operaciones en el objeto de forma m\u00e1s concisa y legible. Cada funci\u00f3n tiene un prop\u00f3sito espec\u00edfico y se utiliza en diferentes situaciones, dependiendo de tus necesidades. </p> <p>Podr\u00edamos decir que las diferencias generales son las siguientes:</p> <ul> <li><code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</li> <li><code>run</code> se utiliza para acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</li> <li><code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> <li><code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</li> <li><code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> </ul> <p>En la siguiente imagen se muestra un resumen visual de las diferencias entre las scope functions:</p> <p></p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html","title":"Arrays","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-en-kotlin","title":"Arrays en Kotlin","text":"<p>En Kotlin, puedes crear arrays utilizando la funci\u00f3n <code>arrayOf()</code>. Los arrays en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un array <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los arrays en Kotlin se crean utilizando la funci\u00f3n <code>arrayOf()</code> seguida de los valores del array entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#acceso-a-elementos-de-un-array","title":"Acceso a elementos de un array","text":"<p>Puedes acceder a elementos individuales de un array utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento del array <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#modificacion-de-elementos-de-un-array","title":"Modificaci\u00f3n de elementos de un array","text":"<p>Para modificar un elemento de un array, puedes utilizar el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas modificar.</p> <pre><code>numeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se modifica el primer elemento del array <code>numeros</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#iteracion-sobre-un-array","title":"Iteraci\u00f3n sobre un array","text":"<p>Puedes iterar sobre los elementos de un array utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del array <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-de-tipos-primitivos","title":"Arrays de tipos primitivos","text":"<p>En Kotlin, puedes utilizar arrays de tipos primitivos como <code>IntArray</code>, <code>DoubleArray</code>, <code>BooleanArray</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intArrayOf(1, 2, 3, 4, 5)\nval dobles = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanArrayOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean arrays de tipos primitivos <code>IntArray</code>, <code>DoubleArray</code> y <code>BooleanArray</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#operaciones-con-arrays","title":"Operaciones con arrays","text":"<p>Los arrays en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del array, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el array, <code>indexOf</code> para obtener el \u00edndice de un elemento en el array, etc.</p> <pre><code>val tama\u00f1o = numeros.size\nval contieneTres = numeros.contains(3)\nval indiceDeCuatro = numeros.indexOf(4)\n</code></pre> <p>En el ejemplo anterior, se obtiene el tama\u00f1o del array <code>numeros</code>, se comprueba si el array contiene el n\u00famero <code>3</code> y se obtiene el \u00edndice del n\u00famero <code>4</code> en el array.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html","title":"Listas","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-en-kotlin","title":"Listas en Kotlin","text":"<p>En Kotlin, puedes crear listas utilizando la funci\u00f3n <code>listOf()</code>. Las listas en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = listOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea una lista <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Las listas en Kotlin se crean utilizando la funci\u00f3n <code>listOf()</code> seguida de los valores de la lista entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#acceso-a-elementos-de-una-lista","title":"Acceso a elementos de una lista","text":"<p>Puedes acceder a elementos individuales de una lista utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento de la lista <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#iteracion-sobre-una-lista","title":"Iteraci\u00f3n sobre una lista","text":"<p>Puedes iterar sobre los elementos de una lista utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos de la lista <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-de-tipos-primitivos","title":"Listas de tipos primitivos","text":"<p>En Kotlin, puedes utilizar listas de tipos primitivos como <code>IntList</code>, <code>DoubleList</code>, <code>BooleanList</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intListOf(1, 2, 3, 4, 5)\nval dobles = doubleListOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanListOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean listas de tipos primitivos <code>IntList</code>, <code>DoubleList</code> y <code>BooleanList</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#modificacion-de-elementos-de-una-lista","title":"Modificaci\u00f3n de elementos de una lista","text":"<p>Las listas en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de una lista una vez que se ha creado. Si necesitas una lista mutable, puedes utilizar la funci\u00f3n <code>mutableListOf()</code>.</p> <pre><code>val numeros = mutableListOf(1, 2, 3, 4, 5)\nnumeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se crea una lista mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Se modifica el primer elemento de la lista asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#operaciones-comunes-con-listas","title":"Operaciones comunes con listas","text":"<p>Kotlin proporciona una serie de funciones de extensi\u00f3n para realizar operaciones comunes con listas, como <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>sortedBy()</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\nval suma = numeros.reduce { acc, numero -&gt; acc + numero }\nval ordenados = numeros.sortedBy { numero -&gt; numero }\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>map()</code>, <code>filter()</code>, <code>reduce()</code> y <code>sortedBy()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Est\u00e1s funciones hacen lo siguiente:</p> <ul> <li> <p><code>map()</code>: Aplica una funci\u00f3n a cada elemento de la lista y devuelve una nueva lista con los resultados.</p> </li> <li> <p><code>filter()</code>: Filtra los elementos de la lista que cumplen una condici\u00f3n dada y devuelve una nueva lista con los elementos filtrados.</p> </li> <li> <p><code>reduce()</code>: Combina los elementos de la lista en un solo valor utilizando una funci\u00f3n dada.</p> </li> <li> <p><code>sortedBy()</code>: Ordena los elementos de la lista en funci\u00f3n de una clave dada y devuelve una nueva lista ordenada.</p> </li> <li> <p><code>groupBy()</code>: Agrupa los elementos de la lista en funci\u00f3n de una clave dada y devuelve un mapa de claves y listas de elementos.</p> </li> </ul> <p>Otros ejemplos de operaciones comunes con listas son <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code>, <code>distinct()</code>, etc.</p> <pre><code>val suma = numeros.sum()\nval maximo = numeros.max()\nval minimo = numeros.min()\nval promedio = numeros.average()\nval unicos = numeros.distinct()\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code> y <code>distinct()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Su funcionalidad es la siguiente:</p> <ul> <li> <p><code>sum()</code>: Calcula la suma de los elementos de la lista.</p> </li> <li> <p><code>max()</code>: Devuelve el valor m\u00e1ximo de la lista.</p> </li> <li> <p><code>min()</code>: Devuelve el valor m\u00ednimo de la lista.</p> </li> <li> <p><code>average()</code>: Calcula el promedio de los elementos de la lista.</p> </li> <li> <p><code>distinct()</code>: Devuelve una nueva lista con los elementos \u00fanicos de la lista original.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/42-listas.html#funciones-de-extension-para-listas","title":"Funciones de extensi\u00f3n para listas","text":"<p>En Kotlin, puedes crear tus propias funciones de extensi\u00f3n para realizar operaciones espec\u00edficas con listas.</p> <pre><code>fun List&lt;Int&gt;.duplicar(): List&lt;Int&gt; {\n    return this.map { it * 2 }\n}\n\nval duplicados = numeros.duplicar()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>duplicar()</code> que duplica cada elemento de una lista de enteros. La funci\u00f3n de extensi\u00f3n se llama con la lista <code>numeros</code> y devuelve una nueva lista con los elementos duplicados.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html","title":"43 maps","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-en-kotlin","title":"Maps en Kotlin","text":"<p>En Kotlin, un <code>Map</code> es una colecci\u00f3n de pares clave-valor donde cada clave est\u00e1 asociada a un valor. Los <code>Map</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = mapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Los <code>Map</code> en Kotlin se crean utilizando la funci\u00f3n <code>mapOf()</code> seguida de los pares clave-valor entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#acceso-a-elementos-de-un-map","title":"Acceso a elementos de un Map","text":"<p>Puedes acceder a elementos individuales de un <code>Map</code> utilizando la clave del elemento que deseas acceder.</p> <pre><code>val numeroUno = numeros[\"uno\"]\nval numeroDos = numeros[\"dos\"]\n</code></pre> <p>En el ejemplo anterior, se accede a los valores asociados a las claves <code>\"uno\"</code> y <code>\"dos\"</code> del <code>Map</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#iteracion-sobre-un-map","title":"Iteraci\u00f3n sobre un Map","text":"<p>Puedes iterar sobre los pares clave-valor de un <code>Map</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for ((clave, valor) in numeros) {\n    println(\"Clave: $clave, Valor: $valor\")\n}\n\nnumeros.forEach { (clave, valor) -&gt;\n    println(\"Clave: $clave, Valor: $valor\")\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los pares clave-valor del <code>Map</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-de-tipos-primitivos","title":"Maps de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Map</code> de tipos primitivos como <code>IntMap</code>, <code>DoubleMap</code>, <code>BooleanMap</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intMapOf(1 to \"uno\", 2 to \"dos\", 3 to \"tres\")\nval dobles = doubleMapOf(1.0 to \"uno\", 2.0 to \"dos\", 3.0 to \"tres\")\nval booleanos = booleanMapOf(true to \"verdadero\", false to \"falso\")\n</code></pre> <p>En el ejemplo anterior, se crean <code>Map</code> de tipos primitivos <code>IntMap</code>, <code>DoubleMap</code> y <code>BooleanMap</code> con pares clave-valor iniciales.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#modificacion-de-elementos-de-un-map","title":"Modificaci\u00f3n de elementos de un Map","text":"<p>Los <code>Map</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Map</code> una vez que se ha creado. Si necesitas un <code>Map</code> mutable, puedes utilizar la funci\u00f3n <code>mutableMapOf()</code>.</p> <pre><code>val numeros = mutableMapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\nnumeros[\"uno\"] = 10\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> mutable <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Se modifica el valor asociado a la clave <code>\"uno\"</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#operaciones-con-maps","title":"Operaciones con Maps","text":"<p>Los <code>Map</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code>, <code>filterValues()</code>, etc.</p> <pre><code>val valorUno = numeros.get(\"uno\")\nval contieneDos = numeros.containsKey(\"dos\")\nval contieneCinco = numeros.containsValue(5)\nval claves = numeros.keys\nval valores = numeros.values\nval numerosPares = numeros.filterKeys { clave -&gt; clave.length % 2 == 0 }\nval numerosImpares = numeros.filterValues { valor -&gt; valor % 2 != 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code> y <code>filterValues()</code> para realizar operaciones comunes con el <code>Map</code> <code>numeros</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>get()</code>: Obtiene el valor asociado a una clave.</li> <li><code>containsKey()</code>: Comprueba si una clave est\u00e1 presente en el <code>Map</code>.</li> <li><code>containsValue()</code>: Comprueba si un valor est\u00e1 presente en el <code>Map</code>.</li> <li><code>keys</code>: Obtiene las claves del <code>Map</code>.</li> <li><code>values</code>: Obtiene los valores del <code>Map</code>.</li> <li><code>filterKeys()</code>: Filtra los pares clave-valor del <code>Map</code> por las claves.</li> <li><code>filterValues()</code>: Filtra los pares clave-valor del <code>Map</code> por los valores.</li> </ul> <p>Los <code>Map</code> en Kotlin son una forma eficiente de almacenar y acceder a datos asociados a claves. Puedes utilizar <code>Map</code> para representar relaciones entre objetos y realizar operaciones comunes con ellos de forma sencilla y eficiente.</p> <p>Para m\u00e1s informaci\u00f3n sobre los <code>Map</code> en Kotlin, puedes consultar la documentaci\u00f3n oficial de Kotlin sobre Maps.`;</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html","title":"44 sets","text":"<p>import CodeBlock from '@theme/CodeBlock';</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-en-kotlin","title":"Sets en Kotlin","text":"<p>En Kotlin, un <code>Set</code> es una colecci\u00f3n de elementos \u00fanicos, lo que significa que no puede contener elementos duplicados. Los <code>Set</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = setOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los <code>Set</code> en Kotlin se crean utilizando la funci\u00f3n <code>setOf()</code> seguida de los valores del <code>Set</code> entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#acceso-a-elementos-de-un-set","title":"Acceso a elementos de un Set","text":"<p>Puedes acceder a elementos individuales de un <code>Set</code> utilizando la funci\u00f3n <code>contains()</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>.</p> <pre><code>val contieneTres = numeros.contains(3)\nval contieneSeis = numeros.contains(6)\n</code></pre> <p>En el ejemplo anterior, se comprueba si el <code>Set</code> <code>numeros</code> contiene los elementos <code>3</code> y <code>6</code> utilizando la funci\u00f3n <code>contains()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#iteracion-sobre-un-set","title":"Iteraci\u00f3n sobre un Set","text":"<p>Puedes iterar sobre los elementos de un <code>Set</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del <code>Set</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-de-tipos-primitivos","title":"Sets de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Set</code> de tipos primitivos como <code>IntSet</code>, <code>DoubleSet</code>, <code>BooleanSet</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intSetOf(1, 2, 3, 4, 5)\nval dobles = doubleSetOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanSetOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean <code>Set</code> de tipos primitivos <code>IntSet</code>, <code>DoubleSet</code> y <code>BooleanSet</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#modificacion-de-elementos-de-un-set","title":"Modificaci\u00f3n de elementos de un Set","text":"<p>Los <code>Set</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Set</code> una vez que se ha creado. Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code>.</p> <pre><code>val numeros = mutableSetOf(1, 2, 3, 4, 5)\nnumeros.add(6)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code> y se a\u00f1ade el valor <code>6</code> al <code>Set</code> utilizando la funci\u00f3n <code>add()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#operaciones-con-sets","title":"Operaciones con Sets","text":"<p>Los <code>Set</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del <code>Set</code>, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>, <code>union</code> para unir dos <code>Set</code>, <code>intersect</code> para obtener la intersecci\u00f3n de dos <code>Set</code>, etc.</p> <pre><code>val numerosPares = setOf(2, 4, 6, 8, 10)\nval numerosImpares = setOf(1, 3, 5, 7, 9)\n\nval union = numeros.union(numerosPares)\nval interseccion = numeros.intersect(numerosImpares)\nval diferencia = numeros.subtract(numerosPares)\nval diferenciaSimetrica = numeros.symmetricDifference(numerosPares)\nval contieneTodos = numeros.containsAll(numerosPares)\nval contieneAlguno = numeros.containsAny(numerosPares)\nval esSubconjunto = numeros.isSubset(numerosPares)\nval esSuperconjunto = numeros.isSuperset(numerosPares)\nval esDisjunto = numeros.isDisjoint(numerosPares)\nval esVacio = numeros.isEmpty()\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>union()</code> e <code>intersect()</code> para realizar operaciones comunes con los <code>Set</code> <code>numeros</code>, <code>numerosPares</code> y <code>numerosImpares</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>union()</code>: Devuelve un <code>Set</code> que contiene todos los elementos de los dos <code>Set</code>.</li> <li><code>intersect()</code>: Devuelve un <code>Set</code> que contiene los elementos comunes de los dos <code>Set</code>.</li> <li><code>subtract()</code>: Devuelve un <code>Set</code> que contiene los elementos del primer <code>Set</code> que no est\u00e1n en el segundo <code>Set</code>.</li> <li><code>symmetricDifference()</code>: Devuelve un <code>Set</code> que contiene los elementos que est\u00e1n en uno de los <code>Set</code> pero no en ambos.</li> <li><code>containsAll()</code>: Comprueba si un <code>Set</code> contiene todos los elementos de otro <code>Set</code>.</li> <li><code>containsAny()</code>: Comprueba si un <code>Set</code> contiene al menos un elemento de otro <code>Set</code>.</li> <li><code>isSubset()</code>: Comprueba si un <code>Set</code> es un subconjunto de otro <code>Set</code>.</li> <li><code>isSuperset()</code>: Comprueba si un <code>Set</code> es un superconjunto de otro <code>Set</code>.</li> <li><code>isDisjoint()</code>: Comprueba si dos <code>Set</code> son disjuntos, es decir, si no tienen elementos en com\u00fan.</li> <li><code>isEmpty()</code>: Comprueba si un <code>Set</code> est\u00e1 vac\u00edo.</li> </ul> <p>Los <code>Set</code> en Kotlin son una forma eficiente de almacenar y manipular colecciones de elementos \u00fanicos. Puedes utilizar las operaciones proporcionadas por los <code>Set</code> para realizar operaciones comunes, como unir, intersecar, restar y comparar <code>Set</code> entre s\u00ed.</p> <p>Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code> para crear un <code>Set</code> que puedas modificar. Los <code>Set</code> en Kotlin son una herramienta poderosa que te permite trabajar con colecciones de elementos \u00fanicos de forma eficiente y concisa.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html","title":"Corrutinas","text":""},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#corrutinas-en-kotlin","title":"Corrutinas en Kotlin","text":"<p>Las corrutinas son una caracter\u00edstica de Kotlin que permite escribir c\u00f3digo as\u00edncrono de manera m\u00e1s sencilla y legible. Las corrutinas son funciones que pueden suspenderse y reanudarse en un punto determinado, lo que permite realizar operaciones as\u00edncronas sin bloquear el hilo principal.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-sincrono","title":"C\u00f3digo s\u00edncrono","text":"<p>El c\u00f3digo s\u00edncrono es el c\u00f3digo que se ejecuta de manera secuencial, es decir, una instrucci\u00f3n se ejecuta despu\u00e9s de que la anterior haya terminado. En Kotlin, el c\u00f3digo s\u00edncrono se ejecuta en el hilo principal de la aplicaci\u00f3n.    </p> <pre><code>fun main() {\n    val resultado = obtenerDatos()\n    println(\"Datos: $resultado\")\n}\nfun obtenerDatos(): String {\n    Thread.sleep(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n s\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> llama a la funci\u00f3n <code>obtenerDatos</code> y espera a que se complete antes de imprimir los datos obtenidos.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-asincrono","title":"C\u00f3digo as\u00edncrono","text":"<p>El c\u00f3digo as\u00edncrono es el c\u00f3digo que se ejecuta de manera concurrente, es decir, varias instrucciones se pueden ejecutar al mismo tiempo. En Kotlin, el c\u00f3digo as\u00edncrono se puede escribir utilizando corrutinas.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#los-metodos-launch-y-async","title":"Los m\u00e9todos launch y async","text":"<p>En Kotlin, las funciones <code>launch</code> y <code>async</code> se utilizan para crear corrutinas. </p> <p>La principal diferencia entre ellas es que <code>launch</code> se utiliza para ejecutar una corrutina que no devuelve un valor, mientras que <code>async</code> se utiliza para ejecutar una corrutina que devuelve un valor.  </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n\nsuspend fun main() {\n    launch { obtenerDatos() }\n    println(\"Datos obtenidos\")\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. En el segundo ejemplo, se utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina sin esperar a que se complete.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#excepciones","title":"Excepciones","text":"<p>En Kotlin, las corrutinas pueden lanzar excepciones que se pueden manejar utilizando bloques <code>try-catch</code>. Las excepciones lanzadas en una corrutina se propagan a la corrutina padre y se pueden manejar en el hilo principal.  </p> <pre><code>suspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse y lanza una excepci\u00f3n. La funci\u00f3n <code>main</code> utiliza un bloque <code>try-catch</code> para manejar la excepci\u00f3n lanzada en la corrutina.</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin: La documentaci\u00f3n oficial de Kotlin sobre corrutinas, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar corrutinas en Kotlin.</li> </ul> <p>La importancia de controlar las excepciones al usar corrutinas</p> <p>Cuando se utilizan corrutinas en Kotlin, es importante controlar las excepciones que se pueden producir durante la ejecuci\u00f3n de la aplicaci\u00f3n. Las excepciones no controladas pueden provocar fallos en la aplicaci\u00f3n y afectar negativamente la experiencia del usuario.   </p> <p>Por lo tanto, es importante utilizar bloques <code>try-catch</code> para manejar las excepciones que se pueden producir en las corrutinas. Adem\u00e1s, es recomendable utilizar la funci\u00f3n <code>CoroutineExceptionHandler</code> para manejar las excepciones que se producen en las corrutinas de manera global.</p> <pre><code>val exceptionHandler = CoroutineExceptionHandler { _, exception -&gt;\n    println(\"Error: ${exception.message}\")\n}\n\nsuspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}   \n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#cancelacion","title":"Cancelaci\u00f3n","text":"<p>En Kotlin, las corrutinas se pueden cancelar utilizando la funci\u00f3n <code>cancel()</code>. La cancelaci\u00f3n de una corrutina no detiene inmediatamente su ejecuci\u00f3n, sino que la marca como cancelada y permite que se complete de manera segura. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        try {\n            obtenerDatos()\n        } catch (e: CancellationException) {\n            println(\"Corrutina cancelada\")\n        }\n    }\n    delay(500)\n    job.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. Si la corrutina es cancelada, se lanza una excepci\u00f3n <code>CancellationException</code> que se puede manejar en el bloque <code>try-catch</code>.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#la-clase-job","title":"La clase Job","text":"<p>En Kotlin, la clase <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un <code>Job</code> representa una unidad de trabajo que se puede cancelar y supervisar. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        obtenerDatos()\n    }\n    delay(500)\n    job.cancel()\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. </p> <p>El objeto <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de la corrutina y se puede utilizar para supervisar su estado. </p> <p>La importancia de Job</p> <p>Job desempe\u00f1a un papel importante para garantizar la simultaneidad estructurada, ya que administra el ciclo de vida de las corrutinas y mantiene la relaci\u00f3n de superior y secundario.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#jerarquia-de-trabajos","title":"Jerarqu\u00eda de trabajos","text":"<p>En Kotlin, la jerarqu\u00eda de trabajos se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un trabajo (Job) representa una unidad de trabajo que se puede cancelar y supervisar. Los trabajos se pueden organizar en una jerarqu\u00eda para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente. </p> <pre><code>suspend fun main() {\n    val parentJob = Job()\n    val childJob1 = Job(parentJob)\n    val childJob2 = Job(parentJob)\n\n    launch(childJob1) {\n        obtenerDatos()\n    }\n    launch(childJob2) {\n        obtenerDatos()\n    }\n\n    delay(500)\n    parentJob.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> crea un trabajo padre y dos trabajos secundarios que se ejecutan en paralelo. Despu\u00e9s de 500 milisegundos, se cancela el trabajo padre utilizando la funci\u00f3n <code>cancel()</code>, lo que cancela todos los trabajos secundarios.</p> <p></p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinescope","title":"CoroutineScope","text":"<p>En Kotlin, el <code>CoroutineScope</code> es una interfaz que define un \u00e1mbito para las corrutinas. </p> <p>Un <code>CoroutineScope</code> se utiliza para crear y gestionar corrutinas en una aplicaci\u00f3n. </p> <pre><code>class MyCoroutineScope : CoroutineScope {\n    private val job = Job()\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + job\n\n    fun cancel() {\n        job.cancel()\n    }\nsuspend fun main() {\n    val scope = MyCoroutineScope()\n    scope.launch {\n        obtenerDatos()\n    }\n    delay(500)\n    scope.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>MyCoroutineScope</code> que implementa la interfaz <code>CoroutineScope</code>. La clase <code>MyCoroutineScope</code> define un \u00e1mbito para las corrutinas utilizando la propiedad <code>coroutineContext</code>, que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>. La clase tambi\u00e9n incluye una funci\u00f3n <code>cancel()</code> que cancela todas las corrutinas en el \u00e1mbito. En la funci\u00f3n <code>main</code>, se crea una instancia de <code>MyCoroutineScope</code> y se utiliza para ejecutar una corrutina que llama a la funci\u00f3n <code>obtenerDatos</code>. Despu\u00e9s de 500 milisegundos, se cancela el \u00e1mbito utilizando la funci\u00f3n <code>cancel()</code>.  </p> <p>launch y async en CoroutineScope</p> <p>launch() y async() son funciones de extension de la interfaz <code>CoroutineScope</code> que se utilizan para crear corrutinas en un \u00e1mbito determinado. La funci\u00f3n <code>launch()</code> se utiliza para crear una corrutina que no devuelve un valor, mientras que la funci\u00f3n <code>async()</code> se utiliza para crear una corrutina que devuelve un valor. Ambas funciones se pueden utilizar en un \u00e1mbito de <code>CoroutineScope</code> para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinecontext","title":"CoroutineContext","text":"<p>En Kotlin, el <code>CoroutineContext</code> es una interfaz que define el contexto en el que se ejecuta una corrutina. </p> <p>Un <code>CoroutineContext</code> se utiliza para definir el despachador, la supervisi\u00f3n y otros elementos del contexto de una corrutina. </p> <p>Es en esencia un mapa que almacena pares clave-valor que se utilizan para definir el contexto de una corrutina. </p> <p>Estos campos no son obligatorios pero algunos de los m\u00e1s comunes son: - <code>Job</code>: Un objeto que representa una unidad de trabajo que se puede cancelar y supervisar. - <code>CoroutineName</code>: Un objeto que representa el nombre de una corrutina. - <code>CoroutineExceptionHandler</code>: Un objeto que maneja las excepciones que se producen en una corrutina.  - <code>Dispatcher</code>: Un objeto que define en qu\u00e9 hilo o grupo de hilos se ejecuta la corrutina. </p> <pre><code>suspend fun main() {\n    val context = Dispatchers.Main + Job()\n    withContext(context) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>.  </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinedispatcher","title":"CoroutineDispatcher","text":"<p>En Kotlin, el <code>CoroutineDispatcher</code> es una interfaz que define el despachador de una corrutina. </p> <p>Un <code>CoroutineDispatcher</code> se utiliza para definir en qu\u00e9 hilo o grupo de hilos se ejecuta una corrutina. </p> <p>Puede utilizar los despachadores predefinidos de Kotlin, como <code>Dispatchers.Main</code>, <code>Dispatchers.IO</code> y <code>Dispatchers.Default</code>, o crear un despachador personalizado.</p> <p>Para crear uno personalizado se puede utilizar la clase <code>ExecutorCoroutineDispatcher</code> de Kotlin. </p> <pre><code>suspend fun main() {\n    val dispatcher = Dispatchers.IO\n    withContext(dispatcher) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que utiliza el despachador <code>Dispatchers.IO</code>.  </p>"},{"location":"temas/01/index.html","title":"UT1 - Visi\u00f3n General y Entorno de desarrollo","text":""},{"location":"temas/01/index.html#ut1-evolucion-y-entornos-de-desarrollo","title":"UT1. Evoluci\u00f3n y Entornos de desarrollo","text":""},{"location":"temas/01/index.html#1-limitaciones-en-el-desarrollo-movil","title":"1. Limitaciones en el desarrollo m\u00f3vil","text":"<p>A menudo, cuando empezamos a programar, venimos de un mundo de desarrollo de escritorio o incluso web, donde los recursos parecen casi infinitos. Un ordenador de sobremesa moderno tiene gigabytes de RAM, procesadores de m\u00faltiples n\u00facleos a altas velocidades, almacenamiento masivo y una conexi\u00f3n a internet estable y r\u00e1pida. Los servidores que alojan aplicaciones web son a\u00fan m\u00e1s potentes.</p> <p>Sin embargo, el entorno m\u00f3vil es un ecosistema completamente diferente. Un smartphone, por muy avanzado que sea, es un dispositivo que llevamos en el bolsillo, alimentado por una bater\u00eda y sujeto a condiciones muy variables. Ignorar estas limitaciones no solo lleva a una mala calificaci\u00f3n en esta asignatura, sino, lo que es peor, a crear aplicaciones que los usuarios desinstalar\u00e1n por ser lentas, consumir su bater\u00eda o no funcionar cuando m\u00e1s las necesitan.</p> <p>Pensemos en un desarrollador de escritorio como el arquitecto de un gran rascacielos con cimientos profundos y acceso a la red el\u00e9ctrica principal. En cambio, un desarrollador m\u00f3vil es como el ingeniero de un coche de F\u00f3rmula 1: cada gramo de peso, cada gota de combustible y cada pieza de la aerodin\u00e1mica cuentan. La optimizaci\u00f3n no es una opci\u00f3n; es una obligaci\u00f3n.</p> <p>A continuaci\u00f3n, vamos a desglosar las principales \u00e1reas de restricci\u00f3n.</p> <ol> <li> <p>Recursos de Hardware: La eterna dieta</p> <p>A pesar de los impresionantes avances, los dispositivos m\u00f3viles operan con recursos de hardware significativamente m\u00e1s modestos que sus hom\u00f3logos de escritorio.</p> <p><code>Procesador (CPU)</code>: Las CPUs m\u00f3viles est\u00e1n dise\u00f1adas con un objetivo principal: la eficiencia energ\u00e9tica. Un procesador de escritorio puede permitirse consumir 100W o m\u00e1s y disipar el calor con grandes ventiladores. Una CPU m\u00f3vil debe operar con un consumo m\u00ednimo para no agotar la bater\u00eda en minutos y sobrecalentar el dispositivo. Esto implica velocidades de reloj m\u00e1s bajas y arquitecturas (como ARM) optimizadas para el bajo consumo, lo que se traduce en una menor capacidad de c\u00f3mputo bruto. Tareas muy intensivas, como el renderizado de v\u00eddeo o c\u00e1lculos complejos, deben ser abordadas con mucho m\u00e1s cuidado.</p> <p><code>Memoria (RAM)</code>: Mientras que un PC de gama media actual puede tener 16 GB o 32 GB de RAM, un smartphone de gama alta puede tener 8 GB o 12 GB, y los de gama media, bastante menos. Adem\u00e1s, el sistema operativo m\u00f3vil (Android o iOS) es muy agresivo a la hora de gestionar esta memoria. Si tu aplicaci\u00f3n consume demasiada RAM, el sistema no dudar\u00e1 en \"matarla\" (finalizar su proceso) sin previo aviso para liberar recursos para la aplicaci\u00f3n que est\u00e1 en primer plano. Esto contrasta con un sistema de escritorio, donde las aplicaciones pueden permanecer en memoria durante d\u00edas.</p> <p><code>Almacenamiento</code>: Aunque los dispositivos modernos ofrecen m\u00e1s almacenamiento, sigue siendo un recurso finito y, a menudo, no ampliable. Las aplicaciones deben ser ligeras. Una aplicaci\u00f3n de escritorio puede ocupar varios gigabytes sin que el usuario se preocupe, pero una app m\u00f3vil que ocupe ese espacio ser\u00e1 una candidata clara a ser eliminada cuando el usuario necesite liberar espacio para sus fotos o v\u00eddeos.</p> </li> <li> <p>La Bater\u00eda: El recurso m\u00e1s preciado</p> <p>Esta es, sin duda, la limitaci\u00f3n m\u00e1s cr\u00edtica y definitoria del desarrollo m\u00f3vil. A diferencia del desarrollo web o de escritorio, donde la alimentaci\u00f3n es constante, en el m\u00f3vil cada ciclo de CPU, cada byte enviado por la red y cada p\u00edxel encendido en la pantalla consume una porci\u00f3n de un recurso muy limitado: la bater\u00eda.</p> <p><code>Consumo energ\u00e9tico</code>: El desarrollador debe ser consciente del impacto energ\u00e9tico de su c\u00f3digo. Dejar un sensor activo (como el GPS) innecesariamente, realizar operaciones de red con demasiada frecuencia (polling) o ejecutar procesos complejos en segundo plano son los caminos m\u00e1s r\u00e1pidos para agotar la bater\u00eda del usuario y ganarse una rese\u00f1a de una estrella en la tienda de aplicaciones.</p> <p><code>Optimizaci\u00f3n del sistema</code>: Los sistemas operativos m\u00f3viles modernos implementan mecanismos muy estrictos para controlar el consumo, como Doze Mode y App Standby en Android. Estos modos ponen las aplicaciones en un estado de \"sue\u00f1o profundo\", restringiendo su acceso a la red y a la CPU cuando el dispositivo no est\u00e1 en uso. El desarrollador ya no tiene control total sobre cu\u00e1ndo se ejecuta su c\u00f3digo en segundo plano.</p> </li> <li> <p>Conectividad: Un mundo inestable y costoso</p> <p>Las aplicaciones de escritorio y web suelen asumir una conexi\u00f3n a internet permanente, r\u00e1pida y de bajo coste (Wi-Fi o Ethernet). En el mundo m\u00f3vil, la realidad es muy diferente.</p> <p><code>Variabilidad de la red</code>: La aplicaci\u00f3n debe funcionar de manera predecible en m\u00faltiples escenarios: una conexi\u00f3n Wi-Fi de alta velocidad, una red 5G, una conexi\u00f3n 4G inestable en un tren, una red 3G lenta en una zona rural, o incluso sin conexi\u00f3n alguna.</p> <p><code>Latencia y ancho de banda</code>: La latencia en redes m\u00f3viles es generalmente mayor que en redes fijas. Las transferencias de datos deben minimizarse. No puedes permitirte descargar 50 MB de datos cada vez que el usuario abre la app. Debes implementar estrategias de cach\u00e9, compresi\u00f3n de datos y sincronizaci\u00f3n inteligente.</p> <p><code>Coste de los datos</code>: A diferencia del Wi-Fi, los datos m\u00f3viles suelen tener un coste para el usuario. Una aplicaci\u00f3n que consuma una cantidad excesiva del plan de datos de un usuario ser\u00e1 desinstalada r\u00e1pidamente. Debes ofrecer opciones para limitar el uso de datos (por ejemplo, descargar contenido pesado solo con Wi-Fi).</p> </li> <li> <p>Fragmentaci\u00f3n del Ecosistema</p> <p>Mientras que en el desarrollo de escritorio se trabaja con un conjunto relativamente est\u00e1ndar de resoluciones de pantalla y capacidades, y en la web se usan t\u00e9cnicas de \"responsive design\", en el m\u00f3vil (especialmente en Android) nos enfrentamos a una fragmentaci\u00f3n extrema.</p> <p><code>Diversidad de pantallas</code>: Existen miles de modelos de dispositivos con diferentes tama\u00f1os de pantalla, densidades de p\u00edxeles (DPI), y relaciones de aspecto. Tu interfaz de usuario (UI) debe adaptarse fluidamente a todas ellas, desde un tel\u00e9fono peque\u00f1o hasta una tablet de gran formato.</p> <p><code>Variedad de Hardware</code>: M\u00e1s all\u00e1 de la pantalla, te encontrar\u00e1s con una enorme diversidad de CPUs, GPUs, cantidad de RAM y sensores disponibles (algunos tienen NFC, otros no; algunos tienen un bar\u00f3metro, la mayor\u00eda no). Tu aplicaci\u00f3n debe ser capaz de gestionar esta diversidad, ya sea adaptando su funcionalidad o informando al usuario de que una caracter\u00edstica no est\u00e1 disponible en su dispositivo.</p> <p><code>Versiones del Sistema Operativo</code>: Especialmente en Android, los usuarios tardan en actualizar sus dispositivos. No es raro tener que dar soporte a varias versiones del sistema operativo simult\u00e1neamente, cada una con sus propias APIs, caracter\u00edsticas y bugs.</p> </li> <li> <p>Ciclo de Vida de la Aplicaci\u00f3n y Restricciones del SO</p> <p>En un ordenador de escritorio, el usuario lanza una aplicaci\u00f3n y esta se ejecuta hasta que \u00e9l decide cerrarla. En un dispositivo m\u00f3vil, el ciclo de vida es mucho m\u00e1s complejo y est\u00e1 gestionado de forma estricta por el sistema operativo.</p> <p><code>Estados de la aplicaci\u00f3n</code>: Una aplicaci\u00f3n m\u00f3vil no est\u00e1 simplemente \"abierta\" o \"cerrada\". Pasa por m\u00faltiples estados (creada, iniciada, en primer plano, pausada, detenida, destruida). Por ejemplo, si entra una llamada mientras el usuario est\u00e1 usando tu app, esta pasar\u00e1 al estado de \"pausada\". Debes guardar el estado del usuario en ese momento para que, al volver, pueda continuar donde lo dej\u00f3.</p> <p><code>Procesos en segundo plano (Background)</code>: Como mencionamos antes, la ejecuci\u00f3n de c\u00f3digo en segundo plano est\u00e1 severamente restringida. No puedes simplemente iniciar un hilo que se ejecute indefinidamente. Debes usar las APIs espec\u00edficas proporcionadas por el sistema (como WorkManager en Android) que permiten al SO ejecutar tu tarea de la forma m\u00e1s eficiente posible (por ejemplo, agrupando tareas de varias apps para despertar al dispositivo una sola vez).</p> </li> </ol> <p>Desarrollar para dispositivos m\u00f3viles es un desaf\u00edo apasionante que requiere un cambio de mentalidad. No se trata de trasladar directamente las pr\u00e1cticas del desarrollo de escritorio o web, sino de abrazar las restricciones y convertirlas en una gu\u00eda para la excelencia en la ingenier\u00eda de software.</p> <p>Una aplicaci\u00f3n m\u00f3vil exitosa no es la que m\u00e1s funcionalidades tiene, sino la que ofrece una experiencia fluida, es respetuosa con los recursos del usuario (bater\u00eda, datos, almacenamiento) y funciona de manera fiable en un entorno impredecible. Recordad siempre: en el mundo m\u00f3vil, la eficiencia no es una caracter\u00edstica, es el cimiento sobre el que se construye todo lo dem\u00e1s.</p>"},{"location":"temas/01/index.html#2-desarrollo-movil-en-la-actualidad-un-ecosistema-de-opciones","title":"2. Desarrollo M\u00f3vil en la Actualidad: Un Ecosistema de Opciones","text":"<p>Hace una d\u00e9cada, las opciones eran limitadas. Hoy, nos encontramos ante un ecosistema rico y diverso con diferentes enfoques, cada uno con sus propias filosof\u00edas, ventajas y desventajas. La elecci\u00f3n de la tecnolog\u00eda es una de las decisiones m\u00e1s cr\u00edticas que tomar\u00e9is como desarrolladores o arquitectos de software, ya que impactar\u00e1 directamente en el presupuesto del proyecto, el tiempo de desarrollo, el rendimiento de la aplicaci\u00f3n y la experiencia final del usuario.</p> <p>El objetivo de este documento es proporcionaros un mapa claro de este territorio. Analizaremos las tres grandes rutas que podemos tomar para construir una aplicaci\u00f3n m\u00f3vil: el desarrollo Nativo, el H\u00edbrido y las Progressive Web Apps (PWA). \u00a1Empecemos!</p>"},{"location":"temas/01/index.html#a-desarrollo-nativo-la-via-de-la-maxima-potencia-y-experiencia","title":"A. Desarrollo Nativo: La V\u00eda de la M\u00e1xima Potencia y Experiencia","text":"<p>El desarrollo nativo consiste en construir una aplicaci\u00f3n utilizando las herramientas, lenguajes y APIs (Application Programming Interfaces) que la propia plataforma provee de forma oficial. En esencia, se crea una aplicaci\u00f3n espec\u00edfica y optimizada para un \u00fanico sistema operativo.</p> <p>\ud83d\udd25 Esto significa que si queremos que nuestra app funcione en Android y en iOS, necesitaremos desarrollar dos aplicaciones separadas, una para cada plataforma, con sus respectivos c\u00f3digos fuente.</p> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Insuperable: La aplicaci\u00f3n se compila a c\u00f3digo m\u00e1quina que se ejecuta directamente sobre el sistema operativo, sin capas intermedias. Esto garantiza la m\u00e1xima velocidad, fluidez y capacidad de respuesta. Es la opci\u00f3n ideal para juegos, aplicaciones con gr\u00e1ficos intensivos o que realicen c\u00e1lculos complejos.</p> </li> <li> <p>Acceso Total al Hardware y APIs: Tienes acceso inmediato y completo a todas las capacidades del dispositivo: GPS, c\u00e1mara, aceler\u00f3metro, NFC, ARKit (iOS), etc. Adem\u00e1s, eres el primero en poder usar las nuevas funcionalidades que se lanzan con cada actualizaci\u00f3n del sistema operativo.</p> </li> <li> <p>Experiencia de Usuario (UX) Perfecta: La interfaz de usuario (UI) se construye con los componentes nativos de la plataforma. El resultado es una aplicaci\u00f3n que se ve y se siente exactamente como el resto del sistema operativo, lo que la hace intuitiva y familiar para el usuario.</p> </li> <li> <p>Mayor Seguridad y Fiabilidad: Al operar directamente sobre la plataforma, se aprovechan todas sus capas de seguridad y optimizaciones.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Para Android:</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Kotlin: Es el lenguaje moderno, conciso y seguro que Google recomienda oficialmente desde 2019. Es interoperable al 100% con Java.</p> </li> <li> <p>Java: Fue el lenguaje original para el desarrollo en Android. Sigue siendo muy utilizado, especialmente en proyectos m\u00e1s antiguos (legacy), pero Kotlin es la opci\u00f3n preferida para nuevos desarrollos.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Android Studio. Es el IDE oficial de Google, basado en IntelliJ IDEA. Incluye todo lo necesario: editor de c\u00f3digo, depurador, emuladores, analizadores de rendimiento, etc.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Android Developers (Oficial) - El punto de partida para todo.</p> </li> <li> <p>Documentaci\u00f3n de Kotlin - Aprende el lenguaje que impulsa el desarrollo moderno de Android.</p> </li> <li> <p>Descargar Android Studio</p> </li> </ul> </li> </ul> <p>Para iOS (Ecosistema Apple)</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Swift: Es el lenguaje moderno, potente y seguro creado por Apple. Es la opci\u00f3n recomendada para cualquier aplicaci\u00f3n nueva en el ecosistema de Apple (iOS, iPadOS, macOS, watchOS).</p> </li> <li> <p>Objective-C: Es el lenguaje original de desarrollo para iOS. Aunque Swift lo ha superado en popularidad, todav\u00eda es fundamental para mantener proyectos existentes.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Xcode. Es el IDE oficial de Apple, que se ejecuta exclusivamente en macOS. Proporciona todas las herramientas para desarrollar, depurar y publicar apps para todas las plataformas de Apple.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Apple Developer (Oficial) - Tu puerta de entrada al desarrollo para iOS.</p> </li> <li> <p>Documentaci\u00f3n de Swift - La gu\u00eda oficial y completa del lenguaje Swift.</p> </li> <li> <p>Descargar Xcode</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-desarrollo-hibrido-un-codigo-para-gobernarlos-a-todos","title":"B. Desarrollo H\u00edbrido: Un C\u00f3digo para Gobernarlos a Todos","text":"<p>El desarrollo h\u00edbrido, tambi\u00e9n conocido como multiplataforma, busca resolver el principal inconveniente del desarrollo nativo: la necesidad de mantener dos bases de c\u00f3digo. La filosof\u00eda aqu\u00ed es \"escribe una vez, ejecuta en todas partes\" (write once, run anywhere).</p> <p>Se utiliza un \u00fanico lenguaje y un framework espec\u00edfico para generar aplicaciones que funcionen tanto en Android como en iOS.</p> <p>Ventajas Clave</p> <ul> <li> <p>Eficiencia en Coste y Tiempo: Es la ventaja m\u00e1s evidente. Se necesita un solo equipo de desarrollo y un \u00fanico c\u00f3digo base, lo que reduce dr\u00e1sticamente los tiempos y costes de desarrollo y mantenimiento.</p> </li> <li> <p>Lanzamiento R\u00e1pido al Mercado (Time-to-Market): Al desarrollar para ambas plataformas simult\u00e1neamente, puedes lanzar tu producto mucho m\u00e1s r\u00e1pido.</p> </li> <li> <p>Consistencia de Marca: La aplicaci\u00f3n tendr\u00e1 una apariencia muy similar en ambas plataformas, lo que puede ser beneficioso para la identidad de marca.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes_1","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Existen diferentes enfoques dentro del mundo h\u00edbrido, pero los m\u00e1s relevantes hoy en d\u00eda son:</p> <p>Flutter</p> <ul> <li> <p>Concepto: Es un toolkit de UI desarrollado por Google que ha ganado una tracci\u00f3n inmensa. Flutter no utiliza los componentes nativos de la UI, sino que trae su propio motor de renderizado (Skia) para dibujar cada p\u00edxel en la pantalla. Esto le da un control total sobre la interfaz y permite animaciones complejas a 60/120 FPS.</p> </li> <li> <p>Lenguaje: Dart. Un lenguaje moderno, orientado a objetos y optimizado para el desarrollo de UI.</p> </li> <li> <p>Ideal para: Aplicaciones con una interfaz de usuario muy personalizada, expresiva y con muchas animaciones.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Flutter (Oficial) - Descubre por qu\u00e9 es una de las tecnolog\u00edas m\u00e1s queridas por los desarrolladores.</p> </li> <li> <p>Documentaci\u00f3n de Dart - Aprende los fundamentos del lenguaje de Flutter.</p> </li> </ul> </li> </ul> <p>React Native</p> <ul> <li> <p>Concepto: Creado por Meta (Facebook), React Native permite a los desarrolladores web usar sus conocimientos de JavaScript y React para crear aplicaciones m\u00f3viles. A diferencia de Flutter, React Native utiliza un \"puente\" (bridge) para comunicarse con los componentes de la UI nativa de cada plataforma. Esto puede hacer que la app se sienta un poco m\u00e1s \"nativa\".</p> </li> <li> <p>Lenguaje: JavaScript o TypeScript (una versi\u00f3n de JavaScript con tipado est\u00e1tico, muy recomendada).</p> </li> <li> <p>Ideal para: Empresas con equipos de desarrollo web que quieran pasar al m\u00f3vil, o para aplicaciones donde el aspecto nativo sea una prioridad.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>React Native (Oficial) - La documentaci\u00f3n oficial para empezar.</li> </ul> </li> </ul> <p>.NET MAUI (Multi-platform App UI)</p> <ul> <li> <p>Concepto: Es la evoluci\u00f3n de Xamarin.Forms, impulsada por Microsoft. Permite a los desarrolladores del ecosistema .NET usar C# y XAML para crear aplicaciones para iOS, Android, Windows y macOS desde una \u00fanica base de c\u00f3digo.</p> </li> <li> <p>Lenguaje: C#.</p> </li> <li> <p>Ideal para: Organizaciones que ya tienen una fuerte inversi\u00f3n en tecnolog\u00edas de Microsoft y .NET.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>.NET MAUI (Oficial) - La plataforma multiplataforma del ecosistema .NET.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-kotlin-multiplatform-kmp-lo-mejor-de-ambos-mundos","title":"C. Kotlin Multiplatform (KMP): \u00bfLo mejor de Ambos mundos?","text":"<p>Hemos analizado el desarrollo Nativo y el H\u00edbrido como dos caminos separados. El primero nos da el m\u00e1ximo rendimiento y la mejor experiencia de usuario a costa de duplicar el trabajo. El segundo nos ofrece eficiencia y una base de c\u00f3digo \u00fanica, pero a veces con compromisos en rendimiento o en acceso a las \u00faltimas funcionalidades nativas.</p> <p>Pero, \u00bfy si existiera un enfoque que intentara combinar la eficiencia del c\u00f3digo compartido con el poder del desarrollo nativo? Aqu\u00ed es donde entra en juego Kotlin Multiplatform (KMP).</p> <p>KMP no es otro framework h\u00edbrido como Flutter o React Native. Es un enfoque radicalmente diferente.</p> <p>La L\u00f3gica Compartida, la UI Nativa</p> <p>La filosof\u00eda de Kotlin Multiplatform, impulsado por JetBrains (los creadores de Kotlin y de IntelliJ), no es \"escribe una vez, ejecuta en todas partes\", sino m\u00e1s bien \"escribe la l\u00f3gica de negocio una vez, y construye la interfaz de usuario de forma nativa\".</p> <p>KMP permite a los desarrolladores escribir c\u00f3digo en Kotlin que puede ser compilado para m\u00faltiples plataformas:</p> <ul> <li>JVM (para aplicaciones Android y de servidor).</li> <li>JavaScript (para aplicaciones web).</li> <li>Nativo (utilizando la infraestructura del compilador LLVM para generar binarios para iOS, macOS, Windows, etc.).</li> </ul> <p>La idea central es identificar el c\u00f3digo que es independiente de la interfaz de usuario ---la l\u00f3gica de negocio--- y compartirlo entre plataformas.</p>"},{"location":"temas/01/index.html#que-es-la-logica-de-negocio","title":"\u00bfQu\u00e9 es la \"L\u00f3gica de Negocio\"?","text":"<p>Piensa en todo lo que tu aplicaci\u00f3n hace \"detr\u00e1s de las c\u00e1maras\":</p> <ul> <li>Acceso a la red: Realizar llamadas a una API REST o GraphQL.</li> <li>Gesti\u00f3n de la base de datos: Guardar, leer y actualizar datos en una base de datos local (como SQLite).</li> <li>Modelos de datos: Las clases que representan la informaci\u00f3n de tu app (Usuario, Producto, etc.).</li> <li>Validaciones: Comprobar que un email tiene el formato correcto o que una contrase\u00f1a cumple los requisitos.</li> <li>Algoritmos y c\u00e1lculos: Cualquier procesamiento de datos espec\u00edfico de tu aplicaci\u00f3n.</li> </ul> <p>Todo este c\u00f3digo, que suele ser el n\u00facleo de la aplicaci\u00f3n, no depende de si el bot\u00f3n en la pantalla es redondo o cuadrado. Por lo tanto, se puede escribir una sola vez en Kotlin y compartirlo.</p>"},{"location":"temas/01/index.html#y-que-pasa-con-la-interfaz-de-usuario-ui","title":"\u00bfY qu\u00e9 pasa con la Interfaz de Usuario (UI)?","text":"<p>Aqu\u00ed es donde KMP brilla y se diferencia de los frameworks h\u00edbridos. La UI se construye de forma 100% nativa en cada plataforma:</p> <ul> <li> <p>En Android: Creas tus vistas (layouts) y gestionas el ciclo de vida de las Activities y Fragments utilizando Jetpack Compose o las vistas XML tradicionales. Desde este c\u00f3digo nativo, llamas a la l\u00f3gica de negocio compartida en Kotlin.</p> </li> <li> <p>En iOS: Desarrollas tu interfaz de usuario con SwiftUI o UIKit, exactamente como lo har\u00eda un desarrollador nativo de iOS. Desde tu c\u00f3digo en Swift, puedes invocar directamente las funciones y clases del m\u00f3dulo de Kotlin compartido.</p> </li> </ul> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Nativo: Dado que la UI y toda la interacci\u00f3n con la plataforma se gestionan con c\u00f3digo nativo, el rendimiento y la fluidez son id\u00e9nticos a los de una aplicaci\u00f3n puramente nativa. No hay \"puentes\" ni capas de abstracci\u00f3n que ralenticen la interfaz.</p> </li> <li> <p>UI/UX Perfecta: La aplicaci\u00f3n se ve, se siente y se comporta exactamente como el usuario espera en su dispositivo, ya que utilizas los componentes nativos de Android (Material Design) y de iOS (Human Interface Guidelines).</p> </li> <li> <p>Eficiencia sin Sacrificios: Compartes una parte significativa del c\u00f3digo (a menudo m\u00e1s del 50-60%), lo que reduce el tiempo de desarrollo, la duplicaci\u00f3n de esfuerzos y la probabilidad de bugs, sin renunciar a las ventajas del desarrollo nativo.</p> </li> <li> <p>Acceso Inmediato a APIs Nativas: Como est\u00e1s escribiendo c\u00f3digo nativo en la capa de UI, puedes acceder a las \u00faltimas APIs de cada sistema operativo desde el primer d\u00eda, sin esperar a que un framework de terceros a\u00f1ada soporte.</p> </li> <li> <p>Adopci\u00f3n Gradual: Puedes empezar a usar KMP en una peque\u00f1a parte de una aplicaci\u00f3n existente, tanto en Android como en iOS, sin necesidad de reescribirla por completo.</p> </li> </ul> <p>Desventajas y Consideraciones</p> <ul> <li> <p>Complejidad Inicial: La configuraci\u00f3n del proyecto puede ser m\u00e1s compleja que en otros enfoques. Requiere conocimientos tanto de desarrollo en Android (Gradle) como en iOS (Xcode, CocoaPods).</p> </li> <li> <p>Se Necesitan Habilidades Nativas: A diferencia del desarrollo h\u00edbrido puro, no basta con un solo equipo de desarrolladores. Necesitas expertos que se sientan c\u00f3modos construyendo la UI en Android (Kotlin/Compose) y en iOS (Swift/SwiftUI).</p> </li> <li> <p>Ecosistema en Crecimiento: Aunque est\u00e1 madurando r\u00e1pidamente, el ecosistema de librer\u00edas multiplataforma todav\u00eda es m\u00e1s peque\u00f1o que el de plataformas como React Native o Flutter.</p> </li> </ul>"},{"location":"temas/01/index.html#un-ecosistema-en-evolucion-compose-multiplatform","title":"Un Ecosistema en Evoluci\u00f3n: Compose Multiplatform","text":"<p>Para a\u00f1adir una capa m\u00e1s, JetBrains est\u00e1 llevando Jetpack Compose (el moderno toolkit de UI declarativa de Android) al mundo multiplataforma con Compose Multiplatform.</p> <p>Compose Multiplatform permite compartir no solo la l\u00f3gica de negocio, sino tambi\u00e9n la interfaz de usuario, utilizando el mismo c\u00f3digo declarativo en Kotlin para describir la UI en Android, iOS , escritorio (Windows, macOS, Linux) y web (Wasm).</p> <p>Esto acerca a KMP al modelo de Flutter, donde tanto la l\u00f3gica como la UI son compartidas, pero con la ventaja de estar construido sobre el lenguaje y el ecosistema de Kotlin.</p> <ul> <li> <p>Recursos para profundizar:</p> <ul> <li>Kotlin Multiplatform (Oficial) - La documentaci\u00f3n oficial y el mejor lugar para empezar.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#d-progressive-web-apps-pwa-la-web-se-viste-de-app","title":"D. Progressive Web Apps (PWA): La Web se Viste de App","text":"<p>Las PWA no son aplicaciones m\u00f3viles en el sentido tradicional. Son aplicaciones web que utilizan las tecnolog\u00edas web m\u00e1s modernas para ofrecer una experiencia muy similar a la de una aplicaci\u00f3n nativa. No se instalan desde una tienda de aplicaciones, sino que el usuario puede \"a\u00f1adirlas a la pantalla de inicio\" directamente desde el navegador.</p> <p>Ventajas Clave</p> <ul> <li> <p>Sin Tiendas de Aplicaciones: No necesitas pasar por los procesos de revisi\u00f3n y publicaci\u00f3n de la App Store de Apple o Google Play. La \"instalaci\u00f3n\" es instant\u00e1nea.</p> </li> <li> <p>Multiplataforma por Definici\u00f3n: Funcionan en cualquier dispositivo que tenga un navegador web moderno (Android, iOS, Windows, macOS, etc.). El mismo c\u00f3digo sirve para todo.</p> </li> <li> <p>Siempre Actualizadas: Al ser una web, el usuario siempre tiene la \u00faltima versi\u00f3n disponible sin necesidad de actualizar nada.</p> </li> <li> <p>Compartibles: Se puede compartir la \"app\" simplemente enviando una URL.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-clave-y-lenguajes","title":"Tecnolog\u00edas Clave y Lenguajes","text":"<p>Las PWA se construyen sobre el est\u00e1ndar de la web.</p> <ul> <li> <p>Lenguajes: HTML5, CSS3, JavaScript/TypeScript.</p> </li> <li> <p>Componentes Esenciales:</p> <ul> <li> <p>HTTPS: Es un requisito de seguridad indispensable.</p> </li> <li> <p>Service Worker: Es un script que el navegador ejecuta en segundo plano. Es la tecnolog\u00eda que permite funcionalidades como el trabajo offline (acceder a la app sin conexi\u00f3n) y las notificaciones push.</p> </li> <li> <p>Web App Manifest: Es un archivo JSON que le dice al navegador c\u00f3mo debe verse y comportarse la aplicaci\u00f3n cuando se \"instala\" (nombre, icono, pantalla de bienvenida, etc.).</p> </li> </ul> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>web.dev by Google (PWA) - Una de las mejores gu\u00edas para entender y construir PWAs.</p> </li> <li> <p>MDN Web Docs: Service Worker API - Documentaci\u00f3n t\u00e9cnica de referencia.</p> </li> </ul> </li> </ul> <p>\u00bfQu\u00e9 tecnolog\u00eda y lenguaje elegir?</p> <p></p>"},{"location":"temas/01/index.html#3-el-ciclo-de-vida-de-una-aplicacion-movil","title":"3. El Ciclo de Vida de una Aplicaci\u00f3n M\u00f3vil","text":"<p>Pensemos en una aplicaci\u00f3n no como un simple programa, sino como un producto con el que un usuario interact\u00faa a lo largo del tiempo. Este viaje, desde que oye hablar de la app hasta que decide eliminarla de su tel\u00e9fono, se conoce como su ciclo de vida. Entender cada fase nos permite tomar mejores decisiones para que nuestra app no solo sea \u00fatil, sino tambi\u00e9n exitosa.</p>"},{"location":"temas/01/index.html#a-descubrimiento-como-me-encuentran","title":"A. Descubrimiento: \"\u00bfC\u00f3mo me encuentran?\"","text":"<p>Esta es la fase de \"marketing\". Nuestra aplicaci\u00f3n ya est\u00e1 terminada y publicada, pero para el usuario, todo empieza aqu\u00ed. \u00bfC\u00f3mo llega un usuario a conocer nuestra existencia entre millones de aplicaciones?</p> <ul> <li> <p>Tiendas de Aplicaciones (App Stores): Son el principal escaparate.</p> <ul> <li> <p>Google Play Store (Android) y Apple App Store (iOS) son los mercados dominantes. Act\u00faan como gigantescos centros comerciales donde los usuarios pueden buscar, explorar categor\u00edas (juegos, productividad, etc.), ver listas de \u00e9xitos (\"Top Ventas\", \"Top Gratuitas\"), y leer rese\u00f1as y valoraciones de otros usuarios.</p> </li> <li> <p>B\u00fasqueda: La mayor\u00eda de los descubrimientos ocurren a trav\u00e9s del buscador de la tienda. Por eso, un buen nombre, un icono atractivo y una descripci\u00f3n clara (lo que se conoce como ASO - App Store Optimization) son cruciales.</p> </li> <li> <p>Recomendaciones Editoriales: Ser destacado por los equipos editoriales de Google o Apple puede catapultar una aplicaci\u00f3n a la fama.</p> </li> </ul> </li> <li> <p>Otros Canales: No todo ocurre en las tiendas.</p> <ul> <li> <p>Buscadores Web: Una b\u00fasqueda en Google puede llevar a la ficha de una aplicaci\u00f3n en la tienda.</p> </li> <li> <p>Redes Sociales y \"Boca a Boca\": Recomendaciones de amigos, influencers o publicidad en plataformas como Instagram, TikTok o X.</p> </li> <li> <p>Medios de Comunicaci\u00f3n: Art\u00edculos en blogs de tecnolog\u00eda o noticias que hablen de nuestra app.</p> </li> <li> <p>Publicidad Directa: Un c\u00f3digo QR en un cartel o un enlace en una web pueden llevar directamente a la p\u00e1gina de instalaci\u00f3n.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-instalacion-te-quiero-en-mi-movil","title":"B. Instalaci\u00f3n: \"Te quiero en mi m\u00f3vil\"","text":"<p>Una vez descubierta la app, el usuario decide \"adquirirla\". Este proceso, aunque parece simple, tiene matices importantes, sobre todo en cuanto a seguridad.</p> <ul> <li> <p>Desde Tiendas Oficiales:</p> <ul> <li> <p>Este es el m\u00e9todo seguro y recomendado.</p> </li> <li> <p>El usuario pulsa el bot\u00f3n \"Instalar\" (en Google Play) o \"Obtener\" (en la App Store).</p> </li> <li> <p>La tienda gestiona todo el proceso de forma segura: verifica la identidad del usuario, descarga el paquete de la aplicaci\u00f3n (<code>.apk</code> en Android, <code>.ipa</code> en iOS) y lo instala en el dispositivo. El sistema operativo coloca el icono de la app en la pantalla de inicio o en el caj\u00f3n de aplicaciones.</p> </li> </ul> </li> <li> <p>Desde Fuentes Externas (\"Sideloading\"):</p> <ul> <li> <p>Esta opci\u00f3n es pr\u00e1cticamente exclusiva de Android. Permite a los usuarios instalar aplicaciones descargando el archivo <code>.apk</code> directamente desde una p\u00e1gina web o una tienda de aplicaciones alternativa (como F-Droid, que se especializa en software de c\u00f3digo abierto).</p> </li> <li> <p>Riesgos de Seguridad: El \"sideloading\" es la principal v\u00eda de entrada de malware en Android. La aplicaci\u00f3n no ha pasado los controles de seguridad de Google Play, por lo que podr\u00eda contener software malicioso.</p> </li> <li> <p>Por defecto, Android bloquea estas instalaciones. El usuario debe conceder expl\u00edcitamente permiso a la aplicaci\u00f3n (por ejemplo, al navegador Chrome) para \"instalar aplicaciones desconocidas\", asumiendo el riesgo que conlleva.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-ejecucion-a-funcionar","title":"C. Ejecuci\u00f3n: \"\u00a1A funcionar!\"","text":"<p>Una vez instalada, la aplicaci\u00f3n est\u00e1 lista para ser utilizada. Al pulsar su icono por primera vez, ocurren varias cosas:</p> <ol> <li> <p>Carga en Memoria: El sistema operativo carga el c\u00f3digo de la aplicaci\u00f3n en la memoria RAM del dispositivo.</p> </li> <li> <p>Pantalla de Bienvenida (Splash Screen): A menudo se muestra una pantalla de inicio con el logo de la app mientras se cargan los recursos necesarios en segundo plano.</p> </li> <li> <p>Solicitud de Permisos: \u00a1Un paso fundamental! Las aplicaciones ya no reciben todos los permisos al instalarse. Ahora, deben solicitar acceso a funciones sensibles en tiempo de ejecuci\u00f3n, es decir, la primera vez que necesitan usarlas.</p> <ul> <li> <p>Ejemplo: Una app de mensajer\u00eda pedir\u00e1 acceso a tus contactos cuando intentes buscar a un amigo, y pedir\u00e1 acceso a la c\u00e1mara cuando pulses el bot\u00f3n para hacer una foto.</p> </li> <li> <p>El usuario puede Aceptar o Denegar cada permiso individualmente. Como desarrolladores, debemos gestionar qu\u00e9 ocurre si un usuario deniega un permiso esencial.</p> </li> </ul> </li> </ol> <p>Una vez configurada y con los permisos necesarios, la aplicaci\u00f3n se encuentra en su estado normal de uso, interactuando con el usuario.</p>"},{"location":"temas/01/index.html#d-actualizacion-mejorando-contigo","title":"D. Actualizaci\u00f3n: \"Mejorando contigo\"","text":"<p>Una aplicaci\u00f3n no es un producto est\u00e1tico. El software necesita evolucionar para seguir siendo \u00fatil y seguro.</p> <ul> <li> <p>Motivos para una Actualizaci\u00f3n:</p> <ul> <li> <p>Nuevas Funcionalidades: A\u00f1adir caracter\u00edsticas que los usuarios han pedido o que mejoran el producto.</p> </li> <li> <p>Correcci\u00f3n de Errores (Bugs): Ning\u00fan software es perfecto. Las actualizaciones solucionan fallos y problemas de estabilidad.</p> </li> <li> <p>Mejoras de Rendimiento: Optimizar el c\u00f3digo para que la app sea m\u00e1s r\u00e1pida o consuma menos bater\u00eda.</p> </li> <li> <p>Parches de Seguridad: Solucionar vulnerabilidades que podr\u00edan poner en riesgo los datos del usuario.</p> </li> </ul> </li> <li> <p>Proceso de Actualizaci\u00f3n:</p> <ul> <li> <p>Autom\u00e1ticas: Es el m\u00e9todo m\u00e1s com\u00fan. Las tiendas de aplicaciones descargan e instalan las nuevas versiones en segundo plano, generalmente cuando el dispositivo est\u00e1 conectado a una red Wi-Fi y cargando, para no molestar al usuario.</p> </li> <li> <p>Manuales: El usuario puede ir a la secci\u00f3n \"Mis aplicaciones\" de la tienda y forzar la actualizaci\u00f3n de una o todas las apps pendientes.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#e-borrado-desinstalacion-ha-sido-un-placer","title":"E. Borrado (Desinstalaci\u00f3n): \"Ha sido un placer\"","text":"<p>Llega un momento en que el usuario ya no necesita la aplicaci\u00f3n. El proceso de desinstalaci\u00f3n est\u00e1 dise\u00f1ado para ser simple, pero es importante saber qu\u00e9 se elimina y qu\u00e9 puede quedar.</p> <ul> <li> <p>Proceso Est\u00e1ndar: El usuario realiza una pulsaci\u00f3n larga sobre el icono de la app y selecciona la opci\u00f3n \"Desinstalar\" o \"Eliminar App\".</p> </li> <li> <p>\u00bfDesinstalaci\u00f3n Completa o Parcial?</p> <ul> <li> <p>Generalmente, la desinstalaci\u00f3n que realiza el usuario es completa desde el punto de vista de la aplicaci\u00f3n en s\u00ed. El sistema operativo elimina:</p> <ol> <li> <p>El paquete de la aplicaci\u00f3n (<code>.apk</code> / <code>.ipa</code>).</p> </li> <li> <p>El almacenamiento privado de la app (su \"sandbox\"). Aqu\u00ed se guardan las configuraciones, bases de datos internas, cach\u00e9 y otros archivos que la app necesita para funcionar.</p> </li> </ol> </li> <li> <p>\u00bfQu\u00e9 puede quedar (Datos Residuales)? A veces, la desinstalaci\u00f3n no elimina el 100% de los datos asociados. Esto no es una \"desinstalaci\u00f3n parcial\" que el usuario elige, sino una consecuencia de c\u00f3mo funcionan los sistemas de archivos.</p> <ul> <li> <p>Archivos en Almacenamiento Compartido: Si tu aplicaci\u00f3n de edici\u00f3n de fotos guard\u00f3 una imagen en la carpeta <code>DCIM/MisFotos</code>, ese archivo no se borrar\u00e1 al desinstalar la app. El sistema lo considera propiedad del usuario, no de la aplicaci\u00f3n.</p> </li> <li> <p>Datos en la Nube: Si el usuario cre\u00f3 una cuenta en tus servidores, esa cuenta y sus datos asociados (perfil, historial, etc.) permanecen en la nube. No se eliminan al borrar la app del tel\u00e9fono. El usuario tendr\u00eda que eliminar su cuenta expl\u00edcitamente.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#comparativa-de-ciclos-de-vida-web-vs-pwa-vs-nativa","title":"Comparativa de Ciclos de Vida -- Web vs PWA vs Nativa","text":"Fase Ciclo Vida \ud83c\udf10 Web Tradicional \ud83d\ude80 Progressive Web App (PWA) \ud83d\udcf1 Aplicaci\u00f3n 1. Descubrimiento M\u00e1xima visibilidad. A trav\u00e9s de buscadores (Google, etc.), enlaces, redes sociales. No depende de una tienda. Lo mejor de ambos mundos. Descubrible como una web (buscadores, enlaces) y potencialmente listada en tiendas de apps (ej. Google Play). Dependiente de la tienda. Principalmente a trav\u00e9s de la App Store y Google Play. El ASO es crucial. 2. Instalaci\u00f3n Sin instalaci\u00f3n. La principal ventaja. El usuario accede al instante. Cero fricci\u00f3n. Instalaci\u00f3n opcional y ligera. El usuario puede \"A\u00f1adir a la pantalla de inicio\". Es un proceso casi instant\u00e1neo y no ocupa mucho espacio. Instalaci\u00f3n obligatoria. El usuario debe ir a la tienda, descargar varios MB (o GB) y esperar a que se instale. Es el punto de mayor fricci\u00f3n. 3.  Ejecuci\u00f3n Dentro del navegador. Se ejecuta en una pesta\u00f1a, con las limitaciones de la interfaz del navegador (barra de URL, etc.). Requiere conexi\u00f3n. Como una app. Se lanza desde su propio icono en la pantalla de inicio, a pantalla completa. Puede funcionar offline gracias al Service Worker. Directamente en el SO. Se lanza desde su icono. Ofrece la m\u00e1xima integraci\u00f3n, rendimiento y acceso completo al hardware del dispositivo (c\u00e1mara, GPS, etc.). 4. Actualizaci\u00f3n Transparente e instant\u00e1nea. Cada vez que el usuario entra, recibe la \u00faltima versi\u00f3n del servidor. No hay proceso de actualizaci\u00f3n. Autom\u00e1tica y en segundo plano. El Service Worker busca y actualiza la app de forma silenciosa. El usuario tiene la nueva versi\u00f3n la pr\u00f3xima vez que la abre. Gestionada por la tienda. Puede ser autom\u00e1tica o manual. Requiere descargar de nuevo el paquete completo o una parte, y un proceso de instalaci\u00f3n. 5. Borrado No existe. El usuario simplemente cierra la pesta\u00f1a o borra el historial/cach\u00e9 del navegador. Sencillo. El usuario elimina el icono de la pantalla de inicio, igual que en una app nativa. Los datos se pueden borrar desde la configuraci\u00f3n del navegador. Proceso manual. El usuario debe realizar una desinstalaci\u00f3n expl\u00edcita (pulsaci\u00f3n larga, etc.) para liberar el espacio de almacenamiento. <p>\u26a1 An\u00e1lisis Detallado de las Diferencias</p>"},{"location":"temas/01/index.html#friccion-en-la-entrada-la-gran-diferencia","title":"Fricci\u00f3n en la Entrada: La Gran Diferencia","text":"<p>La principal ventaja de la web y las PWAs es la inmediatez. Piensa en cu\u00e1ntas veces has entrado a una web que no conoc\u00edas frente a cu\u00e1ntas apps nuevas has instalado en el \u00faltimo mes. El proceso de ir a una tienda, esperar la descarga y la instalaci\u00f3n es una barrera (fricci\u00f3n) que hace que muchos usuarios abandonen el proceso. Una PWA elimina casi por completo esa barrera, ofreciendo una experiencia similar a la nativa con la facilidad de acceso de una web.</p>"},{"location":"temas/01/index.html#capacidades-y-acceso-al-dispositivo","title":"Capacidades y Acceso al Dispositivo","text":"<p>Aqu\u00ed es donde la aplicaci\u00f3n nativa sigue siendo la reina.</p> <ul> <li> <p>Web: Est\u00e1 limitada por el \"sandbox\" (caja de arena) del navegador. Tiene acceso limitado a sensores y hardware.</p> </li> <li> <p>PWA: Mejora mucho respecto a la web. Gracias a las nuevas APIs, puede acceder a notificaciones push, ubicaci\u00f3n, c\u00e1mara y funcionamiento offline. Sin embargo, todav\u00eda tiene un acceso m\u00e1s restringido que una app nativa, especialmente en iOS.</p> </li> <li> <p>Nativa: Tiene acceso total y de m\u00e1ximo rendimiento a todas las capacidades del dispositivo: NFC, Bluetooth avanzado, sensores, archivos del sistema, etc.</p> </li> </ul>"},{"location":"temas/01/index.html#el-proceso-de-actualizacion-control-vs-inmediatez","title":"El Proceso de Actualizaci\u00f3n: Control vs. Inmediatez","text":"<ul> <li> <p>El modelo nativo da al usuario (y al desarrollador) un mayor control sobre las versiones. A veces, los usuarios deciden no actualizar una app si no les gusta la nueva versi\u00f3n.</p> </li> <li> <p>El modelo web/PWA es mucho m\u00e1s \u00e1gil. Como desarrollador, te aseguras de que todos tus usuarios est\u00e1n utilizando siempre la \u00faltima versi\u00f3n, lo que simplifica enormemente el mantenimiento y la correcci\u00f3n de errores. No tienes que dar soporte a versiones antiguas.</p> </li> </ul> <p>No hay una tecnolog\u00eda superior a las otras en todos los aspectos. La elecci\u00f3n depende enteramente del prop\u00f3sito del proyecto.</p> <ul> <li> <p>Para una herramienta que necesita el m\u00e1ximo rendimiento y una integraci\u00f3n profunda con el hardware (un juego, una app de edici\u00f3n de v\u00eddeo, una app que use Bluetooth intensivamente), el camino nativo es indiscutible.</p> </li> <li> <p>Para un blog, una tienda online o una herramienta de consulta donde la inmediatez y el alcance son lo m\u00e1s importante, una PWA es una soluci\u00f3n fant\u00e1stica, ya que combina la visibilidad de la web con una experiencia de usuario muy mejorada.</p> </li> <li> <p>Una web tradicional sigue siendo perfecta para contenido informativo simple o sitios donde la funcionalidad offline y las notificaciones no aportan un valor a\u00f1adido significativo.</p> </li> </ul>"},{"location":"temas/01/index.html#android-el-sdk-de-android-y-sus-versiones","title":"Android: El SDK de Android y sus Versiones","text":"<p>En este apartado vamos a desmontar la \"caja de herramientas\" que nos permite construir aplicaciones para Android. Hablaremos del SDK, de sus componentes y de c\u00f3mo entender el sistema de versiones de Android, que es crucial para garantizar que nuestras apps funcionen correctamente en la mayor\u00eda de dispositivos posibles.</p> <p>Pensemos en nosotros como chefs que quieren preparar un plato espec\u00edfico (nuestra app). El SDK ser\u00eda nuestra cocina profesional: no solo nos da los ingredientes (las APIs), sino tambi\u00e9n los cuchillos, los fogones y los manuales de recetas (las herramientas y la documentaci\u00f3n). Sin esta cocina, solo tendr\u00edamos ideas, pero no podr\u00edamos cocinar nada.</p>"},{"location":"temas/01/index.html#a-que-es-un-sdk-software-development-kit","title":"A. \u00bfQu\u00e9 es un SDK (Software Development Kit)?","text":"<p>Un SDK, o Kit de Desarrollo de Software, es un conjunto de herramientas de software y programas proporcionados por un fabricante de hardware o software para permitir la creaci\u00f3n de aplicaciones para una plataforma espec\u00edfica. En nuestro caso, Google nos proporciona el SDK de Android para que podamos crear apps para su sistema operativo.</p> <p>Un SDK t\u00edpicamente incluye:</p> <ul> <li> <p>Bibliotecas de c\u00f3digo (APIs): C\u00f3digo preescrito que nos da acceso a las funcionalidades del dispositivo, como la c\u00e1mara, el GPS o la interfaz de usuario.</p> </li> <li> <p>Depurador (Debugger): Una herramienta para encontrar y corregir errores en nuestro c\u00f3digo.</p> </li> <li> <p>Documentaci\u00f3n: Manuales, gu\u00edas y ejemplos que nos ense\u00f1an a usar las herramientas y las bibliotecas.</p> </li> <li> <p>Emuladores: Programas que nos permiten probar nuestra app en un dispositivo virtual sin necesidad de tener un tel\u00e9fono f\u00edsico.</p> </li> </ul> <p>En resumen, el SDK es el paquete TODO-EN-UNO indispensable para empezar a desarrollar.</p>"},{"location":"temas/01/index.html#b-los-componentes-del-sdk-de-android","title":"B. Los Componentes del SDK de Android","text":"<p>Dentro de Android Studio, el SDK se gestiona a trav\u00e9s del \"SDK Manager\" y se divide principalmente en dos pesta\u00f1as: SDK Platforms y SDK Tools. Es vital entender la diferencia.</p>"},{"location":"temas/01/index.html#sdk-platforms","title":"SDK Platforms","text":"<p>Piensa en una \"Platform\" como una versi\u00f3n espec\u00edfica y completa del sistema operativo Android empaquetada para el desarrollador. Cada \"Platform\" corresponde a un nivel de API concreto (que veremos m\u00e1s adelante).</p> <p>Cada paquete de \"SDK Platform\" incluye:</p> <ul> <li> <p>El <code>android.jar</code>: Este es el archivo clave. Contiene todas las APIs y clases de esa versi\u00f3n de Android contra las que compilaremos nuestro c\u00f3digo. Es nuestro \"diccionario\" de funcionalidades disponibles.</p> </li> <li> <p>Imagen del Sistema (System Image): Es una copia del sistema operativo Android que se usa para ejecutar los emuladores. Si quieres probar tu app en un emulador de Android 14, necesitas descargar la \"System Image\" de Android 14.</p> </li> </ul> <p>En resumen: Si quieres que tu app use funciones de Android 14 y probarla en un emulador de Android 14, necesitas descargar la \"SDK Platform\" para el nivel de API de Android 14.</p>"},{"location":"temas/01/index.html#sdk-tools","title":"SDK Tools","text":"<p>Estas son las herramientas independientes de la versi\u00f3n de Android que usamos para desarrollar, depurar y probar nuestra aplicaci\u00f3n. Son la maquinaria de nuestra cocina. No importa si cocinamos una receta de 2020 o de 2024, los fogones y cuchillos son los mismos (aunque se afilen y mejoren de vez en cuando).</p> <p>Las herramientas m\u00e1s importantes aqu\u00ed son:</p> <ul> <li> <p>Android SDK Build-Tools: Un conjunto de herramientas que toman nuestro c\u00f3digo y lo compilan y empaquetan en un archivo <code>.apk</code> o <code>.aab</code> instalable.</p> </li> <li> <p>Android Emulator: El software que nos permite crear y ejecutar dispositivos virtuales.</p> </li> <li> <p>Android SDK Platform-Tools: Incluye herramientas de l\u00ednea de comandos esenciales como:</p> <ul> <li> <p>ADB (Android Debug Bridge): El \"puente\" de comunicaci\u00f3n entre nuestro ordenador y el dispositivo (f\u00edsico o emulado). Nos permite instalar apps, depurar, ver logs, etc.</p> </li> <li> <p>Fastboot: Para flashear el firmware del dispositivo.</p> </li> </ul> </li> </ul> <p>En resumen: Las SDK Tools son las herramientas generales para construir y probar, mientras que las SDK Platforms son los \"ingredientes\" espec\u00edficos de cada versi\u00f3n de Android.</p>"},{"location":"temas/01/index.html#c-entendiendo-las-versiones-de-android-la-clave-esta-en-el-nivel-de-api","title":"C. Entendiendo las Versiones de Android: \u00a1La Clave est\u00e1 en el Nivel de API!","text":"<p>Aqu\u00ed es donde muchos estudiantes se l\u00edan. Google usa dos nombres para cada versi\u00f3n de Android, y es crucial saber cu\u00e1l es el importante para nosotros, los desarrolladores.</p>"},{"location":"temas/01/index.html#nombre-comercial-y-postre","title":"Nombre Comercial (y postre \ud83c\udf70)","text":"<p>Es el nombre p\u00fablico y de marketing que Google utiliza para cada gran lanzamiento. Suelen ser nombres de postres o dulces en orden alfab\u00e9tico (aunque esta tradici\u00f3n se ha relajado en los \u00faltimos a\u00f1os).</p> <ul> <li>Ejemplos: Android 8 (Oreo), Android 9 (Pie), Android 10, Android 11, Android 12 (Snow Cone).</li> </ul> <p>Este nombre es \u00fatil para los usuarios, pero casi irrelevante para los desarrolladores. Es una etiqueta de marketing.</p>"},{"location":"temas/01/index.html#nivel-de-api-api-level","title":"Nivel de API (API Level)","text":"<p>Este es el n\u00famero que realmente nos importa. El Nivel de API es un \u00fanico n\u00famero entero que identifica de forma inequ\u00edvoca la versi\u00f3n del framework de APIs que ofrece una plataforma Android.</p> <p>Cuando se lanzan nuevas funcionalidades para desarrolladores (por ejemplo, un nuevo tipo de notificaci\u00f3n o un permiso de privacidad), Google incrementa el Nivel de API.</p> <p>\u00bfPor qu\u00e9 es tan importante? Porque nuestro c\u00f3digo se escribe \"contra\" un nivel de API. Si usamos una funci\u00f3n que se introdujo en el API Level 33 (Android 13), nuestra aplicaci\u00f3n no funcionar\u00e1 en un dispositivo con API Level 32 (Android 12L), porque esa funci\u00f3n simplemente no existe en ese sistema operativo. \u00a1La app \"crashear\u00e1\"!</p>"},{"location":"temas/01/index.html#d-listado-de-versiones-de-android","title":"D. Listado de Versiones de Android","text":"<p>Las versiones de Android incluyen nombres de dulces y postres como\u00a0Cupcake, Donut, Eclair, Froyo, Gingerbread, Honeycomb, Ice Cream Sandwich, Jelly Bean, KitKat, Lollipop, Marshmallow, Nougat, Oreo y Pie.\u00a0Posteriormente, a partir de Android 10, se han numerado las versiones (Android 10, 11, 12, 13, 14, 15, etc.).\u00a0</p> <p>Versiones antiguas (con nombres de postres)\u00a0</p> <ul> <li>Android 1.5\u00a0- Cupcake</li> <li>Android 1.6\u00a0- Donut</li> <li>Android 2.0/2.1\u00a0- Eclair</li> <li>Android 2.2\u00a0- Froyo</li> <li>Android 2.3\u00a0- Gingerbread</li> <li>Android 3.0\u00a0- Honeycomb</li> <li>Android 4.0\u00a0- Ice Cream Sandwich</li> <li>Android 4.1 - 4.3\u00a0- Jelly Bean</li> <li>Android 4.4\u00a0- KitKat</li> <li>Android 5.0/5.1\u00a0- Lollipop</li> <li>Android 6.0\u00a0- Marshmallow</li> <li>Android 7.0/7.1\u00a0- Nougat</li> <li>Android 8.0/8.1\u00a0- Oreo</li> <li>Android 9.0\u00a0- Pie</li> </ul> <p>Versiones recientes (numeradas)\u00a0</p> <ul> <li>Android 10\u00a0- Fue la primera versi\u00f3n sin nombre de postre.</li> <li>Android 11\u00a0- Lanzada en 2020.</li> <li>Android 12\u00a0- Lanzada en 2021, con una variante optimizada para pantallas grandes llamada Android 12L.</li> <li>Android 13\u00a0- Lanzada en 2022.</li> <li>Android 14\u00a0- Lanzada en 2023.</li> <li>Android 15\u00a0- Lanzada en 2024.</li> <li>Android 16\u00a0- Lanzada en 2025.</li> </ul> <p>C\u00f3mo verificar la versi\u00f3n de Android en tu dispositivo\u00a0</p> <ul> <li>Abre la aplicaci\u00f3n Configuraci\u00f3n o Ajustes.</li> <li>Despl\u00e1zate hacia abajo y selecciona Acerca del tel\u00e9fono o Acerca de la tablet.</li> <li>Busca la opci\u00f3n Versi\u00f3n de Android para ver la informaci\u00f3n de tu sistema operativo.</li> </ul> <p>\u2139\ufe0f M\u00e1s informaci\u00f3n en: Lista de versiones de Android</p>"},{"location":"temas/02/index.html","title":"Inicio","text":""},{"location":"temas/02/index.html#ut2-programacion-de-aplicaciones-para-dispositivos-moviles-en-android","title":"UT2. Programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android","text":"<p>En este tema veremos una visi\u00f3n general de la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android, comenzando a crear las primeras aplicaciones, y entendiendo los conceptos b\u00e1sicos de la plataforma Android.</p> <p>Android permite crear aplicaciones utilizando Java o Kotlin, siendo este \u00faltimo el lenguaje recomendado por Google para el desarrollo de aplicaciones Android.</p> <ul> <li>En lenguaje Kotlin</li> </ul> <p>\u00cdndice:</p> <ul> <li>2.1 Primeros pasos</li> <li>2.2 Ciclo de vida de una aplicaci\u00f3n Android</li> <li>2.3 Primera aplicaci\u00f3n</li> </ul> <p></p>"},{"location":"temas/02/index.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html","title":"2.1. Primeros pasos","text":""},{"location":"temas/02/2.1-primeros-pasos.html#21-primeros-pasos-con-android","title":"2.1 Primeros pasos con Android","text":"<p>En este apartado vamos a dar los primeros pasos en la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles con Android, y en este punto, la parte fundamental es conocer el entorno de desarrollo Android Studio, y entender los conceptos b\u00e1sicos de la plataforma Android.</p>"},{"location":"temas/02/2.1-primeros-pasos.html#a-instalar-y-configurar-android-studio","title":"A. Instalar y configurar Android Studio","text":"<p>Para comenzar a desarrollar aplicaciones Android, lo primero que necesitas es instalar Android Studio, que es el entorno de desarrollo oficial para Android. Puedes descargarlo desde la p\u00e1gina oficial de Android Studio: https://developer.android.com/studio.</p> <p>Una vez que hayas descargado e instalado Android Studio, sigue estos pasos para configurarlo:</p> <ol> <li>Instalar el SDK de Android: Durante la instalaci\u00f3n de Android Studio, aseg\u00farate de seleccionar la opci\u00f3n para instalar el SDK de Android. Esto es necesario para compilar y ejecutar aplicaciones Android.</li> <li>Configurar un emulador: Android Studio incluye un emulador que te permite probar tus aplicaciones en diferentes dispositivos virtuales. Configura un emulador con las caracter\u00edsticas que desees (tama\u00f1o de pantalla, versi\u00f3n de Android, etc.) desde el AVD Manager (Android Virtual Device Manager).</li> <li>Crear un nuevo proyecto: Una vez que Android Studio est\u00e9 configurado, crea un nuevo proyecto seleccionando y elige una plantilla b\u00e1sica para comenzar.</li> <li>Familiarizarse con la interfaz: T\u00f3mate un tiempo para explorar la interfaz de Android Studio, incluyendo el editor de c\u00f3digo, el dise\u00f1ador de interfaces, el panel de herramientas y la consola de logcat.</li> <li>Ejecutar la aplicaci\u00f3n: Finalmente, ejecuta tu aplicaci\u00f3n en el emulador o en un dispositivo f\u00edsico conectado para asegurarte de que todo est\u00e9 funcionando correctamente.</li> </ol> Video: Instalaci\u00f3n y configuraci\u00f3n de Android Studio <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#b-estructura-de-un-proyecto-android","title":"B. Estructura de un proyecto Android","text":"<p>Un proyecto Android tiene una estructura espec\u00edfica que incluye varios archivos y carpetas importantes. A continuaci\u00f3n, se describen las principales partes de un proyecto Android. Android Studio tiene diferentes vistas para explorar la estructura de un proyecto. La vista \"Android\" es la m\u00e1s com\u00fan y muestra una estructura simplificada y organizada del proyecto.</p> <p>Vamos a explorar las diferentes vistas disponibles en Android Studio para entender mejor la estructura de un proyecto Android en el siguiente v\u00eddeo:</p> Video: Estructura de un proyecto en Android Studio <p></p> <p>La vista m\u00e1s com\u00fan y utilizada es la vista \"Android\", que organiza los archivos y carpetas de manera l\u00f3gica para facilitar la navegaci\u00f3n y el desarrollo. A continuaci\u00f3n, se describen las principales partes de un proyecto Android en la vista \"Android\".</p> <p>Estructura de un proyecto Android</p> <p>Esta es la estructura t\u00edpica de un proyecto Android en la vista \"Android\" de Android Studio:</p> <ul> <li>app: Esta es la carpeta principal que contiene el c\u00f3digo fuente y los recursos de la aplicaci\u00f3n.<ul> <li>manifests: Contiene el archivo <code>AndroidManifest.xml</code>, que define la configuraci\u00f3n b\u00e1sica de la aplicaci\u00f3n, como las actividades, permisos y servicios.</li> <li>java: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n en lenguaje Kotlin o Java. Aqu\u00ed es donde escribir\u00e1s la l\u00f3gica de tu aplicaci\u00f3n.</li> <li>res: Contiene los recursos de la aplicaci\u00f3n, como im\u00e1genes, archivos XML de dise\u00f1o, cadenas de texto y estilos.</li> <li>drawable: Carpeta para almacenar im\u00e1genes y gr\u00e1ficos utilizados en la aplicaci\u00f3n.</li> <li>layout: Carpeta para almacenar archivos XML que definen la interfaz de usuario (UI) de las actividades y fragmentos.</li> <li>values: Carpeta para almacenar archivos XML que contienen recursos como cadenas de texto, colores y estilos.</li> </ul> </li> <li>Gradle Scripts: Contiene los archivos de configuraci\u00f3n de Gradle, que es el sistema de construcci\u00f3n utilizado por Android Studio. Aqu\u00ed puedes definir dependencias, versiones de SDK y otras configuraciones de construcci\u00f3n.</li> <li>build.gradle (Project): Archivo de configuraci\u00f3n a nivel de proyecto.</li> <li>build.gradle (Module: app): Archivo de configuraci\u00f3n a nivel de m\u00f3dulo (aplicaci\u00f3n).</li> <li>settings.gradle: Archivo que define los m\u00f3dulos del proyecto.</li> <li>local.properties: Archivo que contiene la ruta del SDK de Android en tu sistema. Este archivo no debe ser compartido en sistemas de control de versiones.</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html#c-estructura-del-buildgradle","title":"C. Estructura del build.gradle","text":"<p>El archivo <code>build.gradle</code> es un archivo de configuraci\u00f3n utilizado por Gradle, el sistema de construcci\u00f3n utilizado por Android Studio. Este archivo define c\u00f3mo se debe construir y empaquetar la aplicaci\u00f3n, as\u00ed como las dependencias necesarias para el proyecto.</p> <p>\u00bfQu\u00e9 es Gradle?</p> <p>Gradle es un sistema de automatizaci\u00f3n de construcci\u00f3n que se utiliza para compilar, probar y empaquetar aplicaciones. En el contexto de Android, Gradle se utiliza para gestionar las dependencias, configurar las variantes de construcci\u00f3n y definir tareas personalizadas.</p> <p>El archivo <code>build.gradle</code> se encuentra en la ra\u00edz del proyecto y en el m\u00f3dulo de la aplicaci\u00f3n (generalmente llamado <code>app</code>). A continuaci\u00f3n, se describen las principales secciones y configuraciones que puedes encontrar en un archivo <code>build.gradle</code> t\u00edpico para un proyecto Android.</p> <p>En el siguiente v\u00eddeo se explica la estructura del archivo <code>build.gradle</code> y c\u00f3mo configurarlo para un proyecto Android.</p> Video: Estructura del build.gradle de App <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#d-partes-de-la-interfaz-de-android-studio","title":"D. Partes de la interfaz de Android Studio","text":"<p>Android Studio es un entorno de desarrollo integrado (IDE) completo que proporciona una amplia gama de herramientas y caracter\u00edsticas para desarrollar aplicaciones Android. A continuaci\u00f3n, se describen las principales partes de la interfaz de Android Studio:</p> Video: Partes de la interfaz de Android Studio <p></p> Partes de la interfaz de Android Studio <ul> <li> <p>Barra de men\u00fa: La barra de men\u00fa en la parte superior de la ventana proporciona acceso a diversas funciones y configuraciones, como crear nuevos proyectos, abrir archivos, ejecutar aplicaciones y acceder a herramientas de desarrollo.</p> </li> <li> <p>Barra de herramientas: Justo debajo de la barra de men\u00fa, la barra de herramientas contiene botones para acciones comunes, como ejecutar y depurar aplicaciones, sincronizar el proyecto con Gradle y acceder al AVD Manager.</p> </li> <li> <p>Panel del proyecto: En el lado izquierdo de la ventana, el panel del proyecto muestra la estructura del proyecto y permite navegar por los archivos y carpetas del proyecto. Puedes cambiar entre diferentes vistas, como \"Android\", \"Project\" y \"Packages\".</p> </li> <li> <p>Editor de c\u00f3digo: El editor de c\u00f3digo ocupa la mayor parte de la ventana y es donde escribir\u00e1s y editar\u00e1s el c\u00f3digo fuente de tu aplicaci\u00f3n. El editor ofrece caracter\u00edsticas como resaltado de sintaxis, autocompletado y refactorizaci\u00f3n.</p> </li> <li> <p>Dise\u00f1ador de interfaces: Android Studio incluye un dise\u00f1ador visual que te permite crear y editar interfaces de usuario (UI) utilizando un editor gr\u00e1fico. Puedes arrastrar y soltar componentes UI desde una paleta y ajustar sus propiedades.</p> </li> <li> <p>Panel de herramientas: En el lado derecho de la ventana, el panel de herramientas proporciona acceso a diversas herramientas \u00fatiles, como el inspector de dise\u00f1o, el administrador de dispositivos virtuales (AVD Manager) y el administrador de SDK.</p> </li> <li> <p>Consola de logcat: En la parte inferior de la ventana, la consola de logcat muestra los mensajes de registro generados por la aplicaci\u00f3n en ejecuci\u00f3n. Esto es \u00fatil para depurar y solucionar problemas en tu aplicaci\u00f3n.</p> </li> <li> <p>Ventana emergente de terminal: Android Studio incluye una terminal integrada que te permite ejecutar comandos directamente desde el IDE. Puedes abrirla desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Terminal\".</p> </li> <li> <p>Ventana emergente de problemas: Esta ventana muestra advertencias y errores relacionados con el c\u00f3digo fuente y las configuraciones del proyecto. Puedes acceder a ella desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Problems\".</p> </li> <li> <p>Ventana emergente de estructura: La ventana emergente de estructura muestra una vista jer\u00e1rquica del archivo actualmente abierto en el editor. Puedes acceder a ella desde el men\u00fa \"</p> </li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html","title":"2.2. Ciclo de Vida","text":""},{"location":"temas/02/2.2-ciclo-vida-app.html#22-ciclo-de-vida-de-una-aplicacion-android","title":"2.2 Ciclo de vida de una aplicaci\u00f3n Android","text":"<p>El ciclo de vida de una aplicaci\u00f3n Android es el conjunto de estados por los que pasa una aplicaci\u00f3n desde que se inicia hasta que se detiene. Comprender el ciclo de vida de una aplicaci\u00f3n es fundamental para desarrollar aplicaciones robustas y eficientes en Android. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#componentes-del-ciclo-de-vida","title":"Componentes del ciclo de vida","text":"<p>En Android, los componentes del ciclo de vida de una aplicaci\u00f3n son actividades, fragmentos, servicios y receptores de difusi\u00f3n. Cada uno de estos componentes tiene su propio ciclo de vida y se comporta de manera diferente en funci\u00f3n de los eventos que se producen en la aplicaci\u00f3n.</p> <p>Vamos a centrarnos en las Actividades o <code>Activity</code>, que son los componentes principales de una aplicaci\u00f3n Android y representan una \u00fanica pantalla con la que el usuario puede interactuar. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#que-es-una-activity","title":"\u00bfQu\u00e9 es una Activity?","text":"<p>Una Activity es uno de los componentes fundamentales de una aplicaci\u00f3n de Android. En t\u00e9rminos simples, una Activity representa una \u00fanica pantalla con una interfaz de usuario (UI). Piensa en cualquier aplicaci\u00f3n que uses: la lista de correos en Gmail, la pantalla para redactar un nuevo email, o la pantalla de configuraci\u00f3n; cada una de estas es, generalmente, una Activity.</p> <p>Sin embargo, su funci\u00f3n va m\u00e1s all\u00e1 de ser solo un contenedor visual. Es el punto de entrada para la interacci\u00f3n del usuario y el lugar donde se aloja la l\u00f3gica de la interfaz. Cada Activity es una clase en tu c\u00f3digo que se encarga de:</p> <ul> <li> <p>Dibujar la interfaz de usuario: Infla los layouts XML que definen la apariencia y la disposici\u00f3n de los elementos en pantalla (botones, texto, im\u00e1genes, etc.).</p> </li> <li> <p>Gestionar eventos del usuario: Responde a las interacciones del usuario, como toques en botones, deslizamientos o entradas de texto.</p> </li> <li> <p>Coordinar la l\u00f3gica de la pantalla: Ejecuta el c\u00f3digo necesario para que esa pantalla funcione como se espera.</p> </li> </ul> <p>Una aplicaci\u00f3n suele estar compuesta por m\u00faltiples Activities que se comunican entre s\u00ed. Por ejemplo, una Activity puede iniciar otra para realizar una acci\u00f3n diferente. Cuando una nueva Activity se inicia, la anterior se detiene y se coloca en una pila (conocida como \"back stack\" o pila de retroceso). Esto permite al usuario navegar hacia atr\u00e1s presionando el bot\u00f3n correspondiente. </p> Video: \u00bfQu\u00e9 es una Activity en Android? <p></p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#estados-de-una-actividad","title":"Estados de una actividad","text":"<p>Las actividades en Android pueden estar en uno de los siguientes estados:</p> <ul> <li>Created: La actividad ha sido creada pero a\u00fan no es visible para el usuario.</li> <li>Started: La actividad es visible para el usuario pero no tiene el foco.</li> <li>Resumed: La actividad est\u00e1 en primer plano y tiene el foco.</li> <li>Paused: La actividad ha perdido el foco pero a\u00fan es visible para el usuario.</li> <li>Stopped: La actividad ya no es visible para el usuario.</li> <li>Destroyed: La actividad ha sido destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#metodos-del-ciclo-de-vida","title":"M\u00e9todos del ciclo de vida","text":"<p>En Android, cada actividad tiene una serie de m\u00e9todos que se invocan en funci\u00f3n de su estado en el ciclo de vida. Algunos de los m\u00e9todos m\u00e1s comunes son:</p> <ul> <li><code>onCreate()</code>: Se llama cuando la actividad se crea por primera vez.</li> <li><code>onStart()</code>: Se llama cuando la actividad se hace visible para el usuario.</li> <li><code>onResume()</code>: Se llama cuando la actividad obtiene el foco y se convierte en activa.</li> <li><code>onPause()</code>: Se llama cuando la actividad pierde el foco pero a\u00fan es visible.</li> <li><code>onStop()</code>: Se llama cuando la actividad ya no es visible para el usuario.</li> <li><code>onDestroy()</code>: Se llama cuando la actividad es destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#ejemplo-de-ciclo-de-vida-de-una-actividad","title":"Ejemplo de ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra un ejemplo del ciclo de vida de una actividad en Android:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(\"MainActivity\", \"onCreate\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        Log.d(\"MainActivity\", \"onStart\")\n    }\n\n    override fun onResume() {\n        super.onResume()\n        Log.d(\"MainActivity\", \"onResume\")\n    }\n\n    override fun onPause() {\n        super.onPause()\n        Log.d(\"MainActivity\", \"onPause\")\n    }\n\n    override fun onStop() {\n        super.onStop()\n        Log.d(\"MainActivity\", \"onStop\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"MainActivity\", \"onDestroy\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una actividad <code>MainActivity</code> con los m\u00e9todos del ciclo de vida m\u00e1s comunes. Cada m\u00e9todo imprime un mensaje de registro en la consola para indicar en qu\u00e9 estado se encuentra la actividad.</p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#imagen-del-ciclo-de-vida-de-una-actividad","title":"Imagen del ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra una imagen que representa el ciclo de vida de una actividad en Android:</p> <p></p> <p>C\u00f3mo podemos observar, el ciclo de vida de una actividad en Android consta de varios estados y transiciones entre ellos. </p> <p>Es importante comprender estos estados para gestionar correctamente el ciclo de vida de una aplicaci\u00f3n Android.</p>"},{"location":"temas/02/2.3-primera-app.html","title":"2.3. Primera aplicaci\u00f3n","text":""},{"location":"temas/02/2.3-primera-app.html#23-mi-primera-aplicacion-android","title":"2.3 Mi primera aplicaci\u00f3n Android","text":"<p>Para desarrollar una aplicaci\u00f3n Android, debemos decidir si vamos a utilizar la interfaz tradicional basada en XML o la m\u00e1s moderna basada en Jetpack Compose. En este apartado, vamos a crear una aplicaci\u00f3n sencilla utilizando ambas tecnolog\u00edas.</p>"},{"location":"temas/02/2.3-primera-app.html#aplicacion-con-interfaz-basada-en-xml","title":"Aplicaci\u00f3n con interfaz basada en XML","text":"<p>En el siguiente video, se indica de forma detallada cada uno de los componentes que conforman una aplicaci\u00f3n Android con interfaz basada en XML.</p> Video: Mi primera aplicaci\u00f3n Android con interfaz basada en XML <p></p>"},{"location":"temas/02/2.3-primera-app.html#aplicacion-con-interfaz-basada-en-jetpack-compose","title":"Aplicaci\u00f3n con interfaz basada en Jetpack Compose","text":"<p>Jetpack Compose es un moderno toolkit de UI para construir interfaces de usuario nativas en Android. Caracter\u00edsticas principales de Jetpack Compose:</p> <ul> <li>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </li> <li>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </li> <li>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </li> <li>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </li> <li>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.  </li> </ul> Video: \u00bfPor qu\u00e9 usar Jetpack Compose? <p></p> <p>Y qu\u00e9 \u00bfdiferencias existen versus una aplicaci\u00f3n con interfaz basada en XML?. En el siguiente video os dejo un ejemplo pr\u00e1ctico comparando ambas tecnolog\u00edas.</p> Video: Aplicaci\u00f3n XML vs Jetpack Compose <p></p>"},{"location":"temas/02/2.3-primera-app.html#proyecto-guiado-aplicacion-de-tarjeta-de-cumpleanos","title":"\ud83d\ude80 Proyecto guiado: Aplicaci\u00f3n de Tarjeta de cumplea\u00f1os","text":"<p>Para esta pr\u00e1ctica, vamos a crear una sencilla aplicaci\u00f3n de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. La aplicaci\u00f3n mostrar\u00e1 un mensaje de felicitaci\u00f3n y una imagen.</p> <p>Para ello, vamos a realizar los siguientes codelgas:</p> <ol> <li> <p>Codelab. Dise\u00f1ar una app de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. Realiza el siguiente Codelab.</p> </li> <li> <p>Codelab. Agregar im\u00e1genes a nuestra primera App. Realiza el siguiente Codelab de la plataforma oficial de Android.</p> </li> <li> <p>Codelab. Vamos tambi\u00e9n a resolver algunos problemas pr\u00e1cticas en el siguiente Codelab.</p> </li> </ol> <p>\u2b06\ufe0f Proyecto</p> <p>Proyecto. App de tarjetas de presentaci\u00f3n. Sigue las indicaciones aqu\u00ed.</p> <p></p>"},{"location":"temas/02/2.3-primera-app.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<p>Utiliza los siguientes recursos para profundizar en aspectos espec\u00edficos vistos en este apartado.</p> <ul> <li>Box, Colum y Row en Jetpack Compose</li> <li>Modifieers en Jetpack Compose</li> <li>Texto en Jetpack Compose</li> <li>Cargar im\u00e1genes e iconos en Jetpack Compose. Utilizar Coil para cargar im\u00e1genes desde Internet.</li> </ul>"}]}