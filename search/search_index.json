{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Inicio","text":""},{"location":"index.html#programacion-multimedia-y-dispositivos-moviles-pmdm","title":"Programaci\u00f3n multimedia y dispositivos m\u00f3viles (PMDM)","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n multimedia y dispositivos m\u00f3viles, que se imparte en el segundo curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 160 horas lectivas, a raz\u00f3n de 4 horas semanales, y se desarrolla a lo largo de los dos primeros trimestres del curso. Se ha planificado bas\u00e1ndose en 2 sesiones de 2 horas lectivas por semana.</p> <p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso. </p> <p>Esta p\u00e1gina servir\u00e1 b\u00e1sicamente de gu\u00eda y contendr\u00e1 ejemplos, enlaces a otros repositorios con proyectos y ejercicios que iremos viendo en clase, o peque\u00f1os tutoriales y codelabs para ir aprendiendo diferentes conceptos.</p> <p>El m\u00f3dulo est\u00e1 dividido en dos grandes bloques, un primer bloque en d\u00f3nde aprender\u00e9is sobre desarrollo de aplicaciones Android usando Kotlin como lenguaje de programaci\u00f3n y Jetpack Compose para el desarrollo de la UI de las mismas.</p> <p>El segundo bloque trata sobre el desarrollo de videojuegos, para lo cual usaremos el motor de videojuegos Unity y el lenguaje C#.</p>"},{"location":"index.html#recursos","title":"Recursos","text":"Recursos del m\u00f3dulo Documentaci\u00f3nAndroid Code LabsSoftwareCursos <ul> <li>Documentaci\u00f3n oficial de Android</li> <li>Documentaci\u00f3n oficial de Kotlin</li> <li>Documentaci\u00f3n oficial de Jetpack Compose</li> </ul> <ul> <li> <p>Principales</p> <ul> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ul> </li> </ul> <ul> <li>IDEs<ul> <li>Android Studio</li> </ul> </li> </ul> <ul> <li>Pildoras inform\u00e1ticas<ul> <li>Curso Android &amp; Kotlin</li> <li>Curso de Android (java) con Android Studio</li> </ul> </li> <li>Youtube<ul> <li>Curso: Android con Kotlin</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul> </li> </ul>"},{"location":"temas/00-android/index.html","title":"Inicio","text":""},{"location":"temas/00-android/index.html#desarrollo-de-aplicaciones-android-con-kotlin-y-jetpack-compose","title":"Desarrollo de aplicaciones Android con Kotlin y Jetpack Compose","text":"<p>En esta p\u00e1gina encontrar\u00e9is todo el material que iremos viendo durante el curso de la parte de Android.</p> <p>P\u00e1gina de descarga de Android Studio</p> <p>Kotlin Playground</p> <p>Repositorio con respuestas a algunas dudas habituales</p>"},{"location":"temas/00-android/index.html#apartados-del-curso","title":"Apartados del curso","text":"<ol> <li> <p>Introducci\u00f3n Kotlin</p> </li> <li> <p>Jetpack Compose</p> <ol> <li> <p>Composable functions</p> </li> <li> <p>State management</p> </li> <li> <p>Listas y cuadr\u00edculas</p> </li> <li> <p>Navegaci\u00f3n y rutas</p> </li> <li> <p>Material Design</p> </li> </ol> </li> <li> <p>Ciclo de vida de una app</p> </li> <li> <p>Arquitecturas en Android</p> </li> <li> <p>La capa de UI</p> </li> <li> <p>Conexi\u00f3n a internet</p> </li> <li> <p>Conversi\u00f3n JSON a objetos</p> </li> <li> <p>Persistencia de datos</p> </li> <li> <p>Ejercicios: Enunciados y soluciones</p> </li> <li> <p>Documentaci\u00f3n extra y recursos externos</p> </li> </ol>"},{"location":"temas/00-android/index.html#codelabs-primordiales","title":"Codelabs primordiales","text":"<ol> <li> <p>Mi primera app para Android - Codelabs introductorios</p> </li> <li> <p>Avanzando con Kotlin y el manejo de la UI - Codelabs</p> </li> <li> <p>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>C\u00f3mo conectarse a internet - Codelabs</p> </li> <li> <p>Persistencia de datos - Codelabs</p> </li> </ol>"},{"location":"temas/00-android/02-arquitectura.html","title":"Arquitectura en Android","text":""},{"location":"temas/00-android/02-arquitectura.html#arquitectura-en-android","title":"Arquitectura en Android","text":"<p>En Android, la arquitectura de una aplicaci\u00f3n se refiere a la estructura y organizaci\u00f3n de sus componentes, como las actividades, fragmentos, servicios y otros elementos que la componen. Una buena arquitectura es fundamental para crear aplicaciones robustas, escalables y f\u00e1ciles de mantener.</p> <p>En este documento, veremos los principios b\u00e1sicos de la arquitectura en Android y c\u00f3mo puedes aplicarlos en tus propias aplicaciones. Tambi\u00e9n veremos algunas de las arquitecturas m\u00e1s comunes en Android, como MVC, MVP, MVVM y Clean Architecture, y c\u00f3mo puedes elegir la mejor arquitectura para tu proyecto.</p>"},{"location":"temas/00-android/02-arquitectura.html#principios-basicos-de-la-arquitectura-en-android","title":"Principios b\u00e1sicos de la arquitectura en Android","text":"<p>Al dise\u00f1ar la arquitectura de una aplicaci\u00f3n Android, es importante tener en cuenta los siguientes principios b\u00e1sicos:  </p> <ul> <li> <p>Separaci\u00f3n de responsabilidades: Divide tu aplicaci\u00f3n en capas o componentes que tengan responsabilidades claras y bien definidas. Por ejemplo, separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y de acceso a datos. </p> </li> <li> <p>Escalabilidad: Dise\u00f1a tu arquitectura de manera que puedas agregar nuevas funcionalidades o componentes sin tener que reescribir todo el c\u00f3digo.  </p> </li> <li> <p>Mantenibilidad: Haz que tu c\u00f3digo sea f\u00e1cil de entender, modificar y depurar. Utiliza patrones de dise\u00f1o y buenas pr\u00e1cticas de programaci\u00f3n para mantener tu c\u00f3digo limpio y organizado.  </p> </li> <li> <p>Pruebas unitarias: Dise\u00f1a tu arquitectura de manera que puedas escribir pruebas unitarias para cada componente de tu aplicaci\u00f3n. Las pruebas unitarias te permiten validar el comportamiento de tu c\u00f3digo de forma automatizada y garantizar su calidad.  </p> </li> <li> <p>Reactividad: Dise\u00f1a tu arquitectura de manera que puedas responder de forma r\u00e1pida y eficiente a los eventos y cambios en tu aplicaci\u00f3n. Utiliza patrones de dise\u00f1o reactivos para crear interfaces de usuario din\u00e1micas y reactivas. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#arquitecturas-comunes-en-android","title":"Arquitecturas comunes en Android","text":"<p>En Android, existen varias arquitecturas comunes que puedes utilizar para dise\u00f1ar tu aplicaci\u00f3n. Algunas de las arquitecturas m\u00e1s populares son las siguientes: </p> <ul> <li> <p>MVC (Modelo-Vista-Controlador): En el patr\u00f3n MVC, la vista es responsable de mostrar la interfaz de usuario, el controlador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos.  </p> </li> <li> <p>MVP (Modelo-Vista-Presentador): En el patr\u00f3n MVP, la vista es responsable de mostrar la interfaz de usuario, el presentador es responsable de manejar las interacciones del usuario y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El presentador act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>MVVM (Modelo-Vista-ViewModel): En el patr\u00f3n MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo.   </p> </li> <li> <p>Clean Architecture: La Clean Architecture es una arquitectura en capas que separa la aplicaci\u00f3n en capas de dominio, aplicaci\u00f3n e infraestructura. Cada capa tiene responsabilidades claras y bien definidas, lo que facilita la escalabilidad y mantenibilidad de la aplicaci\u00f3n. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#eleccion-de-la-arquitectura-adecuada","title":"Elecci\u00f3n de la arquitectura adecuada","text":"<p>A la hora de elegir la arquitectura para tu aplicaci\u00f3n Android, es importante tener en cuenta varios factores, como el tama\u00f1o y complejidad de la aplicaci\u00f3n, el equipo de desarrollo, los requisitos de rendimiento y escalabilidad, y la experiencia previa con las arquitecturas disponibles.    </p> <p>Algunos consejos para elegir la arquitectura adecuada son los siguientes:   </p> <ul> <li> <p>Eval\u00faa tus necesidades: Analiza los requisitos de tu aplicaci\u00f3n y elige la arquitectura que mejor se adapte a ellos. Por ejemplo, si tu aplicaci\u00f3n es peque\u00f1a y sencilla, puedes optar por una arquitectura MVC o MVP. Si tu aplicaci\u00f3n es grande y compleja, puedes optar por una arquitectura MVVM o Clean Architecture.    </p> </li> <li> <p>Prueba diferentes arquitecturas: Experimenta con diferentes arquitecturas y eval\u00faa sus ventajas y desventajas en funci\u00f3n de tus necesidades. No tengas miedo de probar nuevas arquitecturas y adaptarlas a tus necesidades espec\u00edficas.   </p> </li> <li> <p>Consulta la comunidad: Busca en la comunidad de desarrolladores de Android y consulta ejemplos, tutoriales y buenas pr\u00e1cticas sobre arquitectura. La comunidad de desarrolladores es una gran fuente de informaci\u00f3n y te puede ayudar a elegir la arquitectura adecuada para tu proyecto. </p> </li> </ul>"},{"location":"temas/00-android/02-arquitectura.html#la-arquitectura-que-vamos-a-utilizar-en-este-curso-es-mvvm","title":"La arquitectura que vamos a utilizar en este curso es MVVM","text":"<p>En este curso, vamos a utilizar la arquitectura MVVM (Modelo-Vista-ViewModel) para dise\u00f1ar nuestras aplicaciones Android. La arquitectura MVVM es una arquitectura moderna y escalable que separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y acceso a datos.   </p> <p>En la arquitectura MVVM, la vista es responsable de mostrar la interfaz de usuario, el ViewModel es responsable de manejar la l\u00f3gica de presentaci\u00f3n y el modelo es responsable de la l\u00f3gica de negocio y acceso a datos. El ViewModel act\u00faa como un intermediario entre la vista y el modelo, lo que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo. </p> <p>La arquitectura MVVM es una arquitectura popular en Android y es compatible con las bibliotecas y herramientas de Jetpack, como LiveData, ViewModel y Room. Utilizaremos estas bibliotecas y herramientas en nuestro curso para crear aplicaciones Android modernas y eficientes.   </p> <p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/02-arquitectura.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Android: La documentaci\u00f3n oficial de Android, que incluye gu\u00edas, tutoriales y ejemplos para aprender a desarrollar aplicaciones Android.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio Lista de la compra - Enunciado - Soluci\u00f3n</p> </li> <li> <p>App de Carta Alta - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/03-capa-ui.html","title":"Capa de UI","text":""},{"location":"temas/00-android/03-capa-ui.html#capa-de-ui","title":"Capa de UI","text":"<p>En esta secci\u00f3n vamos a ver c\u00f3mo implementar la capa de UI en una arquitectura MVVM (Model-View-ViewModel) en una aplicaci\u00f3n Android con Jetpack Compose.</p>"},{"location":"temas/00-android/03-capa-ui.html#que-es-mvvm","title":"\u00bfQu\u00e9 es MVVM?","text":"<p>MVVM es un patr\u00f3n de arquitectura de software que se utiliza para separar la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio en una aplicaci\u00f3n. En MVVM, la capa de UI se divide en tres componentes principales:</p> <ul> <li> <p>Model: Representa los datos y la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> </li> <li> <p>View: Representa la interfaz de usuario de la aplicaci\u00f3n.</p> </li> <li> <p>ViewModel: Act\u00faa como un intermediario entre el Model y la View. Se encarga de manejar la l\u00f3gica de presentaci\u00f3n y de exponer los datos necesarios para que la View pueda mostrarlos. </p> </li> </ul> <p>MVVM es un patr\u00f3n muy utilizado en el desarrollo de aplicaciones Android, ya que facilita la separaci\u00f3n de responsabilidades y la reutilizaci\u00f3n de c\u00f3digo.  </p>"},{"location":"temas/00-android/03-capa-ui.html#implementacion-de-la-capa-de-ui-en-mvvm","title":"Implementaci\u00f3n de la capa de UI en MVVM","text":"<p>Para implementar la capa de UI en una arquitectura MVVM en una aplicaci\u00f3n Android con Jetpack Compose, puedes seguir los siguientes pasos:  </p> <ol> <li> <p>Definir el Model: Define las clases y estructuras de datos que representan los datos y la l\u00f3gica de negocio de tu aplicaci\u00f3n. Por ejemplo, puedes definir una clase <code>User</code> que represente un usuario de la aplicaci\u00f3n.</p> </li> <li> <p>Definir el ViewModel: Define una clase que extienda <code>ViewModel</code> y que contenga la l\u00f3gica de presentaci\u00f3n de tu aplicaci\u00f3n. Por ejemplo, puedes definir un ViewModel que contenga la l\u00f3gica para cargar los datos de un usuario.</p> </li> <li> <p>Definir la View: Define la interfaz de usuario de tu aplicaci\u00f3n utilizando Jetpack Compose. Por ejemplo, puedes definir una funci\u00f3n componible que muestre los datos de un usuario en la pantalla.</p> </li> <li> <p>Conectar el ViewModel con la View: Conecta el ViewModel con la View para que la View pueda mostrar los datos del ViewModel. Puedes utilizar <code>rememberViewModel</code> para crear una instancia del ViewModel en la View y <code>viewModel</code> para acceder a los datos del ViewModel.</p> </li> </ol>"},{"location":"temas/00-android/03-capa-ui.html#ejemplo-de-implementacion","title":"Ejemplo de implementaci\u00f3n","text":"<p>Video explicaci\u00f3n de la arquitectura MVVM</p> <p></p>"},{"location":"temas/00-android/03-capa-ui.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/00-android/00-compose/index.html#jetpack-compose","title":"Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.    </p>"},{"location":"temas/00-android/00-compose/index.html#caracteristicas-de-jetpack-compose","title":"Caracter\u00edsticas de Jetpack Compose","text":"<ul> <li> <p>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </p> </li> <li> <p>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </p> </li> <li> <p>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </p> </li> <li> <p>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </p> </li> <li> <p>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.    </p> </li> </ul>"},{"location":"temas/00-android/00-compose/index.html#apartados","title":"Apartados","text":"<ul> <li> <p>Composable functions: Aprende a crear funciones componibles en Jetpack Compose y a componerlas para crear interfaces de usuario complejas.</p> </li> <li> <p>State management: Descubre c\u00f3mo gestionar el estado de tu aplicaci\u00f3n en Jetpack Compose y c\u00f3mo hacer que tu interfaz de usuario sea reactiva.</p> </li> <li> <p>Listas y cuadr\u00edculas: Aprende a mostrar listas y cuadr\u00edculas de elementos en Jetpack Compose y a personalizar su apariencia.</p> </li> <li> <p>Navegaci\u00f3n y rutas: Descubre c\u00f3mo implementar la navegaci\u00f3n entre pantallas en Jetpack Compose y c\u00f3mo definir rutas para tu aplicaci\u00f3n.</p> </li> <li> <p>Material Design: Aprende a implementar los principios de Material Design en Jetpack Compose y a personalizar los estilos de tus componentes.</p> </li> </ul> <p>Video Creaci\u00f3n de un proyecto Android y sus partes</p> <p></p> <p>Video L\u00f3gica de actividades e introducci\u00f3n al ciclo de vida</p> <p></p>"},{"location":"temas/00-android/00-compose/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.  </p> </li> <li> <p>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html","title":"Funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#funciones-componibles-en-jetpack-compose","title":"Funciones componibles en Jetpack Compose","text":"<p>En Jetpack Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#crear-una-funcion-componible","title":"Crear una funci\u00f3n componible","text":"<p>Para crear una funci\u00f3n componible en Jetpack Compose, utiliza la anotaci\u00f3n <code>@Composable</code> antes de la definici\u00f3n de la funci\u00f3n. Una funci\u00f3n componible puede tener par\u00e1metros y devolver un \u00e1rbol de elementos de la interfaz de usuario utilizando las funciones de composici\u00f3n proporcionadas por Compose.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Greeting</code> que toma un par\u00e1metro <code>name</code> de tipo <code>String</code> y devuelve un elemento de texto <code>Text</code> que muestra un saludo personalizado.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#componer-funciones-componibles","title":"Componer funciones componibles","text":"<p>Puedes componer funciones componibles para crear interfaces de usuario m\u00e1s complejas. Utiliza las funciones de composici\u00f3n proporcionadas por Compose, como <code>Column</code>, <code>Row</code>, <code>Box</code>, <code>Spacer</code>, etc., para organizar y dise\u00f1ar los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>GreetingList</code> que toma una lista de nombres y muestra un saludo personalizado para cada nombre utilizando la funci\u00f3n componible <code>Greeting</code>.</p> <p>Video introducci\u00f3n a Compose</p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#actualizacion-de-funciones-componibles","title":"Actualizaci\u00f3n de funciones componibles","text":"<p>Las funciones componibles en Jetpack Compose son reactivas, lo que significa que se vuelven a ejecutar autom\u00e1ticamente cuando cambian los datos de entrada. Esto permite que la interfaz de usuario se actualice de forma din\u00e1mica en respuesta a los cambios en los datos.</p> <pre><code>@Composable\nfun Counter(count: Int) {\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n componible <code>Counter</code> que muestra el recuento actual. Cuando cambia el recuento, la funci\u00f3n componible se vuelve a ejecutar autom\u00e1ticamente para reflejar el nuevo valor.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#columnas-y-filas-en-jetpack-compose","title":"Columnas y filas en Jetpack Compose+","text":"<p>Jetpack Compose proporciona las funciones <code>Column</code> y <code>Row</code> para organizar elementos de la interfaz de usuario en columnas y filas respectivamente. Puedes anidar columnas y filas para crear dise\u00f1os m\u00e1s complejos y reutilizables.</p> <pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Spacer(modifier = Modifier.height(8.dp))\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical. Se a\u00f1ade un <code>Spacer</code> entre cada saludo para separarlos visualmente.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificadores-en-jetpack-compose","title":"Modificadores en Jetpack Compose","text":"<p>Jetpack Compose utiliza modificadores para aplicar estilos y comportamientos a los elementos de la interfaz de usuario. Puedes utilizar modificadores para cambiar el tama\u00f1o, la posici\u00f3n, el color, la forma, etc., de los elementos de la interfaz de usuario.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier\n            .padding(16.dp)\n            .background(Color.Blue)\n            .clickable { /* Acci\u00f3n al hacer clic */ }\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un relleno alrededor del texto, el modificador <code>background</code> para cambiar el color de fondo del texto, y el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p> <p>!!! info \"Video Modificadores y uso del tema]     </p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#recursos-en-jetpack-compose","title":"Recursos en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de recursos de Android para gestionar los recursos de la interfaz de usuario, como cadenas, colores, dimensiones, etc. Puedes acceder a los recursos utilizando la funci\u00f3n <code>stringResource()</code>, <code>colorResource()</code>, <code>dimenResource()</code>, etc.</p> <pre><code>@Composable\nfun Greeting() {\n    Text(\n        text = stringResource(id = R.string.hello),\n        color = colorResource(id = R.color.primary),\n        fontSize = dimenResource(id = R.dimen.text_size)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>stringResource()</code> para obtener una cadena de recursos, la funci\u00f3n <code>colorResource()</code> para obtener un color de recursos, y la funci\u00f3n <code>dimenResource()</code> para obtener una dimensi\u00f3n de recursos.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#temas-en-jetpack-compose","title":"Temas en Jetpack Compose","text":"<p>Jetpack Compose utiliza el sistema de temas de Android para aplicar estilos coherentes a la interfaz de usuario. Puedes definir un tema personalizado utilizando la funci\u00f3n <code>provideAppTheme()</code> y aplicarlo a tu aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p> <pre><code>@Composable\nfun MyApp() {\n    MaterialTheme(\n        colors = lightColors(),\n        typography = Typography,\n        shapes = Shapes\n    ) {\n        Greeting()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado con colores, tipograf\u00eda y formas personalizadas, y se aplica a la aplicaci\u00f3n utilizando el modificador <code>MaterialTheme</code>.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplos-de-funciones-componibles","title":"Ejemplos de funciones componibles","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-row","title":"Ejemplo de funci\u00f3n con Row","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Row</code> para organizar el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-box","title":"Ejemplo de funci\u00f3n con Box","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Box(\n        modifier = Modifier\n            .background(Color.Blue)\n            .padding(16.dp)\n    ) {\n        Text(text = \"Hello, $name!\", color = Color.White)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Box</code> para colocar el texto en un cuadro azul con un relleno de 16 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#ejemplo-de-funcion-con-column","title":"Ejemplo de funci\u00f3n con Column","text":"<pre><code>@Composable\nfun GreetingList(names: List&lt;String&gt;) {\n    Column {\n        names.forEach { name -&gt;\n            Greeting(name = name)\n            Divider(color = Color.Gray, thickness = 1.dp)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Column</code> para organizar los saludos en una lista vertical con una l\u00ednea divisoria entre cada saludo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#como-anadir-imagenes-usando-image-y-painterresource","title":"C\u00f3mo a\u00f1adir im\u00e1genes usando Image y painterResource","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Image(\n            painter = painterResource(id = R.drawable.ic_launcher_foreground),\n            contentDescription = null,\n            modifier = Modifier.size(48.dp)\n        )\n        Spacer(modifier = Modifier.width(8.dp))\n        Text(text = \"Hello, $name!\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Image</code> para a\u00f1adir una imagen a la interfaz de usuario utilizando un recurso de imagen.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#previews-en-jetpack-compose","title":"Previews en Jetpack Compose","text":"<p>Jetpack Compose proporciona una funci\u00f3n <code>@Preview</code> que te permite previsualizar tus funciones componibles en tiempo real en Android Studio. Puedes definir previsualizaciones para tus funciones componibles y ver c\u00f3mo se ven en diferentes configuraciones y estados.</p> <pre><code>@Preview\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una previsualizaci\u00f3n <code>GreetingPreview</code> para la funci\u00f3n componible <code>Greeting</code> con el nombre \"World\". Puedes ver la previsualizaci\u00f3n en Android Studio y ajustarla seg\u00fan sea necesario.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-previsualizacion","title":"Opciones de previsualizaci\u00f3n","text":"<p>Jetpack Compose proporciona varias opciones de previsualizaci\u00f3n que te permiten personalizar la apariencia de tus previsualizaciones. Puedes definir diferentes configuraciones, tama\u00f1os, orientaciones, temas, etc., para tus previsualizaciones y ver c\u00f3mo se ven en diferentes contextos.</p> <pre><code>@Preview(\n    showBackground = true,\n    name = \"Greeting Preview\",\n    uiMode = Configuration.UI_MODE_NIGHT_YES,\n    widthDp = 320,\n    heightDp = 240\n)\n@Composable\nfun GreetingPreview() {\n    Greeting(name = \"World\")\n}\n</code></pre> <p>Las opciones de previsualizaci\u00f3n son las siguientes:</p> <ul> <li><code>showBackground</code>: Muestra un fondo en la previsualizaci\u00f3n.</li> <li><code>name</code>: Nombre de la previsualizaci\u00f3n.</li> <li><code>uiMode</code>: Modo de interfaz de usuario (claro, oscuro, etc.).</li> <li><code>widthDp</code>: Ancho de la previsualizaci\u00f3n en dp.</li> <li><code>heightDp</code>: Alto de la previsualizaci\u00f3n en dp.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-en-jetpack-compose","title":"Opciones de alineaci\u00f3n en Jetpack Compose","text":"<p>Jetpack Compose proporciona opciones de alineaci\u00f3n que te permiten alinear los elementos de la interfaz de usuario de forma horizontal y vertical. Puedes utilizar las opciones de alineaci\u00f3n para controlar la posici\u00f3n de los elementos en la pantalla y crear dise\u00f1os m\u00e1s precisos y coherentes.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Text(\n        text = \"Hello, $name!\",\n        modifier = Modifier.align(Alignment.CenterHorizontally)\n    )\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro de la pantalla.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-horizontal","title":"Opciones de alineaci\u00f3n horizontal","text":"<p>Las opciones de alineaci\u00f3n horizontal en Jetpack Compose son las siguientes:</p> <ul> <li><code>start</code>: Alinea el elemento al principio del eje horizontal.</li> <li><code>centerHorizontally</code>: Alinea el elemento en el centro del eje horizontal.</li> <li><code>end</code>: Alinea el elemento al final del eje horizontal.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-vertical","title":"Opciones de alineaci\u00f3n vertical","text":"<p>Las opciones de alineaci\u00f3n vertical en Jetpack Compose son las siguientes:</p> <ul> <li><code>top</code>: Alinea el elemento en la parte superior del eje vertical.</li> <li><code>centerVertically</code>: Alinea el elemento en el centro del eje vertical.</li> <li><code>bottom</code>: Alinea el elemento en la parte inferior del eje vertical.</li> </ul>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#opciones-de-alineacion-personalizadas","title":"Opciones de alineaci\u00f3n personalizadas","text":"<p>Adem\u00e1s de las opciones de alineaci\u00f3n predefinidas, Jetpack Compose te permite crear opciones de alineaci\u00f3n personalizadas utilizando la funci\u00f3n <code>Alignment</code>.</p> <pre><code>val CustomAlignment = Alignment(0.25f, 0.75f)\n</code></pre> <p>En el ejemplo anterior, se define una opci\u00f3n de alineaci\u00f3n personalizada <code>CustomAlignment</code> con un desplazamiento horizontal del 25% y un desplazamiento vertical del 75%.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#uso-de-opciones-de-alineacion-en-column-y-row","title":"Uso de opciones de alineaci\u00f3n en Column y Row","text":"<p>Puedes utilizar las opciones de alineaci\u00f3n en las funciones <code>Column</code> y <code>Row</code> para alinear los elementos de la interfaz de usuario de forma horizontal y vertical.</p> <pre><code>@Composable\nfun Greeting(name: String) {\n    Row(\n        verticalAlignment = Alignment.CenterVertically,\n        horizontalArrangement = Arrangement.SpaceEvenly\n    ) {\n        Text(text = \"Hello, $name!\")\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la opci\u00f3n de alineaci\u00f3n vertical <code>Alignment.CenterVertically</code> y la disposici\u00f3n horizontal <code>Arrangement.SpaceEvenly</code> para alinear el texto y el icono en una fila horizontal.</p> <p>Las diferentes opciones de alineaci\u00f3n y disposici\u00f3n te permiten crear dise\u00f1os flexibles y personalizados en Jetpack Compose.</p> <p>Para el Arrangement existen las siguientes opciones:</p> <ul> <li><code>SpaceAround</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos.</li> <li><code>SpaceBetween</code>: Distribuye el espacio entre los elementos de forma uniforme, sin espacio adicional alrededor de los elementos.</li> <li><code>SpaceEvenly</code>: Distribuye el espacio entre los elementos de forma uniforme, con espacio adicional alrededor de los elementos y en los extremos.</li> <li><code>Center</code>: Centra los elementos en el espacio disponible.</li> <li><code>Start</code>: Coloca los elementos al principio del espacio disponible.</li> <li><code>End</code>: Coloca los elementos al final del espacio disponible.</li> </ul> <p>En las siguientes im\u00e1genes animadas se muestran ejemplos de alineaci\u00f3n horizontal y vertical en Jetpack Compose:</p> <p></p> <p></p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#mas-ejemplos-de-modificaciones","title":"M\u00e1s ejemplos de modificaciones","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tamano","title":"Modificador de tama\u00f1o","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.size(48.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>size</code> para cambiar el tama\u00f1o del texto a 48 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-altura-y-anchura","title":"Modificador de altura y anchura","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.width(100.dp).height(50.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utilizan los modificadores <code>width</code> y <code>height</code> para cambiar la anchura del texto a 100 dp y la altura a 50 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-tipografia","title":"Modificador de tipograf\u00eda","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", style = TextStyle(fontWeight = FontWeight.Bold))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>style</code> para cambiar el peso de la fuente del texto a negrita.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-alineacion","title":"Modificador de alineaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.align(Alignment.CenterHorizontally))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>align</code> para alinear el texto horizontalmente en el centro.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-margen","title":"Modificador de margen","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.padding(16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>padding</code> para a\u00f1adir un margen de 16 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-color-de-fondo","title":"Modificador de color de fondo","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.background(Color.Blue))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>background</code> para cambiar el color de fondo del texto a azul.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-borde","title":"Modificador de borde","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.border(1.dp, Color.Black))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>border</code> para a\u00f1adir un borde de 1 dp de grosor alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-clic","title":"Modificador de clic","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ })\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clickable</code> para a\u00f1adir una acci\u00f3n al hacer clic en el texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-forma","title":"Modificador de forma","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.clip(RoundedCornerShape(4.dp)))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>clip</code> para aplicar una forma redondeada con un radio de 4 dp alrededor del texto.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-rotacion","title":"Modificador de rotaci\u00f3n","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.rotate(45f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>rotate</code> para rotar el texto 45 grados.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-escala","title":"Modificador de escala","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.scale(1.5f))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>scale</code> para escalar el texto a 1.5 veces su tama\u00f1o original.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desplazamiento","title":"Modificador de desplazamiento","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.offset(x = 16.dp, y = 16.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>offset</code> para desplazar el texto 16 dp hacia la derecha y 16 dp hacia abajo.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-sombra","title":"Modificador de sombra","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.shadow(4.dp, shape = CircleShape))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>shadow</code> para a\u00f1adir una sombra de 4 dp alrededor del texto con una forma circular.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#modificador-de-desenfoque","title":"Modificador de desenfoque","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Text(text = \"Hello, $name!\", modifier = Modifier.blur(4.dp))\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza el modificador <code>blur</code> para aplicar un efecto de desenfoque al texto con un radio de 4 dp.</p>"},{"location":"temas/00-android/00-compose/21-composable-functions.html#otros-ejemplos-de-funciones-componibles-de-interes","title":"Otros ejemplos de funciones componibles de inter\u00e9s","text":""},{"location":"temas/00-android/00-compose/21-composable-functions.html#el-uso-de-spacer","title":"El uso de Spacer","text":"<pre><code>@Composable\nfun Greeting(name: String) {\n    Row {\n        Text(text = \"Hello, $name!\")\n        Spacer(modifier = Modifier.width(8.dp))\n        Icon(Icons.Default.Favorite, contentDescription = null)\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>Spacer</code> para a\u00f1adir un espacio entre el texto y el icono en una fila horizontal.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html","title":"Gesti\u00f3n del estado","text":""},{"location":"temas/00-android/00-compose/22-state-management.html#gestion-de-estado-en-jetpack-compose","title":"Gesti\u00f3n de estado en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#que-es-el-estado-y-por-que-es-importante","title":"\u2753\u00bfQu\u00e9 es el estado y por qu\u00e9 es importante ?","text":"<p>Imagina que construyes una aplicaci\u00f3n sin pensar en c\u00f3mo se gestionan los datos. Al principio, todo parece funcionar. Un bot\u00f3n cambia un texto. Un campo de entrada muestra lo que el usuario escribe. Pero pronto, la complejidad crece:</p> <ul> <li>\u00bfQu\u00e9 pasa si al girar la pantalla todo el texto que el usuario escribi\u00f3 desaparece?</li> <li>\u00bfC\u00f3mo se asegura una pantalla de que est\u00e1 mostrando los datos m\u00e1s actualizados que acaban de llegar de internet?</li> <li>Si actualizas un dato en la pantalla A, \u00bfc\u00f3mo se entera la pantalla B de que debe mostrar ese cambio?</li> </ul> <p>Estos problemas surgen de una gesti\u00f3n de estado deficiente o inexistente. La gesti\u00f3n del estado no es un concepto acad\u00e9mico y abstracto; es el pilar fundamental sobre el que se construye cualquier aplicaci\u00f3n interactiva y fiable.</p> <p>En esencia, el estado es la verdad; es el conjunto de datos que define c\u00f3mo se ve y se comporta tu aplicaci\u00f3n en un momento dado. La gesti\u00f3n del estado es la disciplina de controlar c\u00f3mo y d\u00f3nde fluye esa verdad a trav\u00e9s de tu aplicaci\u00f3n.</p> <p>En Jetpack Compose, un framework de UI declarativo, esta importancia se multiplica por diez. A diferencia de los sistemas imperativos (como las Vistas de Android XML) donde t\u00fa manualmente buscas un <code>TextView</code> y le dices <code>setText()</code>, en Compose simplemente declaras: \"La UI debe mostrar el valor de esta variable de estado\". Cuando la variable cambia, la UI reacciona y se actualiza sola.</p> <p>Importante</p> <p>dominar la gesti\u00f3n del estado en Compose no es una opci\u00f3n, es el requisito principal para construir aplicaciones que funcionen correctamente, sean f\u00e1ciles de mantener y est\u00e9n libres de errores impredecibles.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#que-es-el-estado-en-jetpack-compose","title":"\u00bfQu\u00e9 es el Estado en Jetpack Compose?","text":"<p>En Jetpack Compose, el estado es cualquier valor que puede cambiar con el tiempo y que, al hacerlo, debe provocar que la interfaz de usuario se actualice (se redibuje).</p> <p>Pi\u00e9nsalo de esta manera:</p> <ul> <li>El texto que un usuario introduce en un <code>TextField</code>.</li> <li>El estado de un <code>Checkbox</code> (marcado o no marcado).</li> <li>La posici\u00f3n de un <code>Slider</code>.</li> <li>Una lista de mensajes que se carga desde una base de datos.</li> </ul> <p>Todos estos son ejemplos de estado. Si el valor cambia, la UI debe reflejar ese cambio. El mecanismo por el cual Compose redibuja la UI cuando el estado cambia se llama Recomposici\u00f3n.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#declarando-el-estado-el-duo-indispensable-remember-y-mutablestateof","title":"Declarando el Estado: El D\u00fao Indispensable <code>remember</code> y <code>mutableStateOf</code>","text":"<p>Para que Compose pueda \"observar\" un valor y reaccionar a sus cambios, no podemos usar una variable normal como <code>var nombre = \"Android\"</code>. Necesitamos declararla de una forma especial. Aqu\u00ed es donde entran en juego dos funciones clave:</p> <ol> <li> <p><code>mutableStateOf(valorInicial)</code>: Esta funci\u00f3n toma un valor inicial y lo envuelve en un objeto <code>State</code> observable. Cuando el <code>.value</code> de este objeto cambia, Compose se entera y programa una recomposici\u00f3n para todas las funciones Composable que lean ese estado.</p> </li> <li> <p><code>remember { ... }</code>: Las funciones Composable pueden ejecutarse muchas veces (durante las recomposiciones). <code>remember</code> es el ant\u00eddoto contra la \"amnesia\" de la recomposici\u00f3n. Almacena en cach\u00e9 el resultado del bloque de c\u00f3digo que se le pasa, asegurando que este valor sobreviva y no se reinicie cada vez que la UI se redibuja.</p> </li> </ol> <p>La combinaci\u00f3n de ambos es la f\u00f3rmula m\u00e1gica para el estado local en un Composable:</p> <p><code>remember { mutableStateOf(valorInicial) }</code></p> <ul> <li><code>mutableStateOf</code> crea el estado observable.</li> <li><code>remember</code> se asegura de que este estado no se pierda en las recomposiciones.</li> </ul>"},{"location":"temas/00-android/00-compose/22-state-management.html#formas-de-definir-el-estado","title":"Formas de Definir el Estado","text":"<p>Veamos un ejemplo pr\u00e1ctico: un simple contador que incrementa un n\u00famero cada vez que se presiona un bot\u00f3n. Exploraremos las tres formas sint\u00e1cticas de declarar y usar el estado.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-1-la-forma-explicita-con-value","title":"Ejemplo 1: La Forma Expl\u00edcita con <code>.value</code>","text":"<p>Esta es la forma m\u00e1s literal. Accedemos y modificamos el valor del estado a trav\u00e9s de su propiedad <code>.value</code>. Es excelente para entender lo que sucede internamente.</p> <p>Analog\u00eda: Tienes una caja (<code>contadorState</code>) que es inmutable, pero puedes abrirla para cambiar su contenido (<code>contadorState.value</code>).</p> <pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorConValue() {\n    // Creamos el estado y lo recordamos. Su tipo es MutableState&lt;Int&gt;.\n    val contadorState = remember { mutableStateOf(0) }\n\n    Column {\n        // Para leer el valor, debemos usar .value\n        Text(text = \"Has presionado el bot\u00f3n ${contadorState.value} veces.\")\n\n        Button(onClick = {\n            // Para modificar el valor, tambi\u00e9n usamos .value\n            contadorState.value = contadorState.value + 1\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-2-la-forma-idiomatica-con-el-delegado-by","title":"Ejemplo 2: La Forma Idiom\u00e1tica con el Delegado <code>by</code>","text":"<p>Esta es la forma m\u00e1s com\u00fan y recomendada en Kotlin. Usamos el delegado de propiedad <code>by</code> para que Compose gestione el acceso a <code>.value</code> por nosotros. El c\u00f3digo resulta mucho m\u00e1s limpio y legible.</p> <p>Analog\u00eda: Contratas a un asistente (<code>by</code>). En lugar de abrir la caja t\u00fa mismo, le pides el valor directamente a tu asistente, y \u00e9l se encarga de los detalles.</p> <p></p><pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorConDelegado() {\n    // Usamos 'var' porque reasignaremos el valor y 'by' para delegar.\n    // 'contador' se comporta ahora como un Int, no como un State&lt;Int&gt;.\n    var contador by remember { mutableStateOf(0) }\n\n    Column {\n        // Leemos el valor directamente, \u00a1sin .value!\n        Text(text = \"Has presionado el bot\u00f3n $contador veces.\")\n\n        Button(onClick = {\n            // Modificamos el valor directamente.\n            contador++ // o contador = contador + 1\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre> (Nota: Para usar el delegado <code>by</code>, es posible que necesites a\u00f1adir <code>import androidx.compose.runtime.getValue</code> y <code>setValue</code>)<p></p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-3-la-forma-con-desestructuracion","title":"Ejemplo 3: La Forma con Desestructuraci\u00f3n","text":"<p>Esta sintaxis, popular en otros frameworks como React, permite desestructurar el estado en una variable de solo lectura para el valor y una funci\u00f3n para actualizarlo.</p> <p>Analog\u00eda: Tienes un termostato con dos partes: una pantalla que te muestra la temperatura (<code>contador</code>) y una rueda que te permite cambiarla (<code>setContador</code>).</p> <pre><code>import androidx.compose.foundation.layout.Column\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\n\n@Composable\nfun ContadorDesestructurado() {\n    // Desestructuramos el State en un valor y una funci\u00f3n lambda para actualizarlo.\n    val (contador, setContador) = remember { mutableStateOf(0) }\n\n    Column {\n        // Leemos el valor directamente.\n        Text(text = \"Has presionado el bot\u00f3n $contador veces.\")\n\n        Button(onClick = {\n            // Usamos la funci\u00f3n para establecer el nuevo valor.\n            setContador(contador + 1)\n        }) {\n            Text(\"\u00a1Presi\u00f3name!\")\n        }\n    }\n}\n</code></pre> <p>Recuerda los puntos clave</p> <ol> <li>El estado es la fuente de verdad que impulsa tu UI.</li> <li>La recomposici\u00f3n es el proceso autom\u00e1tico por el cual Compose actualiza la UI cuando el estado cambia.</li> <li><code>mutableStateOf</code> crea un estado observable que Compose puede rastrear.</li> <li><code>remember</code> le da memoria a tus Composables, permitiendo que el estado sobreviva a las recomposiciones.</li> <li>La sintaxis con el delegado <code>by</code> es la forma preferida por su simplicidad y legibilidad.</li> </ol> <p>Video introducci\u00f3n al manejo del estado en Compose</p> <p></p>"},{"location":"temas/00-android/00-compose/22-state-management.html#mas-en-detalle","title":"\ud83d\udd2c M\u00e1s en detalle","text":"<p>Puedes definir el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>mutableStateOf()</code> de Compose.</p> <pre><code>val contador = mutableStateOf(0)\n</code></pre> <p>En el ejemplo anterior, se define un estado <code>contador</code> con un valor inicial de <code>0</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-estado","title":"Observaci\u00f3n de estado","text":"<p>Puedes observar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>observeAsState()</code> de Compose.</p> <pre><code>val contadorState = contador.observeAsState()\nval contador = contadorState.value\n</code></pre> <p>En el ejemplo anterior, se observa el estado <code>contador</code> y se obtiene su valor actual.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#actualizacion-de-estado","title":"Actualizaci\u00f3n de estado","text":"<p>Puedes actualizar el estado de tu aplicaci\u00f3n utilizando la funci\u00f3n <code>value</code> de Compose.</p> <pre><code>contador.value++\n</code></pre> <p>En el ejemplo anterior, se incrementa en uno el valor del estado <code>contador</code>.</p> <p>\u00a1Importante!</p> <p>El estado en Compose es inmutable, por lo que debes utilizar la funci\u00f3n <code>value</code> para actualizar el estado.</p> <p>Para que haya recomposici\u00f3n, la actualizaci\u00f3n del estado debe realizarse dentro de un evento de un componente <code>@Composable</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-completo","title":"Ejemplo completo","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#tipos-de-estado","title":"Tipos de estado","text":"<p>En Jetpack Compose, puedes utilizar diferentes tipos de estado para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <ul> <li><code>mutableStateOf()</code>: Crea un estado mutable que puede cambiar a lo largo del tiempo.</li> <li><code>remember</code>: Crea un estado que se mantiene entre recomposiciones.</li> <li><code>derivedStateOf()</code>: Crea un estado derivado a partir de otros estados.</li> </ul>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remember","title":"Uso de remember","text":"<p>La funci\u00f3n <code>remember</code> de Compose te permite crear un estado que se mantiene entre recomposiciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>remember</code> para crear un estado <code>contador</code> que se mantiene entre recomposiciones.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-remembersaveable","title":"Uso de rememberSaveable","text":"<p>La funci\u00f3n <code>rememberSaveable</code> de Compose te permite crear un estado que se mantiene entre configuraciones.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = rememberSaveable { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>rememberSaveable</code> para crear un estado <code>contador</code> que se mantiene entre configuraciones.</p> <p>Remember vs RememberSaveable</p> <p>La diferencia entre <code>remember</code> y <code>rememberSaveable</code> es que <code>rememberSaveable</code> guarda el estado en el <code>Bundle</code> de la actividad para que se pueda restaurar despu\u00e9s de una recreaci\u00f3n de la actividad.</p> <p>Esto es \u00fatil para guardar el estado de la aplicaci\u00f3n cuando la actividad se destruye y se vuelve a crear, por ejemplo, al girar la pantalla.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#uso-de-derivedstateof","title":"Uso de derivedStateOf","text":"<p>La funci\u00f3n <code>derivedStateOf</code> de Compose te permite crear un estado derivado a partir de otros estados.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = mutableStateOf(0)\n    val doble = derivedStateOf { contador.value * 2 }\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contador.value}, Doble: ${doble.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>derivedStateOf</code> para crear un estado <code>doble</code> que es el doble del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-kotlin","title":"\ud83d\udca6 Flows en Kotlin","text":"<p>En Kotlin, un <code>Flow</code> es una secuencia de valores que se emiten de forma as\u00edncrona y reactiva. Los <code>Flow</code> te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla.</p> <p>Explicaci\u00f3n sencilla</p> <p>Imagina que los Flows son como mangueras de agua \ud83d\udca7. Transportan datos (el agua) desde un emisor (el grifo) hasta un colector (alguien que recoge el agua). La diferencia entre los tipos de Flow radica en c\u00f3mo y a qui\u00e9n entregan esa agua.</p> <p>Existen principalmente tres tipos que debes dominar:</p> <ul> <li> <p>Flow (Fr\u00edo \ud83e\udd76): Es la manguera est\u00e1ndar. Solo empieza a soltar agua (emitir datos) cuando alguien abre el grifo (collect). Cada persona que se conecta (collect) obtiene su propia manguera y recibe toda la secuencia de datos desde el principio. No empieza a producir si nadie est\u00e1 escuchando.</p> </li> <li> <p>SharedFlow (Caliente \ud83d\udd25): Es como un aspersor en un jard\u00edn. Emite datos constantemente (o bajo ciertas condiciones) sin importar si alguien est\u00e1 mirando o no. M\u00faltiples colectores pueden conectarse a \u00e9l y todos recibir\u00e1n los mismos datos que se emitan despu\u00e9s de que se conecten. Es ideal para eventos que deben ser compartidos entre varias partes de tu app (ej: \"\u00a1Pago realizado con \u00e9xito!\").</p> </li> <li> <p>StateFlow (Caliente y con memoria \ud83e\uddd0): Es una especializaci\u00f3n de SharedFlow. Piensa en \u00e9l como un term\u00f3metro digital en la pared. Siempre tiene un valor (la temperatura actual) y cualquiera que lo mire ver\u00e1 ese valor. Si el valor cambia, todos los que lo est\u00e9n mirando ver\u00e1n la actualizaci\u00f3n. La clave es que siempre tiene un valor inicial y solo emite el valor m\u00e1s reciente a los nuevos colectores. No emite valores repetidos si son id\u00e9nticos al anterior.</p> </li> </ul> Ejemplo 1 <code>Flow</code>: El Flujo Fr\u00edo <p>Un Flow solo se activa cuando se consume. Perfecto para operaciones de un solo disparo que devuelven una secuencia, como leer de una base de datos o hacer una petici\u00f3n de red.</p> <p></p><pre><code>import kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.flow\nimport kotlinx.coroutines.runBlocking\n\n// 1. Definimos un Flow que emite n\u00fameros del 1 al 3, con una pausa.\nfun getNumeros(): Flow&lt;Int&gt; = flow {\n    println(\"El Flow ha comenzado a emitir.\")\n    for (i in 1..3) {\n        delay(1000) // Simula trabajo o espera\n        emit(i)\n    }\n}\n\nfun main() = runBlocking {\n    println(\"Llamando a la funci\u00f3n que devuelve el Flow...\")\n    val miFlow = getNumeros()\n\n    println(\"Esperando para recolectar...\")\n    delay(2000)\n\n    println(\"Iniciando la recolecci\u00f3n.\")\n    miFlow.collect { numero -&gt;\n        println(\"N\u00famero recibido: $numero\")\n    }\n\n    println(\"La recolecci\u00f3n ha terminado.\")\n}\n</code></pre> Resultado de la ejecuci\u00f3n:<p></p> <pre><code>Llamando a la funci\u00f3n que devuelve el Flow...\nEsperando para recolectar...\nIniciando la recolecci\u00f3n.\nEl Flow ha comenzado a emitir. // &lt;-- \u00a1NOTA! El c\u00f3digo del flow no se ejecuta hasta el .collect()\nN\u00famero recibido: 1\nN\u00famero recibido: 2\nN\u00famero recibido: 3\nLa recolecci\u00f3n ha terminado.\n</code></pre> Ejemplo 2 <code>SharedFlow</code>: El flujo para eventos <p>Ideal para enviar eventos a m\u00faltiples suscriptores. No tiene un estado inicial.</p> <p></p><pre><code>import kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\n\nfun main() = runBlocking {\n// Creamos un SharedFlow mutable para poder emitir valores.\nval eventos = MutableSharedFlow&lt;String&gt;()\n\n// Lanzamos una corrutina para el primer suscriptor\nlaunch {\n    println(\"Suscriptor 1 esperando eventos...\")\n    eventos.collect { evento -&gt;\n        println(\"Suscriptor 1 recibi\u00f3: $evento\")\n    }\n}\n\ndelay(500) // Damos tiempo a que el primer suscriptor se conecte\n\nprintln(\"Emitiendo 'Evento A'\")\neventos.emit(\"Evento A\")\n\n// Lanzamos una segunda corrutina para otro suscriptor\nlaunch {\n    println(\"Suscriptor 2 esperando eventos...\")\n    eventos.collect { evento -&gt;\n        println(\"Suscriptor 2 recibi\u00f3: $evento\")\n    }\n}\n\ndelay(500)\n\nprintln(\"Emitiendo 'Evento B'\")\neventos.emit(\"Evento B\") // Ambos suscriptores reciben este\n}\n</code></pre> Resultado de la ejecuci\u00f3n:<p></p> <pre><code>Suscriptor 1 esperando eventos...\nEmitiendo 'Evento A'\nSuscriptor 1 recibi\u00f3: Evento A\nSuscriptor 2 esperando eventos...\nEmitiendo 'Evento B'\nSuscriptor 1 recibi\u00f3: Evento B\nSuscriptor 2 recibi\u00f3: Evento B // &lt;-- Ambos reciben los eventos emitidos DESPU\u00c9S de suscribirse\n</code></pre> Ejemplo 3 <code>StateFlow</code>: El Rey de Jetpack Compose \ud83d\udc51 EjemploExplicaci\u00f3n del c\u00f3digo <p>En este ejemplo, crearemos una clase Carrito que expondr\u00e1 el n\u00famero de art\u00edculos como un StateFlow. As\u00ed, cualquier parte de nuestro c\u00f3digo que est\u00e9 \"observando\" el carrito sabr\u00e1 inmediatamente cu\u00e1ntos art\u00edculos hay.</p> <p></p><pre><code>import kotlinx.coroutines.*\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\n\n// 1. La clase que gestiona el estado\nclass Carrito {\n\n    // Privado y Mutable: Solo el carrito puede cambiar el n\u00famero de art\u00edculos.\n    // Lo inicializamos con un valor de 0 art\u00edculos.\n    private val _numeroDeArticulos = MutableStateFlow(0)\n\n    // P\u00fablico e Inmutable: Exponemos el Flow como solo lectura.\n    // Cualquiera puede observar cu\u00e1ntos art\u00edculos hay, pero no pueden cambiar el valor directamente.\n    val numeroDeArticulos = _numeroDeArticulos.asStateFlow()\n\n    fun anadirArticulo() {\n        // Usamos .update para cambiar el valor de forma segura.\n        // Es la forma recomendada para modificar un StateFlow.\n        _numeroDeArticulos.update { valorActual -&gt;\n            valorActual + 1\n        }\n        println(\"\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: ${_numeroDeArticulos.value}\")\n    }\n\n    fun quitarArticulo() {\n        if (_numeroDeArticulos.value &gt; 0) {\n            _numeroDeArticulos.update { it - 1 } // 'it' es el valor actual\n            println(\"\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: ${_numeroDeArticulos.value}\")\n        } else {\n            println(\"\u26a0\ufe0f El carrito ya est\u00e1 vac\u00edo.\")\n        }\n    }\n}\n\n// 2. La funci\u00f3n principal que simula el uso\nfun main() = runBlocking {\n    val miCarrito = Carrito()\n\n    // Lanzamos una corrutina que se quedar\u00e1 observando el carrito.\n    // Este ser\u00eda el equivalente a nuestra \"UI\" o consumidor de datos.\n    val jobObservador = launch {\n        println(\"\ud83d\udc40 Observador conectado. Esperando actualizaciones del carrito...\")\n        miCarrito.numeroDeArticulos.collect { total -&gt;\n            // Este bloque se ejecutar\u00e1 cada vez que el valor del StateFlow cambie.\n            println(\"\ud83d\uded2 (Observador) El carrito ahora tiene $total art\u00edculos.\")\n        }\n    }\n\n    // Damos un peque\u00f1o respiro para que el observador se inicie\n    delay(100)\n\n    // Simulamos interacciones del usuario\n    println(\"\\n--- Simulaci\u00f3n de usuario ---\")\n    miCarrito.anadirArticulo()\n    delay(1000)\n\n    miCarrito.anadirArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo()\n    delay(1000)\n\n    miCarrito.quitarArticulo() // Intentamos quitar cuando est\u00e1 vac\u00edo\n    println(\"--- Fin de la simulaci\u00f3n ---\\n\")\n\n    // Cancelamos la corrutina del observador para que el programa termine\n    jobObservador.cancel()\n}\n</code></pre> Salida esperada en la consola:<p></p> <pre><code>\ud83d\udc40 Observador conectado. Esperando actualizaciones del carrito...\n\ud83d\uded2 (Observador) El carrito ahora tiene 0 art\u00edculos.\n\n--- Simulaci\u00f3n de usuario ---\n\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: 1\n\ud83d\uded2 (Observador) El carrito ahora tiene 1 art\u00edculos.\n\ud83d\udce6 Art\u00edculo a\u00f1adido. Total: 2\n\ud83d\uded2 (Observador) El carrito ahora tiene 2 art\u00edculos.\n\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: 1\n\ud83d\uded2 (Observador) El carrito ahora tiene 1 art\u00edculos.\n\ud83d\uddd1\ufe0f Art\u00edculo quitado. Total: 0\n\ud83d\uded2 (Observador) El carrito ahora tiene 0 art\u00edculos.\n\u26a0\ufe0f El carrito ya est\u00e1 vac\u00edo.\n--- Fin de la simulaci\u00f3n ---\n</code></pre> <ol> <li> <p>La Clase <code>Carrito</code>:</p> <ul> <li> <p><code>_numeroDeArticulos</code>: Es un <code>MutableStateFlow</code>. El guion bajo <code>_</code> es una convenci\u00f3n en Kotlin para indicar que es una propiedad privada que no debe usarse desde fuera. Al ser <code>Mutable</code>, esta clase puede cambiar su valor. Siempre necesita un valor inicial (en este caso, <code>0</code>).</p> </li> <li> <p><code>numeroDeArticulos</code>: Esta es la versi\u00f3n p\u00fablica y de solo lectura (<code>StateFlow</code>). La \"UI\" o el consumidor observar\u00e1 esta propiedad. Esto protege el estado; nadie fuera de la clase <code>Carrito</code> puede modificar el n\u00famero de art\u00edculos. Es un principio de encapsulaci\u00f3n.</p> </li> <li> <p><code>anadirArticulo()</code> y <code>quitarArticulo()</code>: Son las acciones que modifican el estado interno (<code>_numeroDeArticulos</code>). La funci\u00f3n <code>.update { ... }</code> es la forma moderna y segura de hacerlo.</p> </li> </ul> </li> <li> <p>La Funci\u00f3n <code>main</code>:</p> <ul> <li> <p><code>launch</code>: Creamos un \"observador\" en una corrutina separada. Este se suscribe al <code>StateFlow</code> p\u00fablico.</p> </li> <li> <p><code>.collect</code>: Aqu\u00ed ocurre la magia. El c\u00f3digo dentro de <code>.collect</code> se ejecuta inmediatamente con el valor actual del <code>StateFlow</code> (que es <code>0</code>) y luego se vuelve a ejecutar cada vez que el valor cambia.</p> </li> <li> <p><code>delay</code>: Usamos pausas para simular el paso del tiempo y que se pueda ver claramente en la consola c\u00f3mo el observador reacciona a los cambios.</p> </li> </ul> </li> </ol> <p>Puedes crear un <code>Flow</code> utilizando la funci\u00f3n <code>flowOf()</code> de Kotlin.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Flow</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#observacion-de-flows","title":"Observaci\u00f3n de Flows","text":"<p>Puedes observar un <code>Flow</code> utilizando la funci\u00f3n <code>collect()</code> de Kotlin.</p> <pre><code>numeros.collect { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se observa el <code>Flow</code> <code>numeros</code> y se imprime cada valor que se emite.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#transformacion-de-flows","title":"Transformaci\u00f3n de Flows","text":"<p>Puedes transformar un <code>Flow</code> utilizando operadores como <code>map</code>, <code>filter</code>, <code>flatMap</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan los operadores <code>map</code> y <code>filter</code> para transformar el <code>Flow</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#tipos-de-flow-en-kotlin","title":"Tipos de flow en Kotlin","text":""},{"location":"temas/00-android/00-compose/22-state-management.html#flows-en-jetpack-compose","title":"Flows en Jetpack Compose","text":"<p>En Jetpack Compose, puedes utilizar Flows para gestionar la informaci\u00f3n de tu aplicaci\u00f3n de forma reactiva.</p> <p>Puedes convertir un <code>Flow</code> en un estado observable utilizando la funci\u00f3n <code>collectAsState()</code> de Compose.</p> <pre><code>val numeros = flowOf(1, 2, 3, 4, 5)\nval numerosState = numeros.collectAsState()\n</code></pre> <p>En el ejemplo anterior, se convierte el <code>Flow</code> <code>numeros</code> en un estado observable <code>numerosState</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#elevacion-del-estado","title":"Elevaci\u00f3n del estado","text":"<p>En Jetpack Compose, puedes elevar el estado de un componente para compartirlo con otros componentes.</p> <p>Esto te permite gestionar el estado de tu aplicaci\u00f3n de forma centralizada y compartirlo entre diferentes partes de tu interfaz de usuario.</p> <pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    ContadorBoton(contador)\n    ContadorTexto(contador)\n}\n\n@Composable\nfun ContadorBoton(contador: MutableState&lt;Int&gt;) {\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Incrementar\")\n    }\n}\n\n@Composable\nfun ContadorTexto(contador: MutableState&lt;Int&gt;) {\n    Text(text = \"Contador: ${contador.value}\")\n}\n</code></pre> <p>En el ejemplo anterior, se eleva el estado <code>contador</code> del componente <code>Contador</code> para compartirlo con los componentes <code>ContadorBoton</code> y <code>ContadorTexto</code>.</p> <p>De esta forma, el estado <code>contador</code> se gestiona de forma centralizada en el componente <code>Contador</code> y se comparte con los componentes hijos. Y ambos se recomponen cuando el estado cambia.</p> <p>Esto tambi\u00e9n facilita la reutilizaci\u00f3n de los componentes y la separaci\u00f3n de las preocupaciones en tu aplicaci\u00f3n. Adem\u00e1s de facilitar la prueba y el mantenimiento del c\u00f3digo.</p> <p>Elevaci\u00f3n del estado vs. Inyecci\u00f3n de dependencias</p> <ul> <li>La elevaci\u00f3n del estado es una t\u00e9cnica com\u00fan en Jetpack Compose para compartir el estado entre componentes.</li> <li>Otra t\u00e9cnica com\u00fan es la inyecci\u00f3n de dependencias, que consiste en pasar el estado como argumento a los componentes que lo necesitan.</li> </ul> <p>Ambas t\u00e9cnicas tienen sus ventajas y desventajas, y la elecci\u00f3n entre ellas depende del dise\u00f1o y la arquitectura de tu aplicaci\u00f3n.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#conclusion","title":"\ud83d\udccc Conclusi\u00f3n","text":"<p>La gesti\u00f3n de estado es una parte fundamental de la arquitectura de tu aplicaci\u00f3n en Jetpack Compose.</p> <p>Con Compose, puedes definir, observar y actualizar el estado de tu aplicaci\u00f3n de forma reactiva y declarativa.</p> <p>Los Flows te permiten trabajar con datos de forma reactiva y gestionar la concurrencia de forma sencilla en Kotlin.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#ejemplo-de-gestion-del-estado-basica-en-una-app-de-contador","title":"Ejemplo de gesti\u00f3n del estado b\u00e1sica en una app de Contador","text":"<pre><code>@Composable\nfun Contador() {\n    val contador = remember { mutableStateOf(0) }\n    val contadorState = contador.observeAsState()\n\n    Button(onClick = { contador.value++ }) {\n        Text(text = \"Contador: ${contadorState.value}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>Contador</code> que muestra un bot\u00f3n y un texto con el valor del estado <code>contador</code>. Al hacer clic en el bot\u00f3n, se incrementa en uno el valor del estado <code>contador</code>.</p>"},{"location":"temas/00-android/00-compose/22-state-management.html#recursos","title":"\ud83d\udce6 Recursos","text":"<ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Ejemplos b\u00e1sicos de Compose: Un repositorio con ejemplos b\u00e1sicos de Jetpack Compose para que puedas aprender a crear interfaces de usuario con Compose.   </li> <li>Avanzando con Kotlin y el manejo de la UI - Codelabs</li> <li>M\u00e1s Kotlin y listas de elementos (LazyColumn) - Codelabs</li> </ul>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html","title":"Listas","text":""},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#listas-en-compose","title":"Listas en Compose","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos utilizando los componentes <code>LazyColumn</code> y <code>LazyRow</code>. Estos componentes te permiten mostrar una lista de elementos de forma eficiente y reactiva.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazycolumn","title":"LazyColumn","text":"<p>El componente <code>LazyColumn</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyColumn</code> para mostrar una lista de elementos verticales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaVertical() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaVertical</code> que muestra una lista de 100 elementos verticales utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p> <p>Video Listas y LazyColumn</p> <p></p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#lazyrow","title":"LazyRow","text":"<p>El componente <code>LazyRow</code> te permite mostrar una lista de elementos de forma eficiente y reactiva. Puedes utilizar <code>LazyRow</code> para mostrar una lista de elementos horizontales que se cargan de forma perezosa a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ListaHorizontal() {\n    LazyRow {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaHorizontal</code> que muestra una lista de 100 elementos horizontales utilizando <code>LazyRow</code>. El m\u00e9todo <code>items()</code> de <code>LazyRow</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#scroll-infinito","title":"Scroll infinito","text":"<p>Puedes implementar el scroll infinito en las listas de Compose utilizando el m\u00e9todo <code>items()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando una lista infinita como argumento. Esto te permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <pre><code>@Composable\nfun ScrollInfinito() {\n    val elementos = remember { mutableStateListOf&lt;String&gt;() }\n\n    LazyColumn {\n        items(elementos) { elemento -&gt;\n            Text(text = elemento)\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ScrollInfinito</code> que muestra una lista de elementos utilizando <code>LazyColumn</code>. Se utiliza un estado mutable <code>mutableStateListOf</code> para almacenar los elementos de la lista, y se pasa esta lista como argumento al m\u00e9todo <code>items()</code> de <code>LazyColumn</code>. Esto permite cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El manejo del scroll infinito en Compose es similar al manejo del scroll infinito en otras bibliotecas de UI, como RecyclerView en Android. Puedes utilizar t\u00e9cnicas como la paginaci\u00f3n y la carga perezosa para cargar nuevos elementos a medida que el usuario se desplaza por la lista.</p> <p>El estado mutable <code>mutableStateListOf</code> se utiliza para almacenar los elementos de la lista y notificar a Compose cuando se actualizan los elementos. Esto permite que Compose vuelva a renderizar la lista con los nuevos elementos.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#elementos-personalizados","title":"Elementos personalizados","text":"<p>Puedes utilizar elementos personalizados en las listas de Compose para mostrar elementos m\u00e1s complejos. Para ello, puedes utilizar el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasar un componente personalizado como argumento.</p> <pre><code>@Composable\nfun ListaPersonalizada() {\n    LazyColumn {\n        items(100) { index -&gt;\n            ElementoPersonalizado(index)\n        }\n    }\n}\n\n@Composable\nfun ElementoPersonalizado(index: Int) {\n    Text(text = \"Elemento $index\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaPersonalizada</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. El m\u00e9todo <code>items()</code> de <code>LazyColumn</code> se utiliza para generar los elementos de la lista en funci\u00f3n de un rango de \u00edndices, y se pasa un componente personalizado <code>ElementoPersonalizado</code> como argumento.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#escuchadores-de-eventos","title":"Escuchadores de eventos","text":"<p>Puedes a\u00f1adir escuchadores de eventos a los elementos de la lista para responder a las interacciones del usuario. Por ejemplo, puedes a\u00f1adir un escuchador de clics a un elemento de la lista para realizar una acci\u00f3n cuando el usuario haga clic en \u00e9l.</p> <pre><code>@Composable\nfun ListaConClics() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Text(\n                text = \"Elemento $index\",\n                modifier = Modifier.clickable { /* Acci\u00f3n al hacer clic */ }\n            )\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConClics</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un escuchador de clics al elemento de la lista utilizando el modificador <code>clickable</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#separadores","title":"Separadores","text":"<p>Puedes a\u00f1adir separadores entre los elementos de la lista utilizando el m\u00e9todo <code>item()</code> de <code>LazyColumn</code> o <code>LazyRow</code> y pasando un componente separador como argumento.</p> <pre><code>@Composable\nfun ListaConSeparadores() {\n    LazyColumn {\n        items(100) { index -&gt;\n            Column {\n                ElementoPersonalizado(index)\n                Divider()\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaConSeparadores</code> que muestra una lista de 100 elementos utilizando <code>LazyColumn</code>. Se a\u00f1ade un separador <code>Divider()</code> entre cada elemento de la lista.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#filtrado-y-ordenacion","title":"Filtrado y ordenaci\u00f3n","text":"<p>Puedes filtrar y ordenar los elementos de la lista utilizando funciones de extensi\u00f3n como <code>filter()</code> y <code>sortedBy()</code>. Estas funciones te permiten realizar operaciones comunes con las listas de forma sencilla y eficiente.</p> <pre><code>@Composable\nfun ListaFiltrada() {\n    val numeros = (0..100).toList()\n\n    LazyColumn {\n        items(numeros.filter { it % 2 == 0 }) { numero -&gt;\n            Text(text = \"N\u00famero $numero\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>ListaFiltrada</code> que muestra una lista de n\u00fameros pares del 0 al 100 utilizando <code>LazyColumn</code>. Se filtran los n\u00fameros pares utilizando la funci\u00f3n de extensi\u00f3n <code>filter()</code>.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#porque-usar-lazycolumn-y-lazyrow-en-lugar-de-column-y-row","title":"Porqu\u00e9 usar LazyColumn y LazyRow en lugar de Column y Row","text":"<p><code>LazyColumn</code> y <code>LazyRow</code> son componentes optimizados para mostrar listas de elementos de forma eficiente y reactiva. A diferencia de <code>Column</code> y <code>Row</code>, que renderizan todos los elementos de la lista de forma inmediata, <code>LazyColumn</code> y <code>LazyRow</code> renderizan solo los elementos visibles en la pantalla y los elementos que est\u00e1n cerca de la zona visible.</p> <p>Esto hace que <code>LazyColumn</code> y <code>LazyRow</code> sean m\u00e1s eficientes en t\u00e9rminos de rendimiento y consumo de recursos, especialmente cuando se trabaja con listas grandes o infinitas.</p> <p>Por lo tanto, es recomendable utilizar <code>LazyColumn</code> y <code>LazyRow</code> para mostrar listas de elementos en Jetpack Compose, ya que proporcionan una experiencia de usuario m\u00e1s fluida y eficiente.</p>"},{"location":"temas/00-android/00-compose/23-listas-cuadriculas.html#cuadriculsa-o-grids","title":"Cuadr\u00edculsa o Grids","text":"<p>En Jetpack Compose, puedes mostrar listas de elementos en forma de cuadr\u00edculas utilizando el componente <code>LazyVerticalGrid</code> o <code>LazyHorizontalGrid</code>. Estos componentes te permiten mostrar una cuadr\u00edcula de elementos de forma eficiente y reactiva.</p> <pre><code>@Composable\nfun CuadriculaVertical() {\n    LazyVerticalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaVertical</code> que muestra una cuadr\u00edcula de 100 elementos en 3 columnas utilizando <code>LazyVerticalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyVerticalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p> <pre><code>@Composable\nfun CuadriculaHorizontal() {\n    LazyHorizontalGrid(cells = GridCells.Fixed(3)) {\n        items(100) { index -&gt;\n            Text(text = \"Elemento $index\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>CuadriculaHorizontal</code> que muestra una cuadr\u00edcula de 100 elementos en 3 filas utilizando <code>LazyHorizontalGrid</code>. El m\u00e9todo <code>items()</code> de <code>LazyHorizontalGrid</code> se utiliza para generar los elementos de la cuadr\u00edcula en funci\u00f3n de un rango de \u00edndices.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html","title":"Navegaci\u00f3n Rutas","text":""},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-y-rutas-en-jetpack-compose","title":"Navegaci\u00f3n y rutas en Jetpack Compose","text":"<p>Jetpack Compose es un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario en aplicaciones Android. Con Compose, puedes crear interfaces de usuario de manera declarativa, lo que significa que puedes definir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#configuracion-de-la-navegacion","title":"Configuraci\u00f3n de la navegaci\u00f3n","text":"<p>Para administrar la navegaci\u00f3n en Jetpack Compose, necesitas agregar la dependencia de <code>navigation-compose</code> a tu archivo <code>build.gradle</code> y definir las rutas y destinos de tu aplicaci\u00f3n en un archivo de configuraci\u00f3n de navegaci\u00f3n.</p> build.gradle.kts<pre><code>dependencies {\n    val nav_version = \"2.8.5\"\n\n    implementation(\"androidx.navigation:navigation-compose:$nav_version\")\n}\n</code></pre> <p>Video ejemplo de uso de Navegaci\u00f3n</p> <p></p> <p>Video ejemplo de Splash Screen personalizada</p> <p></p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-en-jetpack-compose","title":"Navegaci\u00f3n en Jetpack Compose","text":"<p>En Jetpack Compose, puedes implementar la navegaci\u00f3n entre pantallas utilizando el componente <code>NavHost</code>. <code>NavHost</code> es un contenedor que muestra las pantallas de tu aplicaci\u00f3n en funci\u00f3n de las rutas definidas.</p> <pre><code>@Composable\nfun MyApp() {\n    val navController = rememberNavController()\n\n    NavHost(navController = navController, startDestination = \"pantalla1\") {\n        composable(\"pantalla1\") {\n            Pantalla1()\n        }\n        composable(\"pantalla2\") {\n            Pantalla2()\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MyApp</code> que utiliza <code>NavHost</code> para implementar la navegaci\u00f3n entre dos pantallas: <code>Pantalla1</code> y <code>Pantalla2</code>. <code>NavHost</code> toma un <code>NavController</code> como argumento y define las rutas de las pantallas utilizando el m\u00e9todo <code>composable</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#definicion-de-rutas","title":"Definici\u00f3n de rutas","text":"<p>Puedes definir las rutas de tu aplicaci\u00f3n utilizando el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Cada ruta tiene un nombre \u00fanico que se utiliza para identificar la pantalla correspondiente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1()\n    }\n    composable(\"pantalla2\") {\n        Pantalla2()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se definen dos rutas: <code>pantalla1</code> y <code>pantalla2</code>, que corresponden a las pantallas <code>Pantalla1</code> y <code>Pantalla2</code>, respectivamente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas","title":"Navegaci\u00f3n entre pantallas","text":"<p>Puedes navegar entre pantallas en Jetpack Compose utilizando el <code>NavController</code> y el m\u00e9todo <code>navigate</code>.</p> <pre><code>Button(onClick = { navController.navigate(\"pantalla2\") }) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>navigate</code> del <code>NavController</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#paso-de-datos-entre-pantallas","title":"Paso de datos entre pantallas","text":"<p>Puedes pasar datos entre pantallas en Jetpack Compose utilizando el m\u00e9todo <code>navigate</code> y el argumento <code>arguments</code>.</p> <pre><code>Button(onClick = {\n    navController.navigate(\"pantalla2\") {\n        launchSingleTop = true\n        popUpTo(\"pantalla1\") { inclusive = true }\n        arguments = bundleOf(\"dato\" to \"Hola, mundo!\")\n    }\n}) {\n    Text(text = \"Ir a Pantalla 2\")\n}\n</code></pre> <p>En el ejemplo anterior, se define un bot\u00f3n que, al hacer clic en \u00e9l, navega a la pantalla <code>Pantalla2</code> y pasa el dato <code>\"Hola, mundo!\"</code> como argumento.</p> <p>El argumento <code>arguments</code> se utiliza para pasar datos entre pantallas. Puedes utilizar <code>bundleOf</code> para crear un <code>Bundle</code> con los datos que deseas pasar.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recuperacion-de-datos-en-la-pantalla-de-destino","title":"Recuperaci\u00f3n de datos en la pantalla de destino","text":"<p>Puedes recuperar los datos pasados como argumentos en la pantalla de destino utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p> <pre><code>val navBackStackEntry by navController.currentBackStackEntryAsState()\nval dato = navBackStackEntry?.arguments?.getString(\"dato\")\n</code></pre> <p>En el ejemplo anterior, se recupera el dato pasado como argumento en la pantalla <code>Pantalla2</code> utilizando el m\u00e9todo <code>currentBackStackEntryAsState</code> y el argumento <code>arguments</code>.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#navegacion-entre-pantallas-usando-lambdas","title":"Navegaci\u00f3n entre pantallas usando lambdas","text":"<p>En Jetpack Compose, puedes utilizar lambdas para definir la navegaci\u00f3n entre pantallas de forma m\u00e1s concisa.</p> <p>La definici\u00f3n de estas lambdas puede hacerse en el m\u00e9todo <code>composable</code> de <code>NavHost</code>. Esto nos ayuda a mantener un c\u00f3digo m\u00e1s limpio y legible.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantalla1\") {\n    composable(\"pantalla1\") {\n        Pantalla1 {\n            navController.navigate(\"pantalla2\")\n        }\n    }\n    composable(\"pantalla2\") {\n        Pantalla2 {\n            navController.navigate(\"pantalla1\")\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define la navegaci\u00f3n entre las pantallas <code>Pantalla1</code> y <code>Pantalla2</code> utilizando lambdas en el m\u00e9todo <code>composable</code> de <code>NavHost</code>.</p> <p>De esta forma, al definir la navegaci\u00f3n en el propio componente, se mantiene un c\u00f3digo m\u00e1s limpio y legible.</p> <p>Por ejemplo, el composable <code>Pantalla1</code> recibe una lambda que navega a la pantalla <code>Pantalla2</code>, y el composable <code>Pantalla2</code> recibe una lambda que navega a la pantalla <code>Pantalla1</code>.</p> <pre><code>@Composable\nfun Pantalla1(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 2\")\n    }\n}\n\n@Composable\nfun Pantalla2(onNavigate: () -&gt; Unit) {\n    Button(onClick = onNavigate) {\n        Text(text = \"Ir a Pantalla 1\")\n    }\n}\n</code></pre> <p>En los componibles <code>Pantalla1</code> y <code>Pantalla2</code>, se define un bot\u00f3n que, al hacer clic en \u00e9l, ejecuta la lambda recibida como argumento, que navega a la pantalla correspondiente.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#para-la-definicion-de-los-nombres-de-las-pantallas","title":"Para la definici\u00f3n de los nombres de las pantallas","text":"<p>Es importante definir nombres significativos para las pantallas de tu aplicaci\u00f3n. Los nombres de las pantallas deben reflejar claramente el prop\u00f3sito y la funcionalidad de cada pantalla.</p> <p>Por ejemplo, si tienes una pantalla de inicio y una pantalla de perfil, puedes nombrarlas <code>pantallaInicio</code> y <code>pantallaPerfil</code>, respectivamente.</p> <pre><code>NavHost(navController = navController, startDestination = \"pantallaInicio\") {\n    composable(\"pantallaInicio\") {\n        PantallaInicio()\n    }\n    composable(\"pantallaPerfil\") {\n        PantallaPerfil()\n    }\n}\n</code></pre> <p>Estos nombres pueden definirse en un archivo de constantes o en un objeto de compa\u00f1ero para mantener un c\u00f3digo m\u00e1s organizado y legible. Existen varias opciones para definir los nombres de las pantallas, como objetos de compa\u00f1ero, constantes o enumeraciones. </p> <p> </p><pre><code>object Rutas {\n    const val PANTALLA_INICIO = \"pantallaInicio\"\n    const val PANTALLA_PERFIL = \"pantallaPerfil\"\n}\n</code></pre> <pre><code>const val PANTALLA_INICIO = \"pantallaInicio\"\nconst val PANTALLA_PERFIL = \"pantallaPerfil\"\n</code></pre> <pre><code>enum class Rutas {\n    PANTALLA_INICIO,\n    PANTALLA_PERFIL\n}\n</code></pre> <pre><code>sealed class Rutas {\n    object PANTALLA_INICIO : Rutas()\n    object PANTALLA_PERFIL : Rutas()\n}\n</code></pre> <p></p> <p>En el ejemplo anterior, se definen los nombres de las pantallas <code>PANTALLA_INICIO</code> y <code>PANTALLA_PERFIL</code> utilizando un objeto an\u00f3nimo, constantes, enumeraciones y clases selladas.</p>"},{"location":"temas/00-android/00-compose/24-navegacion-rutas.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose Navigation: La documentaci\u00f3n oficial de Jetpack Compose Navigation, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar la navegaci\u00f3n en Compose.</p> </li> <li> <p>Navegaci\u00f3n y arquitectura de la app (MVVM) - Codelabs</p> </li> <li> <p>Ejercicio navegaci\u00f3n - Enunciado - Soluci\u00f3n</p> </li> </ul>"},{"location":"temas/00-android/00-compose/25-material-design.html","title":"Material Design","text":""},{"location":"temas/00-android/00-compose/25-material-design.html#material-design-en-jetpack-compose","title":"Material Design en Jetpack Compose","text":"<p>Material Design es un sistema de dise\u00f1o desarrollado por Google que ayuda a los desarrolladores a crear interfaces de usuario atractivas y coherentes en aplicaciones Android. Con Jetpack Compose, puedes implementar los principios de Material Design de forma sencilla y eficiente.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#temas-y-estilos","title":"Temas y estilos","text":"<p>Jetpack Compose incluye un conjunto de widgets y estilos basados en Material Design que puedes utilizar para crear interfaces de usuario modernas y atractivas. Puedes personalizar los colores, tipograf\u00edas y formas de tus componentes para adaptarlos a la identidad visual de tu aplicaci\u00f3n.</p> <pre><code>@Composable\nfun MiApp() {\n    MaterialTheme {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un componente <code>MiApp</code> que utiliza <code>MaterialTheme</code> para aplicar los estilos de Material Design a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#widgets-de-material-design","title":"Widgets de Material Design","text":"<p>Jetpack Compose incluye una amplia variedad de widgets de Material Design que puedes utilizar para crear interfaces de usuario complejas y atractivas. Algunos de los widgets m\u00e1s comunes son:</p> <ul> <li><code>Button</code>: Un bot\u00f3n interactivo que el usuario puede pulsar para realizar una acci\u00f3n.</li> <li><code>TextField</code>: Un campo de texto que el usuario puede utilizar para introducir texto.</li> <li><code>Checkbox</code>: Una casilla de verificaci\u00f3n que el usuario puede marcar o desmarcar.</li> <li><code>RadioButton</code>: Un bot\u00f3n de opci\u00f3n que el usuario puede seleccionar entre varias opciones.</li> <li><code>Switch</code>: Un interruptor que el usuario puede activar o desactivar.</li> </ul> <p>Puedes utilizar estos widgets y muchos m\u00e1s para crear interfaces de usuario modernas y atractivas en tus aplicaciones Android con Jetpack Compose.</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#personalizacion-de-estilos","title":"Personalizaci\u00f3n de estilos","text":"<p>Puedes personalizar los estilos de Material Design en Jetpack Compose para adaptarlos a la identidad visual de tu aplicaci\u00f3n. Puedes definir tus propios temas y estilos utilizando el componente <code>MaterialTheme</code> y los objetos <code>Typography</code>, <code>Colors</code> y <code>Shapes</code>.</p> <pre><code>val MiTema = lightColors(\n    primary = Color(0xFF6200EE),\n    primaryVariant = Color(0xFF3700B3),\n    secondary = Color(0xFF03DAC6)\n)\n\n@Composable\nfun MiApp() {\n    MaterialTheme(colors = MiTema) {\n        Column {\n            Text(text = \"Hola, mundo!\", style = MaterialTheme.typography.title-large)\n            Button(onClick = { /* Acci\u00f3n */ }) {\n                Text(text = \"Haz clic aqu\u00ed\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define un tema personalizado <code>MiTema</code> con colores personalizados y se utiliza <code>MaterialTheme</code> para aplicar este tema a los componentes de la interfaz de usuario. Se utiliza <code>MaterialTheme.typography.title-large</code> para aplicar un estilo de tipograf\u00eda grande al texto y se utiliza <code>Button</code> para mostrar un bot\u00f3n con el texto \"Haz clic aqu\u00ed\".</p>"},{"location":"temas/00-android/00-compose/25-material-design.html#recursos","title":"Recursos","text":"<ul> <li> <p>Documentaci\u00f3n oficial de Material Design: La documentaci\u00f3n oficial de Material Design, que incluye gu\u00edas, tutoriales y ejemplos para aprender a dise\u00f1ar interfaces de usuario con Material Design.</p> </li> <li> <p>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a crear interfaces de usuario con Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-compose/99-glosario-android.html","title":"Glosario","text":""},{"location":"temas/00-android/00-compose/99-glosario-android.html#glosario-de-android","title":"Glosario de Android","text":"<p>Este documento sirve como referencia r\u00e1pida para los conceptos clave del desarrollo moderno de Android. Los t\u00e9rminos est\u00e1n agrupados por \u00e1reas tem\u00e1ticas para facilitar su comprensi\u00f3n en contexto.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#1-fundamentos-de-kotlin-el-lenguaje","title":"1. Fundamentos de Kotlin (El Lenguaje)","text":"<p>Conceptos del lenguaje sobre los que se construye todo el desarrollo moderno.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#data-class","title":"Data Class","text":"<p>Una clase dise\u00f1ada espec\u00edficamente para contener datos. El compilador genera autom\u00e1ticamente m\u00e9todos \u00fatiles como <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code> y <code>copy()</code>. Fundamental para definir modelos y estados de UI. </p><pre><code>data class Usuario(val id: String, val nombre: String)\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#sealed-class-interface","title":"Sealed Class / Interface","text":"<p>Una jerarqu\u00eda de clases restringida. Define un conjunto cerrado de posibles subclases. Es ideal para modelar Estados de UI (ej: <code>Cargando</code>, <code>Exito</code>, <code>Error</code>) porque obliga al compilador a manejar todos los casos posibles en un <code>when</code>.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#lambda","title":"Lambda","text":"<p>Una funci\u00f3n an\u00f3nima que puede ser tratada como un valor (pasada como par\u00e1metro o guardada en una variable). Es el motor de Jetpack Compose (ej: <code>onClick = { ... }</code>). </p><pre><code>val suma = { x: Int, y: Int -&gt; x + y }\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#extension-function","title":"Extension Function","text":"<p>Capacidad de Kotlin para a\u00f1adir funciones a una clase existente sin tener que heredar de ella. </p><pre><code>fun String.esEmailValido(): Boolean { ... }\n\"test@test.com\".esEmailValido()\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#higher-order-function-funcion-de-orden-superior","title":"Higher-Order Function (Funci\u00f3n de Orden Superior)","text":"<p>Una funci\u00f3n que acepta otra funci\u00f3n como par\u00e1metro o devuelve una funci\u00f3n. Es la base de los <code>LazyColumn</code>, <code>Button</code>, y casi cualquier Composable contenedor.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#2-android-core-el-sistema","title":"2. Android Core (El Sistema)","text":"<p>Los cimientos del sistema operativo Android que todo desarrollador debe conocer.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#activity","title":"Activity","text":"<p>Un componente fundamental que representa una pantalla con una interfaz de usuario. Es el punto de entrada principal para la interacci\u00f3n del usuario. En Compose, solemos tener una sola Activity (<code>MainActivity</code>) que contiene toda la app (\"Single Activity Architecture\").</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#context","title":"Context","text":"<p>Es el puente entre tu c\u00f3digo y el sistema Android. Permite acceder a recursos (cadenas, colores), iniciar Activities, enviar Broadcasts y acceder a servicios del sistema.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#manifest-androidmanifestxml","title":"Manifest (<code>AndroidManifest.xml</code>)","text":"<p>El \"DNI\" de la aplicaci\u00f3n. Un archivo XML que describe la app al sistema: nombre, icono, componentes (Activities, Services), y permisos requeridos.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#intent","title":"Intent","text":"<p>Un objeto de mensajer\u00eda que se usa para solicitar una acci\u00f3n a otro componente de la app. *   Intents Expl\u00edcitos: Para iniciar una Activity espec\u00edfica dentro de tu app. *   Intents Impl\u00edcitos: Para declarar una intenci\u00f3n general (ej: \"Quiero abrir una URL\") y dejar que el sistema decida qu\u00e9 app usar (Chrome, Firefox, etc.).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#lifecycle-ciclo-de-vida","title":"Lifecycle (Ciclo de Vida)","text":"<p>La serie de estados por los que pasa una Activity o Fragment (Creado, Iniciado, Reanudado, Pausado, Destruido). Entenderlo es vital para evitar fugas de memoria y guardar datos correctamente.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#3-jetpack-compose-la-ui-moderna","title":"3. Jetpack Compose (La UI Moderna)","text":"<p>El kit de herramientas declarativo para construir interfaces nativas.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#composable-composable","title":"Composable (<code>@Composable</code>)","text":"<p>Una funci\u00f3n de Kotlin anotada con <code>@Composable</code> que describe QU\u00c9 UI se debe mostrar (no C\u00d3MO). Es el bloque de construcci\u00f3n b\u00e1sico de Compose.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#state-mutablestatet","title":"State (<code>MutableState&lt;T&gt;</code>)","text":"<p>Un contenedor de datos observable. Cuando el valor dentro de un <code>State</code> cambia, Compose detecta el cambio y programa una Recomposici\u00f3n.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#recomposition-recomposicion","title":"Recomposition (Recomposici\u00f3n)","text":"<p>El proceso mediante el cual Compose re-ejecuta tus funciones composables para actualizar la UI con nuevos datos. Compose es inteligente y solo redibuja las partes que han cambiado.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#modifier","title":"Modifier","text":"<p>Un objeto que se encadena para decorar o configurar un composable. Controla el tama\u00f1o, padding, clics, fondo, bordes, etc. El orden de los modificadores importa. </p><pre><code>Box(modifier = Modifier.size(50.dp).background(Color.Red))\n</code></pre><p></p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#side-effect-efecto-secundario","title":"Side Effect (Efecto Secundario)","text":"<p>Cualquier cambio de estado que ocurra fuera del alcance de una funci\u00f3n composable (ej: llamadas a red, acceso a BBDD, logs). En Compose, deben controlarse con APIs especiales como <code>LaunchedEffect</code> para evitar que se ejecuten infinitas veces durante las recomposiciones.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#scaffold","title":"Scaffold","text":"<p>Un composable que implementa la estructura visual b\u00e1sica de Material Design. Proporciona \"slots\" (huecos) predefinidos para la <code>TopBar</code>, <code>BottomBar</code>, <code>FloatingActionButton</code> y el contenido principal.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#4-arquitectura-y-concurrencia-el-cerebro","title":"4. Arquitectura y Concurrencia (El \"Cerebro\")","text":"<p>C\u00f3mo estructurar la aplicaci\u00f3n y manejar tareas en segundo plano.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#mvvm-model-view-viewmodel","title":"MVVM (Model-View-ViewModel)","text":"<p>El patr\u00f3n de arquitectura recomendado por Google. *   Model: Datos y l\u00f3gica de negocio. *   View: La UI (Composable). *   ViewModel: Intermediario que guarda el estado de la UI y gestiona la l\u00f3gica, sobreviviendo a cambios de configuraci\u00f3n (como rotar la pantalla).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#udf-unidirectional-data-flow","title":"UDF (Unidirectional Data Flow)","text":"<p>Flujo de Datos Unidireccional. Un patr\u00f3n donde: 1.  El Estado fluye hacia abajo (del ViewModel a la UI). 2.  Los Eventos fluyen hacia arriba (de la UI al ViewModel). Esto hace que el estado sea predecible y f\u00e1cil de depurar.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#clean-architecture","title":"Clean Architecture","text":"<p>Una forma de organizar el c\u00f3digo en capas (Presentaci\u00f3n, Dominio, Datos) para que sea mantenible, testeable e independiente de librer\u00edas externas. La capa de Dominio (Use Cases) es el n\u00facleo puro de la l\u00f3gica de negocio.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#corrutina-coroutine","title":"Corrutina (Coroutine)","text":"<p>Un hilo ligero gestionado por Kotlin. Permite escribir c\u00f3digo as\u00edncrono (como llamadas a red) de forma secuencial y legible, sin bloquear el hilo principal (UI Thread).</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#suspend-function","title":"Suspend Function","text":"<p>Una funci\u00f3n que puede ser pausada y reanudada. Solo puede ser llamada desde una corrutina u otra funci\u00f3n suspendida. Es la base de la asincron\u00eda en Kotlin.</p>"},{"location":"temas/00-android/00-compose/99-glosario-android.html#flow-stateflow","title":"Flow / StateFlow","text":"<p>Mecanismos para manejar flujos de datos as\u00edncronos (streams). *   Flow (Cold): Flujo de datos que solo emite cuando hay un colector activo. *   StateFlow (Hot): Un tipo especial de Flow que siempre tiene un valor actual y emite actualizaciones a sus colectores. Es el reemplazo moderno de <code>LiveData</code> en arquitectura Kotlin pura.</p>"},{"location":"temas/00-android/00-kotlin/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/00-android/00-kotlin/index.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/index.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/index.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html","title":"El lenguaje Kotlin","text":""},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#el-lenguaje-kotlin","title":"El lenguaje Kotlin","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y seguro que se ejecuta en la m\u00e1quina virtual de Java (JVM) y tambi\u00e9n se puede compilar a JavaScript o nativo. Fue desarrollado por JetBrains y Google en 2011 y se ha convertido en el lenguaje de programaci\u00f3n oficial para el desarrollo de aplicaciones Android.</p>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#caracteristicas-de-kotlin","title":"Caracter\u00edsticas de Kotlin","text":"<ul> <li> <p>Interoperabilidad con Java: Kotlin es 100% interoperable con Java, lo que significa que puedes usar todas las bibliotecas de Java en tus proyectos de Kotlin y viceversa. </p> </li> <li> <p>Seguridad nula: Kotlin tiene un sistema de tipos que elimina la posibilidad de errores de puntero nulo en tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Concisi\u00f3n y legibilidad: Kotlin es un lenguaje conciso y f\u00e1cil de leer. Puedes escribir menos c\u00f3digo y hacer m\u00e1s cosas.   </p> </li> <li> <p>Programaci\u00f3n funcional: Kotlin admite programaci\u00f3n funcional y orientada a objetos. Puedes escribir funciones de orden superior, funciones lambda y mucho m\u00e1s.    </p> </li> <li> <p>Extensiones de funciones: Kotlin te permite agregar nuevas funciones a las clases existentes sin heredar de ellas.    </p> </li> <li> <p>Clases de datos: Kotlin tiene una sintaxis especial para crear clases de datos que contienen solo datos y no tienen comportamiento.   </p> </li> <li> <p>Corrutinas: Kotlin tiene soporte para corutinas, que te permiten escribir c\u00f3digo asincr\u00f3nico de manera secuencial.    </p> </li> <li> <p>Jetpack Compose: Kotlin es el lenguaje oficial para el desarrollo de aplicaciones Android con Jetpack Compose, un marco de trabajo moderno para la creaci\u00f3n de interfaces de usuario. </p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#apartados","title":"Apartados","text":"<ul> <li>Variables y tipos de datos</li> <li>Expresiones vs. sentencias</li> <li>Funciones y lambdas</li> <li>Null Safety</li> <li>Clases y objetos</li> <li>Objetos an\u00f3nimos</li> <li>Data classes</li> <li>Enum classes</li> <li>Gen\u00e9ricos</li> <li>Sealed classes</li> <li>Scope functions</li> <li>Arrays en Kotlin</li> <li>Colecciones en Kotlin</li> <li>Mapas en Kotlin</li> <li>Sets en Kotlin</li> <li>Corrutinas en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/01-sobre-kotlin.html#recursos","title":"Recursos","text":"<ul> <li> <p>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</p> </li> <li> <p>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</p> </li> <li> <p>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html","title":"Variables","text":""},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-variables-y-datos-en-kotlin","title":"Tipos de variables y datos en Kotlin","text":"<p>En Kotlin las variables pueden declararse de dos formas, de forma expl\u00edcita o de forma impl\u00edcita. En el caso de las variables expl\u00edcitas, se debe indicar el tipo de dato que almacenar\u00e1 la variable, mientras que en las variables impl\u00edcitas, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <p>Sobre la inferencia de tipos</p> <p>Que el tipo de dato se infiera autom\u00e1ticamente no quiere decir que Kotlin sea un lenguaje de tipado din\u00e1mico, ya que una vez que se asigna un tipo de dato a una variable, no se puede cambiar.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-explicitas","title":"Variables expl\u00edcitas","text":"<p>Para declarar una variable de forma expl\u00edcita en Kotlin, se debe indicar el tipo de dato que almacenar\u00e1 la variable seguido del nombre de la variable y opcionalmente de su valor inicial.</p> <pre><code>val nombre: String = \"Ejemplo\"\nval edad: Int = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma expl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#variables-implicitas","title":"Variables impl\u00edcitas","text":"<p>Para declarar una variable de forma impl\u00edcita en Kotlin, se debe utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre de la variable y opcionalmente de su valor inicial. En este caso, el tipo de dato se infiere autom\u00e1ticamente por el compilador.</p> <pre><code>val nombre = \"Ejemplo\"\nval edad = 25\n</code></pre> <p>En el ejemplo anterior, se declaran dos variables de forma impl\u00edcita, una de tipo <code>String</code> llamada <code>nombre</code> y otra de tipo <code>Int</code> llamada <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-primitivos","title":"Tipos de datos primitivos","text":"<p>En Kotlin, los tipos de datos primitivos son los mismos que en Java, pero con algunas diferencias en la forma en que se declaran.</p> <ul> <li>Byte: Almacena n\u00fameros enteros de 8 bits.</li> <li>Short: Almacena n\u00fameros enteros de 16 bits.</li> <li>Int: Almacena n\u00fameros enteros de 32 bits.</li> <li>Long: Almacena n\u00fameros enteros de 64 bits.</li> <li>Float: Almacena n\u00fameros de punto flotante de 32 bits.</li> <li>Double: Almacena n\u00fameros de punto flotante de 64 bits.</li> <li>Char: Almacena caracteres Unicode de 16 bits.</li> <li>Boolean: Almacena valores booleanos (<code>true</code> o <code>false</code>).</li> </ul> <pre><code>val entero: Int = 10\nval flotante: Float = 10.5f\nval caracter: Char = 'A'\nval booleano: Boolean = true\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#tipos-de-datos-compuestos","title":"Tipos de datos compuestos","text":"<p>Adem\u00e1s de los tipos de datos primitivos, Kotlin tambi\u00e9n tiene tipos de datos compuestos que permiten almacenar colecciones de datos.</p> <ul> <li>Array: Almacena una colecci\u00f3n de elementos del mismo tipo.</li> <li>List: Almacena una colecci\u00f3n de elementos ordenados.</li> <li>Set: Almacena una colecci\u00f3n de elementos \u00fanicos.</li> <li>Map: Almacena una colecci\u00f3n de pares clave-valor.</li> </ul> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\nval nombres = listOf(\"Juan\", \"Mar\u00eda\", \"Pedro\")\nval colores = setOf(\"Rojo\", \"Verde\", \"Azul\")\nval edades = mapOf(\"Juan\" to 25, \"Mar\u00eda\" to 30, \"Pedro\" to 35)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#conversion-de-tipos","title":"Conversi\u00f3n de tipos","text":"<p>En Kotlin, la conversi\u00f3n de tipos se realiza de forma segura y expl\u00edcita utilizando funciones espec\u00edficas para cada tipo de dato.</p> <pre><code>val numero: Int = 10\nval texto: String = numero.toString()\n\nval texto: String = \"10\"\nval numero: Int = texto.toInt()\n</code></pre> <p>En el primer ejemplo, se convierte un n\u00famero entero a una cadena de texto utilizando la funci\u00f3n <code>toString()</code>. En el segundo ejemplo, se convierte una cadena de texto a un n\u00famero entero utilizando la funci\u00f3n <code>toInt()</code>.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-mutables-e-inmutables","title":"Sobre las variables mutables e inmutables","text":"<p>En Kotlin, las variables se pueden declarar como <code>val</code> (inmutables) o <code>var</code> (mutables). Las variables inmutables no pueden cambiar su valor una vez asignado, mientras que las variables mutables pueden cambiar su valor en cualquier momento.</p> <pre><code>val nombre: String = \"Ejemplo\" // Variable inmutable\nvar edad: Int = 25 // Variable mutable\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es inmutable, por lo que su valor no puede cambiar una vez asignado. La variable <code>edad</code>, en cambio, es mutable, por lo que su valor puede cambiar en cualquier momento.    </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-la-mutabilidad-y-la-inmutabilidad","title":"Sobre la mutabilidad y la inmutabilidad","text":"<p>La inmutabilidad es una caracter\u00edstica importante en Kotlin, ya que ayuda a prevenir los errores de programaci\u00f3n al evitar que los valores de las variables cambien de forma inesperada. Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s seguro y predecible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.   </p> <p>Cu\u00e1ndo trabajamos con listas o arrays, podemos modificar los elementos de la lista, pero no podemos cambiar la referencia de la lista. </p> <pre><code>val lista = mutableListOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Modifica el elemento en la posici\u00f3n 0\nlista = mutableListOf(6, 7, 8, 9, 10) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se modifica el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero no se puede cambiar la referencia de la lista. Si se intenta asignar una nueva lista a la variable <code>lista</code>, se produce un error de compilaci\u00f3n.</p> <p>Podemos ver tambi\u00e9n un ejemplo de lista mutable pero cuyo contenido no puede ser modificado.</p> <pre><code>val lista = listOf(1, 2, 3, 4, 5)\nlista[0] = 10 // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta modificar el elemento en la posici\u00f3n <code>0</code> de la lista <code>lista</code>, pero como la lista es inmutable, se produce un error de compilaci\u00f3n.</p> <p>Esto nos deja claro que la inmutabilidad no solo se refiere a la variable en s\u00ed, sino tambi\u00e9n a los elementos que contiene la variable.</p> <p>Podemos entonces tener cuatro situaciones posibles:</p> <ul> <li>Variable inmutable y elementos inmutables: No se puede cambiar ni la variable ni los elementos.</li> <li>Variable inmutable y elementos mutables: No se puede cambiar la variable, pero s\u00ed los elementos.</li> <li>Variable mutable y elementos inmutables: Se puede cambiar la variable, pero no los elementos.</li> <li>Variable mutable y elementos mutables: Se puede cambiar tanto la variable como los elementos.</li> </ul> <p>Las variables inmutables y la programaci\u00f3n funcional</p> <p>Las variables inmutables son una caracter\u00edstica fundamental de la programaci\u00f3n funcional, ya que permiten escribir c\u00f3digo m\u00e1s seguro y predecible al evitar los efectos secundarios y las mutaciones de estado. </p> <p>Al utilizar variables inmutables, se puede escribir c\u00f3digo m\u00e1s conciso, legible y mantenible, lo que facilita la depuraci\u00f3n y el mantenimiento del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-nulas","title":"Sobre las variables nulas","text":"<p>En Kotlin, las variables pueden ser nulas si se declara con el operador <code>?</code>. Esto permite que una variable pueda contener un valor nulo en lugar de un valor no nulo.</p> <pre><code>val nombre: String? = null\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> se declara como nula utilizando el operador <code>?</code>. Esto significa que la variable <code>nombre</code> puede contener un valor nulo en lugar de un valor no nulo.</p> <p>Sobre la seguridad de nulos en Kotlin</p> <p>El manejo de nulos en Kotlin es una de las caracter\u00edsticas m\u00e1s importantes del lenguaje, ya que ayuda a prevenir los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n.</p> <p>M\u00e1s adelante veremos c\u00f3mo manejar los valores nulos de forma segura en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-variables-declaradas-como-const","title":"Sobre las variables declaradas como const","text":"<p>En Kotlin, las variables se pueden declarar como <code>const</code> para indicar que su valor es constante en tiempo de compilaci\u00f3n. Las variables <code>const</code> deben ser de tipo <code>val</code> y deben estar en el \u00e1mbito de un objeto o de un compa\u00f1ero de clase.</p> <pre><code>const val PI = 3.14159\n</code></pre> <p>En el ejemplo anterior, se declara una constante <code>PI</code> con un valor de <code>3.14159</code>. Esta constante es accesible en tiempo de compilaci\u00f3n y su valor no puede cambiar en tiempo de ejecuci\u00f3n.   </p>"},{"location":"temas/00-android/00-kotlin/11-variables-tipos-datos.html#sobre-las-strings-en-kotlin","title":"Sobre las Strings en Kotlin","text":"<p>En Kotlin, las cadenas de texto se pueden declarar utilizando comillas simples (<code>'</code>) o comillas dobles (<code>\"</code>). Las cadenas de texto declaradas con comillas simples son de tipo <code>Char</code>, mientras que las declaradas con comillas dobles son de tipo <code>String</code>.</p> <pre><code>val caracter: Char = 'A'\nval texto: String = \"Ejemplo\"\n</code></pre> <p>En el ejemplo anterior, se declara una variable <code>caracter</code> de tipo <code>Char</code> con el valor <code>'A'</code> y una variable <code>texto</code> de tipo <code>String</code> con el valor <code>\"Ejemplo\"</code>.</p> <p>Las Strings en Kotlin se pueden comparar utilizando el operador <code>==</code> para comparar el contenido de las cadenas y el operador <code>===</code> para comparar las referencias de las cadenas.</p> <pre><code>val texto1 = \"Hola\"\nval texto2 = \"Hola\"\n\nprintln(texto1 == texto2) // true\nprintln(texto1 === texto2) // true\n</code></pre> <p>En el ejemplo anterior, se comparan dos cadenas de texto <code>texto1</code> y <code>texto2</code> utilizando los operadores <code>==</code> y <code>===</code>. Ambas comparaciones devuelven <code>true</code> ya que las cadenas son iguales en contenido y referencia. </p> <p>A diferencia de Java, en Kotlin las cadenas de texto son inmutables, lo que significa que una vez que se crea una cadena de texto, no se puede modificar su contenido. Para modificar una cadena de texto en Kotlin, se debe crear una nueva cadena con el contenido modificado.</p> <pre><code>val texto = \"Hola\"\nval nuevoTexto = texto + \" Mundo\"\n</code></pre> <p>En el ejemplo anterior, se crea una nueva cadena de texto <code>nuevoTexto</code> concatenando la cadena <code>texto</code> con la cadena <code>\" Mundo\"</code>. La cadena <code>texto</code> no se modifica, sino que se crea una nueva cadena con el contenido modificado.    </p> <p>Sin embargo, si comparamos una string con un caracter, Kotlin no permite la comparaci\u00f3n directa, ya que son tipos de datos diferentes.</p> <pre><code>val texto = \"H\"\nval caracter = 'H'\n\nprintln(texto == caracter) // Error de compilaci\u00f3n\n</code></pre> <p>En el ejemplo anterior, se intenta comparar una cadena de texto <code>texto</code> con un caracter <code>caracter</code>, lo cual produce un error de compilaci\u00f3n ya que los tipos de datos son diferentes.   </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html","title":"Expresiones vs Sentencias","text":""},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones-vs-sentencias","title":"Expresiones vs sentencias","text":"<p>En Kotlin, las expresiones y las sentencias son dos conceptos fundamentales que se utilizan para definir el flujo de control y la l\u00f3gica de un programa. Aunque ambos se utilizan para realizar operaciones y tomar decisiones en un programa, existen diferencias importantes entre ellos que es importante comprender.    </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#expresiones","title":"Expresiones","text":"<p>En Kotlin, una expresi\u00f3n es una combinaci\u00f3n de valores, variables, operadores y funciones que se eval\u00faa para producir un resultado. Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor. </p> <p>Las expresiones en Kotlin pueden tener un valor de retorno, lo que significa que pueden ser utilizadas en cualquier lugar donde se espere un valor, como en la inicializaci\u00f3n de una variable, en una sentencia de control de flujo o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nval resultado = numero * 2\n</code></pre> <p>En el ejemplo anterior, la expresi\u00f3n <code>numero * 2</code> se eval\u00faa para producir un resultado que se asigna a la variable <code>resultado</code>. La expresi\u00f3n <code>numero * 2</code> es una expresi\u00f3n aritm\u00e9tica que multiplica el valor de la variable <code>numero</code> por <code>2</code> y devuelve el resultado.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#sentencias","title":"Sentencias","text":"<p>En Kotlin, una sentencia es una instrucci\u00f3n que realiza una acci\u00f3n en un programa. Las sentencias pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo que toma decisiones basadas en condiciones.    </p> <p>Las sentencias en Kotlin no tienen un valor de retorno, lo que significa que no pueden ser utilizadas en lugares donde se espere un valor, como en la inicializaci\u00f3n de una variable o en una llamada a una funci\u00f3n. </p> <pre><code>val numero = 10\nif (numero &gt; 0) {\n    println(\"El n\u00famero es positivo\")\n} else {\n    println(\"El n\u00famero es negativo\")\n}\n</code></pre> <p>En el ejemplo anterior, la sentencia <code>if (numero &gt; 0) { ... } else { ... }</code> es una estructura de control de flujo que toma una decisi\u00f3n basada en la condici\u00f3n <code>numero &gt; 0</code>. La sentencia <code>if</code> eval\u00faa la condici\u00f3n y ejecuta el bloque de c\u00f3digo correspondiente si la condici\u00f3n es verdadera.  </p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#diferencias-entre-expresiones-y-sentencias","title":"Diferencias entre expresiones y sentencias","text":"<p>Las principales diferencias entre expresiones y sentencias en Kotlin son las siguientes:</p> <ul> <li> <p>Valor de retorno: Las expresiones tienen un valor de retorno y pueden ser utilizadas en lugares donde se espere un valor, mientras que las sentencias no tienen un valor de retorno y no pueden ser utilizadas en lugares donde se espere un valor.</p> </li> <li> <p>Complejidad: Las expresiones pueden ser tan simples como una constante o tan complejas como una llamada a una funci\u00f3n que devuelve un valor, mientras que las sentencias realizan acciones en un programa y pueden ser tan simples como una asignaci\u00f3n de variable o tan complejas como una estructura de control de flujo.</p> </li> <li> <p>Uso: Las expresiones se utilizan para realizar operaciones y producir resultados, mientras que las sentencias se utilizan para realizar acciones en un programa, como asignar valores a variables, tomar decisiones basadas en condiciones o repetir bloques de c\u00f3digo.</p> </li> </ul> <p>La ventaja de las expresiones en la programaci\u00f3n funcional</p> <p>En la programaci\u00f3n funcional, se fomenta el uso de expresiones en lugar de sentencias, ya que las expresiones son m\u00e1s concisas, legibles y f\u00e1ciles de entender. </p> <p>Al utilizar expresiones en lugar de sentencias, se puede escribir menos c\u00f3digo y hacer m\u00e1s cosas.</p> <p>Esto es especialmente \u00fatil en Kotlin, que es un lenguaje de programaci\u00f3n funcional que fomenta el uso de expresiones para realizar operaciones y producir resultados de forma concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/12-expresiones-vs-sentencias.html#ejemplo-de-una-funcion-que-usa-sentencias-statement-y-expresiones-expression","title":"Ejemplo de una funci\u00f3n que usa sentencias (statement) y expresiones (expression)","text":"<p>Pongamos el ejemplo de una funci\u00f3n que dictamina si una persona es mayor de edad o no. </p> Versi\u00f3n con sentencias<pre><code>fun esMayorDeEdad(edad: Int): Boolean {\n    if (edad &gt;= 18) {\n        return true\n    } else {\n        return false\n    }\n}\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza sentencias para tomar una decisi\u00f3n basada en la edad de la persona y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> Versi\u00f3n con expresiones<pre><code>fun esMayorDeEdad(edad: Int): Boolean = edad &gt;= 18\n</code></pre> <p>En este caso, la funci\u00f3n <code>esMayorDeEdad</code> utiliza una expresi\u00f3n para evaluar si la edad de la persona es mayor o igual a <code>18</code> y devolver un valor booleano que indica si la persona es mayor de edad o no.</p> <p>C\u00f3mo se puede observar, la versi\u00f3n con expresiones es m\u00e1s concisa y legible que la versi\u00f3n con sentencias, ya que utiliza una expresi\u00f3n para realizar la misma operaci\u00f3n de forma m\u00e1s eficiente y clara.</p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html","title":"When","text":""},{"location":"temas/00-android/00-kotlin/12.1-when.html#operador-when","title":"Operador When","text":"<p>Piensa en el operador <code>when</code> como el <code>switch</code> de Java que fue al gimnasio, ley\u00f3 varios libros de filosof\u00eda y se volvi\u00f3 incre\u00edblemente flexible y poderoso.</p> <p>Vamos a desglosar todos sus usos, desde el reemplazo directo del <code>switch</code> hasta sus capacidades m\u00e1s expresivas.</p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#1-el-caso-basico-when-como-un-switch-mejorado","title":"1. El Caso B\u00e1sico: <code>when</code> como un <code>switch</code> Mejorado","text":"<p>Este es el uso m\u00e1s directo y f\u00e1cil de entender. Se parece mucho a un <code>switch-case</code> de Java, pero con mejoras clave.</p> <p>Correlaci\u00f3n con <code>switch</code> de Java: *   <code>case X:</code> se convierte en <code>X -&gt;</code>. *   <code>default:</code> se convierte en <code>else -&gt;</code>. *   No necesitas <code>break;</code>. \u00a1Esto elimina toda una categor\u00eda de bugs! La ejecuci\u00f3n se detiene autom\u00e1ticamente al encontrar la primera rama que coincide.</p> <p>Ejemplo en Java: </p><pre><code>int day = 2;\nString dayName;\nswitch (day) {\n    case 1:\n        dayName = \"Lunes\";\n        break;\n    case 2:\n        dayName = \"Martes\";\n        break;\n    case 3:\n        dayName = \"Mi\u00e9rcoles\";\n        break;\n    default:\n        dayName = \"Otro d\u00eda\";\n        break;\n}\nSystem.out.println(dayName); // Martes\n</code></pre><p></p> <p>Ejemplo equivalente en Kotlin: </p><pre><code>val day = 2\nval dayName = when (day) {\n    1 -&gt; \"Lunes\"\n    2 -&gt; \"Martes\"\n    3 -&gt; \"Mi\u00e9rcoles\"\n    else -&gt; \"Otro d\u00eda\"\n}\nprintln(dayName) // Martes\n</code></pre><p></p> <p>Ventajas inmediatas:</p> <ul> <li>M\u00e1s limpio y conciso.</li> <li>A prueba de errores de \"fall-through\" (olvidar un <code>break</code>).</li> <li>Puede ser una expresi\u00f3n: F\u00edjate que asignamos el resultado del <code>when</code> directamente a la variable <code>dayName</code>. Esto es imposible con el <code>switch</code> de Java.</li> </ul>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#2-when-como-expresion-su-primer-superpoder","title":"2. <code>when</code> como Expresi\u00f3n (Su primer superpoder)","text":"<p>Cuando usas <code>when</code> para devolver un valor (como en el ejemplo anterior), el compilador de Kotlin te exige que seas exhaustivo. Esto significa que debes cubrir todos los casos posibles.</p> <p>Esto es incre\u00edblemente \u00fatil con <code>enum</code> o <code>sealed classes</code>.</p> <p>Ejemplo con un <code>enum</code>:</p> <p></p><pre><code>enum class DayOfWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY }\n\nfun getDayType(day: DayOfWeek): String {\n    return when (day) {\n        DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY -&gt; \"D\u00eda laboral\"\n        DayOfWeek.SATURDAY, DayOfWeek.SUNDAY -&gt; \"Fin de semana\"\n        // No se necesita 'else' aqu\u00ed. \u00bfPor qu\u00e9?\n        // Porque hemos cubierto TODOS los valores posibles del enum.\n        // Si a\u00f1adieras un nuevo d\u00eda al enum, \u00a1este c\u00f3digo dar\u00eda un error de compilaci\u00f3n\n        // hasta que lo manejes! Esto es seguridad en estado puro.\n    }\n}\n</code></pre> Nuevas caracter\u00edsticas mostradas:<p></p> <ul> <li>Combinar casos: Puedes poner varias condiciones en la misma rama, separadas por comas (<code>,</code>).</li> <li>Exhaustividad: El compilador te protege de olvidar casos.</li> </ul>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#3-when-sin-argumento-el-modo-if-else-if-inteligente","title":"3. <code>when</code> sin Argumento (El modo \"if-else if\" inteligente)","text":"<p>Aqu\u00ed es donde <code>when</code> deja al <code>switch</code> de Java a a\u00f1os luz. Puedes usar <code>when</code> sin pasarle un objeto entre par\u00e9ntesis. Cuando lo haces, cada rama se convierte en una condici\u00f3n booleana que se eval\u00faa en orden.</p> <p>Correlaci\u00f3n con Java:  Es como una cadena de <code>if-else if-else</code> m\u00e1s legible.</p> <p>Ejemplo:</p> <p></p><pre><code>val name = \"Pedro\"\nval score = 85\n\nval description = when {\n    name == \"Admin\" -&gt; \"El usuario es un administrador.\"\n    score &lt; 50 -&gt; \"Necesita mejorar.\"\n    score &gt;= 95 -&gt; \"\u00a1Excelente trabajo!\"\n    name.startsWith(\"P\") &amp;&amp; score &gt; 80 -&gt; \"Usuario destacado del grupo P.\"\n    else -&gt; \"Usuario est\u00e1ndar.\"\n}\nprintln(description) // \"Usuario destacado del grupo P.\"\n</code></pre> Como puedes ver, cada rama es una expresi\u00f3n booleana arbitraria. Se ejecutar\u00e1 la primera que sea <code>true</code>.<p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#4-when-para-comprobar-tipos-con-smart-casting","title":"4. <code>when</code> para Comprobar Tipos (con Smart Casting)","text":"<p>Este es uno de los usos m\u00e1s idiom\u00e1ticos y potentes en Kotlin, especialmente para manejar datos heterog\u00e9neos.</p> <p>Ejemplo con <code>is</code> y <code>smart casting</code>: </p><pre><code>fun processObject(obj: Any) { // Any es como Object en Java\n    when (obj) {\n        is String -&gt; {\n            // Smart Casting: El compilador sabe que 'obj' es un String aqu\u00ed.\n            // Puedes llamar a m\u00e9todos de String directamente sin castear.\n            println(\"Es un String con longitud ${obj.length}\")\n        }\n        is Int -&gt; {\n            println(\"Es un Entero con valor ${obj + 10}\")\n        }\n        is Boolean -&gt; {\n            println(\"Es un Booleano: ${!obj}\")\n        }\n        else -&gt; {\n            println(\"Es un tipo desconocido.\")\n        }\n    }\n}\n\nprocessObject(\"Hola Kotlin\") // \"Es un String con longitud 11\"\nprocessObject(25)            // \"Es un Entero con valor 35\"\n</code></pre> En la rama <code>is String</code>, <code>obj</code> es tratado autom\u00e1ticamente como un <code>String</code>. \u00a1No necesitas hacer <code>((String) obj).length()</code>!<p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#5-when-para-comprobar-rangos-y-colecciones","title":"5. <code>when</code> para Comprobar Rangos y Colecciones","text":"<p>Puedes usar el operador <code>in</code> para verificar si un valor est\u00e1 dentro de un rango o una colecci\u00f3n.</p> <p>Ejemplo con <code>in</code>: </p><pre><code>val temperature = 25\nval numbers = listOf(1, 3, 5, 7, 9)\n\nwhen (temperature) {\n    in -10..10 -&gt; println(\"Hace fr\u00edo.\")\n    in 11..22 -&gt; println(\"Est\u00e1 templado.\")\n    in numbers -&gt; println(\"\u00a1Es un n\u00famero impar de un solo d\u00edgito!\")\n    !in 0..100 -&gt; println(\"Temperatura fuera del rango normal.\") // Tambi\u00e9n puedes usar !in\n    else -&gt; println(\"Temperatura agradable.\")\n}\n// Salida: \"Temperatura agradable.\"\n</code></pre><p></p>"},{"location":"temas/00-android/00-kotlin/12.1-when.html#tabla-comparativa-when-kotlin-vs-switch-java","title":"Tabla Comparativa: <code>when</code> (Kotlin) vs. <code>switch</code> (Java)","text":"Caracter\u00edstica <code>switch</code> (Java) <code>when</code> (Kotlin) Ventaja de Kotlin Sintaxis b\u00e1sica <code>case X: ...; break;</code> <code>X -&gt; ...</code> M\u00e1s concisa y segura (sin <code>break</code>). Valor por defecto <code>default:</code> <code>else -&gt;</code> Nombres m\u00e1s intuitivos. Puede ser una expresi\u00f3n? No S\u00ed Permite c\u00f3digo m\u00e1s funcional y reduce la mutabilidad. Exhaustividad No forzada por el compilador S\u00ed (cuando se usa como expresi\u00f3n) C\u00f3digo mucho m\u00e1s seguro y robusto. Tipos de condici\u00f3n Constantes (primitivos, <code>String</code>, <code>enum</code>) Cualquier objeto y expresi\u00f3n Inmensamente m\u00e1s flexible. Combinar casos S\u00ed (con <code>case</code> apilados sin <code>break</code>) S\u00ed (usando comas <code>,</code>) M\u00e1s expl\u00edcito y menos propenso a errores. Uso sin argumento No es posible S\u00ed (<code>when { ... }</code>) Permite condiciones complejas, actuando como un <code>if-else</code> mejorado. Comprobar tipos No directamente (necesita <code>instanceof</code>) S\u00ed (con <code>is</code> y smart casting) C\u00f3digo m\u00e1s limpio y seguro para polimorfismo. Comprobar rangos No directamente S\u00ed (con <code>in X..Y</code>) Muy \u00fatil para l\u00f3gica de rangos num\u00e9ricos. <p>En resumen, <code>when</code> en Kotlin comienza como un simple <code>switch</code> pero se expande para convertirse en una de las herramientas de control de flujo m\u00e1s vers\u00e1tiles y seguras que existen en cualquier lenguaje de programaci\u00f3n moderno.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html","title":"Funciones y lambdas","text":""},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-y-lambdas-en-kotlin","title":"Funciones y lambdas en Kotlin","text":"<p>En Kotlin, las funciones son ciudadanos de primera clase, lo que significa que puedes tratarlas como cualquier otro tipo de dato, como un <code>Int</code> o un <code>String</code>. Esto te permite pasar funciones como argumentos a otras funciones, devolver funciones de otras funciones y almacenar funciones en variables. </p> <p>Las funciones en Kotlin se definen utilizando la palabra clave <code>fun</code>, seguida del nombre de la funci\u00f3n, los par\u00e1metros de entrada y el tipo de retorno. </p> <pre><code>fun suma(a: Int, b: Int): Int {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n suma los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-orden-superior","title":"Funciones de orden superior","text":"<p>En Kotlin, puedes pasar funciones como argumentos a otras funciones. Estas funciones se conocen como funciones de orden superior y te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable. </p> <pre><code>fun operacion(a: Int, b: Int, funcion: (Int, Int) -&gt; Int): Int {\n    return funcion(a, b)\n}\n\nfun suma(a: Int, b: Int): Int {\n    return a + b\n}\n\nfun resta(a: Int, b: Int): Int {\n    return a - b\n}\n\nval resultadoSuma = operacion(10, 5, ::suma)\nval resultadoResta = operacion(10, 5, ::resta)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>operacion</code> que toma dos par\u00e1metros de tipo <code>Int</code> y una funci\u00f3n de orden superior que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n <code>operacion</code> aplica la funci\u00f3n de orden superior a los dos par\u00e1metros de entrada y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda","title":"Funciones lambda","text":"<p>En Kotlin, puedes definir funciones an\u00f3nimas conocidas como funciones lambda. Las funciones lambda son funciones sin nombre que puedes pasar como argumentos a otras funciones. </p> <pre><code>val suma = { a: Int, b: Int -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n\nval resultadoSuma = suma(10, 5)\nval resultadoResta = resta(10, 5)\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. Las funciones lambda se asignan a variables y se pueden utilizar como cualquier otra funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#los-parametros-en-kotlin","title":"Los par\u00e1metros en Kotlin","text":"<p>A diferencia de Java, en Kotlin los par\u00e1metros de una funci\u00f3n son inmutables por defecto, lo que significa que no se pueden modificar dentro de la funci\u00f3n. Si necesitas modificar un par\u00e1metro dentro de una funci\u00f3n, debes declararlo como una variable <code>var</code>.</p> <pre><code>fun duplicar(numero: Int): Int {\n    var resultado = numero\n    resultado *= 2\n    return resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>duplicar</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. El par\u00e1metro <code>numero</code> se declara como una variable <code>var</code> para poder modificar su valor dentro de la funci\u00f3n.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-con-valores-por-defecto","title":"Par\u00e1metros con valores por defecto","text":"<p>Los par\u00e1metros de una funci\u00f3n en Kotlin pueden tener valores por defecto, lo que te permite llamar a la funci\u00f3n sin proporcionar todos los argumentos.</p> <pre><code>fun saludar(nombre: String = \"Mundo\") {\n    println(\"Hola, $nombre!\")\n}\n\nsaludar() // Hola, Mundo!\nsaludar(\"Juan\") // Hola, Juan!\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>saludar</code> que toma un par\u00e1metro de tipo <code>String</code> con un valor por defecto de <code>\"Mundo\"</code>. Si no se proporciona un argumento al llamar a la funci\u00f3n, se utiliza el valor por defecto.</p> <p>Funciones con valores por defecto y su no obligatoriedad, su uso en Compose</p> <p>Las funciones con valores por defecto son muy \u00fatiles en Jetpack Compose, ya que te permiten definir componentes con valores por defecto y llamar a esos componentes sin proporcionar todos los argumentos.</p> <p>Por ejemplo, puedes definir un bot\u00f3n con un texto por defecto y un color por defecto, y luego llamar a ese bot\u00f3n sin proporcionar el texto o el color si deseas utilizar los valores por defecto.</p> <pre><code>@Composable\nfun Boton(texto: String = \"Aceptar\", color: Color = Color.Blue) {\n    Button(onClick = { /* Acci\u00f3n al hacer clic */ }) {\n        Text(texto, color = color)\n    }\n}\n\nBoton() // Bot\u00f3n con texto \"Aceptar\" y color azul\nBoton(\"Cancelar\", Color.Red) // Bot\u00f3n con texto \"Cancelar\" y color rojo\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#parametros-de-una-funcion-lambda","title":"Par\u00e1metros de una funci\u00f3n lambda","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes especificar los tipos de los par\u00e1metros de entrada o dejar que el compilador infiera los tipos autom\u00e1ticamente.</p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt; a + b }\nval resta = { a: Int, b: Int -&gt; a - b }\n</code></pre> <p>En el ejemplo anterior, se definen dos funciones lambda <code>suma</code> y <code>resta</code> que toman dos par\u00e1metros de tipo <code>Int</code> y devuelven un valor de tipo <code>Int</code>. En la funci\u00f3n lambda <code>suma</code>, se especifican los tipos de los par\u00e1metros de entrada, mientras que en la funci\u00f3n lambda <code>resta</code>, se deja que el compilador infiera los tipos autom\u00e1ticamente.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#la-palabra-reservada-it","title":"La palabra reservada <code>it</code>","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar la palabra reservada <code>it</code> para referirte al \u00fanico par\u00e1metro de entrada si la funci\u00f3n lambda tiene un solo par\u00e1metro.</p> <pre><code>val cuadrado: (Int) -&gt; Int = { it * it }\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>cuadrado</code> que toma un par\u00e1metro de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. </p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>La palabra reservada <code>it</code> se utiliza para referirse al \u00fanico par\u00e1metro de entrada de la funci\u00f3n lambda.</p> <p>Esto es \u00fatil cuando la funci\u00f3n lambda tiene un solo par\u00e1metro y quieres hacer el c\u00f3digo m\u00e1s conciso.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-lambda-con-multiples-lineas","title":"Funciones lambda con m\u00faltiples l\u00edneas","text":"<p>En una funci\u00f3n lambda en Kotlin, puedes utilizar m\u00faltiples l\u00edneas de c\u00f3digo si es necesario. </p> <pre><code>val suma: (Int, Int) -&gt; Int = { a, b -&gt;\n    val resultado = a + b\n    println(\"La suma de $a y $b es $resultado\")\n    resultado\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n lambda <code>suma</code> que toma dos par\u00e1metros de tipo <code>Int</code> y devuelve un valor de tipo <code>Int</code>. La funci\u00f3n lambda realiza la suma de los dos par\u00e1metros y muestra un mensaje por consola con el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#numero-variable-de-argumentos","title":"N\u00famero variable de argumentos","text":"<p>En Kotlin, puedes definir funciones que toman un n\u00famero variable de argumentos utilizando el operador <code>vararg</code>.</p> <pre><code>fun sumar(vararg numeros: Int): Int {\n    var suma = 0\n    for (numero in numeros) {\n        suma += numero\n    }\n    return suma\n}\n\nval resultado = sumar(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma un n\u00famero variable de argumentos de tipo <code>Int</code> utilizando el operador <code>vararg</code>. La funci\u00f3n suma todos los n\u00fameros pasados como argumentos y devuelve el resultado.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#funciones-de-extension-extension-functions","title":"Funciones de extensi\u00f3n (Extension Functions)","text":"<p>En Kotlin, puedes agregar nuevas funciones a las clases existentes sin heredar de ellas. </p> <p>Estas funciones se conocen como funciones de extensi\u00f3n y te permiten extender la funcionalidad de las clases sin modificar su c\u00f3digo fuente.</p> <pre><code>fun String.invertir(): String {\n    return this.reversed()\n}\n\nval texto = \"Hola, mundo!\"\nval textoInvertido = texto.invertir()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>invertir</code> para la clase <code>String</code> que invierte el contenido de la cadena de texto. La funci\u00f3n de extensi\u00f3n se llama como si fuera un m\u00e9todo de la clase <code>String</code>.</p> <p>Funciones de extensi\u00f3n y funciones de orden superior</p> <p>Las funciones de extensi\u00f3n y las funciones de orden superior son dos caracter\u00edsticas poderosas de Kotlin que te permiten escribir c\u00f3digo m\u00e1s conciso y reutilizable.</p> <p>Las funciones de extensi\u00f3n te permiten agregar nuevas funciones a las clases existentes sin heredar de ellas, mientras que las funciones de orden superior te permiten pasar funciones como argumentos a otras funciones.</p> <p>Al combinar estas dos caracter\u00edsticas, puedes escribir c\u00f3digo m\u00e1s flexible y expresivo en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#ejemplo-poniendo-en-practica-todo","title":"\ud83c\udfaf Ejemplo. Poniendo en pr\u00e1ctica todo","text":"<p>Imaginen que estamos desarrollando una aplicaci\u00f3n para gestionar los cursos de una universidad. Vamos a trabajar con una lista de estudiantes.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-1-definir-nuestro-modelo-de-datos","title":"Paso 1: Definir nuestro modelo de datos #\ufe0f\u20e3","text":"<p>Primero, definamos una clase de datos (<code>data class</code>) que representar\u00e1 a un estudiante. Las <code>data class</code> en Kotlin son perfectas para este prop\u00f3sito, ya que nos proveen autom\u00e1ticamente de m\u00e9todos \u00fatiles como <code>equals()</code>, <code>hashCode()</code> y <code>toString()</code>.</p> <pre><code>data class Estudiante(\n    val id: Int,\n    val nombre: String,\n    val calificacion: Double,\n    val curso: String,\n    val activo: Boolean = true\n)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-2-generar-nuestra-coleccion-de-datos","title":"Paso 2: Generar nuestra colecci\u00f3n de datos #\ufe0f\u20e3","text":"<p>Ahora, vamos a crear una lista (<code>List</code>) de estudiantes para nuestros ejemplos. Las listas son colecciones ordenadas de elementos. En Kotlin, podemos crearlas f\u00e1cilmente con la funci\u00f3n <code>listOf()</code>.</p> <pre><code>val estudiantes = listOf(\n    Estudiante(1, \"Ana\", 9.5, \"Kotlin Avanzado\", true),\n    Estudiante(2, \"Luis\", 6.8, \"Jetpack Compose\", false),\n    Estudiante(3, \"Carlos\", 8.9, \"Kotlin Avanzado\", true),\n    Estudiante(4, \"Sof\u00eda\", 10.0, \"Arquitectura Android\", true),\n    Estudiante(5, \"Marta\", 7.2, \"Jetpack Compose\", true),\n    Estudiante(6, \"Pedro\", 5.5, \"Kotlin Avanzado\", true),\n    Estudiante(7, \"Luc\u00eda\", 8.1, \"Arquitectura Android\", false)\n)\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#paso-3-procesando-la-coleccion-con-funciones-de-orden-superior-y-lambdas","title":"Paso 3: Procesando la colecci\u00f3n con funciones de orden superior y Lambdas #\ufe0f\u20e3","text":"<p>Aqu\u00ed es donde reside la magia de la programaci\u00f3n funcional en Kotlin. En lugar de usar bucles <code>for</code> tradicionales para todo, podemos usar funciones que aceptan otras funciones (lambdas) como par\u00e1metros para procesar colecciones.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#1-filter-filtrando-la-coleccion","title":"1. <code>filter</code>: Filtrando la colecci\u00f3n","text":"<p>La funci\u00f3n <code>filter</code> crea una nueva lista que contiene \u00fanicamente los elementos que cumplen con una condici\u00f3n espec\u00edfica (el \"predicado\").</p> <p>Ejemplo: Queremos obtener solo los estudiantes que hayan aprobado, es decir, que tengan una calificaci\u00f3n mayor o igual a 7.0.</p> <pre><code>val estudiantesAprobados = estudiantes.filter { estudiante -&gt;\n    estudiante.calificacion &gt;= 7.0\n}\n\nprintln(\"Estudiantes Aprobados:\")\nestudiantesAprobados.forEach { println(it) }\n\n// --- Salida ---\n// Estudiantes Aprobados:\n// Estudiante(id=1, nombre=Ana, calificacion=9.5, curso=Kotlin Avanzado, activo=true)\n// Estudiante(id=3, nombre=Carlos, calificacion=8.9, curso=Kotlin Avanzado, activo=true)\n// Estudiante(id=4, nombre=Sof\u00eda, calificacion=10.0, curso=Arquitectura Android, activo=true)\n// Estudiante(id=5, nombre=Marta, calificacion=7.2, curso=Jetpack Compose, activo=true)\n// Estudiante(id=7, nombre=Luc\u00eda, calificacion=8.1, curso=Arquitectura Android, activo=false)\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ estudiante -&gt; estudiante.calificacion &gt;= 7.0 }</code> se ejecuta para cada estudiante en la lista. Si la expresi\u00f3n devuelve <code>true</code>, el estudiante se incluye en la nueva lista <code>estudiantesAprobados</code>.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#2-map-transformando-la-coleccion","title":"2. <code>map</code>: Transformando la colecci\u00f3n #\ufe0f\u20e3","text":"<p>La funci\u00f3n <code>map</code> crea una nueva lista transformando cada elemento de la lista original en algo nuevo.</p> <p>Ejemplo: Necesitamos una lista que contenga solo los nombres de todos los estudiantes, pero en may\u00fasculas.</p> <pre><code>val nombresEnMayusculas = estudiantes.map { it.nombre.uppercase() }\n\nprintln(\"\\nNombres de Estudiantes en May\u00fasculas:\")\nprintln(nombresEnMayusculas)\n\n// --- Salida ---\n// Nombres de Estudiantes en May\u00fasculas:\n// [ANA, LUIS, CARLOS, SOF\u00cdA, MARTA, PEDRO, LUC\u00cdA]\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ it.nombre.uppercase() }</code> toma cada estudiante (<code>it</code> es el nombre impl\u00edcito para un \u00fanico par\u00e1metro) y devuelve su nombre convertido a may\u00fasculas. El resultado es una <code>List&lt;String&gt;</code>.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#3-find-o-firstornull-encontrando-un-elemento","title":"3. <code>find</code> (o <code>firstOrNull</code>): Encontrando un elemento #\ufe0f\u20e3","text":"<p>La funci\u00f3n <code>firstOrNull</code> devuelve el primer elemento que cumple una condici\u00f3n, o <code>null</code> si ninguno la cumple.</p> <p>Ejemplo: Busquemos al estudiante con el ID 4.</p> <pre><code>val estudianteBuscado = estudiantes.firstOrNull { it.id == 4 }\n\nif (estudianteBuscado != null) {\n    println(\"\\nEstudiante encontrado: ${estudianteBuscado.nombre}\")\n} else {\n    println(\"\\nNo se encontr\u00f3 al estudiante.\")\n}\n\n// --- Salida ---\n// Estudiante encontrado: Sof\u00eda\n</code></pre>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#4-groupby-agrupando-elementos","title":"4. <code>groupBy</code>: Agrupando elementos #\ufe0f\u20e3","text":"<p>Esta funci\u00f3n es incre\u00edblemente \u00fatil. Agrupa los elementos de una colecci\u00f3n en un <code>Map</code>, donde las claves son el resultado de la lambda y los valores son listas de los elementos que generaron esa clave.</p> <p>Ejemplo: Agrupemos a los estudiantes por el curso en el que est\u00e1n inscritos.</p> <pre><code>val estudiantesPorCurso = estudiantes.groupBy { it.curso }\n\nprintln(\"\\nEstudiantes agrupados por curso:\")\nestudiantesPorCurso.forEach { (curso, listaEstudiantes) -&gt;\n    println(\"Curso: $curso\")\n    listaEstudiantes.forEach { estudiante -&gt;\n        println(\"  - ${estudiante.nombre}\")\n    }\n}\n\n// --- Salida ---\n// Estudiantes agrupados por curso:\n// Curso: Kotlin Avanzado\n//   - Ana\n//   - Carlos\n//   - Pedro\n// Curso: Jetpack Compose\n//   - Luis\n//   - Marta\n// Curso: Arquitectura Android\n//   - Sof\u00eda\n//   - Luc\u00eda\n</code></pre> <p>Explicaci\u00f3n</p> <p>La lambda <code>{ it.curso }</code> se ejecuta para cada estudiante, y el valor que devuelve (el nombre del curso) se usa como clave en el <code>Map</code> resultante.</p>"},{"location":"temas/00-android/00-kotlin/13-funciones-lambdas.html#encadenamiento-de-operaciones-el-verdadero-poder","title":"Encadenamiento de Operaciones: El verdadero poder \ud83d\udcaa","text":"<p>La verdadera expresividad se alcanza cuando encadenamos estas funciones. Las operaciones se ejecutan en secuencia, permiti\u00e9ndonos realizar consultas complejas de forma muy legible.</p> <p>Ejemplo complejo: Queremos obtener los nombres de los estudiantes activos del curso \"Kotlin Avanzado\" que hayan aprobado, ordenados por su calificaci\u00f3n de mayor a menor.</p> <pre><code>val resultadoFinal = estudiantes\n    .filter { it.curso == \"Kotlin Avanzado\" &amp;&amp; it.activo } // 1. Filtra por curso y estado activo\n    .filter { it.calificacion &gt;= 7.0 }                 // 2. Filtra los aprobados de ese grupo\n    .sortedByDescending { it.calificacion }               // 3. Ordena de mayor a menor calificaci\u00f3n\n    .map { \"${it.nombre} - Calificaci\u00f3n: ${it.calificacion}\" } // 4. Mapea al formato deseado (String)\n\nprintln(\"\\nConsulta compleja:\")\nresultadoFinal.forEach { println(it) }\n\n// --- Salida ---\n// Consulta compleja:\n// Ana - Calificaci\u00f3n: 9.5\n// Carlos - Calificaci\u00f3n: 8.9\n</code></pre>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html","title":"Null safety","text":""},{"location":"temas/00-android/00-kotlin/14-null-safety.html#null-safety-en-kotlin","title":"Null safety en Kotlin","text":"<p>En Kotlin, el manejo de nulos es una parte fundamental del lenguaje. </p> <p>Kotlin est\u00e1 dise\u00f1ado para evitar los errores de referencia nula que son comunes en otros lenguajes de programaci\u00f3n, como Java. </p> <p>En Kotlin, los tipos de datos pueden ser nulos o no nulos, lo que te permite expresar de forma segura si un valor puede ser nulo o no.  </p> <p>Diferencia con Java</p> <p>En Java, todos los tipos de datos pueden ser nulos, lo que puede llevar a errores de referencia nula si no se manejan correctamente. </p> <p>En Kotlin, los tipos de datos no nulos deben ser manejados de forma expl\u00edcita, lo que ayuda a prevenir los errores de referencia nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#tipos-de-datos-nulos","title":"Tipos de datos nulos","text":"<p>En Kotlin, los tipos de datos pueden ser nulos o no nulos.</p> <ul> <li> <p>Tipos de datos no nulos: Los tipos de datos no nulos no pueden contener valores nulos y deben ser inicializados con un valor no nulo.</p> </li> <li> <p>Tipos de datos nulos: Los tipos de datos nulos pueden contener valores nulos y deben ser inicializados con un valor nulo o con la funci\u00f3n <code>null</code>.</p> </li> </ul> <pre><code>val nombre: String = \"Juan\" // Tipo de dato no nulo\n\nval apellido: String? = null // Tipo de dato nulo\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String</code> no nulo, por lo que no puede contener un valor nulo. La variable <code>apellido</code>, en cambio, es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#operadores-de-seguridad-de-nulos","title":"Operadores de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar operadores de seguridad de nulos para manejar los valores nulos de forma segura.</p> <ul> <li> <p>Operador de llamada segura (<code>?.</code>): El operador de llamada segura <code>?.</code> te permite acceder a las propiedades de un objeto nulo sin lanzar una excepci\u00f3n de referencia nula.</p> </li> <li> <p>Operador de elvis (<code>?:</code>): El operador de elvis <code>?:</code> te permite proporcionar un valor predeterminado en caso de que una expresi\u00f3n sea nula.</p> </li> <li> <p>Operador de no nulo (<code>!!</code>): El operador de no nulo <code>!!</code> te permite forzar la ejecuci\u00f3n de una expresi\u00f3n nula, lo que puede lanzar una excepci\u00f3n de referencia nula si la expresi\u00f3n es nula.</p> </li> </ul> <pre><code>val nombre: String? = null\n\nval longitud = nombre?.length // null\n\nval longitud = nombre?.length ?: 0 // 0\n\nval longitud = nombre!!.length // Lanza una excepci\u00f3n de referencia nula\n</code></pre> <p>En el ejemplo anterior, la variable <code>nombre</code> es de tipo <code>String?</code> nulo, por lo que puede contener un valor nulo.</p> <ul> <li> <p>En la primera l\u00ednea, se utiliza el operador de llamada segura <code>?.</code> para acceder a la propiedad <code>length</code> de la variable <code>nombre</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length</code> devuelve <code>null</code>.</p> </li> <li> <p>En la segunda l\u00ednea, se utiliza el operador de elvis <code>?:</code> para proporcionar un valor predeterminado de <code>0</code> en caso de que la expresi\u00f3n <code>nombre?.length</code> sea nula. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre?.length ?: 0</code> devuelve <code>0</code>.</p> </li> <li> <p>En la tercera l\u00ednea, se utiliza el operador de no nulo <code>!!</code> para forzar la ejecuci\u00f3n de la expresi\u00f3n <code>nombre!!.length</code>. Como <code>nombre</code> es nulo, la expresi\u00f3n <code>nombre!!.length</code> lanza una excepci\u00f3n de referencia nula.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#funciones-de-extension-de-seguridad-de-nulos","title":"Funciones de extensi\u00f3n de seguridad de nulos","text":"<p>En Kotlin, puedes utilizar funciones de extensi\u00f3n para agregar funcionalidades a los tipos de datos nulos.</p> <pre><code>fun String?.oLongitud(): Int {\n    return this?.length ?: 0\n}\n\nval nombre: String? = null\n\nval longitud = nombre.oLongitud() // 0\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>oLongitud</code> para el tipo de dato <code>String?</code>. La funci\u00f3n <code>oLongitud</code> devuelve la longitud de la cadena si no es nula, o <code>0</code> si es nula.</p>"},{"location":"temas/00-android/00-kotlin/14-null-safety.html#conclusiones","title":"Conclusiones","text":"<p>El manejo de nulos en Kotlin es una parte fundamental del lenguaje que te permite expresar de forma segura si un valor puede ser nulo o no.</p> <p>Al utilizar tipos de datos nulos y operadores de seguridad de nulos, puedes prevenir los errores de referencia nula y escribir c\u00f3digo m\u00e1s robusto y seguro.</p> <p>Recursos</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin sobre seguridad de nulos</li> <li>Kotlin Playground: Un entorno de programaci\u00f3n en l\u00ednea para probar y aprender Kotlin.</li> <li>Apuntes Kotlin: Un repositorio con apuntes y ejemplos de Kotlin.</li> </ul>"},{"location":"temas/00-android/00-kotlin/21-poo.html","title":"POO","text":""},{"location":"temas/00-android/00-kotlin/21-poo.html#programacion-orientada-a-objetos-en-kotlin","title":"Programaci\u00f3n orientada a objetos en Kotlin","text":"<p>La programaci\u00f3n orientada a objetos (POO) es un paradigma de programaci\u00f3n que se basa en el concepto de \"objetos\", que pueden contener datos en forma de campos (tambi\u00e9n conocidos como atributos) y c\u00f3digo en forma de procedimientos (tambi\u00e9n conocidos como m\u00e9todos).    </p> <p>En Kotlin, puedes crear clases y objetos para modelar entidades del mundo real y encapsular datos y comportamientos relacionados. Kotlin es un lenguaje de programaci\u00f3n orientado a objetos y admite todas las caracter\u00edsticas tradicionales de la programaci\u00f3n orientada a objetos, como la herencia, el polimorfismo, la encapsulaci\u00f3n y la abstracci\u00f3n.  </p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#clases-y-objetos","title":"Clases y objetos","text":"<p>En Kotlin, puedes definir una clase utilizando la palabra clave <code>class</code> seguida del nombre de la clase y el cuerpo de la clase entre llaves <code>{}</code>. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con valores predeterminados.</p> <p>Para crear un objeto de una clase en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#propiedades-y-metodos","title":"Propiedades y m\u00e9todos","text":"<p>En Kotlin, puedes definir propiedades y m\u00e9todos en una clase utilizando la palabra clave <code>var</code> o <code>val</code> seguida del nombre de la propiedad o el m\u00e9todo y el tipo de dato de la propiedad o el m\u00e9todo.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y un m\u00e9todo <code>saludar</code> que imprime un mensaje de saludo con el nombre de la persona.</p> <p>Para acceder a las propiedades y m\u00e9todos de un objeto en Kotlin, puedes utilizar el operador de acceso <code>.</code> seguido del nombre de la propiedad o el m\u00e9todo.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. Luego, se llama al m\u00e9todo <code>saludar</code> en el objeto <code>persona</code> para imprimir un mensaje de saludo con el nombre de la persona.</p> <p>Diferencias con Java</p> <p>A diferencia de Java, en Kotlin, las propiedades y los m\u00e9todos de una clase son p\u00fablicos por defecto, lo que significa que se pueden acceder desde cualquier parte del c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>En Kotlin, puedes encapsular propiedades y m\u00e9todos en una clase utilizando los modificadores de acceso <code>public</code>, <code>protected</code>, <code>private</code> y <code>internal</code>.</p> <ul> <li><code>public</code>: Las propiedades y m\u00e9todos p\u00fablicos son accesibles desde cualquier parte del c\u00f3digo.</li> <li><code>protected</code>: Las propiedades y m\u00e9todos protegidos son accesibles desde la clase actual y las clases derivadas.</li> <li><code>private</code>: Las propiedades y m\u00e9todos privados son accesibles solo desde la clase actual.</li> <li><code>internal</code>: Las propiedades y m\u00e9todos internos son accesibles desde el m\u00f3dulo actual.</li> </ul> <pre><code>class Persona {\n    var nombre: String = \"\"\n        private set\n    var edad: Int = 0\n        private set\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que se han encapsulado con el modificador de acceso <code>private</code>. Esto significa que las propiedades <code>nombre</code> y <code>edad</code> solo se pueden acceder y modificar dentro de la clase <code>Persona</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"Juan\"\npersona.edad = 30\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto. </p> <p>Sin embargo, al intentar modificar las propiedades <code>nombre</code> y <code>edad</code> desde fuera de la clase <code>Persona</code>, se produce un error de compilaci\u00f3n debido a que las propiedades est\u00e1n encapsuladas con el modificador de acceso <code>private</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#setters-y-getters-personalizados","title":"Setters y Getters personalizados","text":"<p>En Kotlin, puedes definir setters y getters personalizados para las propiedades de una clase utilizando la palabra clave <code>set</code> y <code>get</code> seguida de la l\u00f3gica personalizada para establecer y obtener el valor de la propiedad.</p> <pre><code>class Persona {\n    var nombre: String = \"\"\n        set(value) {\n            field = value.capitalize()\n        }\n    var edad: Int = 0\n        set(value) {\n            field = if (value &gt;= 0) value else 0\n        }\n\n    fun saludar() {\n        println(\"Hola, soy $nombre\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code> que tienen setters personalizados. El setter de la propiedad <code>nombre</code> capitaliza el valor de la propiedad, y el setter de la propiedad <code>edad</code> establece el valor de la propiedad en <code>0</code> si es menor que <code>0</code>.</p> <p>Para acceder a las propiedades de una clase en Kotlin, puedes utilizar los m\u00e9todos de acceso <code>get</code> y <code>set</code> para obtener y establecer el valor de una propiedad.</p> <pre><code>val persona = Persona()\npersona.nombre = \"juan\"\npersona.edad = -10\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores","title":"Constructores","text":"<p>En Kotlin, puedes definir un constructor primario utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <p>Sin embargo, en Kotlin, puedes omitir la palabra clave <code>constructor</code> y definir los par\u00e1metros del constructor directamente en la declaraci\u00f3n de la clase.</p> <pre><code>class Persona(nombre: String, edad: Int) {\n    var nombre: String = nombre\n    var edad: Int = edad\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor primario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor.</p> <p>Para crear un objeto de una clase con un constructor primario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor primario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#constructores-secundarios","title":"Constructores secundarios","text":"<p>En Kotlin, puedes definir constructores secundarios utilizando la palabra clave <code>constructor</code> seguida de los par\u00e1metros del constructor. </p> <pre><code>class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n\n    constructor(nombre: String, edad: Int) {\n        this.nombre = nombre\n        this.edad = edad\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un constructor secundario que toma dos par\u00e1metros <code>nombre</code> y <code>edad</code>. Las propiedades de la clase se inicializan con los valores de los par\u00e1metros del constructor secundario.</p> <p>Para crear un objeto de una clase con un constructor secundario en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor secundario de la clase con los argumentos del constructor.</p> <pre><code>val persona = Persona(\"Juan\", 30)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>persona</code> de la clase <code>Persona</code> utilizando el constructor secundario y se inicializan las propiedades <code>nombre</code> y <code>edad</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#herencia","title":"Herencia","text":"<p>En Kotlin, puedes crear una clase que herede de otra clase utilizando la palabra clave <code>:</code> seguida del nombre de la clase base.</p> <pre><code>open class Persona {\n    var nombre: String = \"\"\n    var edad: Int = 0\n}\n\nclass Empleado : Persona() {\n    var salario: Double = 0.0\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con dos propiedades <code>nombre</code> y <code>edad</code>, y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y agrega una propiedad <code>salario</code>.</p> <p>Para crear un objeto de una clase derivada en Kotlin, puedes utilizar la palabra clave <code>val</code> o <code>var</code> seguida del nombre del objeto, el operador de asignaci\u00f3n <code>=</code> y la invocaci\u00f3n del constructor de la clase derivada.</p> <pre><code>val empleado = Empleado()\nempleado.nombre = \"Juan\"\nempleado.edad = 30\nempleado.salario = 1000.0\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se inicializan las propiedades <code>nombre</code>, <code>edad</code> y <code>salario</code> del objeto.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#polimorfismo","title":"Polimorfismo","text":"<p>En Kotlin, puedes utilizar el polimorfismo para tratar un objeto de una clase derivada como un objeto de la clase base.</p> <pre><code>open class Persona {\n    open fun saludar() {\n        println(\"Hola, soy una persona\")\n    }\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> y sobrescribe el m\u00e9todo <code>saludar</code>.</p> <p>La palabra reservada open</p> <p>La palabra reservada <code>open</code> se utiliza para marcar una clase o un miembro de una clase como \"sobrese\u00edble\", lo que significa que puede ser heredado y sobrescrito por clases derivadas. </p> <p>Para utilizar el polimorfismo en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/21-poo.html#abstraccion","title":"Abstracci\u00f3n","text":"<p>En Kotlin, puedes utilizar la abstracci\u00f3n para definir una clase base con m\u00e9todos abstractos que deben ser implementados por las clases derivadas.</p> <pre><code>abstract class Persona {\n    abstract fun saludar()\n}\n\nclass Empleado : Persona() {\n    override fun saludar() {\n        println(\"Hola, soy un empleado\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>Persona</code> con un m\u00e9todo abstracto <code>saludar</code> y una clase <code>Empleado</code> que hereda de la clase <code>Persona</code> e implementa el m\u00e9todo <code>saludar</code>.</p> <p>Para utilizar la abstracci\u00f3n en Kotlin, puedes crear un objeto de la clase derivada y asignarlo a una variable de la clase base.</p> <pre><code>val persona: Persona = Empleado()\npersona.saludar()\n</code></pre> <p>En el ejemplo anterior, se crea un objeto <code>empleado</code> de la clase <code>Empleado</code> y se asigna a una variable <code>persona</code> de la clase <code>Persona</code>. Al llamar al m\u00e9todo <code>saludar</code> en la variable <code>persona</code>, se ejecuta la implementaci\u00f3n del m\u00e9todo <code>saludar</code> de la clase <code>Empleado</code>.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html","title":"Objetos an\u00f3nimos","text":""},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#objetos-anonimos-en-kotlin","title":"Objetos an\u00f3nimos en Kotlin","text":"<p>En Kotlin, puedes crear objetos an\u00f3nimos utilizando la palabra clave <code>object</code>. </p> <p>Los objetos an\u00f3nimos son instancias de una clase an\u00f3nima que no tienen un nombre y se utilizan para definir una clase de forma concisa y reutilizable.</p> <pre><code>val persona = object {\n    val nombre = \"Juan\"\n    val edad = 25\n}\n\nprintln(persona.nombre) // Juan\nprintln(persona.edad) // 25\n</code></pre> <p>En el ejemplo anterior, se crea un objeto an\u00f3nimo que tiene dos propiedades <code>nombre</code> y <code>edad</code>. </p> <p>El objeto an\u00f3nimo se asigna a la variable <code>persona</code> y se puede acceder a sus propiedades utilizando la notaci\u00f3n de punto.</p> <p>Los objetos an\u00f3nimos son \u00fatiles cuando necesitas crear una instancia de una clase de forma r\u00e1pida y concisa sin tener que definir una clase con nombre.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#uso-de-objetos-anonimos","title":"Uso de objetos an\u00f3nimos","text":"<p>Los objetos an\u00f3nimos se utilizan en Kotlin para:</p> <ul> <li>Crear instancias de una clase de forma r\u00e1pida y concisa.</li> <li>Definir clases de forma reutilizable sin tener que definir una clase con nombre.</li> <li>Implementar interfaces y clases abstractas de forma an\u00f3nima.</li> </ul> <p>Los objetos an\u00f3nimos son una caracter\u00edstica poderosa de Kotlin que te permite escribir c\u00f3digo de forma m\u00e1s concisa y eficiente.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-de-interfaces-con-objetos-anonimos","title":"Implementaci\u00f3n de interfaces con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar interfaces de forma an\u00f3nima utilizando objetos an\u00f3nimos. Esto te permite definir una clase que implementa una interfaz sin tener que definir una clase con nombre.</p> <pre><code>interface Saludable {\n    fun saludar()\n}\n\nval persona = object : Saludable {\n    override fun saludar() {\n        println(\"Hola, soy una persona saludable!\")\n    }\n}\n\npersona.saludar() // Hola, soy una persona saludable!\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Saludable</code> con un m\u00e9todo <code>saludar</code>.</p> <p>Se crea un objeto an\u00f3nimo que implementa la interfaz <code>Saludable</code> y se asigna a la variable <code>persona</code>.</p> <p>El objeto an\u00f3nimo define la implementaci\u00f3n del m\u00e9todo <code>saludar</code> y se puede llamar al m\u00e9todo utilizando la notaci\u00f3n de punto.</p>"},{"location":"temas/00-android/00-kotlin/22-objetos-anonimos.html#implementacion-del-patron-singleton-con-objetos-anonimos","title":"Implementaci\u00f3n del patr\u00f3n Singleton con objetos an\u00f3nimos","text":"<p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos. El patr\u00f3n Singleton garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <pre><code>object Configuracion {\n    val servidor = \"localhost\"\n    val puerto = 8080\n}\n\nprintln(Configuracion.servidor) // localhost\nprintln(Configuracion.puerto) // 8080\n</code></pre> <p>En el ejemplo anterior, se define un objeto an\u00f3nimo <code>Configuracion</code> que tiene dos propiedades <code>servidor</code> y <code>puerto</code>.</p> <p>El objeto an\u00f3nimo se utiliza para almacenar la configuraci\u00f3n de la aplicaci\u00f3n y garantiza que solo haya una instancia de la configuraci\u00f3n en toda la aplicaci\u00f3n.</p> <p>Caracter\u00edsticas de los objetos an\u00f3nimos</p> <p>Los objetos an\u00f3nimos en Kotlin tienen las siguientes caracter\u00edsticas:</p> <ul> <li>No tienen un nombre y se crean utilizando la palabra clave <code>object</code>.</li> <li>Pueden tener propiedades, m\u00e9todos y constructores.</li> <li>Se utilizan para definir clases de forma concisa y reutilizable.</li> <li>Se pueden utilizar para implementar interfaces y clases abstractas de forma an\u00f3nima.</li> <li>Se pueden utilizar para implementar el patr\u00f3n Singleton y almacenar configuraciones globales.</li> </ul> <p>Sobre el patr\u00f3n Singleton</p> <p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o que garantiza que una clase tenga una \u00fanica instancia y proporciona un punto de acceso global a esa instancia.</p> <p>En Kotlin, puedes implementar el patr\u00f3n Singleton utilizando objetos an\u00f3nimos, que garantizan que solo haya una instancia de la clase en toda la aplicaci\u00f3n.</p> <p>Usos comunes del patr\u00f3n Singleton incluyen la creaci\u00f3n de objetos de configuraci\u00f3n, conexiones a bases de datos y puntos de acceso a servicios globales.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html","title":"Data classes","text":""},{"location":"temas/00-android/00-kotlin/23-data-classes.html#data-classes-en-kotlin","title":"Data classes en Kotlin","text":"<p>En Kotlin, puedes crear clases de datos utilizando la palabra clave <code>data</code>. Las clases de datos son una forma concisa de definir clases que contienen datos y no tienen l\u00f3gica adicional.</p> <pre><code>data class Persona(val nombre: String, val edad: Int)\n</code></pre> <p>En el ejemplo anterior, se define una clase de datos <code>Persona</code> que tiene dos propiedades <code>nombre</code> y <code>edad</code>. La clase de datos se crea utilizando la palabra clave <code>data</code> seguida del nombre de la clase y las propiedades de la clase.</p> <p>Short explicativo en YouTube</p> <p>Enlace al v\u00eddeo</p> <p>v\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#propiedades-de-las-clases-de-datos","title":"Propiedades de las clases de datos","text":"<p>Las clases de datos en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Propiedades de solo lectura: Las propiedades de una clase de datos son de solo lectura y no se pueden modificar una vez que se han inicializado.</p> </li> <li> <p>M\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente los m\u00e9todos <code>toString()</code>, <code>equals()</code> y <code>hashCode()</code> a partir de las propiedades de la clase.</p> </li> <li> <p>M\u00e9todos <code>componentN()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente m\u00e9todos <code>componentN()</code> que te permiten desestructurar objetos de la clase en variables individuales.</p> </li> <li> <p>M\u00e9todo <code>copy()</code>: Las clases de datos en Kotlin generan autom\u00e1ticamente un m\u00e9todo <code>copy()</code> que te permite crear copias de objetos de la clase con propiedades modificadas.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#creacion-de-objetos-de-clases-de-datos","title":"Creaci\u00f3n de objetos de clases de datos","text":"<p>Para crear un objeto de una clase de datos en Kotlin, puedes utilizar la palabra clave <code>data</code> seguida del nombre de la clase y los valores de las propiedades.</p> <pre><code>val persona = Persona(\"Juan\", 25)\n</code></pre> <p>En el ejemplo anterior, se crea un objeto de la clase de datos <code>Persona</code> con el nombre <code>Juan</code> y la edad <code>25</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#desestructuracion-de-objetos-de-clases-de-datos","title":"Desestructuraci\u00f3n de objetos de clases de datos","text":"<p>En Kotlin, puedes desestructurar objetos de clases de datos en variables individuales utilizando la notaci\u00f3n de desestructuraci\u00f3n.</p> <pre><code>val (nombre, edad) = persona\n</code></pre> <p>En el ejemplo anterior, se desestructura el objeto <code>persona</code> en las variables <code>nombre</code> y <code>edad</code>.</p>"},{"location":"temas/00-android/00-kotlin/23-data-classes.html#copia-de-objetos-de-clases-de-datos","title":"Copia de objetos de clases de datos","text":"<p>En Kotlin, puedes crear copias de objetos de clases de datos utilizando el m\u00e9todo <code>copy()</code>.</p> <pre><code>val persona2 = persona.copy(edad = 30)\n</code></pre> <p>En el ejemplo anterior, se crea una copia del objeto <code>persona</code> con la edad modificada a <code>30</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html","title":"Enum classes","text":""},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#enum-classes-en-kotlin","title":"Enum classes en Kotlin","text":"<p>En Kotlin, puedes crear enumeraciones utilizando la palabra clave <code>enum class</code>.</p> <p>Las enumeraciones son una forma de definir un conjunto fijo de constantes que representan valores espec\u00edficos. Cada constante en una enumeraci\u00f3n tiene un nombre y un valor asociado.</p> <pre><code>enum class Color {\n    ROJO, VERDE, AZUL\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con tres constantes <code>ROJO</code>, <code>VERDE</code> y <code>AZUL</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-de-las-enumeraciones","title":"Propiedades de las enumeraciones","text":"<p>Las enumeraciones en Kotlin tienen las siguientes propiedades:</p> <ul> <li> <p>Constantes: Las enumeraciones contienen un conjunto fijo de constantes que representan valores espec\u00edficos.</p> </li> <li> <p>Propiedades y m\u00e9todos: Las enumeraciones pueden tener propiedades y m\u00e9todos asociados con cada constante.</p> </li> <li> <p>Constructores: Las enumeraciones pueden tener constructores personalizados para inicializar las constantes con valores espec\u00edficos.</p> </li> <li> <p>Implementaci\u00f3n de interfaces: Las enumeraciones pueden implementar interfaces y heredar de clases.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#acceso-a-las-constantes-de-una-enumeracion","title":"Acceso a las constantes de una enumeraci\u00f3n","text":"<p>Puedes acceder a las constantes de una enumeraci\u00f3n utilizando la notaci\u00f3n de punto.</p> <pre><code>val color = Color.ROJO\n</code></pre> <p>En el ejemplo anterior, se accede a la constante <code>ROJO</code> de la enumeraci\u00f3n <code>Color</code> y se asigna a la variable <code>color</code>.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#propiedades-y-metodos-de-una-enumeracion","title":"Propiedades y m\u00e9todos de una enumeraci\u00f3n","text":"<p>Puedes definir propiedades y m\u00e9todos en una enumeraci\u00f3n para agregar funcionalidades a las constantes.</p> <pre><code>enum class Color(val rgb: Int) {\n    ROJO(0xFF0000),\n    VERDE(0x00FF00),\n    AZUL(0x0000FF);\n\n    fun nombreEnMayusculas(): String {\n        return name.toUpperCase()\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una enumeraci\u00f3n <code>Color</code> con una propiedad <code>rgb</code> y un m\u00e9todo <code>nombreEnMayusculas</code> que devuelve el nombre de la constante en may\u00fasculas.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#implementacion-de-interfaces-con-enumeraciones","title":"Implementaci\u00f3n de interfaces con enumeraciones","text":"<p>Las enumeraciones en Kotlin pueden implementar interfaces para agregar funcionalidades a las constantes.</p> <pre><code>interface Describible {\n    fun describir(): String\n}\n\nenum class DiaSemana : Describible {\n    LUNES {\n        override fun describir(): String {\n            return \"Primer d\u00eda de la semana\"\n        }\n    },\n    MARTES {\n        override fun describir(): String {\n            return \"Segundo d\u00eda de la semana\"\n        }\n    },\n    MIERCOLES {\n        override fun describir(): String {\n            return \"Tercer d\u00eda de la semana\"\n        }\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Describible</code> con un m\u00e9todo <code>describir</code>.</p> <p>Se crea una enumeraci\u00f3n <code>DiaSemana</code> que implementa la interfaz <code>Describible</code> y define la implementaci\u00f3n del m\u00e9todo <code>describir</code> para cada constante.</p>"},{"location":"temas/00-android/00-kotlin/24-enum-classes.html#uso-de-enumeraciones-en-kotlin","title":"Uso de enumeraciones en Kotlin","text":"<p>Las enumeraciones son \u00fatiles en Kotlin para:</p> <ul> <li>Definir un conjunto fijo de constantes que representan valores espec\u00edficos.</li> <li>Agregar propiedades y m\u00e9todos a las constantes para agregar funcionalidades.</li> <li>Implementar interfaces y heredar de clases para agregar funcionalidades a las constantes.</li> </ul>"},{"location":"temas/00-android/00-kotlin/25-genericos.html","title":"Gen\u00e9ricos","text":""},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-kotlin","title":"Gen\u00e9ricos en Kotlin","text":"<p>En Kotlin, puedes utilizar gen\u00e9ricos para crear clases, funciones e interfaces que trabajen con tipos de datos de forma gen\u00e9rica. Los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p> <p>Video explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#clases-genericas","title":"Clases gen\u00e9ricas","text":"<p>En Kotlin, puedes crear clases gen\u00e9ricas utilizando la palabra clave <code>class</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la clase puede manejar.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval cajaCadena = Caja(\"Hola\")\n\nval entero: Int = cajaEntero.obtenerContenido()\nval cadena: String = cajaCadena.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una clase gen\u00e9rica <code>Caja</code> que tiene un par\u00e1metro de tipo <code>T</code>. La clase <code>Caja</code> tiene una propiedad <code>contenido</code> de tipo <code>T</code> y un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido de la caja.</p> <p>Se crean dos instancias de la clase <code>Caja</code> con tipos de datos diferentes: una con un entero y otra con una cadena. Se obtiene el contenido de cada caja y se asigna a variables de tipo <code>Int</code> y <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#funciones-genericas","title":"Funciones gen\u00e9ricas","text":"<p>En Kotlin, puedes crear funciones gen\u00e9ricas utilizando la palabra clave <code>fun</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la funci\u00f3n puede manejar.</p> <pre><code>fun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\nimprimirElemento(10)\nimprimirElemento(\"Hola\")\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n gen\u00e9rica <code>imprimirElemento</code> que toma un par\u00e1metro de tipo <code>T</code> y lo imprime en la consola. La funci\u00f3n <code>imprimirElemento</code> se llama dos veces con un entero y una cadena como argumentos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#interfaces-genericas","title":"Interfaces gen\u00e9ricas","text":"<p>En Kotlin, puedes crear interfaces gen\u00e9ricas utilizando la palabra clave <code>interface</code> seguida de los par\u00e1metros de tipo entre corchetes <code>&lt;&gt;</code>. Los par\u00e1metros de tipo se utilizan para definir los tipos de datos que la interfaz puede manejar.</p> <pre><code>interface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;T&gt;(val contenido: T) : Contenedor&lt;T&gt; {\n    override fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nval cajaEntero = Caja(10)\nval entero: Int = cajaEntero.obtenerContenido()\n</code></pre> <p>En el ejemplo anterior, se define una interfaz gen\u00e9rica <code>Contenedor</code> que tiene un par\u00e1metro de tipo <code>T</code>. La interfaz <code>Contenedor</code> define un m\u00e9todo <code>obtenerContenido</code> que devuelve el contenido del contenedor.</p> <p>Se crea una clase <code>Caja</code> que implementa la interfaz <code>Contenedor</code> con un tipo de dato <code>T</code>. Se crea una instancia de la clase <code>Caja</code> con un entero y se obtiene el contenido de la caja.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#variance-en-genericos","title":"Variance en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar la anotaci\u00f3n <code>in</code> y <code>out</code> para especificar la variabilidad de los par\u00e1metros de tipo en clases y funciones gen\u00e9ricas.</p> <ul> <li><code>in</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de entrada (como par\u00e1metros de m\u00e9todos).</li> <li><code>out</code>: Indica que el par\u00e1metro de tipo solo se utiliza en posiciones de salida (como valores de retorno de m\u00e9todos).</li> </ul> <pre><code>interface Contenedor&lt;out T&gt; {\n    fun obtenerContenido(): T\n}\n\nclass Caja&lt;in T&gt;(val contenido: T) {\n    fun ponerContenido(nuevoContenido: T) {\n        // ...\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una interfaz <code>Contenedor</code> con un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de salida. La clase <code>Caja</code> tiene un par\u00e1metro de tipo <code>T</code> que solo se utiliza en posiciones de entrada.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#restricciones-en-genericos","title":"Restricciones en gen\u00e9ricos","text":"<p>En Kotlin, puedes utilizar restricciones para limitar los tipos de datos que se pueden utilizar en clases y funciones gen\u00e9ricas. Puedes utilizar restricciones para garantizar que los tipos de datos cumplan ciertos requisitos.</p> <pre><code>fun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n\nval resultadoEntero = sumar(1, 2)\nval resultadoFlotante = sumar(1.5, 2.5)\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>sumar</code> que toma dos par\u00e1metros de tipo <code>T</code> que deben ser subtipos de <code>Number</code>. La funci\u00f3n <code>sumar</code> devuelve la suma de los dos par\u00e1metros.</p> <p>Se llama a la funci\u00f3n <code>sumar</code> con un entero y un flotante como argumentos, y se asigna el resultado a variables de tipo <code>Int</code> y <code>Float</code>.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#genericos-en-clases-y-funciones","title":"Gen\u00e9ricos en clases y funciones","text":"<p>En Kotlin, los gen\u00e9ricos te permiten escribir c\u00f3digo que es reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos. Puedes utilizar gen\u00e9ricos en clases, funciones e interfaces para crear c\u00f3digo gen\u00e9rico y flexible.</p> <pre><code>class Caja&lt;T&gt;(val contenido: T) {\n    fun obtenerContenido(): T {\n        return contenido\n    }\n}\n\nfun &lt;T&gt; imprimirElemento(elemento: T) {\n    println(elemento)\n}\n\ninterface Contenedor&lt;T&gt; {\n    fun obtenerContenido(): T\n}\n\nfun &lt;T : Number&gt; sumar(a: T, b: T): T {\n    return a + b\n}\n</code></pre> <p>En el ejemplo anterior, se muestran ejemplos de clases gen\u00e9ricas, funciones gen\u00e9ricas e interfaces gen\u00e9ricas en Kotlin. Puedes utilizar gen\u00e9ricos para escribir c\u00f3digo que sea reutilizable y flexible, ya que puedes definir clases y funciones que trabajen con cualquier tipo de datos.</p>"},{"location":"temas/00-android/00-kotlin/25-genericos.html#recursos-adicionales","title":"Recursos adicionales","text":"<ul> <li>Documentaci\u00f3n oficial de Kotlin sobre gen\u00e9ricos</li> <li>Tutorial de Kotlin sobre gen\u00e9ricos</li> <li>Ejemplos de gen\u00e9ricos en Kotlin</li> </ul>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html","title":"Clases selladas","text":""},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#clases-selladas-en-kotlin","title":"Clases selladas en Kotlin","text":"<p>Las clases selladas son un tipo especial de clase en Kotlin que se utilizan para representar un conjunto finito de subclases. </p> <p>Las clases selladas son \u00fatiles cuando tienes un conjunto limitado de subclases y quieres asegurarte de que todas las subclases se manejan de forma segura en un bloque <code>when</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#declaracion-de-clases-selladas","title":"Declaraci\u00f3n de clases selladas","text":"<p>En Kotlin, puedes declarar una clase sellada utilizando la palabra clave <code>sealed</code> antes de la palabra clave <code>class</code>. </p> <pre><code>sealed class Resultado {\n    data class Exito(val mensaje: String) : Resultado()\n    data class Error(val mensaje: String) : Resultado()\n}\n</code></pre> <p>En el ejemplo anterior, se declara una clase sellada <code>Resultado</code> con dos subclases: <code>Exito</code> y <code>Error</code>. Ambas subclases tienen una propiedad <code>mensaje</code> de tipo <code>String</code>.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#uso-de-clases-selladas","title":"Uso de clases selladas","text":"<p>Las clases selladas se utilizan principalmente en expresiones <code>when</code> para manejar de forma segura todas las subclases. </p> <pre><code>fun procesarResultado(resultado: Resultado) {\n    when (resultado) {\n        is Resultado.Exito -&gt; println(\"Exito: ${resultado.mensaje}\")\n        is Resultado.Error -&gt; println(\"Error: ${resultado.mensaje}\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>procesarResultado</code> que toma un par\u00e1metro de tipo <code>Resultado</code>. Dentro de la expresi\u00f3n <code>when</code>, se manejan de forma segura las subclases <code>Exito</code> y <code>Error</code> de la clase sellada <code>Resultado</code>.</p> <p>Las clases selladas son una forma segura y concisa de manejar un conjunto finito de subclases en Kotlin.</p>"},{"location":"temas/00-android/00-kotlin/26-sealed-classes.html#ventajas-de-las-clases-selladas","title":"Ventajas de las clases selladas","text":"<ul> <li>Seguridad: Las clases selladas garantizan que todas las subclases se manejen de forma segura en un bloque <code>when</code>.</li> <li>Concisi\u00f3n: Las clases selladas permiten definir un conjunto finito de subclases de forma concisa y legible.</li> <li>Extensibilidad: Las clases selladas pueden tener subclases anidadas, lo que permite una mayor extensibilidad y modularidad en el c\u00f3digo.</li> </ul> <p>Las clases selladas son una caracter\u00edstica poderosa de Kotlin que te permite representar de forma segura un conjunto finito de subclases y manejarlas de forma concisa y legible en tu c\u00f3digo.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html","title":"Scope functions","text":""},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#scope-functions-en-kotlin","title":"Scope functions en Kotlin","text":"<p>En Kotlin, los scope functions son funciones que te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto. Estas funciones te permiten acceder a las propiedades y m\u00e9todos del objeto de forma m\u00e1s concisa y legible. </p> <p>Las scope functions en Kotlin son las siguientes: </p> <ul> <li><code>let</code></li> <li><code>run</code></li> <li><code>with</code></li> <li><code>apply</code></li> <li><code>also</code></li> </ul> <p>V\u00eddeo explicativo en YouTube</p> <p></p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#let","title":"<code>let</code>","text":"<p>La funci\u00f3n <code>let</code> te permite ejecutar un bloque de c\u00f3digo en el contexto de un objeto y devolver el resultado de la \u00faltima expresi\u00f3n del bloque. </p> <p>La funci\u00f3n <code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.let {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n    it.edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>let</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#run","title":"<code>run</code>","text":"<p>A diferencia de <code>let</code>, la funci\u00f3n <code>run</code> te permite acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</p> <p>La funci\u00f3n <code>run</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = persona?.run {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>run</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#with","title":"<code>with</code>","text":"<p>La funci\u00f3n <code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>with</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</p> <pre><code>val resultado = with(persona) {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad + 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>with</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver la edad incrementada en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#apply","title":"<code>apply</code>","text":"<p>A diferencia de las funciones anteriores, la funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <p>La funci\u00f3n <code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</p> <pre><code>val resultado = persona?.apply {\n    println(\"Nombre: $nombre\")\n    println(\"Edad: $edad\")\n    edad += 1\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>apply</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y modificar la edad increment\u00e1ndola en 1.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#also","title":"<code>also</code>","text":"<p>La funci\u00f3n <code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</p> <p>La funci\u00f3n <code>also</code> se utiliza para realizar operaciones en un objeto y devolver el objeto original.</p> <pre><code>val resultado = persona?.also {\n    println(\"Nombre: ${it.nombre}\")\n    println(\"Edad: ${it.edad}\")\n}\n</code></pre> <p>En el ejemplo anterior, se utiliza la funci\u00f3n <code>also</code> para acceder a las propiedades <code>nombre</code> y <code>edad</code> del objeto <code>persona</code> y devolver el objeto original.</p>"},{"location":"temas/00-android/00-kotlin/31-scope-functions.html#resumen","title":"Resumen","text":"<p>En resumen, las scope functions en Kotlin te permiten ejecutar un bloque de c\u00f3digo en el contexto de un objeto y realizar operaciones en el objeto de forma m\u00e1s concisa y legible. Cada funci\u00f3n tiene un prop\u00f3sito espec\u00edfico y se utiliza en diferentes situaciones, dependiendo de tus necesidades. </p> <p>Podr\u00edamos decir que las diferencias generales son las siguientes:</p> <ul> <li><code>let</code> se utiliza para realizar operaciones en un objeto y devolver un resultado.</li> <li><code>run</code> se utiliza para acceder a las propiedades y m\u00e9todos del objeto sin necesidad de utilizar <code>it</code>.</li> <li><code>with</code> es similar a <code>run</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> <li><code>apply</code> se utiliza para realizar operaciones en un objeto y devolver el objeto modificado.</li> <li><code>also</code> es similar a <code>apply</code>, pero se utiliza con un objeto como argumento en lugar de un receptor.</li> </ul> <p>En la siguiente imagen se muestra un resumen visual de las diferencias entre las scope functions:</p> <p></p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html","title":"Arrays","text":""},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-en-kotlin","title":"Arrays en Kotlin","text":"<p>En Kotlin, puedes crear arrays utilizando la funci\u00f3n <code>arrayOf()</code>. Los arrays en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = arrayOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un array <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los arrays en Kotlin se crean utilizando la funci\u00f3n <code>arrayOf()</code> seguida de los valores del array entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#acceso-a-elementos-de-un-array","title":"Acceso a elementos de un array","text":"<p>Puedes acceder a elementos individuales de un array utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento del array <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#modificacion-de-elementos-de-un-array","title":"Modificaci\u00f3n de elementos de un array","text":"<p>Para modificar un elemento de un array, puedes utilizar el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas modificar.</p> <pre><code>numeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se modifica el primer elemento del array <code>numeros</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#iteracion-sobre-un-array","title":"Iteraci\u00f3n sobre un array","text":"<p>Puedes iterar sobre los elementos de un array utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del array <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#arrays-de-tipos-primitivos","title":"Arrays de tipos primitivos","text":"<p>En Kotlin, puedes utilizar arrays de tipos primitivos como <code>IntArray</code>, <code>DoubleArray</code>, <code>BooleanArray</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intArrayOf(1, 2, 3, 4, 5)\nval dobles = doubleArrayOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanArrayOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean arrays de tipos primitivos <code>IntArray</code>, <code>DoubleArray</code> y <code>BooleanArray</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/41-arrays.html#operaciones-con-arrays","title":"Operaciones con arrays","text":"<p>Los arrays en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del array, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el array, <code>indexOf</code> para obtener el \u00edndice de un elemento en el array, etc.</p> <pre><code>val tama\u00f1o = numeros.size\nval contieneTres = numeros.contains(3)\nval indiceDeCuatro = numeros.indexOf(4)\n</code></pre> <p>En el ejemplo anterior, se obtiene el tama\u00f1o del array <code>numeros</code>, se comprueba si el array contiene el n\u00famero <code>3</code> y se obtiene el \u00edndice del n\u00famero <code>4</code> en el array.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html","title":"Listas","text":""},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-en-kotlin","title":"Listas en Kotlin","text":"<p>En Kotlin, puedes crear listas utilizando la funci\u00f3n <code>listOf()</code>. Las listas en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = listOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea una lista <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Las listas en Kotlin se crean utilizando la funci\u00f3n <code>listOf()</code> seguida de los valores de la lista entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#acceso-a-elementos-de-una-lista","title":"Acceso a elementos de una lista","text":"<p>Puedes acceder a elementos individuales de una lista utilizando el operador de indexaci\u00f3n <code>[]</code> seguido del \u00edndice del elemento que deseas acceder.</p> <pre><code>val primerNumero = numeros[0]\nval segundoNumero = numeros[1]\n</code></pre> <p>En el ejemplo anterior, se accede al primer y segundo elemento de la lista <code>numeros</code> utilizando los \u00edndices <code>0</code> y <code>1</code> respectivamente.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#iteracion-sobre-una-lista","title":"Iteraci\u00f3n sobre una lista","text":"<p>Puedes iterar sobre los elementos de una lista utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos de la lista <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#listas-de-tipos-primitivos","title":"Listas de tipos primitivos","text":"<p>En Kotlin, puedes utilizar listas de tipos primitivos como <code>IntList</code>, <code>DoubleList</code>, <code>BooleanList</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intListOf(1, 2, 3, 4, 5)\nval dobles = doubleListOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanListOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean listas de tipos primitivos <code>IntList</code>, <code>DoubleList</code> y <code>BooleanList</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#modificacion-de-elementos-de-una-lista","title":"Modificaci\u00f3n de elementos de una lista","text":"<p>Las listas en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de una lista una vez que se ha creado. Si necesitas una lista mutable, puedes utilizar la funci\u00f3n <code>mutableListOf()</code>.</p> <pre><code>val numeros = mutableListOf(1, 2, 3, 4, 5)\nnumeros[0] = 10\n</code></pre> <p>En el ejemplo anterior, se crea una lista mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Se modifica el primer elemento de la lista asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/42-listas.html#operaciones-comunes-con-listas","title":"Operaciones comunes con listas","text":"<p>Kotlin proporciona una serie de funciones de extensi\u00f3n para realizar operaciones comunes con listas, como <code>map()</code>, <code>filter()</code>, <code>reduce()</code>, <code>sortedBy()</code>, etc.</p> <pre><code>val cuadrados = numeros.map { numero -&gt; numero * numero }\nval pares = numeros.filter { numero -&gt; numero % 2 == 0 }\nval suma = numeros.reduce { acc, numero -&gt; acc + numero }\nval ordenados = numeros.sortedBy { numero -&gt; numero }\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>map()</code>, <code>filter()</code>, <code>reduce()</code> y <code>sortedBy()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Est\u00e1s funciones hacen lo siguiente:</p> <ul> <li> <p><code>map()</code>: Aplica una funci\u00f3n a cada elemento de la lista y devuelve una nueva lista con los resultados.</p> </li> <li> <p><code>filter()</code>: Filtra los elementos de la lista que cumplen una condici\u00f3n dada y devuelve una nueva lista con los elementos filtrados.</p> </li> <li> <p><code>reduce()</code>: Combina los elementos de la lista en un solo valor utilizando una funci\u00f3n dada.</p> </li> <li> <p><code>sortedBy()</code>: Ordena los elementos de la lista en funci\u00f3n de una clave dada y devuelve una nueva lista ordenada.</p> </li> <li> <p><code>groupBy()</code>: Agrupa los elementos de la lista en funci\u00f3n de una clave dada y devuelve un mapa de claves y listas de elementos.</p> </li> </ul> <p>Otros ejemplos de operaciones comunes con listas son <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code>, <code>distinct()</code>, etc.</p> <pre><code>val suma = numeros.sum()\nval maximo = numeros.max()\nval minimo = numeros.min()\nval promedio = numeros.average()\nval unicos = numeros.distinct()\n</code></pre> <p>En el ejemplo anterior, se utilizan las funciones de extensi\u00f3n <code>sum()</code>, <code>max()</code>, <code>min()</code>, <code>average()</code> y <code>distinct()</code> para realizar operaciones comunes con la lista <code>numeros</code>.</p> <p>Su funcionalidad es la siguiente:</p> <ul> <li> <p><code>sum()</code>: Calcula la suma de los elementos de la lista.</p> </li> <li> <p><code>max()</code>: Devuelve el valor m\u00e1ximo de la lista.</p> </li> <li> <p><code>min()</code>: Devuelve el valor m\u00ednimo de la lista.</p> </li> <li> <p><code>average()</code>: Calcula el promedio de los elementos de la lista.</p> </li> <li> <p><code>distinct()</code>: Devuelve una nueva lista con los elementos \u00fanicos de la lista original.</p> </li> </ul>"},{"location":"temas/00-android/00-kotlin/42-listas.html#funciones-de-extension-para-listas","title":"Funciones de extensi\u00f3n para listas","text":"<p>En Kotlin, puedes crear tus propias funciones de extensi\u00f3n para realizar operaciones espec\u00edficas con listas.</p> <pre><code>fun List&lt;Int&gt;.duplicar(): List&lt;Int&gt; {\n    return this.map { it * 2 }\n}\n\nval duplicados = numeros.duplicar()\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n de extensi\u00f3n <code>duplicar()</code> que duplica cada elemento de una lista de enteros. La funci\u00f3n de extensi\u00f3n se llama con la lista <code>numeros</code> y devuelve una nueva lista con los elementos duplicados.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html","title":"Maps","text":""},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-en-kotlin","title":"Maps en Kotlin","text":"<p>En Kotlin, un <code>Map</code> es una colecci\u00f3n de pares clave-valor donde cada clave est\u00e1 asociada a un valor. Los <code>Map</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = mapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Los <code>Map</code> en Kotlin se crean utilizando la funci\u00f3n <code>mapOf()</code> seguida de los pares clave-valor entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#acceso-a-elementos-de-un-map","title":"Acceso a elementos de un Map","text":"<p>Puedes acceder a elementos individuales de un <code>Map</code> utilizando la clave del elemento que deseas acceder.</p> <pre><code>val numeroUno = numeros[\"uno\"]\nval numeroDos = numeros[\"dos\"]\n</code></pre> <p>En el ejemplo anterior, se accede a los valores asociados a las claves <code>\"uno\"</code> y <code>\"dos\"</code> del <code>Map</code> <code>numeros</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#iteracion-sobre-un-map","title":"Iteraci\u00f3n sobre un Map","text":"<p>Puedes iterar sobre los pares clave-valor de un <code>Map</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for ((clave, valor) in numeros) {\n    println(\"Clave: $clave, Valor: $valor\")\n}\n\nnumeros.forEach { (clave, valor) -&gt;\n    println(\"Clave: $clave, Valor: $valor\")\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los pares clave-valor del <code>Map</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#maps-de-tipos-primitivos","title":"Maps de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Map</code> de tipos primitivos como <code>IntMap</code>, <code>DoubleMap</code>, <code>BooleanMap</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intMapOf(1 to \"uno\", 2 to \"dos\", 3 to \"tres\")\nval dobles = doubleMapOf(1.0 to \"uno\", 2.0 to \"dos\", 3.0 to \"tres\")\nval booleanos = booleanMapOf(true to \"verdadero\", false to \"falso\")\n</code></pre> <p>En el ejemplo anterior, se crean <code>Map</code> de tipos primitivos <code>IntMap</code>, <code>DoubleMap</code> y <code>BooleanMap</code> con pares clave-valor iniciales.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#modificacion-de-elementos-de-un-map","title":"Modificaci\u00f3n de elementos de un Map","text":"<p>Los <code>Map</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Map</code> una vez que se ha creado. Si necesitas un <code>Map</code> mutable, puedes utilizar la funci\u00f3n <code>mutableMapOf()</code>.</p> <pre><code>val numeros = mutableMapOf(\"uno\" to 1, \"dos\" to 2, \"tres\" to 3)\nnumeros[\"uno\"] = 10\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Map</code> mutable <code>numeros</code> con los pares clave-valor <code>\"uno\" -&gt; 1</code>, <code>\"dos\" -&gt; 2</code> y <code>\"tres\" -&gt; 3</code>. Se modifica el valor asociado a la clave <code>\"uno\"</code> asign\u00e1ndole el valor <code>10</code>.</p>"},{"location":"temas/00-android/00-kotlin/43-maps.html#operaciones-con-maps","title":"Operaciones con Maps","text":"<p>Los <code>Map</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code>, <code>filterValues()</code>, etc.</p> <pre><code>val valorUno = numeros.get(\"uno\")\nval contieneDos = numeros.containsKey(\"dos\")\nval contieneCinco = numeros.containsValue(5)\nval claves = numeros.keys\nval valores = numeros.values\nval numerosPares = numeros.filterKeys { clave -&gt; clave.length % 2 == 0 }\nval numerosImpares = numeros.filterValues { valor -&gt; valor % 2 != 0 }\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>get()</code>, <code>containsKey()</code>, <code>containsValue()</code>, <code>keys</code>, <code>values</code>, <code>filterKeys()</code> y <code>filterValues()</code> para realizar operaciones comunes con el <code>Map</code> <code>numeros</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>get()</code>: Obtiene el valor asociado a una clave.</li> <li><code>containsKey()</code>: Comprueba si una clave est\u00e1 presente en el <code>Map</code>.</li> <li><code>containsValue()</code>: Comprueba si un valor est\u00e1 presente en el <code>Map</code>.</li> <li><code>keys</code>: Obtiene las claves del <code>Map</code>.</li> <li><code>values</code>: Obtiene los valores del <code>Map</code>.</li> <li><code>filterKeys()</code>: Filtra los pares clave-valor del <code>Map</code> por las claves.</li> <li><code>filterValues()</code>: Filtra los pares clave-valor del <code>Map</code> por los valores.</li> </ul> <p>Los <code>Map</code> en Kotlin son una forma eficiente de almacenar y acceder a datos asociados a claves. Puedes utilizar <code>Map</code> para representar relaciones entre objetos y realizar operaciones comunes con ellos de forma sencilla y eficiente.</p> <p>Para m\u00e1s informaci\u00f3n sobre los <code>Map</code> en Kotlin, puedes consultar la documentaci\u00f3n oficial de Kotlin sobre Maps.`;</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html","title":"Sets","text":""},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-en-kotlin","title":"Sets en Kotlin","text":"<p>En Kotlin, un <code>Set</code> es una colecci\u00f3n de elementos \u00fanicos, lo que significa que no puede contener elementos duplicados. Los <code>Set</code> en Kotlin son inmutables por defecto, lo que significa que no puedes modificar su tama\u00f1o una vez que se han creado.</p> <pre><code>val numeros = setOf(1, 2, 3, 4, 5)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code>. Los <code>Set</code> en Kotlin se crean utilizando la funci\u00f3n <code>setOf()</code> seguida de los valores del <code>Set</code> entre par\u00e9ntesis.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#acceso-a-elementos-de-un-set","title":"Acceso a elementos de un Set","text":"<p>Puedes acceder a elementos individuales de un <code>Set</code> utilizando la funci\u00f3n <code>contains()</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>.</p> <pre><code>val contieneTres = numeros.contains(3)\nval contieneSeis = numeros.contains(6)\n</code></pre> <p>En el ejemplo anterior, se comprueba si el <code>Set</code> <code>numeros</code> contiene los elementos <code>3</code> y <code>6</code> utilizando la funci\u00f3n <code>contains()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#iteracion-sobre-un-set","title":"Iteraci\u00f3n sobre un Set","text":"<p>Puedes iterar sobre los elementos de un <code>Set</code> utilizando un bucle <code>for</code> o la funci\u00f3n <code>forEach()</code>.</p> <pre><code>for (numero in numeros) {\n    println(numero)\n}\n\nnumeros.forEach { numero -&gt;\n    println(numero)\n}\n</code></pre> <p>En el ejemplo anterior, se itera sobre los elementos del <code>Set</code> <code>numeros</code> utilizando un bucle <code>for</code> y la funci\u00f3n <code>forEach()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#sets-de-tipos-primitivos","title":"Sets de tipos primitivos","text":"<p>En Kotlin, puedes utilizar <code>Set</code> de tipos primitivos como <code>IntSet</code>, <code>DoubleSet</code>, <code>BooleanSet</code>, etc. para mejorar el rendimiento de tu c\u00f3digo.</p> <pre><code>val enteros = intSetOf(1, 2, 3, 4, 5)\nval dobles = doubleSetOf(1.0, 2.0, 3.0, 4.0, 5.0)\nval booleanos = booleanSetOf(true, false, true, false)\n</code></pre> <p>En el ejemplo anterior, se crean <code>Set</code> de tipos primitivos <code>IntSet</code>, <code>DoubleSet</code> y <code>BooleanSet</code> con valores iniciales.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#modificacion-de-elementos-de-un-set","title":"Modificaci\u00f3n de elementos de un Set","text":"<p>Los <code>Set</code> en Kotlin son inmutables por defecto, por lo que no puedes modificar los elementos de un <code>Set</code> una vez que se ha creado. Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code>.</p> <pre><code>val numeros = mutableSetOf(1, 2, 3, 4, 5)\nnumeros.add(6)\n</code></pre> <p>En el ejemplo anterior, se crea un <code>Set</code> mutable <code>numeros</code> con los valores <code>1, 2, 3, 4, 5</code> y se a\u00f1ade el valor <code>6</code> al <code>Set</code> utilizando la funci\u00f3n <code>add()</code>.</p>"},{"location":"temas/00-android/00-kotlin/44-sets.html#operaciones-con-sets","title":"Operaciones con Sets","text":"<p>Los <code>Set</code> en Kotlin proporcionan una serie de operaciones \u00fatiles, como <code>size</code> para obtener el tama\u00f1o del <code>Set</code>, <code>contains</code> para comprobar si un elemento est\u00e1 presente en el <code>Set</code>, <code>union</code> para unir dos <code>Set</code>, <code>intersect</code> para obtener la intersecci\u00f3n de dos <code>Set</code>, etc.</p> <pre><code>val numerosPares = setOf(2, 4, 6, 8, 10)\nval numerosImpares = setOf(1, 3, 5, 7, 9)\n\nval union = numeros.union(numerosPares)\nval interseccion = numeros.intersect(numerosImpares)\nval diferencia = numeros.subtract(numerosPares)\nval diferenciaSimetrica = numeros.symmetricDifference(numerosPares)\nval contieneTodos = numeros.containsAll(numerosPares)\nval contieneAlguno = numeros.containsAny(numerosPares)\nval esSubconjunto = numeros.isSubset(numerosPares)\nval esSuperconjunto = numeros.isSuperset(numerosPares)\nval esDisjunto = numeros.isDisjoint(numerosPares)\nval esVacio = numeros.isEmpty()\n</code></pre> <p>En el ejemplo anterior, se utilizan las operaciones <code>union()</code> e <code>intersect()</code> para realizar operaciones comunes con los <code>Set</code> <code>numeros</code>, <code>numerosPares</code> y <code>numerosImpares</code>.</p> <p>Estas operaciones sirven para lo siguiente:</p> <ul> <li><code>union()</code>: Devuelve un <code>Set</code> que contiene todos los elementos de los dos <code>Set</code>.</li> <li><code>intersect()</code>: Devuelve un <code>Set</code> que contiene los elementos comunes de los dos <code>Set</code>.</li> <li><code>subtract()</code>: Devuelve un <code>Set</code> que contiene los elementos del primer <code>Set</code> que no est\u00e1n en el segundo <code>Set</code>.</li> <li><code>symmetricDifference()</code>: Devuelve un <code>Set</code> que contiene los elementos que est\u00e1n en uno de los <code>Set</code> pero no en ambos.</li> <li><code>containsAll()</code>: Comprueba si un <code>Set</code> contiene todos los elementos de otro <code>Set</code>.</li> <li><code>containsAny()</code>: Comprueba si un <code>Set</code> contiene al menos un elemento de otro <code>Set</code>.</li> <li><code>isSubset()</code>: Comprueba si un <code>Set</code> es un subconjunto de otro <code>Set</code>.</li> <li><code>isSuperset()</code>: Comprueba si un <code>Set</code> es un superconjunto de otro <code>Set</code>.</li> <li><code>isDisjoint()</code>: Comprueba si dos <code>Set</code> son disjuntos, es decir, si no tienen elementos en com\u00fan.</li> <li><code>isEmpty()</code>: Comprueba si un <code>Set</code> est\u00e1 vac\u00edo.</li> </ul> <p>Los <code>Set</code> en Kotlin son una forma eficiente de almacenar y manipular colecciones de elementos \u00fanicos. Puedes utilizar las operaciones proporcionadas por los <code>Set</code> para realizar operaciones comunes, como unir, intersecar, restar y comparar <code>Set</code> entre s\u00ed.</p> <p>Si necesitas un <code>Set</code> mutable, puedes utilizar la funci\u00f3n <code>mutableSetOf()</code> para crear un <code>Set</code> que puedas modificar. Los <code>Set</code> en Kotlin son una herramienta poderosa que te permite trabajar con colecciones de elementos \u00fanicos de forma eficiente y concisa.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html","title":"Corrutinas en Kotlin","text":""},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#corrutinas-en-kotlin","title":"Corrutinas en Kotlin","text":"<p>Las corrutinas son una caracter\u00edstica de Kotlin que permite escribir c\u00f3digo as\u00edncrono de manera m\u00e1s sencilla y legible. Las corrutinas son funciones que pueden suspenderse y reanudarse en un punto determinado, lo que permite realizar operaciones as\u00edncronas sin bloquear el hilo principal.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-sincrono","title":"C\u00f3digo s\u00edncrono","text":"<p>El c\u00f3digo s\u00edncrono es el c\u00f3digo que se ejecuta de manera secuencial, es decir, una instrucci\u00f3n se ejecuta despu\u00e9s de que la anterior haya terminado. En Kotlin, el c\u00f3digo s\u00edncrono se ejecuta en el hilo principal de la aplicaci\u00f3n.    </p> <pre><code>fun main() {\n    val resultado = obtenerDatos()\n    println(\"Datos: $resultado\")\n}\nfun obtenerDatos(): String {\n    Thread.sleep(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n s\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> llama a la funci\u00f3n <code>obtenerDatos</code> y espera a que se complete antes de imprimir los datos obtenidos.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#codigo-asincrono","title":"C\u00f3digo as\u00edncrono","text":"<p>El c\u00f3digo as\u00edncrono es el c\u00f3digo que se ejecuta de manera concurrente, es decir, varias instrucciones se pueden ejecutar al mismo tiempo. En Kotlin, el c\u00f3digo as\u00edncrono se puede escribir utilizando corrutinas.    </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#los-metodos-launch-y-async","title":"Los m\u00e9todos launch y async","text":"<p>En Kotlin, las funciones <code>launch</code> y <code>async</code> se utilizan para crear corrutinas. </p> <p>La principal diferencia entre ellas es que <code>launch</code> se utiliza para ejecutar una corrutina que no devuelve un valor, mientras que <code>async</code> se utiliza para ejecutar una corrutina que devuelve un valor.  </p> <pre><code>suspend fun main() {\n    val resultado = async { obtenerDatos() }\n    println(\"Datos: ${resultado.await()}\")\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    return \"Datos obtenidos\"\n}\n\nsuspend fun main() {\n    launch { obtenerDatos() }\n    println(\"Datos obtenidos\")\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>async</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera a que se complete utilizando la funci\u00f3n <code>await</code>. En el segundo ejemplo, se utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina sin esperar a que se complete.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#excepciones","title":"Excepciones","text":"<p>En Kotlin, las corrutinas pueden lanzar excepciones que se pueden manejar utilizando bloques <code>try-catch</code>. Las excepciones lanzadas en una corrutina se propagan a la corrutina padre y se pueden manejar en el hilo principal.  </p> <pre><code>suspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}\n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse y lanza una excepci\u00f3n. La funci\u00f3n <code>main</code> utiliza un bloque <code>try-catch</code> para manejar la excepci\u00f3n lanzada en la corrutina.</p> <ul> <li>Documentaci\u00f3n oficial de Kotlin: La documentaci\u00f3n oficial de Kotlin sobre corrutinas, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar corrutinas en Kotlin.</li> </ul> <p>La importancia de controlar las excepciones al usar corrutinas</p> <p>Cuando se utilizan corrutinas en Kotlin, es importante controlar las excepciones que se pueden producir durante la ejecuci\u00f3n de la aplicaci\u00f3n. Las excepciones no controladas pueden provocar fallos en la aplicaci\u00f3n y afectar negativamente la experiencia del usuario.   </p> <p>Por lo tanto, es importante utilizar bloques <code>try-catch</code> para manejar las excepciones que se pueden producir en las corrutinas. Adem\u00e1s, es recomendable utilizar la funci\u00f3n <code>CoroutineExceptionHandler</code> para manejar las excepciones que se producen en las corrutinas de manera global.</p> <pre><code>val exceptionHandler = CoroutineExceptionHandler { _, exception -&gt;\n    println(\"Error: ${exception.message}\")\n}\n\nsuspend fun main() {\n    try {\n        val resultado = async { obtenerDatos() }\n        println(\"Datos: ${resultado.await()}\")\n    } catch (e: Exception) {\n        println(\"Error: ${e.message}\")\n    }\n}   \n\nsuspend fun obtenerDatos(): String {\n    delay(1000)\n    throw Exception(\"Error al obtener los datos\")\n    return \"Datos obtenidos\"\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#cancelacion","title":"Cancelaci\u00f3n","text":"<p>En Kotlin, las corrutinas se pueden cancelar utilizando la funci\u00f3n <code>cancel()</code>. La cancelaci\u00f3n de una corrutina no detiene inmediatamente su ejecuci\u00f3n, sino que la marca como cancelada y permite que se complete de manera segura. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        try {\n            obtenerDatos()\n        } catch (e: CancellationException) {\n            println(\"Corrutina cancelada\")\n        }\n    }\n    delay(500)\n    job.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. Si la corrutina es cancelada, se lanza una excepci\u00f3n <code>CancellationException</code> que se puede manejar en el bloque <code>try-catch</code>.   </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#la-clase-job","title":"La clase Job","text":"<p>En Kotlin, la clase <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un <code>Job</code> representa una unidad de trabajo que se puede cancelar y supervisar. </p> <pre><code>suspend fun main() {\n    val job = launch {\n        obtenerDatos()\n    }\n    delay(500)\n    job.cancel()\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>launch</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en una corrutina y espera 500 milisegundos antes de cancelar la corrutina utilizando la funci\u00f3n <code>cancel()</code>. </p> <p>El objeto <code>Job</code> se utiliza para gestionar la ejecuci\u00f3n de la corrutina y se puede utilizar para supervisar su estado. </p> <p>La importancia de Job</p> <p>Job desempe\u00f1a un papel importante para garantizar la simultaneidad estructurada, ya que administra el ciclo de vida de las corrutinas y mantiene la relaci\u00f3n de superior y secundario.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#jerarquia-de-trabajos","title":"Jerarqu\u00eda de trabajos","text":"<p>En Kotlin, la jerarqu\u00eda de trabajos se utiliza para gestionar la ejecuci\u00f3n de corrutinas. Un trabajo (Job) representa una unidad de trabajo que se puede cancelar y supervisar. Los trabajos se pueden organizar en una jerarqu\u00eda para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente. </p> <pre><code>suspend fun main() {\n    val parentJob = Job()\n    val childJob1 = Job(parentJob)\n    val childJob2 = Job(parentJob)\n\n    launch(childJob1) {\n        obtenerDatos()\n    }\n    launch(childJob2) {\n        obtenerDatos()\n    }\n\n    delay(500)\n    parentJob.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> crea un trabajo padre y dos trabajos secundarios que se ejecutan en paralelo. Despu\u00e9s de 500 milisegundos, se cancela el trabajo padre utilizando la funci\u00f3n <code>cancel()</code>, lo que cancela todos los trabajos secundarios.</p> <p></p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinescope","title":"CoroutineScope","text":"<p>En Kotlin, el <code>CoroutineScope</code> es una interfaz que define un \u00e1mbito para las corrutinas. </p> <p>Un <code>CoroutineScope</code> se utiliza para crear y gestionar corrutinas en una aplicaci\u00f3n. </p> <pre><code>class MyCoroutineScope : CoroutineScope {\n    private val job = Job()\n    override val coroutineContext: CoroutineContext\n        get() = Dispatchers.Main + job\n\n    fun cancel() {\n        job.cancel()\n    }\nsuspend fun main() {\n    val scope = MyCoroutineScope()\n    scope.launch {\n        obtenerDatos()\n    }\n    delay(500)\n    scope.cancel()\n}\n\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n\n}\n</code></pre> <p>En el ejemplo anterior, se define una clase <code>MyCoroutineScope</code> que implementa la interfaz <code>CoroutineScope</code>. La clase <code>MyCoroutineScope</code> define un \u00e1mbito para las corrutinas utilizando la propiedad <code>coroutineContext</code>, que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>. La clase tambi\u00e9n incluye una funci\u00f3n <code>cancel()</code> que cancela todas las corrutinas en el \u00e1mbito. En la funci\u00f3n <code>main</code>, se crea una instancia de <code>MyCoroutineScope</code> y se utiliza para ejecutar una corrutina que llama a la funci\u00f3n <code>obtenerDatos</code>. Despu\u00e9s de 500 milisegundos, se cancela el \u00e1mbito utilizando la funci\u00f3n <code>cancel()</code>.  </p> <p>launch y async en CoroutineScope</p> <p>launch() y async() son funciones de extension de la interfaz <code>CoroutineScope</code> que se utilizan para crear corrutinas en un \u00e1mbito determinado. La funci\u00f3n <code>launch()</code> se utiliza para crear una corrutina que no devuelve un valor, mientras que la funci\u00f3n <code>async()</code> se utiliza para crear una corrutina que devuelve un valor. Ambas funciones se pueden utilizar en un \u00e1mbito de <code>CoroutineScope</code> para gestionar la ejecuci\u00f3n de corrutinas de manera m\u00e1s eficiente.</p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinecontext","title":"CoroutineContext","text":"<p>En Kotlin, el <code>CoroutineContext</code> es una interfaz que define el contexto en el que se ejecuta una corrutina. </p> <p>Un <code>CoroutineContext</code> se utiliza para definir el despachador, la supervisi\u00f3n y otros elementos del contexto de una corrutina. </p> <p>Es en esencia un mapa que almacena pares clave-valor que se utilizan para definir el contexto de una corrutina. </p> <p>Estos campos no son obligatorios pero algunos de los m\u00e1s comunes son: - <code>Job</code>: Un objeto que representa una unidad de trabajo que se puede cancelar y supervisar. - <code>CoroutineName</code>: Un objeto que representa el nombre de una corrutina. - <code>CoroutineExceptionHandler</code>: Un objeto que maneja las excepciones que se producen en una corrutina.  - <code>Dispatcher</code>: Un objeto que define en qu\u00e9 hilo o grupo de hilos se ejecuta la corrutina. </p> <pre><code>suspend fun main() {\n    val context = Dispatchers.Main + Job()\n    withContext(context) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que combina el despachador <code>Dispatchers.Main</code> y un objeto <code>Job</code>.  </p>"},{"location":"temas/00-android/00-kotlin/51-corrutinas.html#coroutinedispatcher","title":"CoroutineDispatcher","text":"<p>En Kotlin, el <code>CoroutineDispatcher</code> es una interfaz que define el despachador de una corrutina. </p> <p>Un <code>CoroutineDispatcher</code> se utiliza para definir en qu\u00e9 hilo o grupo de hilos se ejecuta una corrutina. </p> <p>Puede utilizar los despachadores predefinidos de Kotlin, como <code>Dispatchers.Main</code>, <code>Dispatchers.IO</code> y <code>Dispatchers.Default</code>, o crear un despachador personalizado.</p> <p>Para crear uno personalizado se puede utilizar la clase <code>ExecutorCoroutineDispatcher</code> de Kotlin. </p> <pre><code>suspend fun main() {\n    val dispatcher = Dispatchers.IO\n    withContext(dispatcher) {\n        obtenerDatos()\n    }\n}\nsuspend fun obtenerDatos() {\n    delay(1000)\n    println(\"Datos obtenidos\")\n}\n</code></pre> <p>En el ejemplo anterior, se define una funci\u00f3n <code>obtenerDatos</code> que simula una operaci\u00f3n as\u00edncrona que tarda 1 segundo en completarse. La funci\u00f3n <code>main</code> utiliza la funci\u00f3n <code>withContext</code> para ejecutar la funci\u00f3n <code>obtenerDatos</code> en un contexto que utiliza el despachador <code>Dispatchers.IO</code>.  </p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html","title":"Corrutinas","text":""},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#corrutinas-en-kotlin","title":"Corrutinas en Kotlin","text":"<p>Si alguna vez has sentido que las corrutinas son complicadas, \u00a1no te preocupes! En realidad, son una herramienta fant\u00e1stica para hacer varias cosas a la vez sin que tu aplicaci\u00f3n se congele.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#1-que-es-una-corrutina-la-analogia-del-camarero","title":"1. \u00bfQu\u00e9 es una Corrutina? (La Analog\u00eda del Camarero)","text":"<p>Imagina un restaurante. - El Hilo Principal (Main Thread) es el \u00daNICO camarero que atiende las mesas. - Las Tareas son los pedidos de los clientes.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#sin-corrutinas-bloqueo","title":"Sin Corrutinas (Bloqueo)","text":"<p>Si un cliente pide un caf\u00e9 y el camarero se va a la cocina, se queda all\u00ed parado mirando la cafetera hasta que el caf\u00e9 est\u00e1 listo (5 minutos). Durante esos 5 minutos, nadie m\u00e1s es atendido. Los nuevos clientes se enfadan (la app se congela y sale el aviso de \"La aplicaci\u00f3n no responde\").</p> Pseudoc\u00f3digo Bloqueante (Malo)<pre><code>fun main() {\n    atenderMesa1() // Llega cliente mesa 1\n    // ... esperando ...\n    // \u00a1EL CAMARERO SE QUEDA PARADO EN LA COCINA! (Bloqueo)\n    // ... esperando ...\n    // Mesa 2 intenta llamar al camarero pero nadie responde (ANR)\n    servirMesa1()\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#con-corrutinas-no-bloqueo","title":"Con Corrutinas (No bloqueo)","text":"<p>El camarero toma el pedido del caf\u00e9, lo pasa a la cocina (lanza una corrutina) y vuelve inmediatamente a atender a otras mesas. Cuando la cocina avisa \"\u00a1Caf\u00e9 listo!\", el camarero lo recoge y lo sirve. \u00a1El camarero siempre est\u00e1 disponible!</p> Pseudoc\u00f3digo con Corrutinas (Bueno)<pre><code>fun main() {\n    launch { // \"Lanzamos\" la tarea en segundo plano\n        tomarPedidoMesa1()\n        suspend esperarCocina() // \u00a1PAUSA! El camarero se va a hacer otras cosas\n        // ... (5 minutos despu\u00e9s) ...\n        // La cocina avisa, el camarero vuelve y retoma aqu\u00ed\n        servirMesa1()\n    }\n\n    atenderMesa2() // \u00a1El camarero puede atender a la mesa 2 inmediatamente!\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#2-corrutinas-vs-hilos-threads","title":"2. Corrutinas vs Hilos (Threads)","text":"<p>A veces se confunden, pero hay una gran diferencia: el peso.</p> <ul> <li>Hilos (Threads): Son pesados. Cada hilo consume mucha memoria RAM del sistema. Crear uno nuevo es costoso. Si intentas crear 100.000 hilos, tu ordenador probablemente colapsar\u00e1 (Out of Memory).</li> <li>Corrutinas: Son lig\u00e9risimas. Puedes crear 100.000 corrutinas y a tu ordenador ni le importar\u00e1. Son como \"hilos virtuales\" que viven dentro de los hilos reales.</li> </ul> <p>Resumen: Las corrutinas son mucho m\u00e1s eficientes y baratas que los hilos tradicionales.</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#3-funciones-de-suspension-suspend-fun","title":"3. Funciones de suspensi\u00f3n (<code>suspend fun</code>)","text":"<p>Una funci\u00f3n <code>suspend</code> es una funci\u00f3n con un superpoder: puede pausarse y reanudarse.</p> <p>Cuando llamas a una funci\u00f3n <code>suspend</code> (como <code>delay(1000)</code> o una petici\u00f3n a internet), la corrutina se \"pausa\" sin bloquear al hilo principal. El hilo queda libre para hacer otras cosas (pintar la pantalla, responder a clics). Cuando la operaci\u00f3n termina, la corrutina se \"despierta\" y contin\u00faa donde se qued\u00f3.</p> <pre><code>suspend fun pedirDatosAInternet(): String {\n    delay(2000) // Simula espera de 2 segundos. \u00a1No bloquea el hilo!\n    return \"Datos recibidos\"\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#4-builders-como-arranco-una-corrutina","title":"4. Builders: \u00bfC\u00f3mo arranco una corrutina?","text":"<p>Hay dos formas principales de iniciar una corrutina:</p>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#a-launch-lanzar-y-olvidar","title":"A. <code>launch</code>: \"Lanzar y olvidar\"","text":"<p>Lo usas cuando quieres hacer algo y no necesitas que te devuelva un dato directamente (o el resultado no afecta al flujo inmediato). Ejemplos: Escribir un log en un archivo, mandar una anal\u00edtica, guardar una preferencia.</p> <pre><code>scope.launch {\n    guardarEnBaseDeDatos(usuario)\n    println(\"Usuario guardado\")\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#b-async-pedir-y-esperar-resultado","title":"B. <code>async</code>: \"Pedir y esperar resultado\"","text":"<p>Lo usas cuando necesitas un valor de vuelta. <code>async</code> devuelve un <code>Deferred</code> (una promesa de que tendr\u00e1s un dato en el futuro). Usas <code>.await()</code> para obtener ese dato.</p> <pre><code>scope.launch {\n    // Pedimos dos cosas a la vez (paralelo)\n    val climaDeferred = async { obtenerClima() }\n    val noticiasDeferred = async { obtenerNoticias() }\n\n    // Esperamos a tener ambos\n    val clima = climaDeferred.await()\n    val noticias = noticiasDeferred.await()\n\n    mostrarEnPantalla(clima, noticias)\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#5-dispatchers-donde-se-ejecuta-el-trabajo","title":"5. Dispatchers: \u00bfD\u00d3NDE se ejecuta el trabajo?","text":"<p>Es crucial elegir el <code>Dispatcher</code> (Despachador) correcto para no congelar la app. Imagina que son \"carriles\" o \"departamentos\".</p> Dispatcher Uso Correcto Ejemplo Dispatchers.Main Interfaz de Usuario (UI). Solo operaciones r\u00e1pidas y ligeras. Actualizar un TextView, mostrar un Toast, animaciones. Dispatchers.IO Entrada/Salida (Input/Output). Operaciones largas que esperan datos. Leer/Escribir archivos, Bases de Datos (Room), Peticiones de Red (Retrofit). Dispatchers.Default Procesamiento CPU. Operaciones complejas de c\u00e1lculo. Procesar una imagen grande, ordenar una lista gigante, calcular algoritmos complejos. <p>Ejemplo de cambio de contexto (<code>withContext</code>):</p> <pre><code>scope.launch(Dispatchers.Main) { // 1. Empezamos en el Hilo Principal (UI)\n    mostrarCargando() \n\n    val datos = withContext(Dispatchers.IO) { // 2. Nos mudamos al hilo IO para lo pesado\n        descargarDatosDeInternet() // Esto tarda, pero no bloquea la UI\n    }\n\n    ocultarCargando() // 3. Volvemos autom\u00e1ticamente al Main\n    mostrarDatos(datos)\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#6-scopes-el-ciclo-de-vida","title":"6. Scopes: El ciclo de vida","text":"<p>Las corrutinas necesitan un \"due\u00f1o\" o un \u00e1mbito (<code>Scope</code>) para vivir. Si el due\u00f1o muere, las corrutinas deben cancelarse para no dejar basura memoria (\"zombies\").</p> <p>En Android, usamos los que ya nos dan hechos:</p> <ul> <li><code>lifecycleScope</code> (en Activities/Fragments): Las corrutinas mueren cuando se destruye la Activity/Fragment.</li> <li><code>viewModelScope</code> (en ViewModels): Las corrutinas mueren cuando se limpia el ViewModel. (El m\u00e1s usado).</li> </ul>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#7-ejemplos-realistas","title":"7. Ejemplos Realistas","text":""},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#caso-a-login-de-usuario-viewmodel","title":"Caso A: Login de Usuario (ViewModel)","text":"<pre><code>class LoginViewModel : ViewModel() {\n\n    fun realizarLogin(user: String, pass: String) {\n        // Usamos viewModelScope. Se ejecuta en Main por defecto\n        viewModelScope.launch {\n            try {\n                mostrarSpinner(true) // UI (Main)\n\n                // Nos vamos a IO para la red\n                val resultado = withContext(Dispatchers.IO) {\n                    apiService.login(user, pass)\n                }\n\n                // Volvemos a Main\n                if (resultado.isExitoso) {\n                    navegarAHome()\n                } else {\n                    mostrarError(\"Login incorrecto\")\n                }\n\n            } catch (e: Exception) {\n                mostrarError(\"Error de red: ${e.message}\")\n            } finally {\n                mostrarSpinner(false) // UI (Main)\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#caso-b-cargar-datos-de-base-de-datos-room","title":"Caso B: Cargar datos de Base de Datos (Room)","text":"<pre><code>// En un repositorio o ViewModel\nfun cargarNotas() {\n    viewModelScope.launch(Dispatchers.IO) { // Empezamos directo en IO\n        val notas = database.notaDao().getAll()\n\n        // Si necesitamos pintar esto, cambiamos a Main\n        withContext(Dispatchers.Main) {\n            adapter.setNotas(notas)\n        }\n    }\n}\n</code></pre>"},{"location":"temas/00-android/00-kotlin/52-corrutinas-sencillo.html#resumen-rapido","title":"Resumen R\u00e1pido","text":"<ol> <li><code>suspend</code>: Pausa sin bloquear.</li> <li><code>Main</code>: Para pintar (UI).</li> <li><code>IO</code>: Para esperar (Red/DB).</li> <li><code>Default</code>: Para pensar (C\u00e1lculos CPU).</li> <li><code>viewModelScope</code>: Tu mejor amigo en Android para lanzar corrutinas.</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html","title":"Gradle","text":""},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#gradle-agp-y-estructura-de-proyecto-en-android","title":"Gradle, AGP y Estructura de Proyecto en Android","text":"<p>Como desarrollador Android moderno, entender Gradle y la estructura de tu proyecto es tan importante como saber Kotlin. No es solo \"magia\" que hace que el bot\u00f3n de Play funcione; es el motor que compila, prueba y empaqueta tu aplicaci\u00f3n.</p> <p>En este documento, desmitificaremos estos conceptos y veremos c\u00f3mo se organiza un proyecto profesional hoy en d\u00eda.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#1-que-son-gradle-y-agp","title":"1. \u00bfQu\u00e9 son Gradle y AGP?","text":"<p>A menudo se confunden, pero son cosas distintas que trabajan juntas.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#gradle-el-motor-de-construccion","title":"Gradle: El Motor de Construcci\u00f3n","text":"<p>Gradle es un sistema de automatizaci\u00f3n de compilaci\u00f3n de c\u00f3digo abierto. Es agn\u00f3stico a la plataforma; se usa para Java, C++, Python, etc. Piensa en Gradle como un gestor de tareas muy potente. Sabe c\u00f3mo: - Descargar librer\u00edas de internet. - Compilar c\u00f3digo fuente. - Ejecutar pruebas. - Empaquetar resultados.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#agp-android-gradle-plugin-el-copiloto","title":"AGP (Android Gradle Plugin): El Copiloto","text":"<p>Gradle por s\u00ed solo no sabe qu\u00e9 es un APK o un AndroidManifest. Aqu\u00ed entra el Android Gradle Plugin (AGP). AGP es un plugin que se \"enchufa\" a Gradle y le ense\u00f1a c\u00f3mo construir aplicaciones Android espec\u00edficamente. Le dice a Gradle: \"Hey, estos archivos <code>.xml</code> son recursos y deben procesarse as\u00ed\", o \"Este c\u00f3digo Kotlin debe convertirse en bytecode Dalvik\".</p> <p>Gradle Wrapper</p> <p>En tu proyecto ver\u00e1s archivos <code>gradlew</code> (Linux/Mac) y <code>gradlew.bat</code> (Windows). Este es el Wrapper. Siempre usa el wrapper (<code>./gradlew build</code>) en lugar de instalar Gradle globalmente. Esto garantiza que todo el equipo (y el servidor de integraci\u00f3n continua) use exactamente la misma versi\u00f3n de Gradle definida en <code>gradle/wrapper/gradle-wrapper.properties</code>.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#2-estructura-de-un-proyecto-moderno","title":"2. Estructura de un Proyecto Moderno","text":"<p>Cuando abres Android Studio, por defecto ves la vista \"Android\", que colapsa y organiza los archivos l\u00f3gicamente. Sin embargo, para entender la estructura real, a veces es \u00fatil cambiar a la vista \"Project\".</p> <p>Un proyecto moderno tiene (principalmente) dos niveles de configuraci\u00f3n: Proyecto (Root) y M\u00f3dulo (Module).</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#archivos-de-configuracion-clave","title":"Archivos de Configuraci\u00f3n Clave","text":"Archivo Nivel Prop\u00f3sito <code>settings.gradle.kts</code> Root Define qu\u00e9 m\u00f3dulos componen la app y de d\u00f3nde sacar los plugins. Se ejecuta primero. <code>build.gradle.kts</code> Root Configuraci\u00f3n global para todos los m\u00f3dulos (limpieza, plugins comunes). Suele estar casi vac\u00edo ahora. <code>build.gradle.kts</code> M\u00f3dulo (:app) La configuraci\u00f3n espec\u00edfica de tu app: versiones de SDK, dependencias, firma, etc. <code>libs.versions.toml</code> Gradle Version Catalog. El lugar centralizado para definir versiones y librer\u00edas. <code>local.properties</code> Root Configuraci\u00f3n local de TU m\u00e1quina (ruta del SDK, claves secretas). Nunca se sube a Git."},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#3-gestion-de-dependencias-version-catalogs","title":"3. Gesti\u00f3n de Dependencias: Version Catalogs","text":"<p>Desde hace poco, el est\u00e1ndar recomendado es usar Version Catalogs. En lugar de escribir versiones \"a fuego\" en cada <code>build.gradle.kts</code>, las definimos en un archivo TOML: <code>gradle/libs.versions.toml</code>.</p> <p>Este archivo act\u00faa como un inventario centralizado de todos los \"ingredientes\" (librer\u00edas y plugins) que usa tu app.</p> <p>Estructura de <code>libs.versions.toml</code>: </p><pre><code>[versions]\n# 1. Aqu\u00ed definimos los N\u00daMEROS de las versiones\nkotlin = \"1.9.0\"\ncoreKtx = \"1.10.1\"\nretrofit = \"2.9.0\"\n\n[libraries]\n# 2. Aqu\u00ed definimos las LIBRER\u00cdAS (Ingredientes b\u00e1sicos)\n# Formato: grupo:nombre:versi\u00f3n\n# 'version.ref' apunta a una variable definida arriba en [versions]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\nretrofit-gson = { group = \"com.squareup.retrofit2\", name = \"converter-gson\", version.ref = \"retrofit\" }\n\n[bundles]\n# 3. (Opcional) Aqu\u00ed agrupamos librer\u00edas que siempre van juntas\n# Por ejemplo, para usar Retrofit siempre necesitas el core y un convertidor\nnetworking = [\"retrofit\", \"retrofit-gson\"]\n\n[plugins]\n# 4. Aqu\u00ed definimos los PLUGINS (Herramientas de construcci\u00f3n)\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\n</code></pre><p></p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#ejemplo-practico-como-anado-una-libreria-nueva","title":"Ejemplo Pr\u00e1ctico: \u00bfC\u00f3mo a\u00f1ado una librer\u00eda nueva?","text":"<p>Imagina que quieres a\u00f1adir Coil o Glide para cargar im\u00e1genes desde internet.</p> <p>Paso 1: Buscar la coordenada Maven Buscas en Google \"Coil android library\" y encuentras que la \u00faltima versi\u00f3n es <code>2.4.0</code> y la coordenada es <code>io.coil-kt:coil:2.4.0</code>.</p> <p>Paso 2: A\u00f1adir al cat\u00e1logo (<code>libs.versions.toml</code>) Editas el archivo <code>gradle/libs.versions.toml</code>:</p> <pre><code>[versions]\n...\ncoil = \"2.4.0\" # &lt;--- A\u00f1ades la versi\u00f3n\n\n[libraries]\n...\ncoil = { group = \"io.coil-kt\", name = \"coil\", version.ref = \"coil\" } # &lt;--- Defines la librer\u00eda\n</code></pre> <p>Paso 3: Sincronizar (Sync Gradle)</p> <p>Aparecer\u00e1 una barrita amarilla en Android Studio: \"Sync Now\". P\u00falsala. Esto hace que Gradle lea el nuevo cat\u00e1logo y genere las referencias.</p> <p>Paso 4: Usar en tu m\u00f3dulo (<code>app/build.gradle.kts</code>)</p> <p>Ahora vas a tu archivo de construcci\u00f3n y lo a\u00f1ades. Gracias al cat\u00e1logo, \u00a1tendr\u00e1s autocompletado!</p> <pre><code>dependencies {\n    // ... otras dependencias\n    implementation(libs.coil)\n}\n</code></pre> <p>\u00a1Y listo! Si ma\u00f1ana sale la versi\u00f3n <code>2.5.0</code> de Coil, solo tienes que cambiar el n\u00famero en <code>[versions]</code> del archivo TOML, y se actualizar\u00e1 en todos los m\u00f3dulos que lo usen.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#el-concepto-de-bom-bill-of-materials","title":"El concepto de BOM (Bill of Materials)","text":"<p>En ecosistemas complejos como Jetpack Compose o Firebase, hay muchas librer\u00edas peque\u00f1as (ui, material3, tooling, foundation...) que se actualizan independientemente pero que deben usarse en versiones compatibles entre s\u00ed. Gestionar esto a mano es una pesadilla.</p> <p>Para solucionar esto existe el BOM (Bill of Materials).</p> <p>El BOM es una \"super-librer\u00eda\" vac\u00eda que solo contiene una lista de versiones recomendadas que funcionan bien juntas. Cuando usas un BOM, no indicas la versi\u00f3n de las librer\u00edas individuales; Gradle mira el BOM para saber qu\u00e9 versi\u00f3n usar.</p> <p>Ejemplo con Compose:</p> <ol> <li>En <code>libs.versions.toml</code> defines el BOM con versi\u00f3n, y las librer\u00edas sin versi\u00f3n.</li> </ol> <pre><code>[versions]\ncomposeBom = \"2023.08.00\"\n\n[libraries]\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\n\n# F\u00edjate que aqu\u00ed NO hay 'version.ref'\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n</code></pre> <ol> <li>En <code>build.gradle.kts</code> importas el BOM como <code>platform</code> y luego las librer\u00edas.</li> </ol> <pre><code>dependencies {\n    // Importamos la PLATAFORMA (el BOM)\n    implementation(platform(libs.androidx.compose.bom))\n\n    // Importamos las librer\u00edas sin preocuparnos de la versi\u00f3n\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.material3)\n}\n</code></pre> <p>Esto garantiza que si actualizas el BOM a <code>2023.10.00</code>, todas las librer\u00edas de Compose se actualizar\u00e1n autom\u00e1ticamente a las versiones probadas y compatibles de esa release.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#que-librerias-funcionan-con-bom","title":"\u00bfQu\u00e9 librer\u00edas funcionan con BOM?","text":"<p>No todas las librer\u00edas tienen BOM.</p> <p>El BOM se usa principalmente en ecosistemas grandes donde hay m\u00faltiples m\u00f3dulos que deben coordinarse.</p> <ul> <li> <p>S\u00cd suelen tener BOM:</p> <ul> <li>Jetpack Compose: (<code>androidx.compose:compose-bom</code>) Porque tiene ui, foundation, material, animation, etc.</li> <li>Firebase: (<code>com.google.firebase:firebase-bom</code>) Porque tiene auth, firestore, analytics, crashlytics, etc.</li> <li>OkHttp / Retrofit: A veces ofrecen BOM para gestionar sus familias de dependencias.</li> <li>AWS Amplify: Otro ecosistema gigante.</li> </ul> </li> <li> <p>NO suelen tener BOM:</p> <ul> <li>Librer\u00edas individuales como Glide, Coil, Lottie, Room (aunque es parte de Jetpack, suele versionarse sola o seguir el ciclo de core).</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#como-se-si-una-libreria-tiene-bom","title":"\u00bfC\u00f3mo s\u00e9 si una librer\u00eda tiene BOM?","text":"<p>No hay una \"regla m\u00e1gica\", pero aqu\u00ed tienes 3 formas de saberlo:</p> <ol> <li>Documentaci\u00f3n Oficial (La mejor): Cuando vas a la p\u00e1gina de \"Setup\" o \"Install\" de Compose o Firebase, lo primero que te recomiendan es usar el BOM. Si la documentaci\u00f3n te da directamente la l\u00ednea <code>implementation(\"com.example:lib:1.0.0\")</code>, es que probablemente no tenga BOM.</li> <li>Maven Repository: Si buscas la librer\u00eda en Maven Central, a veces ver\u00e1s un artefacto que termina en <code>-bom</code> (ej. <code>compose-bom</code>).</li> <li>El sentido com\u00fan: Si la librer\u00eda es \"una sola cosa\" (ej. un calendario), no necesita BOM. Si es una \"plataforma\" (ej. Firebase), seguramente lo tenga.</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#resumen-mezclando-todo-en-un-mismo-proyecto","title":"Resumen: Mezclando todo en un mismo proyecto","text":"<p>En un proyecto real, siempre tendr\u00e1s una mezcla de ambas cosas. No hay conflicto, simplemente se declaran diferente en el cat\u00e1logo y se importan diferente en el <code>build.gradle.kts</code>.</p> <p>Escenario Real: Una app que usa Jetpack Compose (BOM), Firebase (BOM) y Retrofit (Normal/Sin BOM).</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#1-libsversionstoml","title":"1. <code>libs.versions.toml</code>","text":"<pre><code>[versions]\n# --- Versiones para BOMs ---\ncomposeBom = \"2023.08.00\"\nfirebaseBom = \"32.2.0\"\n\n# --- Versiones para Librer\u00edas Normales ---\nretrofit = \"2.9.0\"\ncoil = \"2.4.0\"\n\n[libraries]\n# --- BOMs ---\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nfirebase-bom = { group = \"com.google.firebase\", name = \"firebase-bom\", version.ref = \"firebaseBom\" }\n\n# --- Librer\u00edas DENTRO del BOM (SIN versi\u00f3n) ---\nandroidx-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\nfirebase-analytics = { group = \"com.google.firebase\", name = \"firebase-analytics\" }\n\n# --- Librer\u00edas NORMALES (CON versi\u00f3n) ---\nretrofit = { group = \"com.squareup.retrofit2\", name = \"retrofit\", version.ref = \"retrofit\" }\ncoil = { group = \"io.coil-kt\", name = \"coil\", version.ref = \"coil\" }\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#2-appbuildgradlekts","title":"2. <code>app/build.gradle.kts</code>","text":"<pre><code>dependencies {\n    // 1. Importamos las Plataformas (BOMs)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(platform(libs.firebase.bom))\n\n    // 2. Importamos las librer\u00edas del BOM (Sin versi\u00f3n)\n    implementation(libs.androidx.ui)\n    implementation(libs.androidx.material3)\n    implementation(libs.firebase.analytics)\n\n    // 3. Importamos las librer\u00edas Normales (Con versi\u00f3n en el cat\u00e1logo)\n    implementation(libs.retrofit)\n    implementation(libs.coil)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#4-proyecto-de-ejemplo-mysimpleapp","title":"4. Proyecto de Ejemplo: \"MySimpleApp\"","text":"<p>Vamos a diseccionar un proyecto real pero sencillo para ver c\u00f3mo encajan todas las piezas. Imagina una app simple con una sola pantalla.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#41-settingsgradlekts-la-entrada","title":"4.1. <code>settings.gradle.kts</code> (La entrada)","text":"<p>Este archivo le dice a Gradle c\u00f3mo arrancar.</p> <pre><code>pluginManagement {\n    repositories {\n        google()\n        mavenCentral()\n        gradlePluginPortal()\n    }\n}\ndependencyResolutionManagement {\n    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n    repositories {\n        google()\n        mavenCentral()\n    }\n}\n\nrootProject.name = \"MySimpleApp\"\n\ninclude(\":app\") // &lt;--- Aqu\u00ed decimos: \"Este proyecto tiene un m\u00f3dulo llamado 'app'\"\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#42-gradlelibsversionstoml-el-catalogo","title":"4.2. <code>gradle/libs.versions.toml</code> (El cat\u00e1logo)","text":"<p>Aqu\u00ed definimos nuestros ingredientes.</p> <pre><code>[versions]\nagp = \"8.1.1\"\nkotlin = \"1.9.0\"\ncoreKtx = \"1.10.1\"\nappcompat = \"1.6.1\"\nmaterial = \"1.9.0\"\nconstraintlayout = \"2.1.4\"\njunit = \"4.13.2\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nandroidx-appcompat = { group = \"androidx.appcompat\", name = \"appcompat\", version.ref = \"appcompat\" }\nmaterial = { group = \"com.google.android.material\", name = \"material\", version.ref = \"material\" }\nandroidx-constraintlayout = { group = \"androidx.constraintlayout\", name = \"constraintlayout\", version.ref = \"constraintlayout\" }\njunit = { group = \"junit\", name = \"junit\", version.ref = \"junit\" }\n\n[plugins]\nandroidApplication = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlinAndroid = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#43-buildgradlekts-nivel-proyecto","title":"4.3. <code>build.gradle.kts</code> (Nivel Proyecto)","text":"<p>Hoy en d\u00eda es muy simple, solo registra los plugins para usarlos en los hijos.</p> <pre><code>// Build script de nivel superior (Top-level)\nplugins {\n    // Usamos 'apply false' porque solo queremos cargar las clases del plugin,\n    // pero no aplicarlas a este proyecto ra\u00edz (se aplicar\u00e1n en 'app').\n    alias(libs.plugins.androidApplication) apply false\n    alias(libs.plugins.kotlinAndroid) apply false\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#44-appbuildgradlekts-nivel-modulo","title":"4.4. <code>app/build.gradle.kts</code> (Nivel M\u00f3dulo)","text":"<p>Aqu\u00ed es donde ocurre la magia de la configuraci\u00f3n de la app.</p> <pre><code>plugins {\n    alias(libs.plugins.androidApplication)\n    alias(libs.plugins.kotlinAndroid)\n}\n\nandroid {\n    namespace = \"com.example.mysimpleapp\"\n    compileSdk = 33 // Versi\u00f3n del SDK usada para compilar (headers, nuevas APIs)\n\n    defaultConfig {\n        applicationId = \"com.example.mysimpleapp\"\n        minSdk = 24 // Versi\u00f3n m\u00ednima de Android donde instalaremos la app (Android 7.0)\n        targetSdk = 33 // Versi\u00f3n para la que hemos probado y dise\u00f1ado la app\n        versionCode = 1\n        versionName = \"1.0\"\n\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(getDefaultProguardFile(\"proguard-android-optimize.txt\"), \"proguard-rules.pro\")\n        }\n    }\n\n    // Necesario para usar caracter\u00edsticas nuevas de Java/Kotlin\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n\ndependencies {\n    // Referenciamos las librer\u00edas usando el cat\u00e1logo (libs)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n    implementation(libs.androidx.constraintlayout)\n\n    // Tests unitarios\n    testImplementation(libs.junit)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#resumen","title":"Resumen","text":"<p>Esta estructura modular y centralizada parece verbosa al principio para un proyecto peque\u00f1o, pero es vital cuando el proyecto crece. Mantener las versiones en un solo lugar (<code>libs.versions.toml</code>) y separar la configuraci\u00f3n del proyecto de la del m\u00f3dulo es la base del desarrollo profesional en Android.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#5-guia-de-supervivencia-conceptos-del-dia-a-dia","title":"5. Gu\u00eda de Supervivencia: Conceptos del D\u00eda a D\u00eda","text":"<p>Para terminar, aqu\u00ed tienes tres conceptos que usar\u00e1s a diario y que suelen confundir al principio.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#51-sync-vs-build-sincronizar-vs-construir","title":"5.1. \"Sync\" vs \"Build\" (Sincronizar vs Construir)","text":"<ul> <li>Sync (Sincronizar): Es r\u00e1pido. Ocurre cuando cambias un archivo <code>.gradle.kts</code> o <code>.toml</code>. Gradle lee la configuraci\u00f3n, descarga librer\u00edas nuevas y actualiza los \u00edndices de Android Studio. No compila tu c\u00f3digo Kotlin.<ul> <li>Cu\u00e1ndo hacerlo: Siempre que toques algo de la configuraci\u00f3n de Gradle. Ver\u00e1s una barrita amarilla o un elefante con flechas azules.</li> </ul> </li> <li>Build (Construir): Es lento. Compila todo tu c\u00f3digo Kotlin, procesa los recursos y genera el APK.<ul> <li>Cu\u00e1ndo hacerlo: Cuando le das al bot\u00f3n de \"Play\" (Run).</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#52-clean-rebuild-el-apagar-y-encender","title":"5.2. Clean &amp; Rebuild (El \"apagar y encender\")","text":"<p>A veces, Android Studio \"se l\u00eda\". Te marca errores en rojo en c\u00f3digo que sabes que est\u00e1 bien, o la app falla de forma rara. *   Build &gt; Clean Project: Borra la carpeta <code>build/</code> (los archivos temporales de compilaci\u00f3n). *   Build &gt; Rebuild Project: Hace un Clean y luego un Build completo desde cero.     *   Truco del experto: Si algo no tiene sentido, haz un <code>Clean Project</code>. Soluciona el 90% de los problemas \"fantasmas\".</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#53-build-variants-debug-vs-release","title":"5.3. Build Variants: Debug vs Release","text":"<p>Por defecto, cuando le das al Play, est\u00e1s instalando la variante Debug. *   Debug:     *   SE PUEDE depurar (breakpoints).     *   No est\u00e1 optimizada (es m\u00e1s lenta).     *   Se firma con una clave de prueba insegura. *   Release:     *   NO se puede depurar (normalmente).     *   Est\u00e1 optimizada y ofuscada (R8/Proguard).     *   Se firma con tu clave real para subirla a Google Play.</p> <p>Puedes cambiar de variante en la pesta\u00f1a Build Variants (normalmente a la izquierda-abajo en Android Studio). \u00a1No intentes subir una build Debug a la Play Store!</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#6-compatibilidad-y-versiones-de-java","title":"6. Compatibilidad y Versiones de Java","text":"<p>Un dolor de cabeza com\u00fan es cuando las versiones no coinciden. Gradle, el Plugin de Android (AGP) y Java tienen una relaci\u00f3n estricta.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#61-la-matriz-de-compatibilidad","title":"6.1. La Matriz de Compatibilidad","text":"<p>No puedes usar cualquier versi\u00f3n de Gradle con cualquier versi\u00f3n de AGP. *   AGP 8.0+ requiere Gradle 8.0+ y Java 17. *   AGP 7.4 requiere Gradle 7.5+ y Java 11.</p> <p>Consejo: Si actualizas Android Studio, a menudo te propondr\u00e1 actualizar el AGP y Gradle autom\u00e1ticamente. Acepta si tu equipo est\u00e1 de acuerdo, pero ten cuidado si saltas muchas versiones de golpe.</p> <p>Puedes consultar la tabla oficial siempre actualizada aqu\u00ed: Android Gradle Plugin version requirements.</p>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#62-que-java-usa-mi-proyecto","title":"6.2. \u00bfQu\u00e9 Java usa mi proyecto?","text":"<p>Hay dos configuraciones de Java que debes distinguir:</p> <ol> <li> <p>Java para compilar tu c\u00f3digo (Target JVM):     Define qu\u00e9 caracter\u00edsticas de Java puede usar tu c\u00f3digo Kotlin/Java y en qu\u00e9 dispositivos funcionar\u00e1.     Se configura en <code>app/build.gradle.kts</code>:     </p><pre><code>android {\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_1_8\n        targetCompatibility = JavaVersion.VERSION_1_8\n    }\n    kotlinOptions {\n        jvmTarget = \"1.8\"\n    }\n}\n</code></pre> Nota: A partir de AGP 8, por defecto suele ser Java 17, aunque muchos proyectos siguen en 1.8 (Java 8) para m\u00e1xima compatibilidad con m\u00f3viles antiguos.<p></p> </li> <li> <p>Java para ejecutar Gradle (Gradle Daemon):     Es la versi\u00f3n de Java que usa tu ordenador para correr el proceso de construcci\u00f3n.</p> <ul> <li>C\u00f3mo cambiarlo:<ol> <li>Ve a <code>File &gt; Settings</code> (o <code>Android Studio &gt; Settings</code> en Mac).</li> <li>Busca <code>Build, Execution, Deployment &gt; Build Tools &gt; Gradle</code>.</li> <li>En Gradle JDK, selecciona la versi\u00f3n. Normalmente deber\u00edas usar la versi\u00f3n \"Embedded\" que trae Android Studio, o asegurarte de que sea al menos Java 17 para proyectos modernos.</li> </ol> </li> </ul> </li> </ol> <p>El aviso de diferentes JDKs</p> <p>A veces Android Studio te mostrar\u00e1 un aviso diciendo que \"Gradle JDK\" y el \"Project JDK\" son diferentes.</p> <p>Esto ocurre porque Android Studio intenta usar el mismo Java para indexar tu c\u00f3digo que Gradle usa para compilarlo. Si son diferentes, se desperdicia memoria (se arrancan dos m\u00e1quinas virtuales Java) y pueden surgir errores extra\u00f1os de resoluci\u00f3n de tipos.</p> <p>Soluci\u00f3n: Intenta que ambos apunten a la misma instalaci\u00f3n.</p> <ol> <li>Gradle JDK: Ve a <code>Settings &gt; Build... &gt; Build Tools &gt; Gradle</code>.</li> <li>Project SDK: Ve a <code>File &gt; Project Structure... &gt; Project Settings &gt; Project</code>.</li> <li>Aseg\u00farate de que el SDK seleccionado en el paso 2 coincide con la versi\u00f3n elegida en el paso 1 (por ejemplo, seleccionando <code>jbr-17</code> o <code>Embedded JDK</code> en ambos sitios).</li> </ol>"},{"location":"temas/00-android/00-tools/01-gradle-agp-estructura.html#63-donde-miro-que-versiones-tengo-instaladas","title":"6.3. \u00bfD\u00f3nde miro qu\u00e9 versiones tengo instaladas?","text":"<p>A veces te preguntar\u00e1n \"\u00bfQu\u00e9 versi\u00f3n de AGP usas?\" y no sabr\u00e1s d\u00f3nde mirar. Aqu\u00ed tienes la \"chuleta\":</p> <ul> <li>Gradle Version:<ul> <li>Mira en <code>gradle/wrapper/gradle-wrapper.properties</code>.</li> <li>Busca la l\u00ednea <code>distributionUrl=.../gradle-8.0-bin.zip</code>. El n\u00famero <code>8.0</code> es tu versi\u00f3n.</li> </ul> </li> <li>AGP Version:<ul> <li>Mira en <code>libs.versions.toml</code> bajo <code>[versions]</code>, la variable <code>agp</code>.</li> <li>O en <code>build.gradle.kts</code> (Project level) en el bloque <code>plugins</code>.</li> </ul> </li> <li>Kotlin Version:<ul> <li>Mira en <code>libs.versions.toml</code> bajo <code>[versions]</code>, la variable <code>kotlin</code>.</li> <li>O en <code>build.gradle.kts</code> (Project level) en el bloque <code>plugins</code>.</li> </ul> </li> </ul> <p>Alternativamente, en Android Studio, puedes ir a File &gt; Project Structure &gt; Project, y all\u00ed ver\u00e1s un resumen gr\u00e1fico con todas estas versiones.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html","title":"Build-gradle","text":""},{"location":"temas/00-android/00-tools/02-build-gradle.html#el-fichero-de-construccion-buildgradlekts","title":"El Fichero de Construcci\u00f3n: <code>build.gradle.kts</code>","text":"<p>En el coraz\u00f3n de la compilaci\u00f3n de tu aplicaci\u00f3n Android se encuentra el fichero <code>build.gradle.kts</code> (o <code>build.gradle</code> si usas Groovy, aunque el est\u00e1ndar moderno es Kotlin DSL).</p> <p>Este fichero define C\u00d3MO se debe construir tu aplicaci\u00f3n: desde qu\u00e9 versi\u00f3n de Android soporta, hasta qu\u00e9 librer\u00edas externas utiliza.</p> <p>Project vs Module</p> <p>Recuerda que existen dos niveles de <code>build.gradle</code>:</p> <ol> <li>Project-level (<code>build.gradle.kts</code> ra\u00edz): Define configuraci\u00f3n global para todos los m\u00f3dulos (normalmente solo plugins comunes).</li> <li>Module-level (<code>app/build.gradle.kts</code>): Es donde pasar\u00e1s el 99% del tiempo. Define la configuraci\u00f3n espec\u00edfica de tu app (o m\u00f3dulo). Nos centraremos en este.</li> </ol>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#estructura-anatomica","title":"Estructura Anat\u00f3mica","text":"<p>Un fichero <code>build.gradle.kts</code> de m\u00f3dulo t\u00edpico tiene esta estructura:</p> <pre><code>plugins {\n    // 1. Plugins\n}\n\nandroid {\n    // 2. Configuraci\u00f3n Android\n}\n\ndependencies {\n    // 3. Dependencias externas\n}\n</code></pre> <p>Vamos a diseccionar cada parte.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#1-bloque-plugins","title":"1. Bloque <code>plugins</code>","text":"<p>Los plugins son extensiones que \"ense\u00f1an\" a Gradle c\u00f3mo hacer cosas nuevas. Por defecto, Gradle no sabe qu\u00e9 es una \"App Android\". Necesitamos aplicarle el plugin de Android.</p> <pre><code>plugins {\n    // Le dice a Gradle: \"Este m\u00f3dulo es una Aplicaci\u00f3n Android\"\n    alias(libs.plugins.android.application)\n\n    // Le dice a Gradle: \"Vamos a usar Kotlin en Android\"\n    alias(libs.plugins.kotlin.android)\n}\n</code></pre> <p>Version Catalogs (<code>libs.*</code>)</p> <p>F\u00edjate en el uso de <code>alias(libs...)</code>. Esto es Version Catalogs. En lugar de escribir el ID del plugin y la versi\u00f3n \"a fuego\" (hardcoded), referenciamos una definici\u00f3n centralizada en el fichero <code>libs.versions.toml</code>. \u00a1Es mucho m\u00e1s limpio y f\u00e1cil de mantener!</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#2-bloque-android","title":"2. Bloque <code>android</code>","text":"<p>Aqu\u00ed configuramos todo lo relacionado con el SDK de Android.</p>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#namespace-y-compilacion","title":"Namespace y Compilaci\u00f3n","text":"<pre><code>android {\n    // Identificador \u00fanico de tu paquete (sustituye al antiguo 'package' en Manifest)\n    namespace = \"com.ejemplo.miapp\"\n\n    // La versi\u00f3n del SDK que usas para COMPILAR el c\u00f3digo.\n    // Te permite usar las APIs m\u00e1s nuevas de esa versi\u00f3n en tu c\u00f3digo.\n    compileSdk = 35 \n\n    // ...\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#default-config","title":"Default Config","text":"<p>La configuraci\u00f3n base que se aplica a todas las versiones de tu app (debug, release, etc.).</p> <pre><code>    defaultConfig {\n        // ID \u00fanico de la aplicaci\u00f3n en la Play Store.\n        applicationId = \"com.ejemplo.miapp\"\n\n        // M\u00ednima versi\u00f3n de Android donde funciona tu app.\n        // Si pones 24 (Android 7.0), nadie con Android 6.0 podr\u00e1 instalarla.\n        minSdk = 24\n\n        // Versi\u00f3n objetivo. Le dice a Android: \"He probado mi app hasta esta versi\u00f3n\".\n        // Permite que el sistema active optimizaciones o comportamientos nuevos.\n        // Lo ideal es: targetSdk == compileSdk\n        targetSdk = 35\n\n        // Versionado para la tienda (interno y visible).\n        versionCode = 1\n        versionName = \"1.0\"\n\n        // Runner para los tests instrumentados\n        testInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#build-types-tipos-de-construccion","title":"Build Types (Tipos de Construcci\u00f3n)","text":"<p>Define perfiles de compilaci\u00f3n. Por defecto siempre tienes <code>debug</code> y <code>release</code>.</p> <pre><code>    buildTypes {\n        release {\n            // \u00bfActivamos minificaci\u00f3n (R8)? (Borrar c\u00f3digo no usado, ofuscar...)\n            isMinifyEnabled = false \n\n            // Reglas de ProGuard para la ofuscaci\u00f3n\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n        // El bloque 'debug' existe impl\u00edcitamente aunque no lo escribas.\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#opciones-de-compilacion","title":"Opciones de Compilaci\u00f3n","text":"<p>Configuramos la versi\u00f3n de Java que usaremos. Hoy en d\u00eda, Java 11 o 17 son el est\u00e1ndar para desarrollo Android moderno.</p> <pre><code>    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_11\n        targetCompatibility = JavaVersion.VERSION_11\n    }\n    kotlinOptions {\n        jvmTarget = \"11\"\n    }\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#3-bloque-dependencies","title":"3. Bloque <code>dependencies</code>","text":"<p>Aqu\u00ed listamos las librer\u00edas externas que nuestra app necesita para funcionar.</p> <pre><code>dependencies {\n    // Dependencias 'core' (se compilan y empaquetan con la app)\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.appcompat)\n    implementation(libs.material)\n\n    // Dependencias SOLO para Tests Unitarios (JUnit local)\n    // No se empaquetan en la APK final.\n    testImplementation(libs.junit)\n\n    // Dependencias puramente de Tests Instrumentados (Android)\n    androidTestImplementation(libs.androidx.junit)\n    androidTestImplementation(libs.androidx.espresso.core)\n\n    // Herramientas de debug (solo en builds debug)\n    // debugImplementation(libs.leakcanary)\n}\n</code></pre>"},{"location":"temas/00-android/00-tools/02-build-gradle.html#tipos-de-dependencia-comunes","title":"Tipos de dependencia comunes","text":"<ul> <li><code>implementation</code>: La m\u00e1s com\u00fan. La librer\u00eda est\u00e1 disponible en compilaci\u00f3n y ejecuci\u00f3n.</li> <li><code>testImplementation</code>: Solo disponible dentro de <code>src/test</code> (tests unitarios locales).</li> <li><code>androidTestImplementation</code>: Solo disponible dentro de <code>src/androidTest</code> (tests en dispositivo).</li> <li><code>ksp</code> (o <code>kapt</code>): Para procesadores de anotaciones (como Room o Dagger/Hilt).</li> <li><code>debugImplementation</code>: Solo se incluye en la variante <code>debug</code>.</li> </ul> <p>Cuidado con las versiones</p> <p>Evita mezclar versiones de librer\u00edas relacionadas (como las de <code>androidx.lifecycle</code> o <code>kotlinx.coroutines</code>). Usar el Version Catalog (<code>libs.versions.toml</code>) ayuda mucho a mantener la coherencia, ya que defines la versi\u00f3n en un solo lugar.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html","title":"Fichero Manifest","text":""},{"location":"temas/00-android/00-tools/03-android-manifest.html#el-manifiesto-de-la-app-androidmanifestxml","title":"El Manifiesto de la App: <code>AndroidManifest.xml</code>","text":"<p>Si <code>build.gradle</code> es el jefe de obra que construye el edificio, el <code>AndroidManifest.xml</code> es el DNI o Pasaporte de tu aplicaci\u00f3n. </p> <p>Es la primera fuente de verdad que el sistema operativo Android consulta para saber qu\u00e9 hay dentro de tu APK/Bundle y qu\u00e9 permisos pretendes usar.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#1-permisos-y-hardware-declarando-intenciones","title":"1. Permisos y Hardware: Declarando intenciones","text":"<p>Antes de que el sistema te deje entrar en escena, debes declarar qu\u00e9 recursos del tel\u00e9fono vas a utilizar.</p> <ul> <li><code>&lt;uses-permission&gt;</code>: Solicitas permiso para acceder a datos o funciones restringidas.<ul> <li><code>INTERNET</code>: Para conectarte a servicios externos.</li> <li><code>ACCESS_FINE_LOCATION</code>: Para saber la posici\u00f3n GPS exacta del usuario.</li> <li><code>CAMERA</code>: Para tomar fotos o v\u00eddeos.</li> </ul> </li> <li><code>&lt;uses-feature&gt;</code>: Informas sobre el hardware que tu app necesita para funcionar.<ul> <li>Ejemplo: <code>&lt;uses-feature android:name=\"android.hardware.camera\" android:required=\"true\" /&gt;</code>. </li> <li>Importante: Si marcas <code>required=\"true\"</code>, la Google Play Store ocultar\u00e1 tu app a los usuarios cuyo m\u00f3vil no tenga ese hardware.</li> </ul> </li> </ul>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#2-el-bloque-application-el-contenedor-global","title":"2. El Bloque <code>&lt;application&gt;</code>: El contenedor global","text":"<p>Este bloque define las propiedades de alto nivel de toda tu aplicaci\u00f3n. Es como la configuraci\u00f3n general del sistema.</p> <pre><code>&lt;application\n    android:name=\".MyApplication\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/Theme.MiApp\"\n    android:allowBackup=\"true\"\n    android:supportsRtl=\"true\"\n    android:usesCleartextTraffic=\"false\"&gt;\n\n    &lt;!-- Componentes aqu\u00ed inside... --&gt;\n&lt;/application&gt;\n</code></pre>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#elementos-clave-explicados","title":"Elementos clave explicados:","text":"<ul> <li><code>android:name</code>: (Opcional) Referencia a una clase Java/Kotlin que hereda de <code>Application</code>. Es el primer c\u00f3digo que se ejecuta al abrir la app, ideal para inicializar librer\u00edas globales (como bases de datos o inyecci\u00f3n de dependencias).</li> <li><code>android:theme</code>: Define la \"est\u00e9tica\" por defecto. Referencia a un fichero de estilos (normalmente en <code>res/values/themes.xml</code>). Aqu\u00ed se decide si usas Material Design 3, los colores principales de tu marca, o si tu app soporta modo oscuro de forma nativa.</li> <li><code>android:usesCleartextTraffic</code>: Si se pone en <code>false</code> (recomendado), Android bloquear\u00e1 todas las peticiones HTTP no seguras, oblig\u00e1ndote a usar HTTPS. Es vital para la seguridad actual.</li> </ul>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#3-los-4-fantasticos-los-componentes-de-android","title":"3. Los \"4 Fant\u00e1sticos\": Los Componentes de Android","text":"<p>Android no es un programa monol\u00edtico; se compone de piezas intercambiables y declarables. Hay 4 tipos principales de componentes:</p> <ol> <li><code>&lt;activity&gt;</code> (Actividades): Son las pantallas. Cada pantalla que el usuario ve debe estar declarada aqu\u00ed. Es el componente con el que el usuario interact\u00faa directamente.</li> <li><code>&lt;service&gt;</code> (Servicios): Componentes que corren en segundo plano sin interfaz de usuario. Por ejemplo, una app de m\u00fasica que sigue sonando cuando apagas la pantalla o una descarga pesada.</li> <li><code>&lt;receiver&gt;</code> (Broadcast Receivers): Son \"orejas\" que escuchan eventos del sistema. Por ejemplo, una app que se activa cuando el m\u00f3vil se conecta a un cargador o cuando termina de arrancar el sistema (<code>BOOT_COMPLETED</code>).</li> <li><code>&lt;provider&gt;</code> (Content Providers): Permiten compartir datos entre aplicaciones de forma segura. Por ejemplo, la lista de contactos del tel\u00e9fono o la galer\u00eda de fotos se exponen mediante Content Providers.</li> </ol>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#4-intent-filters-la-publicidad-de-tus-capacidades","title":"4. Intent Filters: La \"Publicidad\" de tus capacidades","text":"<p>Los <code>intent-filter</code> son etiquetas que pones a tus componentes para decirle al sistema: \"Yo s\u00e9 hacer esto\".</p> <p>No solo sirven para marcar la pantalla de inicio. Un <code>intent-filter</code> descompone en tres partes:</p> <ol> <li><code>&lt;action&gt;</code>: El qu\u00e9. \u00bfQuieres ver un dato (<code>VIEW</code>)?, \u00bfenviar algo (<code>SEND</code>)?, \u00bfeditar algo (<code>EDIT</code>)?</li> <li><code>&lt;category&gt;</code>: El contexto. \u00bfEs la puerta principal (<code>LAUNCHER</code>)?, \u00bfes algo que se abre desde el navegador (<code>BROWSABLE</code>)?</li> <li><code>&lt;data&gt;</code>: El formato. \u00bfManejas archivos PDF?, \u00bfURLs que empiecen por <code>https://miweb.com</code>?, \u00bfim\u00e1genes PNG?</li> </ol>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#ejemplo-abriendo-nuestra-app-desde-un-enlace-web-deep-linking","title":"Ejemplo: Abriendo nuestra app desde un enlace web (Deep Linking)","text":"<pre><code>&lt;activity android:name=\".ProductDetailActivity\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n        &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n        &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n        &lt;!-- Aceptamos enlaces que sean https://www.tienda.com/productos/... --&gt;\n        &lt;data android:scheme=\"https\" android:host=\"www.tienda.com\" android:pathPrefix=\"/productos\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>Diferencia Vital</p> <p>Si declaras una Activity pero no le pones ning\u00fan <code>intent-filter</code>, la Activity sigue existiendo, pero solo podr\u00e1 ser abierta desde dentro de tu propia app. Sin filtros, el \"mundo exterior\" no sabe c\u00f3mo llegar a ella.</p>"},{"location":"temas/00-android/00-tools/03-android-manifest.html#5-referencias-de-documentacion-oficial","title":"5. Referencias de documentaci\u00f3n oficial","text":"<p>Para profundizar en cada etiqueta y atributo, puedes consultar la documentaci\u00f3n oficial de Android:</p> <ul> <li>Descripci\u00f3n general del manifiesto de la aplicaci\u00f3n: Conceptos b\u00e1sicos y estructura.</li> <li>Referencia del elemento <code>&lt;application&gt;</code>: Lista exhaustiva de todos los atributos configurables.</li> <li>Gu\u00eda de Intenciones y Filtros de Intenciones: C\u00f3mo funciona la comunicaci\u00f3n entre componentes.</li> <li>Referencia de permisos de Android: Diccionario de todos los permisos disponibles en el sistema.</li> </ul>"},{"location":"temas/01/index.html","title":"UT1 - Visi\u00f3n General y Entorno de desarrollo","text":""},{"location":"temas/01/index.html#ut1-evolucion-y-entornos-de-desarrollo","title":"UT1. Evoluci\u00f3n y Entornos de desarrollo","text":""},{"location":"temas/01/index.html#1-limitaciones-en-el-desarrollo-movil","title":"1. Limitaciones en el desarrollo m\u00f3vil","text":"<p>A menudo, cuando empezamos a programar, venimos de un mundo de desarrollo de escritorio o incluso web, donde los recursos parecen casi infinitos. Un ordenador de sobremesa moderno tiene gigabytes de RAM, procesadores de m\u00faltiples n\u00facleos a altas velocidades, almacenamiento masivo y una conexi\u00f3n a internet estable y r\u00e1pida. Los servidores que alojan aplicaciones web son a\u00fan m\u00e1s potentes.</p> <p>Sin embargo, el entorno m\u00f3vil es un ecosistema completamente diferente. Un smartphone, por muy avanzado que sea, es un dispositivo que llevamos en el bolsillo, alimentado por una bater\u00eda y sujeto a condiciones muy variables. Ignorar estas limitaciones no solo lleva a una mala calificaci\u00f3n en esta asignatura, sino, lo que es peor, a crear aplicaciones que los usuarios desinstalar\u00e1n por ser lentas, consumir su bater\u00eda o no funcionar cuando m\u00e1s las necesitan.</p> <p>Pensemos en un desarrollador de escritorio como el arquitecto de un gran rascacielos con cimientos profundos y acceso a la red el\u00e9ctrica principal. En cambio, un desarrollador m\u00f3vil es como el ingeniero de un coche de F\u00f3rmula 1: cada gramo de peso, cada gota de combustible y cada pieza de la aerodin\u00e1mica cuentan. La optimizaci\u00f3n no es una opci\u00f3n; es una obligaci\u00f3n.</p> <p>A continuaci\u00f3n, vamos a desglosar las principales \u00e1reas de restricci\u00f3n.</p> <ol> <li> <p>Recursos de Hardware: La eterna dieta</p> <p>A pesar de los impresionantes avances, los dispositivos m\u00f3viles operan con recursos de hardware significativamente m\u00e1s modestos que sus hom\u00f3logos de escritorio.</p> <p><code>Procesador (CPU)</code>: Las CPUs m\u00f3viles est\u00e1n dise\u00f1adas con un objetivo principal: la eficiencia energ\u00e9tica. Un procesador de escritorio puede permitirse consumir 100W o m\u00e1s y disipar el calor con grandes ventiladores. Una CPU m\u00f3vil debe operar con un consumo m\u00ednimo para no agotar la bater\u00eda en minutos y sobrecalentar el dispositivo. Esto implica velocidades de reloj m\u00e1s bajas y arquitecturas (como ARM) optimizadas para el bajo consumo, lo que se traduce en una menor capacidad de c\u00f3mputo bruto. Tareas muy intensivas, como el renderizado de v\u00eddeo o c\u00e1lculos complejos, deben ser abordadas con mucho m\u00e1s cuidado.</p> <p><code>Memoria (RAM)</code>: Mientras que un PC de gama media actual puede tener 16 GB o 32 GB de RAM, un smartphone de gama alta puede tener 8 GB o 12 GB, y los de gama media, bastante menos. Adem\u00e1s, el sistema operativo m\u00f3vil (Android o iOS) es muy agresivo a la hora de gestionar esta memoria. Si tu aplicaci\u00f3n consume demasiada RAM, el sistema no dudar\u00e1 en \"matarla\" (finalizar su proceso) sin previo aviso para liberar recursos para la aplicaci\u00f3n que est\u00e1 en primer plano. Esto contrasta con un sistema de escritorio, donde las aplicaciones pueden permanecer en memoria durante d\u00edas.</p> <p><code>Almacenamiento</code>: Aunque los dispositivos modernos ofrecen m\u00e1s almacenamiento, sigue siendo un recurso finito y, a menudo, no ampliable. Las aplicaciones deben ser ligeras. Una aplicaci\u00f3n de escritorio puede ocupar varios gigabytes sin que el usuario se preocupe, pero una app m\u00f3vil que ocupe ese espacio ser\u00e1 una candidata clara a ser eliminada cuando el usuario necesite liberar espacio para sus fotos o v\u00eddeos.</p> </li> <li> <p>La Bater\u00eda: El recurso m\u00e1s preciado</p> <p>Esta es, sin duda, la limitaci\u00f3n m\u00e1s cr\u00edtica y definitoria del desarrollo m\u00f3vil. A diferencia del desarrollo web o de escritorio, donde la alimentaci\u00f3n es constante, en el m\u00f3vil cada ciclo de CPU, cada byte enviado por la red y cada p\u00edxel encendido en la pantalla consume una porci\u00f3n de un recurso muy limitado: la bater\u00eda.</p> <p><code>Consumo energ\u00e9tico</code>: El desarrollador debe ser consciente del impacto energ\u00e9tico de su c\u00f3digo. Dejar un sensor activo (como el GPS) innecesariamente, realizar operaciones de red con demasiada frecuencia (polling) o ejecutar procesos complejos en segundo plano son los caminos m\u00e1s r\u00e1pidos para agotar la bater\u00eda del usuario y ganarse una rese\u00f1a de una estrella en la tienda de aplicaciones.</p> <p><code>Optimizaci\u00f3n del sistema</code>: Los sistemas operativos m\u00f3viles modernos implementan mecanismos muy estrictos para controlar el consumo, como Doze Mode y App Standby en Android. Estos modos ponen las aplicaciones en un estado de \"sue\u00f1o profundo\", restringiendo su acceso a la red y a la CPU cuando el dispositivo no est\u00e1 en uso. El desarrollador ya no tiene control total sobre cu\u00e1ndo se ejecuta su c\u00f3digo en segundo plano.</p> </li> <li> <p>Conectividad: Un mundo inestable y costoso</p> <p>Las aplicaciones de escritorio y web suelen asumir una conexi\u00f3n a internet permanente, r\u00e1pida y de bajo coste (Wi-Fi o Ethernet). En el mundo m\u00f3vil, la realidad es muy diferente.</p> <p><code>Variabilidad de la red</code>: La aplicaci\u00f3n debe funcionar de manera predecible en m\u00faltiples escenarios: una conexi\u00f3n Wi-Fi de alta velocidad, una red 5G, una conexi\u00f3n 4G inestable en un tren, una red 3G lenta en una zona rural, o incluso sin conexi\u00f3n alguna.</p> <p><code>Latencia y ancho de banda</code>: La latencia en redes m\u00f3viles es generalmente mayor que en redes fijas. Las transferencias de datos deben minimizarse. No puedes permitirte descargar 50 MB de datos cada vez que el usuario abre la app. Debes implementar estrategias de cach\u00e9, compresi\u00f3n de datos y sincronizaci\u00f3n inteligente.</p> <p><code>Coste de los datos</code>: A diferencia del Wi-Fi, los datos m\u00f3viles suelen tener un coste para el usuario. Una aplicaci\u00f3n que consuma una cantidad excesiva del plan de datos de un usuario ser\u00e1 desinstalada r\u00e1pidamente. Debes ofrecer opciones para limitar el uso de datos (por ejemplo, descargar contenido pesado solo con Wi-Fi).</p> </li> <li> <p>Fragmentaci\u00f3n del Ecosistema</p> <p>Mientras que en el desarrollo de escritorio se trabaja con un conjunto relativamente est\u00e1ndar de resoluciones de pantalla y capacidades, y en la web se usan t\u00e9cnicas de \"responsive design\", en el m\u00f3vil (especialmente en Android) nos enfrentamos a una fragmentaci\u00f3n extrema.</p> <p><code>Diversidad de pantallas</code>: Existen miles de modelos de dispositivos con diferentes tama\u00f1os de pantalla, densidades de p\u00edxeles (DPI), y relaciones de aspecto. Tu interfaz de usuario (UI) debe adaptarse fluidamente a todas ellas, desde un tel\u00e9fono peque\u00f1o hasta una tablet de gran formato.</p> <p><code>Variedad de Hardware</code>: M\u00e1s all\u00e1 de la pantalla, te encontrar\u00e1s con una enorme diversidad de CPUs, GPUs, cantidad de RAM y sensores disponibles (algunos tienen NFC, otros no; algunos tienen un bar\u00f3metro, la mayor\u00eda no). Tu aplicaci\u00f3n debe ser capaz de gestionar esta diversidad, ya sea adaptando su funcionalidad o informando al usuario de que una caracter\u00edstica no est\u00e1 disponible en su dispositivo.</p> <p><code>Versiones del Sistema Operativo</code>: Especialmente en Android, los usuarios tardan en actualizar sus dispositivos. No es raro tener que dar soporte a varias versiones del sistema operativo simult\u00e1neamente, cada una con sus propias APIs, caracter\u00edsticas y bugs.</p> </li> <li> <p>Ciclo de Vida de la Aplicaci\u00f3n y Restricciones del SO</p> <p>En un ordenador de escritorio, el usuario lanza una aplicaci\u00f3n y esta se ejecuta hasta que \u00e9l decide cerrarla. En un dispositivo m\u00f3vil, el ciclo de vida es mucho m\u00e1s complejo y est\u00e1 gestionado de forma estricta por el sistema operativo.</p> <p><code>Estados de la aplicaci\u00f3n</code>: Una aplicaci\u00f3n m\u00f3vil no est\u00e1 simplemente \"abierta\" o \"cerrada\". Pasa por m\u00faltiples estados (creada, iniciada, en primer plano, pausada, detenida, destruida). Por ejemplo, si entra una llamada mientras el usuario est\u00e1 usando tu app, esta pasar\u00e1 al estado de \"pausada\". Debes guardar el estado del usuario en ese momento para que, al volver, pueda continuar donde lo dej\u00f3.</p> <p><code>Procesos en segundo plano (Background)</code>: Como mencionamos antes, la ejecuci\u00f3n de c\u00f3digo en segundo plano est\u00e1 severamente restringida. No puedes simplemente iniciar un hilo que se ejecute indefinidamente. Debes usar las APIs espec\u00edficas proporcionadas por el sistema (como WorkManager en Android) que permiten al SO ejecutar tu tarea de la forma m\u00e1s eficiente posible (por ejemplo, agrupando tareas de varias apps para despertar al dispositivo una sola vez).</p> </li> </ol> <p>Desarrollar para dispositivos m\u00f3viles es un desaf\u00edo apasionante que requiere un cambio de mentalidad. No se trata de trasladar directamente las pr\u00e1cticas del desarrollo de escritorio o web, sino de abrazar las restricciones y convertirlas en una gu\u00eda para la excelencia en la ingenier\u00eda de software.</p> <p>Una aplicaci\u00f3n m\u00f3vil exitosa no es la que m\u00e1s funcionalidades tiene, sino la que ofrece una experiencia fluida, es respetuosa con los recursos del usuario (bater\u00eda, datos, almacenamiento) y funciona de manera fiable en un entorno impredecible. Recordad siempre: en el mundo m\u00f3vil, la eficiencia no es una caracter\u00edstica, es el cimiento sobre el que se construye todo lo dem\u00e1s.</p>"},{"location":"temas/01/index.html#2-desarrollo-movil-en-la-actualidad-un-ecosistema-de-opciones","title":"2. Desarrollo M\u00f3vil en la Actualidad: Un Ecosistema de Opciones","text":"<p>Hace una d\u00e9cada, las opciones eran limitadas. Hoy, nos encontramos ante un ecosistema rico y diverso con diferentes enfoques, cada uno con sus propias filosof\u00edas, ventajas y desventajas. La elecci\u00f3n de la tecnolog\u00eda es una de las decisiones m\u00e1s cr\u00edticas que tomar\u00e9is como desarrolladores o arquitectos de software, ya que impactar\u00e1 directamente en el presupuesto del proyecto, el tiempo de desarrollo, el rendimiento de la aplicaci\u00f3n y la experiencia final del usuario.</p> <p>El objetivo de este documento es proporcionaros un mapa claro de este territorio. Analizaremos las tres grandes rutas que podemos tomar para construir una aplicaci\u00f3n m\u00f3vil: el desarrollo Nativo, el H\u00edbrido y las Progressive Web Apps (PWA). \u00a1Empecemos!</p>"},{"location":"temas/01/index.html#a-desarrollo-nativo-la-via-de-la-maxima-potencia-y-experiencia","title":"A. Desarrollo Nativo: La V\u00eda de la M\u00e1xima Potencia y Experiencia","text":"<p>El desarrollo nativo consiste en construir una aplicaci\u00f3n utilizando las herramientas, lenguajes y APIs (Application Programming Interfaces) que la propia plataforma provee de forma oficial. En esencia, se crea una aplicaci\u00f3n espec\u00edfica y optimizada para un \u00fanico sistema operativo.</p> <p>\ud83d\udd25 Esto significa que si queremos que nuestra app funcione en Android y en iOS, necesitaremos desarrollar dos aplicaciones separadas, una para cada plataforma, con sus respectivos c\u00f3digos fuente.</p> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Insuperable: La aplicaci\u00f3n se compila a c\u00f3digo m\u00e1quina que se ejecuta directamente sobre el sistema operativo, sin capas intermedias. Esto garantiza la m\u00e1xima velocidad, fluidez y capacidad de respuesta. Es la opci\u00f3n ideal para juegos, aplicaciones con gr\u00e1ficos intensivos o que realicen c\u00e1lculos complejos.</p> </li> <li> <p>Acceso Total al Hardware y APIs: Tienes acceso inmediato y completo a todas las capacidades del dispositivo: GPS, c\u00e1mara, aceler\u00f3metro, NFC, ARKit (iOS), etc. Adem\u00e1s, eres el primero en poder usar las nuevas funcionalidades que se lanzan con cada actualizaci\u00f3n del sistema operativo.</p> </li> <li> <p>Experiencia de Usuario (UX) Perfecta: La interfaz de usuario (UI) se construye con los componentes nativos de la plataforma. El resultado es una aplicaci\u00f3n que se ve y se siente exactamente como el resto del sistema operativo, lo que la hace intuitiva y familiar para el usuario.</p> </li> <li> <p>Mayor Seguridad y Fiabilidad: Al operar directamente sobre la plataforma, se aprovechan todas sus capas de seguridad y optimizaciones.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Para Android:</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Kotlin: Es el lenguaje moderno, conciso y seguro que Google recomienda oficialmente desde 2019. Es interoperable al 100% con Java.</p> </li> <li> <p>Java: Fue el lenguaje original para el desarrollo en Android. Sigue siendo muy utilizado, especialmente en proyectos m\u00e1s antiguos (legacy), pero Kotlin es la opci\u00f3n preferida para nuevos desarrollos.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Android Studio. Es el IDE oficial de Google, basado en IntelliJ IDEA. Incluye todo lo necesario: editor de c\u00f3digo, depurador, emuladores, analizadores de rendimiento, etc.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Android Developers (Oficial) - El punto de partida para todo.</p> </li> <li> <p>Documentaci\u00f3n de Kotlin - Aprende el lenguaje que impulsa el desarrollo moderno de Android.</p> </li> <li> <p>Descargar Android Studio</p> </li> </ul> </li> </ul> <p>Para iOS (Ecosistema Apple)</p> <ul> <li> <p>Lenguajes:</p> <ul> <li> <p>Swift: Es el lenguaje moderno, potente y seguro creado por Apple. Es la opci\u00f3n recomendada para cualquier aplicaci\u00f3n nueva en el ecosistema de Apple (iOS, iPadOS, macOS, watchOS).</p> </li> <li> <p>Objective-C: Es el lenguaje original de desarrollo para iOS. Aunque Swift lo ha superado en popularidad, todav\u00eda es fundamental para mantener proyectos existentes.</p> </li> </ul> </li> <li> <p>Entorno de Desarrollo (IDE): Xcode. Es el IDE oficial de Apple, que se ejecuta exclusivamente en macOS. Proporciona todas las herramientas para desarrollar, depurar y publicar apps para todas las plataformas de Apple.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Apple Developer (Oficial) - Tu puerta de entrada al desarrollo para iOS.</p> </li> <li> <p>Documentaci\u00f3n de Swift - La gu\u00eda oficial y completa del lenguaje Swift.</p> </li> <li> <p>Descargar Xcode</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-desarrollo-hibrido-un-codigo-para-gobernarlos-a-todos","title":"B. Desarrollo H\u00edbrido: Un C\u00f3digo para Gobernarlos a Todos","text":"<p>El desarrollo h\u00edbrido, tambi\u00e9n conocido como multiplataforma, busca resolver el principal inconveniente del desarrollo nativo: la necesidad de mantener dos bases de c\u00f3digo. La filosof\u00eda aqu\u00ed es \"escribe una vez, ejecuta en todas partes\" (write once, run anywhere).</p> <p>Se utiliza un \u00fanico lenguaje y un framework espec\u00edfico para generar aplicaciones que funcionen tanto en Android como en iOS.</p> <p>Ventajas Clave</p> <ul> <li> <p>Eficiencia en Coste y Tiempo: Es la ventaja m\u00e1s evidente. Se necesita un solo equipo de desarrollo y un \u00fanico c\u00f3digo base, lo que reduce dr\u00e1sticamente los tiempos y costes de desarrollo y mantenimiento.</p> </li> <li> <p>Lanzamiento R\u00e1pido al Mercado (Time-to-Market): Al desarrollar para ambas plataformas simult\u00e1neamente, puedes lanzar tu producto mucho m\u00e1s r\u00e1pido.</p> </li> <li> <p>Consistencia de Marca: La aplicaci\u00f3n tendr\u00e1 una apariencia muy similar en ambas plataformas, lo que puede ser beneficioso para la identidad de marca.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-y-lenguajes_1","title":"Tecnolog\u00edas y Lenguajes","text":"<p>Existen diferentes enfoques dentro del mundo h\u00edbrido, pero los m\u00e1s relevantes hoy en d\u00eda son:</p> <p>Flutter</p> <ul> <li> <p>Concepto: Es un toolkit de UI desarrollado por Google que ha ganado una tracci\u00f3n inmensa. Flutter no utiliza los componentes nativos de la UI, sino que trae su propio motor de renderizado (Skia) para dibujar cada p\u00edxel en la pantalla. Esto le da un control total sobre la interfaz y permite animaciones complejas a 60/120 FPS.</p> </li> <li> <p>Lenguaje: Dart. Un lenguaje moderno, orientado a objetos y optimizado para el desarrollo de UI.</p> </li> <li> <p>Ideal para: Aplicaciones con una interfaz de usuario muy personalizada, expresiva y con muchas animaciones.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>Flutter (Oficial) - Descubre por qu\u00e9 es una de las tecnolog\u00edas m\u00e1s queridas por los desarrolladores.</p> </li> <li> <p>Documentaci\u00f3n de Dart - Aprende los fundamentos del lenguaje de Flutter.</p> </li> </ul> </li> </ul> <p>React Native</p> <ul> <li> <p>Concepto: Creado por Meta (Facebook), React Native permite a los desarrolladores web usar sus conocimientos de JavaScript y React para crear aplicaciones m\u00f3viles. A diferencia de Flutter, React Native utiliza un \"puente\" (bridge) para comunicarse con los componentes de la UI nativa de cada plataforma. Esto puede hacer que la app se sienta un poco m\u00e1s \"nativa\".</p> </li> <li> <p>Lenguaje: JavaScript o TypeScript (una versi\u00f3n de JavaScript con tipado est\u00e1tico, muy recomendada).</p> </li> <li> <p>Ideal para: Empresas con equipos de desarrollo web que quieran pasar al m\u00f3vil, o para aplicaciones donde el aspecto nativo sea una prioridad.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>React Native (Oficial) - La documentaci\u00f3n oficial para empezar.</li> </ul> </li> </ul> <p>.NET MAUI (Multi-platform App UI)</p> <ul> <li> <p>Concepto: Es la evoluci\u00f3n de Xamarin.Forms, impulsada por Microsoft. Permite a los desarrolladores del ecosistema .NET usar C# y XAML para crear aplicaciones para iOS, Android, Windows y macOS desde una \u00fanica base de c\u00f3digo.</p> </li> <li> <p>Lenguaje: C#.</p> </li> <li> <p>Ideal para: Organizaciones que ya tienen una fuerte inversi\u00f3n en tecnolog\u00edas de Microsoft y .NET.</p> </li> <li> <p>Recursos para profundizar:</p> <ul> <li>.NET MAUI (Oficial) - La plataforma multiplataforma del ecosistema .NET.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-kotlin-multiplatform-kmp-lo-mejor-de-ambos-mundos","title":"C. Kotlin Multiplatform (KMP): \u00bfLo mejor de Ambos mundos?","text":"<p>Hemos analizado el desarrollo Nativo y el H\u00edbrido como dos caminos separados. El primero nos da el m\u00e1ximo rendimiento y la mejor experiencia de usuario a costa de duplicar el trabajo. El segundo nos ofrece eficiencia y una base de c\u00f3digo \u00fanica, pero a veces con compromisos en rendimiento o en acceso a las \u00faltimas funcionalidades nativas.</p> <p>Pero, \u00bfy si existiera un enfoque que intentara combinar la eficiencia del c\u00f3digo compartido con el poder del desarrollo nativo? Aqu\u00ed es donde entra en juego Kotlin Multiplatform (KMP).</p> <p>KMP no es otro framework h\u00edbrido como Flutter o React Native. Es un enfoque radicalmente diferente.</p> <p>La L\u00f3gica Compartida, la UI Nativa</p> <p>La filosof\u00eda de Kotlin Multiplatform, impulsado por JetBrains (los creadores de Kotlin y de IntelliJ), no es \"escribe una vez, ejecuta en todas partes\", sino m\u00e1s bien \"escribe la l\u00f3gica de negocio una vez, y construye la interfaz de usuario de forma nativa\".</p> <p>KMP permite a los desarrolladores escribir c\u00f3digo en Kotlin que puede ser compilado para m\u00faltiples plataformas:</p> <ul> <li>JVM (para aplicaciones Android y de servidor).</li> <li>JavaScript (para aplicaciones web).</li> <li>Nativo (utilizando la infraestructura del compilador LLVM para generar binarios para iOS, macOS, Windows, etc.).</li> </ul> <p>La idea central es identificar el c\u00f3digo que es independiente de la interfaz de usuario ---la l\u00f3gica de negocio--- y compartirlo entre plataformas.</p>"},{"location":"temas/01/index.html#que-es-la-logica-de-negocio","title":"\u00bfQu\u00e9 es la \"L\u00f3gica de Negocio\"?","text":"<p>Piensa en todo lo que tu aplicaci\u00f3n hace \"detr\u00e1s de las c\u00e1maras\":</p> <ul> <li>Acceso a la red: Realizar llamadas a una API REST o GraphQL.</li> <li>Gesti\u00f3n de la base de datos: Guardar, leer y actualizar datos en una base de datos local (como SQLite).</li> <li>Modelos de datos: Las clases que representan la informaci\u00f3n de tu app (Usuario, Producto, etc.).</li> <li>Validaciones: Comprobar que un email tiene el formato correcto o que una contrase\u00f1a cumple los requisitos.</li> <li>Algoritmos y c\u00e1lculos: Cualquier procesamiento de datos espec\u00edfico de tu aplicaci\u00f3n.</li> </ul> <p>Todo este c\u00f3digo, que suele ser el n\u00facleo de la aplicaci\u00f3n, no depende de si el bot\u00f3n en la pantalla es redondo o cuadrado. Por lo tanto, se puede escribir una sola vez en Kotlin y compartirlo.</p>"},{"location":"temas/01/index.html#y-que-pasa-con-la-interfaz-de-usuario-ui","title":"\u00bfY qu\u00e9 pasa con la Interfaz de Usuario (UI)?","text":"<p>Aqu\u00ed es donde KMP brilla y se diferencia de los frameworks h\u00edbridos. La UI se construye de forma 100% nativa en cada plataforma:</p> <ul> <li> <p>En Android: Creas tus vistas (layouts) y gestionas el ciclo de vida de las Activities y Fragments utilizando Jetpack Compose o las vistas XML tradicionales. Desde este c\u00f3digo nativo, llamas a la l\u00f3gica de negocio compartida en Kotlin.</p> </li> <li> <p>En iOS: Desarrollas tu interfaz de usuario con SwiftUI o UIKit, exactamente como lo har\u00eda un desarrollador nativo de iOS. Desde tu c\u00f3digo en Swift, puedes invocar directamente las funciones y clases del m\u00f3dulo de Kotlin compartido.</p> </li> </ul> <p>Ventajas Clave</p> <ul> <li> <p>Rendimiento Nativo: Dado que la UI y toda la interacci\u00f3n con la plataforma se gestionan con c\u00f3digo nativo, el rendimiento y la fluidez son id\u00e9nticos a los de una aplicaci\u00f3n puramente nativa. No hay \"puentes\" ni capas de abstracci\u00f3n que ralenticen la interfaz.</p> </li> <li> <p>UI/UX Perfecta: La aplicaci\u00f3n se ve, se siente y se comporta exactamente como el usuario espera en su dispositivo, ya que utilizas los componentes nativos de Android (Material Design) y de iOS (Human Interface Guidelines).</p> </li> <li> <p>Eficiencia sin Sacrificios: Compartes una parte significativa del c\u00f3digo (a menudo m\u00e1s del 50-60%), lo que reduce el tiempo de desarrollo, la duplicaci\u00f3n de esfuerzos y la probabilidad de bugs, sin renunciar a las ventajas del desarrollo nativo.</p> </li> <li> <p>Acceso Inmediato a APIs Nativas: Como est\u00e1s escribiendo c\u00f3digo nativo en la capa de UI, puedes acceder a las \u00faltimas APIs de cada sistema operativo desde el primer d\u00eda, sin esperar a que un framework de terceros a\u00f1ada soporte.</p> </li> <li> <p>Adopci\u00f3n Gradual: Puedes empezar a usar KMP en una peque\u00f1a parte de una aplicaci\u00f3n existente, tanto en Android como en iOS, sin necesidad de reescribirla por completo.</p> </li> </ul> <p>Desventajas y Consideraciones</p> <ul> <li> <p>Complejidad Inicial: La configuraci\u00f3n del proyecto puede ser m\u00e1s compleja que en otros enfoques. Requiere conocimientos tanto de desarrollo en Android (Gradle) como en iOS (Xcode, CocoaPods).</p> </li> <li> <p>Se Necesitan Habilidades Nativas: A diferencia del desarrollo h\u00edbrido puro, no basta con un solo equipo de desarrolladores. Necesitas expertos que se sientan c\u00f3modos construyendo la UI en Android (Kotlin/Compose) y en iOS (Swift/SwiftUI).</p> </li> <li> <p>Ecosistema en Crecimiento: Aunque est\u00e1 madurando r\u00e1pidamente, el ecosistema de librer\u00edas multiplataforma todav\u00eda es m\u00e1s peque\u00f1o que el de plataformas como React Native o Flutter.</p> </li> </ul>"},{"location":"temas/01/index.html#un-ecosistema-en-evolucion-compose-multiplatform","title":"Un Ecosistema en Evoluci\u00f3n: Compose Multiplatform","text":"<p>Para a\u00f1adir una capa m\u00e1s, JetBrains est\u00e1 llevando Jetpack Compose (el moderno toolkit de UI declarativa de Android) al mundo multiplataforma con Compose Multiplatform.</p> <p>Compose Multiplatform permite compartir no solo la l\u00f3gica de negocio, sino tambi\u00e9n la interfaz de usuario, utilizando el mismo c\u00f3digo declarativo en Kotlin para describir la UI en Android, iOS , escritorio (Windows, macOS, Linux) y web (Wasm).</p> <p>Esto acerca a KMP al modelo de Flutter, donde tanto la l\u00f3gica como la UI son compartidas, pero con la ventaja de estar construido sobre el lenguaje y el ecosistema de Kotlin.</p> <ul> <li> <p>Recursos para profundizar:</p> <ul> <li>Kotlin Multiplatform (Oficial) - La documentaci\u00f3n oficial y el mejor lugar para empezar.</li> </ul> </li> </ul>"},{"location":"temas/01/index.html#d-progressive-web-apps-pwa-la-web-se-viste-de-app","title":"D. Progressive Web Apps (PWA): La Web se Viste de App","text":"<p>Las PWA no son aplicaciones m\u00f3viles en el sentido tradicional. Son aplicaciones web que utilizan las tecnolog\u00edas web m\u00e1s modernas para ofrecer una experiencia muy similar a la de una aplicaci\u00f3n nativa. No se instalan desde una tienda de aplicaciones, sino que el usuario puede \"a\u00f1adirlas a la pantalla de inicio\" directamente desde el navegador.</p> <p>Ventajas Clave</p> <ul> <li> <p>Sin Tiendas de Aplicaciones: No necesitas pasar por los procesos de revisi\u00f3n y publicaci\u00f3n de la App Store de Apple o Google Play. La \"instalaci\u00f3n\" es instant\u00e1nea.</p> </li> <li> <p>Multiplataforma por Definici\u00f3n: Funcionan en cualquier dispositivo que tenga un navegador web moderno (Android, iOS, Windows, macOS, etc.). El mismo c\u00f3digo sirve para todo.</p> </li> <li> <p>Siempre Actualizadas: Al ser una web, el usuario siempre tiene la \u00faltima versi\u00f3n disponible sin necesidad de actualizar nada.</p> </li> <li> <p>Compartibles: Se puede compartir la \"app\" simplemente enviando una URL.</p> </li> </ul>"},{"location":"temas/01/index.html#tecnologias-clave-y-lenguajes","title":"Tecnolog\u00edas Clave y Lenguajes","text":"<p>Las PWA se construyen sobre el est\u00e1ndar de la web.</p> <ul> <li> <p>Lenguajes: HTML5, CSS3, JavaScript/TypeScript.</p> </li> <li> <p>Componentes Esenciales:</p> <ul> <li> <p>HTTPS: Es un requisito de seguridad indispensable.</p> </li> <li> <p>Service Worker: Es un script que el navegador ejecuta en segundo plano. Es la tecnolog\u00eda que permite funcionalidades como el trabajo offline (acceder a la app sin conexi\u00f3n) y las notificaciones push.</p> </li> <li> <p>Web App Manifest: Es un archivo JSON que le dice al navegador c\u00f3mo debe verse y comportarse la aplicaci\u00f3n cuando se \"instala\" (nombre, icono, pantalla de bienvenida, etc.).</p> </li> </ul> </li> <li> <p>Recursos para profundizar:</p> <ul> <li> <p>web.dev by Google (PWA) - Una de las mejores gu\u00edas para entender y construir PWAs.</p> </li> <li> <p>MDN Web Docs: Service Worker API - Documentaci\u00f3n t\u00e9cnica de referencia.</p> </li> </ul> </li> </ul> <p>\u00bfQu\u00e9 tecnolog\u00eda y lenguaje elegir?</p> <p></p>"},{"location":"temas/01/index.html#3-el-ciclo-de-vida-de-una-aplicacion-movil","title":"3. El Ciclo de Vida de una Aplicaci\u00f3n M\u00f3vil","text":"<p>Pensemos en una aplicaci\u00f3n no como un simple programa, sino como un producto con el que un usuario interact\u00faa a lo largo del tiempo. Este viaje, desde que oye hablar de la app hasta que decide eliminarla de su tel\u00e9fono, se conoce como su ciclo de vida. Entender cada fase nos permite tomar mejores decisiones para que nuestra app no solo sea \u00fatil, sino tambi\u00e9n exitosa.</p>"},{"location":"temas/01/index.html#a-descubrimiento-como-me-encuentran","title":"A. Descubrimiento: \"\u00bfC\u00f3mo me encuentran?\"","text":"<p>Esta es la fase de \"marketing\". Nuestra aplicaci\u00f3n ya est\u00e1 terminada y publicada, pero para el usuario, todo empieza aqu\u00ed. \u00bfC\u00f3mo llega un usuario a conocer nuestra existencia entre millones de aplicaciones?</p> <ul> <li> <p>Tiendas de Aplicaciones (App Stores): Son el principal escaparate.</p> <ul> <li> <p>Google Play Store (Android) y Apple App Store (iOS) son los mercados dominantes. Act\u00faan como gigantescos centros comerciales donde los usuarios pueden buscar, explorar categor\u00edas (juegos, productividad, etc.), ver listas de \u00e9xitos (\"Top Ventas\", \"Top Gratuitas\"), y leer rese\u00f1as y valoraciones de otros usuarios.</p> </li> <li> <p>B\u00fasqueda: La mayor\u00eda de los descubrimientos ocurren a trav\u00e9s del buscador de la tienda. Por eso, un buen nombre, un icono atractivo y una descripci\u00f3n clara (lo que se conoce como ASO - App Store Optimization) son cruciales.</p> </li> <li> <p>Recomendaciones Editoriales: Ser destacado por los equipos editoriales de Google o Apple puede catapultar una aplicaci\u00f3n a la fama.</p> </li> </ul> </li> <li> <p>Otros Canales: No todo ocurre en las tiendas.</p> <ul> <li> <p>Buscadores Web: Una b\u00fasqueda en Google puede llevar a la ficha de una aplicaci\u00f3n en la tienda.</p> </li> <li> <p>Redes Sociales y \"Boca a Boca\": Recomendaciones de amigos, influencers o publicidad en plataformas como Instagram, TikTok o X.</p> </li> <li> <p>Medios de Comunicaci\u00f3n: Art\u00edculos en blogs de tecnolog\u00eda o noticias que hablen de nuestra app.</p> </li> <li> <p>Publicidad Directa: Un c\u00f3digo QR en un cartel o un enlace en una web pueden llevar directamente a la p\u00e1gina de instalaci\u00f3n.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#b-instalacion-te-quiero-en-mi-movil","title":"B. Instalaci\u00f3n: \"Te quiero en mi m\u00f3vil\"","text":"<p>Una vez descubierta la app, el usuario decide \"adquirirla\". Este proceso, aunque parece simple, tiene matices importantes, sobre todo en cuanto a seguridad.</p> <ul> <li> <p>Desde Tiendas Oficiales:</p> <ul> <li> <p>Este es el m\u00e9todo seguro y recomendado.</p> </li> <li> <p>El usuario pulsa el bot\u00f3n \"Instalar\" (en Google Play) o \"Obtener\" (en la App Store).</p> </li> <li> <p>La tienda gestiona todo el proceso de forma segura: verifica la identidad del usuario, descarga el paquete de la aplicaci\u00f3n (<code>.apk</code> en Android, <code>.ipa</code> en iOS) y lo instala en el dispositivo. El sistema operativo coloca el icono de la app en la pantalla de inicio o en el caj\u00f3n de aplicaciones.</p> </li> </ul> </li> <li> <p>Desde Fuentes Externas (\"Sideloading\"):</p> <ul> <li> <p>Esta opci\u00f3n es pr\u00e1cticamente exclusiva de Android. Permite a los usuarios instalar aplicaciones descargando el archivo <code>.apk</code> directamente desde una p\u00e1gina web o una tienda de aplicaciones alternativa (como F-Droid, que se especializa en software de c\u00f3digo abierto).</p> </li> <li> <p>Riesgos de Seguridad: El \"sideloading\" es la principal v\u00eda de entrada de malware en Android. La aplicaci\u00f3n no ha pasado los controles de seguridad de Google Play, por lo que podr\u00eda contener software malicioso.</p> </li> <li> <p>Por defecto, Android bloquea estas instalaciones. El usuario debe conceder expl\u00edcitamente permiso a la aplicaci\u00f3n (por ejemplo, al navegador Chrome) para \"instalar aplicaciones desconocidas\", asumiendo el riesgo que conlleva.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#c-ejecucion-a-funcionar","title":"C. Ejecuci\u00f3n: \"\u00a1A funcionar!\"","text":"<p>Una vez instalada, la aplicaci\u00f3n est\u00e1 lista para ser utilizada. Al pulsar su icono por primera vez, ocurren varias cosas:</p> <ol> <li> <p>Carga en Memoria: El sistema operativo carga el c\u00f3digo de la aplicaci\u00f3n en la memoria RAM del dispositivo.</p> </li> <li> <p>Pantalla de Bienvenida (Splash Screen): A menudo se muestra una pantalla de inicio con el logo de la app mientras se cargan los recursos necesarios en segundo plano.</p> </li> <li> <p>Solicitud de Permisos: \u00a1Un paso fundamental! Las aplicaciones ya no reciben todos los permisos al instalarse. Ahora, deben solicitar acceso a funciones sensibles en tiempo de ejecuci\u00f3n, es decir, la primera vez que necesitan usarlas.</p> <ul> <li> <p>Ejemplo: Una app de mensajer\u00eda pedir\u00e1 acceso a tus contactos cuando intentes buscar a un amigo, y pedir\u00e1 acceso a la c\u00e1mara cuando pulses el bot\u00f3n para hacer una foto.</p> </li> <li> <p>El usuario puede Aceptar o Denegar cada permiso individualmente. Como desarrolladores, debemos gestionar qu\u00e9 ocurre si un usuario deniega un permiso esencial.</p> </li> </ul> </li> </ol> <p>Una vez configurada y con los permisos necesarios, la aplicaci\u00f3n se encuentra en su estado normal de uso, interactuando con el usuario.</p>"},{"location":"temas/01/index.html#d-actualizacion-mejorando-contigo","title":"D. Actualizaci\u00f3n: \"Mejorando contigo\"","text":"<p>Una aplicaci\u00f3n no es un producto est\u00e1tico. El software necesita evolucionar para seguir siendo \u00fatil y seguro.</p> <ul> <li> <p>Motivos para una Actualizaci\u00f3n:</p> <ul> <li> <p>Nuevas Funcionalidades: A\u00f1adir caracter\u00edsticas que los usuarios han pedido o que mejoran el producto.</p> </li> <li> <p>Correcci\u00f3n de Errores (Bugs): Ning\u00fan software es perfecto. Las actualizaciones solucionan fallos y problemas de estabilidad.</p> </li> <li> <p>Mejoras de Rendimiento: Optimizar el c\u00f3digo para que la app sea m\u00e1s r\u00e1pida o consuma menos bater\u00eda.</p> </li> <li> <p>Parches de Seguridad: Solucionar vulnerabilidades que podr\u00edan poner en riesgo los datos del usuario.</p> </li> </ul> </li> <li> <p>Proceso de Actualizaci\u00f3n:</p> <ul> <li> <p>Autom\u00e1ticas: Es el m\u00e9todo m\u00e1s com\u00fan. Las tiendas de aplicaciones descargan e instalan las nuevas versiones en segundo plano, generalmente cuando el dispositivo est\u00e1 conectado a una red Wi-Fi y cargando, para no molestar al usuario.</p> </li> <li> <p>Manuales: El usuario puede ir a la secci\u00f3n \"Mis aplicaciones\" de la tienda y forzar la actualizaci\u00f3n de una o todas las apps pendientes.</p> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#e-borrado-desinstalacion-ha-sido-un-placer","title":"E. Borrado (Desinstalaci\u00f3n): \"Ha sido un placer\"","text":"<p>Llega un momento en que el usuario ya no necesita la aplicaci\u00f3n. El proceso de desinstalaci\u00f3n est\u00e1 dise\u00f1ado para ser simple, pero es importante saber qu\u00e9 se elimina y qu\u00e9 puede quedar.</p> <ul> <li> <p>Proceso Est\u00e1ndar: El usuario realiza una pulsaci\u00f3n larga sobre el icono de la app y selecciona la opci\u00f3n \"Desinstalar\" o \"Eliminar App\".</p> </li> <li> <p>\u00bfDesinstalaci\u00f3n Completa o Parcial?</p> <ul> <li> <p>Generalmente, la desinstalaci\u00f3n que realiza el usuario es completa desde el punto de vista de la aplicaci\u00f3n en s\u00ed. El sistema operativo elimina:</p> <ol> <li> <p>El paquete de la aplicaci\u00f3n (<code>.apk</code> / <code>.ipa</code>).</p> </li> <li> <p>El almacenamiento privado de la app (su \"sandbox\"). Aqu\u00ed se guardan las configuraciones, bases de datos internas, cach\u00e9 y otros archivos que la app necesita para funcionar.</p> </li> </ol> </li> <li> <p>\u00bfQu\u00e9 puede quedar (Datos Residuales)? A veces, la desinstalaci\u00f3n no elimina el 100% de los datos asociados. Esto no es una \"desinstalaci\u00f3n parcial\" que el usuario elige, sino una consecuencia de c\u00f3mo funcionan los sistemas de archivos.</p> <ul> <li> <p>Archivos en Almacenamiento Compartido: Si tu aplicaci\u00f3n de edici\u00f3n de fotos guard\u00f3 una imagen en la carpeta <code>DCIM/MisFotos</code>, ese archivo no se borrar\u00e1 al desinstalar la app. El sistema lo considera propiedad del usuario, no de la aplicaci\u00f3n.</p> </li> <li> <p>Datos en la Nube: Si el usuario cre\u00f3 una cuenta en tus servidores, esa cuenta y sus datos asociados (perfil, historial, etc.) permanecen en la nube. No se eliminan al borrar la app del tel\u00e9fono. El usuario tendr\u00eda que eliminar su cuenta expl\u00edcitamente.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"temas/01/index.html#comparativa-de-ciclos-de-vida-web-vs-pwa-vs-nativa","title":"Comparativa de Ciclos de Vida -- Web vs PWA vs Nativa","text":"Fase Ciclo Vida \ud83c\udf10 Web Tradicional \ud83d\ude80 Progressive Web App (PWA) \ud83d\udcf1 Aplicaci\u00f3n 1. Descubrimiento M\u00e1xima visibilidad. A trav\u00e9s de buscadores (Google, etc.), enlaces, redes sociales. No depende de una tienda. Lo mejor de ambos mundos. Descubrible como una web (buscadores, enlaces) y potencialmente listada en tiendas de apps (ej. Google Play). Dependiente de la tienda. Principalmente a trav\u00e9s de la App Store y Google Play. El ASO es crucial. 2. Instalaci\u00f3n Sin instalaci\u00f3n. La principal ventaja. El usuario accede al instante. Cero fricci\u00f3n. Instalaci\u00f3n opcional y ligera. El usuario puede \"A\u00f1adir a la pantalla de inicio\". Es un proceso casi instant\u00e1neo y no ocupa mucho espacio. Instalaci\u00f3n obligatoria. El usuario debe ir a la tienda, descargar varios MB (o GB) y esperar a que se instale. Es el punto de mayor fricci\u00f3n. 3.  Ejecuci\u00f3n Dentro del navegador. Se ejecuta en una pesta\u00f1a, con las limitaciones de la interfaz del navegador (barra de URL, etc.). Requiere conexi\u00f3n. Como una app. Se lanza desde su propio icono en la pantalla de inicio, a pantalla completa. Puede funcionar offline gracias al Service Worker. Directamente en el SO. Se lanza desde su icono. Ofrece la m\u00e1xima integraci\u00f3n, rendimiento y acceso completo al hardware del dispositivo (c\u00e1mara, GPS, etc.). 4. Actualizaci\u00f3n Transparente e instant\u00e1nea. Cada vez que el usuario entra, recibe la \u00faltima versi\u00f3n del servidor. No hay proceso de actualizaci\u00f3n. Autom\u00e1tica y en segundo plano. El Service Worker busca y actualiza la app de forma silenciosa. El usuario tiene la nueva versi\u00f3n la pr\u00f3xima vez que la abre. Gestionada por la tienda. Puede ser autom\u00e1tica o manual. Requiere descargar de nuevo el paquete completo o una parte, y un proceso de instalaci\u00f3n. 5. Borrado No existe. El usuario simplemente cierra la pesta\u00f1a o borra el historial/cach\u00e9 del navegador. Sencillo. El usuario elimina el icono de la pantalla de inicio, igual que en una app nativa. Los datos se pueden borrar desde la configuraci\u00f3n del navegador. Proceso manual. El usuario debe realizar una desinstalaci\u00f3n expl\u00edcita (pulsaci\u00f3n larga, etc.) para liberar el espacio de almacenamiento. <p>\u26a1 An\u00e1lisis Detallado de las Diferencias</p>"},{"location":"temas/01/index.html#friccion-en-la-entrada-la-gran-diferencia","title":"Fricci\u00f3n en la Entrada: La Gran Diferencia","text":"<p>La principal ventaja de la web y las PWAs es la inmediatez. Piensa en cu\u00e1ntas veces has entrado a una web que no conoc\u00edas frente a cu\u00e1ntas apps nuevas has instalado en el \u00faltimo mes. El proceso de ir a una tienda, esperar la descarga y la instalaci\u00f3n es una barrera (fricci\u00f3n) que hace que muchos usuarios abandonen el proceso. Una PWA elimina casi por completo esa barrera, ofreciendo una experiencia similar a la nativa con la facilidad de acceso de una web.</p>"},{"location":"temas/01/index.html#capacidades-y-acceso-al-dispositivo","title":"Capacidades y Acceso al Dispositivo","text":"<p>Aqu\u00ed es donde la aplicaci\u00f3n nativa sigue siendo la reina.</p> <ul> <li> <p>Web: Est\u00e1 limitada por el \"sandbox\" (caja de arena) del navegador. Tiene acceso limitado a sensores y hardware.</p> </li> <li> <p>PWA: Mejora mucho respecto a la web. Gracias a las nuevas APIs, puede acceder a notificaciones push, ubicaci\u00f3n, c\u00e1mara y funcionamiento offline. Sin embargo, todav\u00eda tiene un acceso m\u00e1s restringido que una app nativa, especialmente en iOS.</p> </li> <li> <p>Nativa: Tiene acceso total y de m\u00e1ximo rendimiento a todas las capacidades del dispositivo: NFC, Bluetooth avanzado, sensores, archivos del sistema, etc.</p> </li> </ul>"},{"location":"temas/01/index.html#el-proceso-de-actualizacion-control-vs-inmediatez","title":"El Proceso de Actualizaci\u00f3n: Control vs. Inmediatez","text":"<ul> <li> <p>El modelo nativo da al usuario (y al desarrollador) un mayor control sobre las versiones. A veces, los usuarios deciden no actualizar una app si no les gusta la nueva versi\u00f3n.</p> </li> <li> <p>El modelo web/PWA es mucho m\u00e1s \u00e1gil. Como desarrollador, te aseguras de que todos tus usuarios est\u00e1n utilizando siempre la \u00faltima versi\u00f3n, lo que simplifica enormemente el mantenimiento y la correcci\u00f3n de errores. No tienes que dar soporte a versiones antiguas.</p> </li> </ul> <p>No hay una tecnolog\u00eda superior a las otras en todos los aspectos. La elecci\u00f3n depende enteramente del prop\u00f3sito del proyecto.</p> <ul> <li> <p>Para una herramienta que necesita el m\u00e1ximo rendimiento y una integraci\u00f3n profunda con el hardware (un juego, una app de edici\u00f3n de v\u00eddeo, una app que use Bluetooth intensivamente), el camino nativo es indiscutible.</p> </li> <li> <p>Para un blog, una tienda online o una herramienta de consulta donde la inmediatez y el alcance son lo m\u00e1s importante, una PWA es una soluci\u00f3n fant\u00e1stica, ya que combina la visibilidad de la web con una experiencia de usuario muy mejorada.</p> </li> <li> <p>Una web tradicional sigue siendo perfecta para contenido informativo simple o sitios donde la funcionalidad offline y las notificaciones no aportan un valor a\u00f1adido significativo.</p> </li> </ul>"},{"location":"temas/01/index.html#android-el-sdk-de-android-y-sus-versiones","title":"Android: El SDK de Android y sus Versiones","text":"<p>En este apartado vamos a desmontar la \"caja de herramientas\" que nos permite construir aplicaciones para Android. Hablaremos del SDK, de sus componentes y de c\u00f3mo entender el sistema de versiones de Android, que es crucial para garantizar que nuestras apps funcionen correctamente en la mayor\u00eda de dispositivos posibles.</p> <p>Pensemos en nosotros como chefs que quieren preparar un plato espec\u00edfico (nuestra app). El SDK ser\u00eda nuestra cocina profesional: no solo nos da los ingredientes (las APIs), sino tambi\u00e9n los cuchillos, los fogones y los manuales de recetas (las herramientas y la documentaci\u00f3n). Sin esta cocina, solo tendr\u00edamos ideas, pero no podr\u00edamos cocinar nada.</p>"},{"location":"temas/01/index.html#a-que-es-un-sdk-software-development-kit","title":"A. \u00bfQu\u00e9 es un SDK (Software Development Kit)?","text":"<p>Un SDK, o Kit de Desarrollo de Software, es un conjunto de herramientas de software y programas proporcionados por un fabricante de hardware o software para permitir la creaci\u00f3n de aplicaciones para una plataforma espec\u00edfica. En nuestro caso, Google nos proporciona el SDK de Android para que podamos crear apps para su sistema operativo.</p> <p>Un SDK t\u00edpicamente incluye:</p> <ul> <li> <p>Bibliotecas de c\u00f3digo (APIs): C\u00f3digo preescrito que nos da acceso a las funcionalidades del dispositivo, como la c\u00e1mara, el GPS o la interfaz de usuario.</p> </li> <li> <p>Depurador (Debugger): Una herramienta para encontrar y corregir errores en nuestro c\u00f3digo.</p> </li> <li> <p>Documentaci\u00f3n: Manuales, gu\u00edas y ejemplos que nos ense\u00f1an a usar las herramientas y las bibliotecas.</p> </li> <li> <p>Emuladores: Programas que nos permiten probar nuestra app en un dispositivo virtual sin necesidad de tener un tel\u00e9fono f\u00edsico.</p> </li> </ul> <p>En resumen, el SDK es el paquete TODO-EN-UNO indispensable para empezar a desarrollar.</p>"},{"location":"temas/01/index.html#b-los-componentes-del-sdk-de-android","title":"B. Los Componentes del SDK de Android","text":"<p>Dentro de Android Studio, el SDK se gestiona a trav\u00e9s del \"SDK Manager\" y se divide principalmente en dos pesta\u00f1as: SDK Platforms y SDK Tools. Es vital entender la diferencia.</p>"},{"location":"temas/01/index.html#sdk-platforms","title":"SDK Platforms","text":"<p>Piensa en una \"Platform\" como una versi\u00f3n espec\u00edfica y completa del sistema operativo Android empaquetada para el desarrollador. Cada \"Platform\" corresponde a un nivel de API concreto (que veremos m\u00e1s adelante).</p> <p>Cada paquete de \"SDK Platform\" incluye:</p> <ul> <li> <p>El <code>android.jar</code>: Este es el archivo clave. Contiene todas las APIs y clases de esa versi\u00f3n de Android contra las que compilaremos nuestro c\u00f3digo. Es nuestro \"diccionario\" de funcionalidades disponibles.</p> </li> <li> <p>Imagen del Sistema (System Image): Es una copia del sistema operativo Android que se usa para ejecutar los emuladores. Si quieres probar tu app en un emulador de Android 14, necesitas descargar la \"System Image\" de Android 14.</p> </li> </ul> <p>En resumen: Si quieres que tu app use funciones de Android 14 y probarla en un emulador de Android 14, necesitas descargar la \"SDK Platform\" para el nivel de API de Android 14.</p>"},{"location":"temas/01/index.html#sdk-tools","title":"SDK Tools","text":"<p>Estas son las herramientas independientes de la versi\u00f3n de Android que usamos para desarrollar, depurar y probar nuestra aplicaci\u00f3n. Son la maquinaria de nuestra cocina. No importa si cocinamos una receta de 2020 o de 2024, los fogones y cuchillos son los mismos (aunque se afilen y mejoren de vez en cuando).</p> <p>Las herramientas m\u00e1s importantes aqu\u00ed son:</p> <ul> <li> <p>Android SDK Build-Tools: Un conjunto de herramientas que toman nuestro c\u00f3digo y lo compilan y empaquetan en un archivo <code>.apk</code> o <code>.aab</code> instalable.</p> </li> <li> <p>Android Emulator: El software que nos permite crear y ejecutar dispositivos virtuales.</p> </li> <li> <p>Android SDK Platform-Tools: Incluye herramientas de l\u00ednea de comandos esenciales como:</p> <ul> <li> <p>ADB (Android Debug Bridge): El \"puente\" de comunicaci\u00f3n entre nuestro ordenador y el dispositivo (f\u00edsico o emulado). Nos permite instalar apps, depurar, ver logs, etc.</p> </li> <li> <p>Fastboot: Para flashear el firmware del dispositivo.</p> </li> </ul> </li> </ul> <p>En resumen: Las SDK Tools son las herramientas generales para construir y probar, mientras que las SDK Platforms son los \"ingredientes\" espec\u00edficos de cada versi\u00f3n de Android.</p>"},{"location":"temas/01/index.html#c-entendiendo-las-versiones-de-android-la-clave-esta-en-el-nivel-de-api","title":"C. Entendiendo las Versiones de Android: \u00a1La Clave est\u00e1 en el Nivel de API!","text":"<p>Aqu\u00ed es donde muchos estudiantes se l\u00edan. Google usa dos nombres para cada versi\u00f3n de Android, y es crucial saber cu\u00e1l es el importante para nosotros, los desarrolladores.</p>"},{"location":"temas/01/index.html#nombre-comercial-y-postre","title":"Nombre Comercial (y postre \ud83c\udf70)","text":"<p>Es el nombre p\u00fablico y de marketing que Google utiliza para cada gran lanzamiento. Suelen ser nombres de postres o dulces en orden alfab\u00e9tico (aunque esta tradici\u00f3n se ha relajado en los \u00faltimos a\u00f1os).</p> <ul> <li>Ejemplos: Android 8 (Oreo), Android 9 (Pie), Android 10, Android 11, Android 12 (Snow Cone).</li> </ul> <p>Este nombre es \u00fatil para los usuarios, pero casi irrelevante para los desarrolladores. Es una etiqueta de marketing.</p>"},{"location":"temas/01/index.html#nivel-de-api-api-level","title":"Nivel de API (API Level)","text":"<p>Este es el n\u00famero que realmente nos importa. El Nivel de API es un \u00fanico n\u00famero entero que identifica de forma inequ\u00edvoca la versi\u00f3n del framework de APIs que ofrece una plataforma Android.</p> <p>Cuando se lanzan nuevas funcionalidades para desarrolladores (por ejemplo, un nuevo tipo de notificaci\u00f3n o un permiso de privacidad), Google incrementa el Nivel de API.</p> <p>\u00bfPor qu\u00e9 es tan importante? Porque nuestro c\u00f3digo se escribe \"contra\" un nivel de API. Si usamos una funci\u00f3n que se introdujo en el API Level 33 (Android 13), nuestra aplicaci\u00f3n no funcionar\u00e1 en un dispositivo con API Level 32 (Android 12L), porque esa funci\u00f3n simplemente no existe en ese sistema operativo. \u00a1La app \"crashear\u00e1\"!</p>"},{"location":"temas/01/index.html#d-listado-de-versiones-de-android","title":"D. Listado de Versiones de Android","text":"<p>Las versiones de Android incluyen nombres de dulces y postres como\u00a0Cupcake, Donut, Eclair, Froyo, Gingerbread, Honeycomb, Ice Cream Sandwich, Jelly Bean, KitKat, Lollipop, Marshmallow, Nougat, Oreo y Pie.\u00a0Posteriormente, a partir de Android 10, se han numerado las versiones (Android 10, 11, 12, 13, 14, 15, etc.).\u00a0</p> <p>Versiones antiguas (con nombres de postres)\u00a0</p> <ul> <li>Android 1.5\u00a0- Cupcake</li> <li>Android 1.6\u00a0- Donut</li> <li>Android 2.0/2.1\u00a0- Eclair</li> <li>Android 2.2\u00a0- Froyo</li> <li>Android 2.3\u00a0- Gingerbread</li> <li>Android 3.0\u00a0- Honeycomb</li> <li>Android 4.0\u00a0- Ice Cream Sandwich</li> <li>Android 4.1 - 4.3\u00a0- Jelly Bean</li> <li>Android 4.4\u00a0- KitKat</li> <li>Android 5.0/5.1\u00a0- Lollipop</li> <li>Android 6.0\u00a0- Marshmallow</li> <li>Android 7.0/7.1\u00a0- Nougat</li> <li>Android 8.0/8.1\u00a0- Oreo</li> <li>Android 9.0\u00a0- Pie</li> </ul> <p>Versiones recientes (numeradas)\u00a0</p> <ul> <li>Android 10\u00a0- Fue la primera versi\u00f3n sin nombre de postre.</li> <li>Android 11\u00a0- Lanzada en 2020.</li> <li>Android 12\u00a0- Lanzada en 2021, con una variante optimizada para pantallas grandes llamada Android 12L.</li> <li>Android 13\u00a0- Lanzada en 2022.</li> <li>Android 14\u00a0- Lanzada en 2023.</li> <li>Android 15\u00a0- Lanzada en 2024.</li> <li>Android 16\u00a0- Lanzada en 2025.</li> </ul> <p>C\u00f3mo verificar la versi\u00f3n de Android en tu dispositivo\u00a0</p> <ul> <li>Abre la aplicaci\u00f3n Configuraci\u00f3n o Ajustes.</li> <li>Despl\u00e1zate hacia abajo y selecciona Acerca del tel\u00e9fono o Acerca de la tablet.</li> <li>Busca la opci\u00f3n Versi\u00f3n de Android para ver la informaci\u00f3n de tu sistema operativo.</li> </ul> <p>\u2139\ufe0f M\u00e1s informaci\u00f3n en: Lista de versiones de Android</p>"},{"location":"temas/02/index.html","title":"Inicio","text":""},{"location":"temas/02/index.html#ut2-programacion-de-aplicaciones-para-dispositivos-moviles-en-android","title":"UT2. Programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android","text":"<p>En este tema veremos una visi\u00f3n general de la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles en Android, comenzando a crear las primeras aplicaciones, y entendiendo los conceptos b\u00e1sicos de la plataforma Android.</p> <p>Android permite crear aplicaciones utilizando Java o Kotlin, siendo este \u00faltimo el lenguaje recomendado por Google para el desarrollo de aplicaciones Android.</p> <ul> <li>En lenguaje Kotlin</li> </ul> <p>\u00cdndice:</p> <ul> <li>2.1 Primeros pasos</li> <li>2.2 Ciclo de vida de una aplicaci\u00f3n Android</li> <li>2.3 Primera aplicaci\u00f3n</li> <li>2.4 Gesti\u00f3n del estado</li> <li>2.5 Mejorando el c\u00f3digo</li> <li>2.6 Listas en Compose</li> </ul> <p></p>"},{"location":"temas/02/index.html#recursos","title":"\ud83d\udcc1 Recursos","text":"Android y Jetpack ComposeKotlin <ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.  </li> </ul> <ul> <li>Curso: Android con Kotlin (youtube)</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html","title":"2.1. Primeros pasos","text":""},{"location":"temas/02/2.1-primeros-pasos.html#21-primeros-pasos-con-android","title":"2.1 Primeros pasos con Android","text":"<p>En este apartado vamos a dar los primeros pasos en la programaci\u00f3n de aplicaciones para dispositivos m\u00f3viles con Android, y en este punto, la parte fundamental es conocer el entorno de desarrollo Android Studio, y entender los conceptos b\u00e1sicos de la plataforma Android.</p>"},{"location":"temas/02/2.1-primeros-pasos.html#a-instalar-y-configurar-android-studio","title":"A. Instalar y configurar Android Studio","text":"<p>Para comenzar a desarrollar aplicaciones Android, lo primero que necesitas es instalar Android Studio, que es el entorno de desarrollo oficial para Android. Puedes descargarlo desde la p\u00e1gina oficial de Android Studio: https://developer.android.com/studio.</p> <p>Una vez que hayas descargado e instalado Android Studio, sigue estos pasos para configurarlo:</p> <ol> <li>Instalar el SDK de Android: Durante la instalaci\u00f3n de Android Studio, aseg\u00farate de seleccionar la opci\u00f3n para instalar el SDK de Android. Esto es necesario para compilar y ejecutar aplicaciones Android.</li> <li>Configurar un emulador: Android Studio incluye un emulador que te permite probar tus aplicaciones en diferentes dispositivos virtuales. Configura un emulador con las caracter\u00edsticas que desees (tama\u00f1o de pantalla, versi\u00f3n de Android, etc.) desde el AVD Manager (Android Virtual Device Manager).</li> <li>Crear un nuevo proyecto: Una vez que Android Studio est\u00e9 configurado, crea un nuevo proyecto seleccionando y elige una plantilla b\u00e1sica para comenzar.</li> <li>Familiarizarse con la interfaz: T\u00f3mate un tiempo para explorar la interfaz de Android Studio, incluyendo el editor de c\u00f3digo, el dise\u00f1ador de interfaces, el panel de herramientas y la consola de logcat.</li> <li>Ejecutar la aplicaci\u00f3n: Finalmente, ejecuta tu aplicaci\u00f3n en el emulador o en un dispositivo f\u00edsico conectado para asegurarte de que todo est\u00e9 funcionando correctamente.</li> </ol> Video: Instalaci\u00f3n y configuraci\u00f3n de Android Studio <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#b-estructura-de-un-proyecto-android","title":"B. Estructura de un proyecto Android","text":"<p>Un proyecto Android tiene una estructura espec\u00edfica que incluye varios archivos y carpetas importantes. A continuaci\u00f3n, se describen las principales partes de un proyecto Android. Android Studio tiene diferentes vistas para explorar la estructura de un proyecto. La vista \"Android\" es la m\u00e1s com\u00fan y muestra una estructura simplificada y organizada del proyecto.</p> <p>Vamos a explorar las diferentes vistas disponibles en Android Studio para entender mejor la estructura de un proyecto Android en el siguiente v\u00eddeo:</p> Video: Estructura de un proyecto en Android Studio <p></p> <p>La vista m\u00e1s com\u00fan y utilizada es la vista \"Android\", que organiza los archivos y carpetas de manera l\u00f3gica para facilitar la navegaci\u00f3n y el desarrollo. A continuaci\u00f3n, se describen las principales partes de un proyecto Android en la vista \"Android\".</p> <p>Estructura de un proyecto Android</p> <p>Esta es la estructura t\u00edpica de un proyecto Android en la vista \"Android\" de Android Studio:</p> <ul> <li>app: Esta es la carpeta principal que contiene el c\u00f3digo fuente y los recursos de la aplicaci\u00f3n.<ul> <li>manifests: Contiene el archivo <code>AndroidManifest.xml</code>, que define la configuraci\u00f3n b\u00e1sica de la aplicaci\u00f3n, como las actividades, permisos y servicios.</li> <li>java: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n en lenguaje Kotlin o Java. Aqu\u00ed es donde escribir\u00e1s la l\u00f3gica de tu aplicaci\u00f3n.</li> <li>res: Contiene los recursos de la aplicaci\u00f3n, como im\u00e1genes, archivos XML de dise\u00f1o, cadenas de texto y estilos.</li> <li>drawable: Carpeta para almacenar im\u00e1genes y gr\u00e1ficos utilizados en la aplicaci\u00f3n.</li> <li>layout: Carpeta para almacenar archivos XML que definen la interfaz de usuario (UI) de las actividades y fragmentos.</li> <li>values: Carpeta para almacenar archivos XML que contienen recursos como cadenas de texto, colores y estilos.</li> </ul> </li> <li>Gradle Scripts: Contiene los archivos de configuraci\u00f3n de Gradle, que es el sistema de construcci\u00f3n utilizado por Android Studio. Aqu\u00ed puedes definir dependencias, versiones de SDK y otras configuraciones de construcci\u00f3n.</li> <li>build.gradle (Project): Archivo de configuraci\u00f3n a nivel de proyecto.</li> <li>build.gradle (Module: app): Archivo de configuraci\u00f3n a nivel de m\u00f3dulo (aplicaci\u00f3n).</li> <li>settings.gradle: Archivo que define los m\u00f3dulos del proyecto.</li> <li>local.properties: Archivo que contiene la ruta del SDK de Android en tu sistema. Este archivo no debe ser compartido en sistemas de control de versiones.</li> </ul>"},{"location":"temas/02/2.1-primeros-pasos.html#c-estructura-del-buildgradle","title":"C. Estructura del build.gradle","text":"<p>El archivo <code>build.gradle</code> es un archivo de configuraci\u00f3n utilizado por Gradle, el sistema de construcci\u00f3n utilizado por Android Studio. Este archivo define c\u00f3mo se debe construir y empaquetar la aplicaci\u00f3n, as\u00ed como las dependencias necesarias para el proyecto.</p> <p>\u00bfQu\u00e9 es Gradle?</p> <p>Gradle es un sistema de automatizaci\u00f3n de construcci\u00f3n que se utiliza para compilar, probar y empaquetar aplicaciones. En el contexto de Android, Gradle se utiliza para gestionar las dependencias, configurar las variantes de construcci\u00f3n y definir tareas personalizadas.</p> <p>El archivo <code>build.gradle</code> se encuentra en la ra\u00edz del proyecto y en el m\u00f3dulo de la aplicaci\u00f3n (generalmente llamado <code>app</code>). A continuaci\u00f3n, se describen las principales secciones y configuraciones que puedes encontrar en un archivo <code>build.gradle</code> t\u00edpico para un proyecto Android.</p> <p>En el siguiente v\u00eddeo se explica la estructura del archivo <code>build.gradle</code> y c\u00f3mo configurarlo para un proyecto Android.</p> Video: Estructura del build.gradle de App <p></p>"},{"location":"temas/02/2.1-primeros-pasos.html#d-partes-de-la-interfaz-de-android-studio","title":"D. Partes de la interfaz de Android Studio","text":"<p>Android Studio es un entorno de desarrollo integrado (IDE) completo que proporciona una amplia gama de herramientas y caracter\u00edsticas para desarrollar aplicaciones Android. A continuaci\u00f3n, se describen las principales partes de la interfaz de Android Studio:</p> Video: Partes de la interfaz de Android Studio <p></p> Partes de la interfaz de Android Studio <ul> <li> <p>Barra de men\u00fa: La barra de men\u00fa en la parte superior de la ventana proporciona acceso a diversas funciones y configuraciones, como crear nuevos proyectos, abrir archivos, ejecutar aplicaciones y acceder a herramientas de desarrollo.</p> </li> <li> <p>Barra de herramientas: Justo debajo de la barra de men\u00fa, la barra de herramientas contiene botones para acciones comunes, como ejecutar y depurar aplicaciones, sincronizar el proyecto con Gradle y acceder al AVD Manager.</p> </li> <li> <p>Panel del proyecto: En el lado izquierdo de la ventana, el panel del proyecto muestra la estructura del proyecto y permite navegar por los archivos y carpetas del proyecto. Puedes cambiar entre diferentes vistas, como \"Android\", \"Project\" y \"Packages\".</p> </li> <li> <p>Editor de c\u00f3digo: El editor de c\u00f3digo ocupa la mayor parte de la ventana y es donde escribir\u00e1s y editar\u00e1s el c\u00f3digo fuente de tu aplicaci\u00f3n. El editor ofrece caracter\u00edsticas como resaltado de sintaxis, autocompletado y refactorizaci\u00f3n.</p> </li> <li> <p>Dise\u00f1ador de interfaces: Android Studio incluye un dise\u00f1ador visual que te permite crear y editar interfaces de usuario (UI) utilizando un editor gr\u00e1fico. Puedes arrastrar y soltar componentes UI desde una paleta y ajustar sus propiedades.</p> </li> <li> <p>Panel de herramientas: En el lado derecho de la ventana, el panel de herramientas proporciona acceso a diversas herramientas \u00fatiles, como el inspector de dise\u00f1o, el administrador de dispositivos virtuales (AVD Manager) y el administrador de SDK.</p> </li> <li> <p>Consola de logcat: En la parte inferior de la ventana, la consola de logcat muestra los mensajes de registro generados por la aplicaci\u00f3n en ejecuci\u00f3n. Esto es \u00fatil para depurar y solucionar problemas en tu aplicaci\u00f3n.</p> </li> <li> <p>Ventana emergente de terminal: Android Studio incluye una terminal integrada que te permite ejecutar comandos directamente desde el IDE. Puedes abrirla desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Terminal\".</p> </li> <li> <p>Ventana emergente de problemas: Esta ventana muestra advertencias y errores relacionados con el c\u00f3digo fuente y las configuraciones del proyecto. Puedes acceder a ella desde el men\u00fa \"View\" &gt; \"Tool Windows\" &gt; \"Problems\".</p> </li> <li> <p>Ventana emergente de estructura: La ventana emergente de estructura muestra una vista jer\u00e1rquica del archivo actualmente abierto en el editor. Puedes acceder a ella desde el men\u00fa \"</p> </li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html","title":"2.2. Ciclo de Vida","text":""},{"location":"temas/02/2.2-ciclo-vida-app.html#22-ciclo-de-vida-de-una-aplicacion-android","title":"2.2 Ciclo de vida de una aplicaci\u00f3n Android","text":"<p>El ciclo de vida de una aplicaci\u00f3n Android es el conjunto de estados por los que pasa una aplicaci\u00f3n desde que se inicia hasta que se detiene. Comprender el ciclo de vida de una aplicaci\u00f3n es fundamental para desarrollar aplicaciones robustas y eficientes en Android. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#a-componentes-del-ciclo-de-vida","title":"A. Componentes del ciclo de vida","text":"<p>En Android, los componentes del ciclo de vida de una aplicaci\u00f3n son actividades, fragmentos, servicios y receptores de difusi\u00f3n. Cada uno de estos componentes tiene su propio ciclo de vida y se comporta de manera diferente en funci\u00f3n de los eventos que se producen en la aplicaci\u00f3n.</p> <p>Vamos a centrarnos en las Actividades o <code>Activity</code>, que son los componentes principales de una aplicaci\u00f3n Android y representan una \u00fanica pantalla con la que el usuario puede interactuar. </p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#que-es-una-activity","title":"\u00bfQu\u00e9 es una Activity?","text":"<p>Una Activity es uno de los componentes fundamentales de una aplicaci\u00f3n de Android. En t\u00e9rminos simples, una Activity representa una \u00fanica pantalla con una interfaz de usuario (UI). Piensa en cualquier aplicaci\u00f3n que uses: la lista de correos en Gmail, la pantalla para redactar un nuevo email, o la pantalla de configuraci\u00f3n; cada una de estas es, generalmente, una Activity.</p> <p>Sin embargo, su funci\u00f3n va m\u00e1s all\u00e1 de ser solo un contenedor visual. Es el punto de entrada para la interacci\u00f3n del usuario y el lugar donde se aloja la l\u00f3gica de la interfaz. Cada Activity es una clase en tu c\u00f3digo que se encarga de:</p> <ul> <li> <p>Dibujar la interfaz de usuario: Infla los layouts XML que definen la apariencia y la disposici\u00f3n de los elementos en pantalla (botones, texto, im\u00e1genes, etc.).</p> </li> <li> <p>Gestionar eventos del usuario: Responde a las interacciones del usuario, como toques en botones, deslizamientos o entradas de texto.</p> </li> <li> <p>Coordinar la l\u00f3gica de la pantalla: Ejecuta el c\u00f3digo necesario para que esa pantalla funcione como se espera.</p> </li> </ul> <p>Una aplicaci\u00f3n suele estar compuesta por m\u00faltiples Activities que se comunican entre s\u00ed. Por ejemplo, una Activity puede iniciar otra para realizar una acci\u00f3n diferente. Cuando una nueva Activity se inicia, la anterior se detiene y se coloca en una pila (conocida como \"back stack\" o pila de retroceso). Esto permite al usuario navegar hacia atr\u00e1s presionando el bot\u00f3n correspondiente. </p> Video: \u00bfQu\u00e9 es una Activity en Android? <p></p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#estados-de-una-actividad","title":"Estados de una actividad","text":"<p>Las actividades en Android pueden estar en uno de los siguientes estados:</p> <ul> <li>Created: La actividad ha sido creada pero a\u00fan no es visible para el usuario.</li> <li>Started: La actividad es visible para el usuario pero no tiene el foco.</li> <li>Resumed: La actividad est\u00e1 en primer plano y tiene el foco.</li> <li>Paused: La actividad ha perdido el foco pero a\u00fan es visible para el usuario.</li> <li>Stopped: La actividad ya no es visible para el usuario.</li> <li>Destroyed: La actividad ha sido destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#metodos-del-ciclo-de-vida","title":"M\u00e9todos del ciclo de vida","text":"<p>En Android, cada actividad tiene una serie de m\u00e9todos que se invocan en funci\u00f3n de su estado en el ciclo de vida. Algunos de los m\u00e9todos m\u00e1s comunes son:</p> <ul> <li><code>onCreate()</code>: Se llama cuando la actividad se crea por primera vez.</li> <li><code>onStart()</code>: Se llama cuando la actividad se hace visible para el usuario.</li> <li><code>onResume()</code>: Se llama cuando la actividad obtiene el foco y se convierte en activa.</li> <li><code>onPause()</code>: Se llama cuando la actividad pierde el foco pero a\u00fan es visible.</li> <li><code>onStop()</code>: Se llama cuando la actividad ya no es visible para el usuario.</li> <li><code>onDestroy()</code>: Se llama cuando la actividad es destruida y liberada de la memoria.</li> </ul>"},{"location":"temas/02/2.2-ciclo-vida-app.html#ejemplo-de-ciclo-de-vida-de-una-actividad","title":"Ejemplo de ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra un ejemplo del ciclo de vida de una actividad en Android:</p> <pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        Log.d(\"MainActivity\", \"onCreate\")\n    }\n\n    override fun onStart() {\n        super.onStart()\n        Log.d(\"MainActivity\", \"onStart\")\n    }\n\n    override fun onResume() {\n        super.onResume()\n        Log.d(\"MainActivity\", \"onResume\")\n    }\n\n    override fun onPause() {\n        super.onPause()\n        Log.d(\"MainActivity\", \"onPause\")\n    }\n\n    override fun onStop() {\n        super.onStop()\n        Log.d(\"MainActivity\", \"onStop\")\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        Log.d(\"MainActivity\", \"onDestroy\")\n    }\n}\n</code></pre> <p>En el ejemplo anterior, se define una actividad <code>MainActivity</code> con los m\u00e9todos del ciclo de vida m\u00e1s comunes. Cada m\u00e9todo imprime un mensaje de registro en la consola para indicar en qu\u00e9 estado se encuentra la actividad.</p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#imagen-del-ciclo-de-vida-de-una-actividad","title":"Imagen del ciclo de vida de una actividad","text":"<p>A continuaci\u00f3n, se muestra una imagen que representa el ciclo de vida de una actividad en Android:</p> <p></p> <p>C\u00f3mo podemos observar, el ciclo de vida de una actividad en Android consta de varios estados y transiciones entre ellos. </p> <p>Es importante comprender estos estados para gestionar correctamente el ciclo de vida de una aplicaci\u00f3n Android.</p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#la-activity-el-contenedor-principal-de-tu-pantalla","title":"La activity: El contenedor Principal de tu Pantalla","text":"<p>Imagina una aplicaci\u00f3n como una obra de teatro. La Activity ser\u00eda el escenario principal donde se desarrolla un acto completo. En t\u00e9rminos m\u00e1s t\u00e9cnicos, una <code>Activity</code> es un componente de la aplicaci\u00f3n que proporciona una pantalla con la que los usuarios pueden interactuar para hacer algo, como marcar un n\u00famero de tel\u00e9fono, tomar una foto, enviar un correo electr\u00f3nico o ver un mapa. Cada <code>Activity</code> recibe una ventana en la que puede dibujar su interfaz de usuario.</p> <p>Piensa en las aplicaciones que usas a diario. Cuando abres tu cliente de correo, la lista de correos es probablemente una <code>Activity</code>. Al hacer clic en un correo, se abre una nueva pantalla para leerlo; esa es otra <code>Activity</code>.</p> <p>Ejemplo Pr\u00e1ctico:</p> <p>Supongamos que estamos creando una aplicaci\u00f3n de notas simple. La pantalla principal que muestra la lista de todas las notas ser\u00eda nuestra <code>MainActivity</code>.</p> <pre><code>// MainActivity.kt\nimport androidx.appcompat.app.AppCompatActivity\nimport android.os.Bundle\n\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        // Aqu\u00ed inicializar\u00edamos la lista de notas, etc.\n    }\n}\n</code></pre> <p>Y su correspondiente layout en XML:</p> <pre><code>&lt;!-- activity_main.xml --&gt;\n&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\"&gt;\n\n    &lt;ListView\n        android:id=\"@+id/notes_list\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\" /&gt;\n\n&lt;/LinearLayout&gt;\n</code></pre>"},{"location":"temas/02/2.2-ciclo-vida-app.html#practicamos-etapas-del-ciclo-de-vida","title":"\ud83d\ude80 Pr\u00e1cticamos: Etapas del ciclo de vida","text":"<p>Para esta pr\u00e1ctica, vamos a ejecutar una App, y probar cada una de las etapas del ciclo de vida..</p> <p>Para ello, realiza el siguiente Codelab:</p> <ul> <li>Etapas del ciclo de vida de la actividad Codelab.</li> </ul> <p></p>"},{"location":"temas/02/2.2-ciclo-vida-app.html#el-ciclo-de-vida-de-la-activity-nacer-vivir-y-morir","title":"El Ciclo de Vida de la Activity: Nacer, Vivir y Morir","text":"<p>Una <code>Activity</code> no existe de forma est\u00e1tica; pasa por diferentes estados a lo largo de su existencia, desde que se crea hasta que se destruye. Este es el famoso ciclo de vida de la Activity, y entenderlo es absolutamente crucial para construir aplicaciones robustas y evitar errores, como fugas de memoria o fallos inesperados.</p> <p>El sistema operativo Android gestiona estos estados a trav\u00e9s de una serie de m\u00e9todos que puedes sobrescribir en tu clase <code>Activity</code>:</p> <ul> <li><code>onCreate()</code>: Es el primer m\u00e9todo que se llama cuando se crea la <code>Activity</code>. Aqu\u00ed es donde debes realizar toda la inicializaci\u00f3n est\u00e1tica: crear vistas, vincular datos a listas, etc. Este m\u00e9todo recibe un <code>Bundle</code> que contiene el estado previamente guardado de la actividad, si es que existe (por ejemplo, despu\u00e9s de una rotaci\u00f3n de pantalla).</li> <li><code>onStart()</code>: Se llama cuando la <code>Activity</code> est\u00e1 a punto de hacerse visible para el usuario.</li> <li><code>onResume()</code>: Se invoca cuando la <code>Activity</code> ya es visible y el usuario puede empezar a interactuar con ella. La <code>Activity</code> permanece en este estado hasta que algo interrumpe el foco, como una llamada telef\u00f3nica entrante o la navegaci\u00f3n a otra <code>Activity</code>.</li> <li><code>onPause()</code>: Es la contraparte de <code>onResume()</code>. Se llama cuando la <code>Activity</code> est\u00e1 a punto de pasar a segundo plano, pero a\u00fan es parcialmente visible. Aqu\u00ed deber\u00edas detener operaciones que consuman muchos recursos y que no necesiten ejecutarse mientras la <code>Activity</code> no est\u00e1 en primer plano.</li> <li><code>onStop()</code>: Se llama cuando la <code>Activity</code> ya no es visible para el usuario. Esto puede ocurrir porque se ha iniciado una nueva <code>Activity</code> que la cubre por completo o porque el usuario ha vuelto a la pantalla de inicio.</li> <li><code>onRestart()</code>: Se invoca justo antes de que una <code>Activity</code> que estaba detenida (<code>onStop()</code>) vuelva a iniciarse.</li> <li><code>onDestroy()</code>: Es la llamada final antes de que la <code>Activity</code> sea destruida. Esto puede suceder porque la aplicaci\u00f3n se est\u00e1 cerrando, o porque el sistema necesita liberar memoria.</li> </ul> <p>Visual\u00edzalo como el viaje de un personaje en nuestra obra de teatro: entra en escena (<code>onCreate</code>, <code>onStart</code>, <code>onResume</code>), interact\u00faa con el p\u00fablico (<code>onResume</code>), otro personaje le quita el foco temporalmente (<code>onPause</code>), sale del escenario (<code>onStop</code>), y finalmente, termina su papel en la obra (<code>onDestroy</code>).</p> <p>\u00bfUna Activity por cada Pantalla?.</p> <p>Esta es una pregunta importante y la respuesta ha evolucionado con el tiempo.</p> <p>En los inicios de Android, la respuesta habr\u00eda sido un rotundo \"s\u00ed\". Cada pantalla completa de tu aplicaci\u00f3n se implementaba como una <code>Activity</code> separada. Por lo tanto, para una aplicaci\u00f3n con 5 pantallas, tendr\u00edas 5 archivos de <code>Activity</code> (por ejemplo, <code>LoginActivity.kt</code>, <code>HomeActivity.kt</code>, <code>ProfileActivity.kt</code>, <code>SettingsActivity.kt</code>, <code>DetailActivity.kt</code>) y 5 archivos de layout XML correspondientes.</p> <p>Sin embargo, esta no es la pr\u00e1ctica recomendada hoy en d\u00eda, ni siquiera en el mundo del XML.</p> <p>La introducci\u00f3n de los <code>Fragment</code>s cambi\u00f3 las reglas del juego. La arquitectura moderna, incluso antes de Jetpack Compose, aboga por una Arquitectura de Actividad \u00danica (Single Activity Architecture).</p> <p>Arquitectura de Actividad \u00danica (Single Activity Architecture)</p> <p>Significa que tu aplicaci\u00f3n podr\u00eda tener una \u00fanica <code>Activity</code> (por ejemplo, <code>MainActivity.kt</code>) que act\u00faa como el contenedor principal, y las \"pantallas\" diferentes ser\u00edan en realidad <code>Fragment</code>s distintos. La navegaci\u00f3n entre pantallas consistir\u00eda en reemplazar un <code>Fragment</code> por otro dentro de la misma <code>Activity</code>.</p> <p>\ud83c\udfaf Revisa el siguiente cuadro para conocer c\u00f3mo funciona el dise\u00f1o de Android antes de Jetpack compose.</p> En profundidad. Desarrollo Android antes de Compose \ud83e\udde9 <p>A: El Fragment: Piezas Modulares y Reutilizables de tu Interfaz</p> <p>Ahora, volvamos a nuestro escenario teatral. Si la <code>Activity</code> es el acto completo, un Fragment ser\u00eda un actor o un conjunto de actores con su propio guion y comportamiento. Un <code>Fragment</code> representa una porci\u00f3n reutilizable de la interfaz de usuario de tu aplicaci\u00f3n. No puede existir por s\u00ed solo; debe ser alojado por una <code>Activity</code> u otro <code>Fragment</code>.</p> <p>Piensa en una aplicaci\u00f3n de noticias en una tablet. Podr\u00edas tener una <code>Activity</code> principal que, en la parte izquierda, muestra una lista de titulares (un <code>Fragment</code>) y, en la parte derecha, muestra el contenido del titular seleccionado (otro <code>Fragment</code>). En un tel\u00e9fono, debido al menor espacio, la <code>Activity</code> podr\u00eda mostrar solo la lista de titulares. Al seleccionar uno, se reemplazar\u00eda el <code>Fragment</code> de la lista por el del contenido. \u00a1Es la misma l\u00f3gica y c\u00f3digo de <code>Fragment</code>, pero reutilizado en diferentes contextos!</p> <p>Relaci\u00f3n entre Activity y Fragment:</p> <ul> <li>Contenedor-Contenido: La <code>Activity</code> es el contenedor, y el <code>Fragment</code> es una parte de su contenido.</li> <li>Ciclo de Vida Anidado: El ciclo de vida de un <code>Fragment</code> est\u00e1 directamente ligado al de su <code>Activity</code> anfitriona. Por ejemplo, cuando la <code>Activity</code> se pausa (<code>onPause()</code>), todos los <code>Fragment</code>s dentro de ella tambi\u00e9n reciben su llamada a <code>onPause()</code>. Sin embargo, el <code>Fragment</code> tiene m\u00e9todos de ciclo de vida adicionales propios, como <code>onAttach()</code> (cuando se asocia a la <code>Activity</code>), <code>onCreateView()</code> (cuando dibuja su propia interfaz) y <code>onDetach()</code> (cuando se desvincula).</li> <li>Comunicaci\u00f3n: La <code>Activity</code> puede pasar datos a sus <code>Fragment</code>s, y los <code>Fragment</code>s pueden comunicarse con su <code>Activity</code> (y a trav\u00e9s de ella, con otros <code>Fragments</code> ) para coordinar acciones.</li> </ul> <p>Ventajas de la Arquitectura de Actividad \u00danica con Fragments</p> <ol> <li>Rendimiento y Eficiencia: Cambiar entre <code>Fragment</code>s es mucho m\u00e1s ligero y r\u00e1pido que iniciar <code>Activities</code> completamente nuevas, que son componentes m\u00e1s pesados del sistema.</li> <li>Facilidad para Compartir Datos: Es mucho m\u00e1s sencillo compartir datos y estados entre <code>Fragment</code>s que est\u00e1n en la misma <code>Activity</code> (usando un <code>ViewModel</code> compartido, por ejemplo) que pasar datos complejos entre <code>Activities</code>.</li> <li>Experiencia de Usuario Fluida: Las transiciones y animaciones entre <code>Fragment</code>s son m\u00e1s f\u00e1ciles de implementar y se sienten m\u00e1s integradas.</li> <li>Modularidad: Fomenta la creaci\u00f3n de componentes de UI reutilizables.</li> </ol> <p>Entonces, para una aplicaci\u00f3n de 5 pantallas, la aproximaci\u00f3n moderna (XML) ser\u00eda:</p> <ul> <li>1 Activity: <code>MainActivity.kt</code> con su layout. Este layout tendr\u00eda un contenedor, como un <code>FrameLayout</code> o un <code>FragmentContainerView</code>, donde se alojar\u00e1n los <code>Fragment</code>s.</li> <li>5 Fragments: Cada uno con su propio archivo de clase Kotlin y su archivo de layout. Por ejemplo, <code>LoginFragment.kt</code> con <code>fragment_login.xml</code>, <code>HomeFragment.kt</code> con <code>fragment_home.xml</code>, etc.</li> </ul> <p>B: Ciclo de Vida en la arquitectura de Actividad \u00fanica con Fragments</p> <p>\u00bfLa pregunta l\u00f3gica entonces ser\u00eda? Si solo tengo una Actividad, \u00bfc\u00faal ser\u00eda su ciclo de vida? y \u00bfc\u00f3mo afectar\u00eda si el usuario se desplaza de una pantalla a otra de la Aplicaci\u00f3n?</p> <p>La respuesta corta y fundamental es: el ciclo de vida de la <code>Activity</code> ya no se ve afectado por la navegaci\u00f3n interna de la aplicaci\u00f3n, sino \u00fanicamente por eventos que afectan a la ventana de la aplicaci\u00f3n en su totalidad.</p> <p>Vamos a desglosarlo con detalle, manteniendo nuestra analog\u00eda del teatro.</p> <p>Nuestra <code>MainActivity</code> es el teatro entero. Los <code>Fragment</code>s son los actos o escenas que ocurren en su \u00fanico escenario.</p> <p>El Rol Inmutable del Ciclo de Vida de la Activity</p> <p>En un modelo de Actividad \u00danica, los m\u00e9todos del ciclo de vida de tu <code>MainActivity</code> (<code>onCreate</code>, <code>onStart</code>, <code>onResume</code>, <code>onPause</code>, <code>onStop</code>, <code>onDestroy</code>) se seguir\u00e1n llamando, pero las razones para que se llamen son diferentes y m\u00e1s simples de predecir.</p> <p>Piensa en el ciclo de vida de la <code>Activity</code> como el estado del \"teatro\":</p> <ul> <li><code>onCreate()</code>: El teatro se construye por primera vez. Esto pasa solo una vez al iniciar la app.</li> <li><code>onStart()</code> / <code>onResume()</code>: Se abren las puertas del teatro y las luces del escenario se encienden. El espect\u00e1culo est\u00e1 en curso y el p\u00fablico (el usuario) est\u00e1 prestando atenci\u00f3n. La <code>Activity</code> est\u00e1 en primer plano y es interactiva.</li> <li><code>onPause()</code> / <code>onStop()</code>: Las luces del escenario se aten\u00faan o se apagan. El espect\u00e1culo se detiene. Esto ocurre cuando algo externo interrumpe la aplicaci\u00f3n. Por ejemplo:<ul> <li>El usuario presiona el bot\u00f3n \"Home\" del dispositivo.</li> <li>El usuario presiona el bot\u00f3n \"Recientes\" para cambiar a otra aplicaci\u00f3n.</li> <li>Recibes una llamada telef\u00f3nica que aparece sobre tu aplicaci\u00f3n.</li> <li>Aparece un di\u00e1logo de permisos del sistema.</li> </ul> </li> <li><code>onDestroy()</code>: El teatro va a ser demolido. Esto sucede cuando el usuario cierra la aplicaci\u00f3n o si el sistema operativo necesita recuperar memoria de forma agresiva.</li> </ul> <p>Como puedes ver, ninguno de estos eventos tiene que ver con cambiar de la \"pantalla de lista\" a la \"pantalla de detalle\". El cambio entre <code>Fragment</code>s es un evento interno. Para el sistema operativo, el \"teatro\" (<code>MainActivity</code>) ha permanecido abierto, con las luces encendidas y el p\u00fablico atento todo el tiempo.</p> <p>El Doble Ciclo de Vida en Acci\u00f3n: Activity vs. Fragment</p> <p>Aqu\u00ed es donde reside la magia y la clave de la pregunta. Cuando navegas de un <code>Fragment</code> a otro, est\u00e1s operando con el ciclo de vida del <code>Fragment</code>, mientras que el ciclo de vida de la <code>Activity</code> permanece estable.</p> <p>Veamos el escenario exacto:</p> <p>Tu aplicaci\u00f3n est\u00e1 en <code>HomeFragment</code> y el usuario hace clic en un elemento para ir a <code>DetailFragment</code>.</p> <ol> <li> <p>Estado Inicial:</p> <ul> <li><code>MainActivity</code>: Est\u00e1 en el estado <code>RESUMED</code> (ha pasado por <code>onCreate</code>, <code>onStart</code>, <code>onResume</code>). Su estado no va a cambiar.</li> <li><code>HomeFragment</code>: Tambi\u00e9n est\u00e1 en el estado <code>RESUMED</code> (ha pasado por su propio ciclo de vida: <code>onAttach</code>, <code>onCreate</code>, <code>onCreateView</code>, <code>onStart</code>, <code>onResume</code>).</li> </ul> </li> <li> <p>El Usuario Inicia la Navegaci\u00f3n (hace clic):</p> <ul> <li>El <code>FragmentManager</code> (o la librer\u00eda de Navegaci\u00f3n de Jetpack) recibe la orden de reemplazar <code>HomeFragment</code> con <code>DetailFragment</code>.</li> </ul> </li> <li> <p>El Ciclo de Vida de los Fragments se Activa:</p> <ul> <li> <p><code>HomeFragment</code> (el que se va): El sistema lo retira del escenario. Pasa por su ciclo de vida de \"destrucci\u00f3n de vista\":</p> <ul> <li><code>onPause()</code></li> <li><code>onStop()</code></li> <li><code>onDestroyView()</code> (\u00a1Muy importante! Su l\u00f3gica se va, pero su vista (el layout XML) es lo que se destruye).</li> <li>Si no se a\u00f1ade a la \"pila de retroceso\" (back stack), tambi\u00e9n pasar\u00e1 por <code>onDestroy()</code> y <code>onDetach()</code>. Si se a\u00f1ade, el objeto del fragmento permanece en memoria.</li> </ul> </li> <li> <p><code>DetailFragment</code> (el que llega): El sistema lo pone en el escenario. Pasa por su ciclo de vida de \"creaci\u00f3n\":</p> <ul> <li><code>onAttach()</code> (se engancha a la <code>MainActivity</code>).</li> <li><code>onCreate()</code> (se inicializa el fragmento).</li> <li><code>onCreateView()</code> (infla su layout XML para convertirse en una vista).</li> <li><code>onStart()</code></li> <li><code>onResume()</code> (ahora es visible e interactivo para el usuario).</li> </ul> </li> </ul> </li> <li> <p>Estado Final (Temporal):</p> <ul> <li><code>MainActivity</code>: Sigue en <code>RESUMED</code>. No se ha enterado del cambio a nivel de su propio ciclo de vida. Para ella, todo sigue igual.</li> <li><code>HomeFragment</code>: Su vista ha sido destruida.</li> <li><code>DetailFragment</code>: Est\u00e1 en el estado <code>RESUMED</code>.</li> </ul> </li> </ol> <p>\u00bfQu\u00e9 pasa si el usuario presiona el bot\u00f3n \"Atr\u00e1s\"? El proceso se invierte. <code>DetailFragment</code> es destruido y <code>HomeFragment</code> se vuelve a crear (pasa por <code>onCreateView</code> de nuevo) para mostrarse en pantalla. Y durante todo este proceso, <code>MainActivity</code> sigue felizmente en su estado <code>RESUMED</code>.</p> <p>Las Reglas de Oro del Ciclo de Vida en una Actividad \u00danica</p> <p>Para que te quede grabado, aqu\u00ed tienes las reglas fundamentales:</p> <ol> <li>El Ciclo de Vida de la <code>Activity</code> gestiona el estado de la ventana de la aplicaci\u00f3n. \u00bfEst\u00e1 tu app en primer plano o en segundo plano? \u00bfLa est\u00e1n interrumpiendo?</li> <li>El Ciclo de Vida del <code>Fragment</code> gestiona el estado de una porci\u00f3n de la UI dentro de la ventana de la aplicaci\u00f3n. \u00bfEst\u00e1 esta porci\u00f3n de UI visible en pantalla o no?</li> <li>La <code>Activity</code> es la directora de orquesta; el <code>Fragment</code> es un m\u00fasico. Cuando la directora (Activity) dice \"pausa\" (porque llega una llamada), todos los m\u00fasicos (Fragments activos) tambi\u00e9n pausan. Pero un m\u00fasico puede dejar de tocar y ser reemplazado por otro sin que la directora altere el tempo general de la orquesta.</li> </ol> <p>Entender esta separaci\u00f3n es la clave para dominar el desarrollo moderno de Android (incluso en Compose, donde los conceptos de ciclo de vida siguen siendo vitales) y para crear aplicaciones eficientes, r\u00e1pidas y sin fugas de memoria.</p>"},{"location":"temas/02/2.3-primera-app.html","title":"2.3. Primera aplicaci\u00f3n","text":""},{"location":"temas/02/2.3-primera-app.html#23-mi-primera-aplicacion-android","title":"2.3 Mi primera aplicaci\u00f3n Android","text":"<p>Para desarrollar una aplicaci\u00f3n Android, debemos decidir si vamos a utilizar la interfaz tradicional basada en XML o la m\u00e1s moderna basada en Jetpack Compose. En este apartado, vamos a crear una aplicaci\u00f3n sencilla utilizando ambas tecnolog\u00edas.</p>"},{"location":"temas/02/2.3-primera-app.html#1-aplicacion-con-interfaz-basada-en-xml","title":"1. Aplicaci\u00f3n con interfaz basada en XML","text":"<p>En el siguiente video, se indica de forma detallada cada uno de los componentes que conforman una aplicaci\u00f3n Android con interfaz basada en XML.</p> Video: Mi primera aplicaci\u00f3n Android con interfaz basada en XML <p></p>"},{"location":"temas/02/2.3-primera-app.html#2-aplicacion-con-interfaz-basada-en-jetpack-compose","title":"2. Aplicaci\u00f3n con interfaz basada en Jetpack Compose","text":"<p>Jetpack Compose es un moderno toolkit de UI para construir interfaces de usuario nativas en Android. Caracter\u00edsticas principales de Jetpack Compose:</p> <ul> <li>Declarativo: Con Compose, defines la interfaz de usuario de tu aplicaci\u00f3n de manera declarativa, lo que significa que puedes describir c\u00f3mo se ve tu aplicaci\u00f3n en funci\u00f3n del estado de la misma. Esto hace que sea m\u00e1s f\u00e1cil de entender y mantener tu c\u00f3digo.  </li> <li>Composable functions: En Compose, las interfaces de usuario se crean a partir de funciones componibles, que son funciones que devuelven un \u00e1rbol de elementos de la interfaz de usuario. Puedes componer estas funciones para crear interfaces de usuario complejas y reutilizables.  </li> <li>State management: Compose tiene un sistema de manejo de estado integrado que te permite gestionar el estado de tu aplicaci\u00f3n de manera sencilla y eficiente. Puedes definir y observar el estado de tu aplicaci\u00f3n de forma reactiva.  </li> <li>Material Design: Compose incluye un conjunto de widgets y estilos basados en Material Design, el lenguaje de dise\u00f1o de Google para aplicaciones Android. Puedes utilizar estos widgets y estilos para crear interfaces de usuario modernas y atractivas.  </li> <li>Preview en tiempo real: Compose incluye una funci\u00f3n de vista previa en tiempo real que te permite ver c\u00f3mo se ver\u00e1 tu interfaz de usuario mientras escribes c\u00f3digo. Esto hace que sea m\u00e1s f\u00e1cil iterar y probar tu dise\u00f1o.  </li> </ul> <p>Introducci\u00f3n a Compose</p> <p>Es fundamental leer la documentaci\u00f3n oficial para obtener m\u00e1s informaci\u00f3n. A lo largo del curso, se ir\u00e1n indicando tarjetas con puntos clave de acceso a la documentaci\u00f3n oficial.</p> Video: \u00bfPor qu\u00e9 usar Jetpack Compose? <p></p> <p>Y qu\u00e9 \u00bfdiferencias existen versus una aplicaci\u00f3n con interfaz basada en XML?. En el siguiente video os dejo un ejemplo pr\u00e1ctico comparando ambas tecnolog\u00edas.</p> Video: Aplicaci\u00f3n XML vs Jetpack Compose <p></p>"},{"location":"temas/02/2.3-primera-app.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.3-primera-app.html#proyecto-guiado-aplicacion-de-tarjeta-de-cumpleanos","title":"\ud83d\ude80 Proyecto guiado: Aplicaci\u00f3n de \"Tarjeta de cumplea\u00f1os\"","text":"<p>Para esta pr\u00e1ctica, vamos a crear una sencilla aplicaci\u00f3n de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. La aplicaci\u00f3n mostrar\u00e1 un mensaje de felicitaci\u00f3n y una imagen.</p> <p>\u2b06\ufe0f Proyecto</p> <p>Proyecto. App de tarjetas de presentaci\u00f3n. Sigue las indicaciones aqu\u00ed.</p> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li> <p>Codelab. Dise\u00f1ar una app de tarjeta de cumplea\u00f1os utilizando Jetpack Compose. Realiza el siguiente Codelab.</p> </li> <li> <p>Codelab. Agregar im\u00e1genes a nuestra primera App. Realiza el siguiente Codelab de la plataforma oficial de Android.</p> </li> <li> <p>Codelab. Vamos tambi\u00e9n a resolver algunos problemas pr\u00e1cticas en el siguiente Codelab.</p> </li> </ol> <p></p>"},{"location":"temas/02/2.3-primera-app.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<p>Utiliza los siguientes recursos para profundizar en aspectos espec\u00edficos vistos en este apartado.</p> <ul> <li>Box, Colum y Row en Jetpack Compose</li> <li>Modifiers en Jetpack Compose</li> <li>Texto en Jetpack Compose</li> <li>Cargar im\u00e1genes e iconos en Jetpack Compose. Utilizar Coil para cargar im\u00e1genes desde Internet.</li> </ul>"},{"location":"temas/02/2.4-gestion-estado.html","title":"2.4. Gesti\u00f3n del estado","text":""},{"location":"temas/02/2.4-gestion-estado.html#24-gestion-del-estado","title":"2.4 Gesti\u00f3n del estado","text":"<p>Una aplicaci\u00f3n sin estado, es una aplicaci\u00f3n est\u00e1tica, es decir, que muestra sus elementos y estos son siempre fijos a lo largo del tiempo, ninguna acci\u00f3n puede cambiarlos.</p> <p>Importante</p> <p>dominar la gesti\u00f3n del estado en Compose no es una opci\u00f3n, es el requisito principal para construir aplicaciones que funcionen correctamente, sean f\u00e1ciles de mantener y est\u00e9n libres de errores impredecibles.</p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n de la gesti\u00f3n del estado</p>"},{"location":"temas/02/2.4-gestion-estado.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.4-gestion-estado.html#proyecto-guiados-aplicacion-app-clicks-y-calculadora-de-propinas","title":"\ud83d\ude80 Proyecto guiados: Aplicaci\u00f3n \"App Clicks\" y \"Calculadora de propinas","text":"<p>En estas pr\u00e1ctica ten\u00e9is que crear 2 aplicaciones.</p> <ul> <li> <p>\u2b06\ufe0f Proyecto</p> <p>Para esta pr\u00e1ctica, vamos a crear una aplicaci\u00f3n que nos va cambiar la imagen en base a un n\u00famero de clicks.</p> <p>Proyecto. App Clicks. Sigue las indicaciones aqu\u00ed.</p> Video: Explicaci\u00f3n paso de la realizaci\u00f3n de la Actividad <p></p> </li> </ul> <p></p> <ul> <li> <p>\u2b06\ufe0f Proyecto</p> <p>Para esta pr\u00e1ctica, vamos a crear una aplicaci\u00f3n que nos va a permitir calcular las propinas en un restaurante.</p> <p>Proyecto. Calculadora de propinas. Sigue las indicaciones aqu\u00ed.</p> Video: Explicaci\u00f3n paso de la realizaci\u00f3n de la Actividad <p> </p> </li> </ul> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>\u00bfQu\u00e9 vas a aprender?\"</p> <ul> <li>Manejo del estado</li> <li>Crear componentes reutilizables </li> <li>Para ello, vamos a realizar los siguientes proyectos guiados:</li> </ul> <ol> <li>Codelab. C\u00f3mo crear una app interactiva de \"Dice Roller\". </li> <li>Codelab. Introducci\u00f3n al estado en Compose. Realiza el siguiente Codelab.</li> </ol> <p> </p>"},{"location":"temas/02/2.4-gestion-estado.html#recursos","title":"\ud83d\udcc1 Recursos","text":"<p>Utiliza los siguientes recursos para profundizar en aspectos espec\u00edficos vistos en este apartado.</p> <ul> <li>El estado y Jetpack Compose</li> <li>Video: Tu App Android con dise\u00f1o Material con AppBar y Scaffold</li> </ul>"},{"location":"temas/02/2.5-mejorando-codigo.html","title":"2.5. Mejorando el c\u00f3digo","text":""},{"location":"temas/02/2.5-mejorando-codigo.html#mejorar-para-reestructurar-el-codigo-en-jetpack-compose","title":"Mejorar para reestructurar el c\u00f3digo en Jetpack Compose","text":"<p>Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad tambi\u00e9n puede llevar a que el c\u00f3digo crezca r\u00e1pidamente y se vuelva desordenado.</p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-1-crea-un-composable-base-para-tu-aplicacion","title":"\u2705 Consejo 1: Crea un Composable Base para tu Aplicaci\u00f3n","text":"<p>El Problema: Ciertas configuraciones, como aplicar el tema de Material Design (<code>MaterialTheme</code>) o un color de fondo base con <code>Surface</code>, deben repetirse en cada pantalla y en cada <code>@Preview</code> para que se vean correctamente. Esto genera mucho c\u00f3digo duplicado.</p> <p>La Soluci\u00f3n: Encapsula toda esta configuraci\u00f3n com\u00fan en un \u00fanico Composable que sirva como la base para toda tu aplicaci\u00f3n y tus vistas previas.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: Tu <code>MainActivity</code> podr\u00eda verse as\u00ed, con la configuraci\u00f3n directamente en <code>setContent</code>.</li> </ul> <pre><code>class MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyMoviesTheme { // Aplicando el tema\n                // Un contenedor Surface que usa el color de fondo del tema\n                Surface(color = MaterialTheme.colors.background) {\n                    MainScreen() // La pantalla principal\n                }\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Extraemos esa l\u00f3gica a un nuevo Composable.</li> </ul> <p></p><pre><code>// Archivo: ui/MyMoviesApp.kt\n\n@Composable\nfun MyMoviesApp(content: @Composable () -&gt; Unit) {\n    MyMoviesTheme {\n        Surface(color = MaterialTheme.colors.background) {\n            content() // Aqu\u00ed se insertar\u00e1 el contenido espec\u00edfico de cada pantalla\n        }\n    }\n}\n\n// Ahora, tu MainActivity es mucho m\u00e1s limpia:\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContent {\n            MyMoviesApp {\n                MainScreen()\n            }\n        }\n    }\n}\n</code></pre> Ahora puedes reutilizar <code>MyMoviesApp</code> en todas tus <code>@Preview</code> para asegurar consistencia visual.<p></p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-2-divide-los-composables-grandes-en-otros-mas-pequenos","title":"\u2705 Consejo 2: Divide los Composables Grandes en Otros m\u00e1s Peque\u00f1os","text":"<p>El Problema: Una funci\u00f3n Composable puede crecer hasta tener cientos de l\u00edneas, mezclando la l\u00f3gica de una barra de navegaci\u00f3n, una lista, botones, etc. Esto dificulta la lectura y el mantenimiento.</p> <p>La Soluci\u00f3n: Aplica el principio de responsabilidad \u00fanica. Crea funciones Composable peque\u00f1as y con nombres descriptivos (sem\u00e1nticos) que hagan una sola cosa.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: La <code>TopAppBar</code> se define directamente dentro del <code>Scaffold</code>, haciendo el c\u00f3digo m\u00e1s denso.</li> </ul> <pre><code>@Composable\nfun MainScreen() {\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(text = stringResource(id = R.string.app_name)) },\n                actions = {\n                    IconButton(onClick = { /* TODO */ }) {\n                        Icon(imageVector = Icons.Default.Search, contentDescription = null)\n                    }\n                    IconButton(onClick = { /* TODO */ }) {\n                        Icon(imageVector = Icons.Default.Share, contentDescription = null)\n                    }\n                }\n            )\n        }\n    ) { padding -&gt;\n        // Contenido de la pantalla\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Extraemos la <code>TopAppBar</code> a su propia funci\u00f3n.</li> </ul> <pre><code>// Archivo: ui/screens/main/MainAppBar.kt\n\n@Composable\nfun MainAppBar() {\n    TopAppBar(\n        title = { Text(text = stringResource(id = R.string.app_name)) },\n        actions = {\n            // Podr\u00edamos incluso extraer estos botones a otro Composable si fueran m\u00e1s complejos\n            IconButton(onClick = { /* TODO */ }) {\n                Icon(imageVector = Icons.Default.Search, contentDescription = null)\n            }\n            IconButton(onClick = { /* TODO */ }) {\n                Icon(imageVector = Icons.Default.Share, contentDescription = null)\n            }\n        }\n    )\n}\n\n// Ahora el Scaffold es mucho m\u00e1s legible:\n@Composable\nfun MainScreen() {\n    Scaffold(\n        topBar = { MainAppBar() }\n    ) { padding -&gt;\n        // Contenido de la pantalla\n    }\n}\n</code></pre>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-3-crea-composables-que-definan-una-pantalla-completa","title":"\u2705 Consejo 3: Crea Composables que Definan una Pantalla Completa","text":"<p>El Problema: Si tu aplicaci\u00f3n tiene varias pantallas (inicio, detalle, perfil), colocar la l\u00f3gica de todas ellas en <code>MainActivity</code> es insostenible.</p> <p>La Soluci\u00f3n: Crea un Composable de alto nivel para cada pantalla. Esta funci\u00f3n ser\u00e1 la responsable de construir la UI completa de esa pantalla, incluyendo su <code>Scaffold</code>, <code>TopAppBar</code>, etc.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: La l\u00f3gica del <code>Scaffold</code> estaba directamente en <code>setContent</code> o en un Composable base.</li> <li>Despu\u00e9s: Creamos un Composable que representa la pantalla principal.</li> </ul> <pre><code>// Archivo: ui/screens/main/MainScreen.kt\n\n@Composable\nfun MainScreen() {\n    // Scaffold define la estructura b\u00e1sica de la pantalla (barra superior, contenido, etc.)\n    Scaffold(\n        topBar = { MainAppBar() }\n    ) { padding -&gt;\n        // El contenido principal de la pantalla es una lista de medios\n        MediaList(modifier = Modifier.padding(padding))\n    }\n}\n\n// El setContent de la Activity ahora solo llama al Composable de la pantalla.\n// Cuando implementes navegaci\u00f3n, aqu\u00ed decidir\u00e1s qu\u00e9 pantalla mostrar.\nsetContent {\n    MyMoviesApp {\n        MainScreen()\n    }\n}\n</code></pre>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-4-estructura-los-paquetes-de-ui-por-pantallas","title":"\u2705 Consejo 4: Estructura los Paquetes de UI por Pantallas","text":"<p>El Problema: Tener todos los archivos Composable en un mismo paquete (<code>ui</code>) funciona para proyectos peque\u00f1os, pero se vuelve un caos a medida que la aplicaci\u00f3n crece.</p> <p>La Soluci\u00f3n: Organiza tus archivos en paquetes que reflejen la estructura de tu aplicaci\u00f3n, generalmente por funcionalidad o por pantalla.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Antes: Todos los archivos de UI en un solo lugar.</li> </ul> <pre><code>com.antonioleiva.mymovies\n\u2514\u2500\u2500 ui\n    \u251c\u2500\u2500 MainActivity.kt\n    \u251c\u2500\u2500 MainAppBar.kt\n    \u251c\u2500\u2500 MediaList.kt\n    \u251c\u2500\u2500 MediaItem.kt\n    \u2514\u2500\u2500 theme\n        \u2514\u2500\u2500 ...\n</code></pre> <ul> <li>Despu\u00e9s: Creamos una estructura m\u00e1s organizada.</li> </ul> <pre><code>com.antonioleiva.mymovies\n\u251c\u2500\u2500 model // Clases de datos (ej. MediaItem.kt)\n\u2502   \u2514\u2500\u2500 MediaItem.kt\n\u2514\u2500\u2500 ui\n    \u251c\u2500\u2500 MainActivity.kt // La Actividad principal, punto de entrada\n    \u251c\u2500\u2500 MyMoviesApp.kt  // El Composable base\n    \u251c\u2500\u2500 screens\n    \u2502   \u251c\u2500\u2500 main        // Paquete para la pantalla principal\n    \u2502   \u2502   \u251c\u2500\u2500 MainScreen.kt\n    \u2502   \u2502   \u251c\u2500\u2500 MainAppBar.kt\n    \u2502   \u2502   \u2514\u2500\u2500 MediaList.kt\n    \u2502   \u2514\u2500\u2500 detail      // Paquete para la pantalla de detalle (futuro)\n    \u2514\u2500\u2500 theme\n        \u2514\u2500\u2500 ...\n</code></pre> <p>Esta estructura te dice de un vistazo qu\u00e9 componentes pertenecen a qu\u00e9 pantalla.</p>"},{"location":"temas/02/2.5-mejorando-codigo.html#consejo-5-extrae-las-dimensiones-a-recursos","title":"\u2705 Consejo 5: Extrae las Dimensiones a Recursos","text":"<p>El Problema: Escribir valores como <code>padding(16.dp)</code> o <code>height(200.dp)</code> directamente en el c\u00f3digo (hardcodear) dificulta hacer cambios globales y adaptar la UI a diferentes tama\u00f1os de pantalla (m\u00f3viles vs. tablets).</p> <p>La Soluci\u00f3n: Define todas tus dimensiones en archivos de recursos XML (<code>res/values/dimens.xml</code>) y accede a ellos desde tu c\u00f3digo Compose.</p> <p>Ejemplo Pr\u00e1ctico</p> <ul> <li>Paso 1: Crear el archivo de recursos <code>dimens.xml</code>.</li> </ul> <pre><code>&lt;!-- Archivo: app/src/main/res/values/dimens.xml --&gt;\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;resources&gt;\n    &lt;dimen name=\"padding_xsmall\"&gt;2dp&lt;/dimen&gt;\n    &lt;dimen name=\"padding_medium\"&gt;16dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_min_width\"&gt;150dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_thumb_height\"&gt;200dp&lt;/dimen&gt;\n    &lt;dimen name=\"cell_play_icon_size\"&gt;92dp&lt;/dimen&gt;\n&lt;/resources&gt;\n</code></pre> <ul> <li> <p>Paso 2: Usar los recursos en el c\u00f3digo.</p> </li> <li> <p>Antes:</p> </li> </ul> <pre><code>@Composable\nfun MediaListItem(...) {\n    Column {\n        Box(modifier = Modifier.height(200.dp)) {\n            //...\n            Icon(\n                modifier = Modifier.size(92.dp),\n                //...\n            )\n        }\n        Box(modifier = Modifier.padding(16.dp)) {\n            //...\n        }\n    }\n}\n</code></pre> <ul> <li>Despu\u00e9s: Usamos <code>dimensionResource</code> para obtener los valores del XML.</li> </ul> <pre><code>import androidx.compose.ui.res.dimensionResource\nimport com.antonioleiva.mymovies.R // Importante importar tu clase R\n\n@Composable\nfun MediaListItem(...) {\n    Column {\n        Box(modifier = Modifier.height(dimensionResource(R.dimen.cell_thumb_height))) {\n            //...\n            Icon(\n                modifier = Modifier.size(dimensionResource(R.dimen.cell_play_icon_size)),\n                //...\n            )\n        }\n        Box(modifier = Modifier.padding(dimensionResource(R.dimen.padding_medium))) {\n            //...\n        }\n    }\n}\n</code></pre> <p>De esta forma, si necesitas cambiar un espaciado en toda la app, solo modificas el archivo <code>dimens.xml</code>.</p>"},{"location":"temas/02/2.6-mostrar-listas.html","title":"2.6. Manejo de listas","text":""},{"location":"temas/02/2.6-mostrar-listas.html#26-listas-en-compose","title":"2.6. Listas en Compose","text":"<p>Las listas son unos de los principales componentes de cualquier aplicaci\u00f3n, ya que nos van a permitir mostrar una lista de elementos. Si estos elementos son pocos, y solo ocupan parte de la pantalla, se pueden utilizar los elementos que ya conocemos como <code>Column</code> o <code>Row</code>, pero cuando son muchos los elementos necesitamos algo m\u00e1s potente, y que nos permita ser eficientes y que consuma los m\u00ednimos recursos.</p> <p>Para esto Compose nos provee los componentes <code>LazColum</code> y <code>LazyRow</code></p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n sobre listas y cuadriculas</p> <p>Cuando comienzas a desarrollar con Jetpack Compose, una de las primeras cosas que notas es la facilidad con la que puedes crear interfaces de usuario directamente en Kotlin. Sin embargo, esta flexibilidad tambi\u00e9n puede llevar a que el c\u00f3digo crezca r\u00e1pidamente y se vuelva desordenado.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#desmitificando-lazyrow-y-lazycolumn-en-jetpack-compose","title":"\ud83d\udca1Desmitificando LazyRow y LazyColumn en Jetpack Compose","text":""},{"location":"temas/02/2.6-mostrar-listas.html#1-cual-es-la-necesidad-el-problema-de-las-listas-largas","title":"1. \u00bfCu\u00e1l es la Necesidad? El Problema de las Listas Largas","text":"<p>Imaginemos una aplicaci\u00f3n com\u00fan: una red social con un feed de noticias, una tienda online con cientos de productos o una simple lista de contactos. Todas estas aplicaciones comparten un requisito: mostrar una cantidad potencialmente grande de elementos en pantalla.</p> <p>Si abord\u00e1ramos este problema de forma ingenua, utilizando los componentes b\u00e1sicos <code>Row</code> o <code>Column</code>, nos encontrar\u00edamos con un grave problema de rendimiento. Un <code>Column</code>, por ejemplo, renderizar\u00e1 todos y cada uno de sus elementos hijos de una sola vez, sin importar si son visibles en la pantalla o no. Para una lista de diez o veinte elementos, esto podr\u00eda ser aceptable. Pero, \u00bfqu\u00e9 sucede con cien, mil o una lista de longitud desconocida? La aplicaci\u00f3n intentar\u00eda componer y dibujar todos los elementos, consumiendo una cantidad masiva de memoria y ciclos de CPU. El resultado es inevitable: una interfaz que se congela, responde con lentitud (lo que conocemos como \"lag\") y, en el peor de los casos, una aplicaci\u00f3n que colapsa con un error de <code>OutOfMemoryError</code>.</p> <p>Aqu\u00ed es donde la \"pereza\" (del ingl\u00e9s \"lazy\") se convierte en nuestra mayor aliada.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#2-la-funcion-de-lazyrow-y-lazycolumn-composicion-perezosa","title":"2. La Funci\u00f3n de LazyRow y LazyColumn: Composici\u00f3n \"Perezosa\"","text":"<p><code>LazyRow</code> y <code>LazyColumn</code> son los equivalentes en Jetpack Compose al veterano <code>RecyclerView</code> del sistema de vistas tradicional de Android. Su prop\u00f3sito fundamental es mostrar de manera eficiente listas de elementos, ya sea de forma horizontal (<code>LazyRow</code>) o vertical (<code>LazyColumn</code>).</p> <p>La magia detr\u00e1s de estos componentes radica en su estrategia de composici\u00f3n y renderizado \"perezoso\". En lugar de componer todos los elementos de la lista de una vez, <code>LazyColumn</code> y <code>LazyRow</code> solo componen y dibujan los elementos que son actualmente visibles dentro del viewport (el \u00e1rea visible en la pantalla) y unos pocos m\u00e1s que est\u00e1n a punto de aparecer para garantizar un desplazamiento suave. A medida que el usuario se desplaza, los elementos que salen del viewport son descartados (liberando recursos), y nuevos elementos son compuestos justo a tiempo para ser mostrados.</p> <p>Este enfoque \"justo a tiempo\" tiene un impacto dr\u00e1stico y positivo en el rendimiento de la aplicaci\u00f3n:</p> <ul> <li>Uso de Memoria Optimizado: Al no mantener en memoria elementos que no est\u00e1n en pantalla, se reduce significativamente la huella de memoria de la aplicaci\u00f3n.</li> <li>Mejora del Rendimiento de Renderizado: La CPU y la GPU tienen mucho menos trabajo que hacer en cada frame, lo que se traduce en una interfaz de usuario fluida y receptiva, libre de \"lag\".</li> <li>Tiempos de Carga Iniciales R\u00e1pidos: La pantalla se muestra r\u00e1pidamente, ya que no es necesario procesar toda la lista de datos para la primera visualizaci\u00f3n.</li> </ul>"},{"location":"temas/02/2.6-mostrar-listas.html#3-como-funcionan-internamente","title":"3. \u00bfC\u00f3mo Funcionan Internamente?","text":"<p>A diferencia de <code>RecyclerView</code>, que se basa en un mecanismo de reciclaje de vistas (reutilizando instancias de <code>View</code> ya creadas), <code>LazyColumn</code> y <code>LazyRow</code> aprovechan el modelo de funcionamiento de Jetpack Compose.</p> <p>Cuando un elemento en una <code>LazyColumn</code> se desplaza fuera de la pantalla, su composici\u00f3n es descartada del \u00e1rbol de la UI. Cuando un nuevo elemento necesita ser mostrado, se crea una nueva composici\u00f3n para \u00e9l. Podr\u00eda pensarse que crear nuevas composiciones constantemente es costoso, pero el sistema de recomposici\u00f3n inteligente de Compose es extremadamente eficiente. Solo las partes de la UI que cambian se vuelven a componer, y la creaci\u00f3n de estos <code>Composables</code> es significativamente m\u00e1s ligera que la inflaci\u00f3n de vistas XML en el sistema tradicional.</p> <p>Para gestionar todo este proceso, estos componentes utilizan un <code>LazyListScope</code>, un DSL (Lenguaje Espec\u00edfico de Dominio) que permite definir los elementos de la lista de una manera declarativa y sencilla.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#4-puntos-imporntantes","title":"4. Puntos imporntantes","text":""},{"location":"temas/02/2.6-mostrar-listas.html#uso-utilizando-claves-de-elementos","title":"Uso utilizando claves de elementos","text":"<p>Aplica a LazyColumn y LazyRow.</p> <p>La posici\u00f3n determina el elemento pulsado o seleccionado. Esto puede dar problemas si se reordenan las listas. Para evitar este problema se pueden utilizar una clave (key) para cada elemento (como par\u00e1metro de items )</p> <pre><code>@Composable\nfun MessageList(messages: List&lt;Message&gt;) {\n    LazyColumn {\n        items(\n            items = messages,\n            key = { message -&gt;\n                // Devuelve una clave \u00fanica para el item\n                message.id\n            }\n        ) { message -&gt;\n            MessageRow(message)\n        }\n    }\n}\n</code></pre> <p>(mas detalles aqui)</p>"},{"location":"temas/02/2.6-mostrar-listas.html#padding-del-contenido","title":"Padding del contenido","text":"<p>Para a\u00f1adir espacio entre los bordes y el contenidos usamos PaddingValues con el par\u00e1metro de la funci\u00f3n <code>contentPadding</code></p> <pre><code>LazyColumn(\n    contentPadding = PaddingValues(horizontal = 16.dp, vertical = 8.dp),\n) {\n    // ...\n}\n</code></pre>"},{"location":"temas/02/2.6-mostrar-listas.html#espaciado-de-contenido","title":"Espaciado de contenido.","text":"<p>Para agregar espaciado entre elementos que forman el contenido usamos:</p> <pre><code>// solamente vertical\nLazyColumn(\n    verticalArrangement = Arrangement.spacedBy(4.dp),\n) {\n    // ...\n}\n// solamente horizontal\nLazyRow(\n    horizontalArrangement = Arrangement.spacedBy(4.dp),\n) {\n    // ...\n}\n</code></pre> <p>y en los Grid tanto horizontal como vertical:</p> <pre><code>LazyVerticalGrid(\n    columns = GridCells.Fixed(2),\n    verticalArrangement = Arrangement.spacedBy(16.dp),\n    horizontalArrangement = Arrangement.spacedBy(16.dp)\n) {\n    items(data) { item -&gt;\n        Item(item)\n    }\n}\n</code></pre> Ejemplos Pr\u00e1cticos: De lo B\u00e1sico a lo Avanzado \ud83d\udc68\u200d\ud83d\udcbb <p>Veamos c\u00f3mo se traduce todo esto en c\u00f3digo. La simplicidad de su implementaci\u00f3n es una de las grandes ventajas de Compose.</p> <p>Ejemplo 1: Una Lista Vertical Simple</p> <p>Supongamos que tenemos una lista de nombres de estudiantes que queremos mostrar verticalmente.</p> <pre><code>import androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.lazy.LazyColumn\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun StudentList(students: List&lt;String&gt;) {\n    LazyColumn {\n        items(students) { studentName -&gt;\n            Text(\n                text = studentName,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(16.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>En este sencillo ejemplo, <code>LazyColumn</code> recibe una lista de <code>students</code>. El bloque <code>items</code> itera sobre esta lista y genera un <code>Composable</code> <code>Text</code> para cada estudiante. <code>LazyColumn</code> se encarga autom\u00e1ticamente de componer solo los elementos visibles.</p> <p>Ejemplo 2: Un Carrusel Horizontal de Im\u00e1genes (<code>LazyRow</code>)</p> <p>Ahora, creemos un carrusel horizontal, ideal para galer\u00edas de im\u00e1genes o categor\u00edas de productos.</p> <pre><code>import androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.foundation.lazy.LazyRow\nimport androidx.compose.foundation.lazy.items\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport com.example.myapp.R // Aseg\u00farate de tener tus recursos de imagen\n\n@Composable\nfun ImageCarousel(imageResIds: List&lt;Int&gt;) {\n    LazyRow {\n        items(imageResIds) { imageResId -&gt;\n            Image(\n                painter = painterResource(id = imageResId),\n                contentDescription = null, // Deber\u00eda ser descriptivo\n                modifier = Modifier\n                    .size(150.dp)\n                    .padding(8.dp)\n            )\n        }\n    }\n}\n</code></pre> <p>El funcionamiento es id\u00e9ntico al de <code>LazyColumn</code>, pero la disposici\u00f3n y el desplazamiento son horizontales.</p> <p>Ejemplo 3: Lista con M\u00faltiples Tipos de Elementos</p> <p>Una de las grandes ventajas de <code>LazyColumn</code> es la facilidad para manejar listas heterog\u00e9neas. Imaginemos una lista que contiene cabeceras de secci\u00f3n y elementos de datos.</p> <pre><code>sealed class ListItem {\n    data class Header(val title: String) : ListItem()\n    data class DataItem(val content: String) : ListItem()\n}\n\n@Composable\nfun MixedList(items: List&lt;ListItem&gt;) {\n    LazyColumn {\n        items(items) { item -&gt;\n            when (item) {\n                is ListItem.Header -&gt; {\n                    Text(\n                        text = item.title,\n                        // Estilos para la cabecera\n                    )\n                }\n                is ListItem.DataItem -&gt; {\n                    Text(\n                        text = item.content,\n                        // Estilos para el item de dato\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Simplemente utilizando una estructura <code>when</code> dentro del bloque <code>items</code>, podemos emitir diferentes <code>Composables</code> seg\u00fan el tipo de dato, de una forma mucho m\u00e1s limpia que con el <code>getItemViewType</code> de <code>RecyclerView</code>.</p> <p>Ejemplo 4: Cabeceras Adhesivas (Sticky Headers)</p> <p>Con una peque\u00f1a modificaci\u00f3n, podemos hacer que nuestras cabeceras se queden \"pegadas\" en la parte superior de la pantalla mientras el contenido de su secci\u00f3n se desplaza.</p> <pre><code>@OptIn(ExperimentalFoundationApi::class)\n@Composable\nfun StickyHeaderList(sections: Map&lt;String, List&lt;String&gt;&gt;) {\n    LazyColumn {\n        sections.forEach { (headerTitle, items) -&gt;\n            stickyHeader {\n                Text(\n                    text = headerTitle,\n                    // Estilos para la cabecera adhesiva\n                )\n            }\n            items(items) { itemContent -&gt;\n                Text(\n                    text = itemContent,\n                    modifier = Modifier.padding(16.dp)\n                )\n            }\n        }\n    }\n}\n</code></pre> <p>El DSL <code>stickyHeader</code> (actualmente experimental) nos brinda esta compleja funcionalidad con una simplicidad asombrosa.</p> <p>5. La Clave del Rendimiento: <code>key</code></p> <p>Para optimizar a\u00fan m\u00e1s el rendimiento, especialmente en listas din\u00e1micas donde los elementos pueden a\u00f1adirse, eliminarse o reordenarse, es fundamental proporcionar una <code>key</code> \u00fanica y estable para cada elemento.</p> <pre><code>items(items = myItems, key = { it.id }) { item -&gt;\n    // Tu Composable para el item\n}\n</code></pre> <p>Al proporcionar una clave, ayudamos a Compose a identificar de manera \u00fanica cada elemento. Esto permite que el estado del elemento (como el estado de un <code>remember</code>) se mantenga correctamente cuando la lista cambia, y habilita animaciones de reordenamiento m\u00e1s eficientes.</p>"},{"location":"temas/02/2.6-mostrar-listas.html#5-cuadriculas-diferidas-lazygrid","title":"5. Cuadr\u00edculas diferidas (LazyGrid)","text":"<p><code>LazyVerticalGrid</code> muestra los elementos en una cuadr\u00edcula con deslazamiento vertical que ocupa varias columnas</p> <p>La declaraci\u00f3n de LazyVerticalGrid:</p> <pre><code>@Composable\n@ComposableTarget\npublic fun LazyVerticalGrid(\n    columns: GridCells,\n    modifier: Modifier = COMPILED_CODE,\n    state: LazyGridState = COMPILED_CODE,\n    contentPadding: PaddingValues = COMPILED_CODE,\n    reverseLayout: Boolean = COMPILED_CODE,\n    verticalArrangement: Arrangement.Vertical = COMPILED_CODE,\n    horizontalArrangement: Arrangement.Horizontal = COMPILED_CODE,\n    flingBehavior: FlingBehavior = COMPILED_CODE,\n    userScrollEnabled: Boolean = COMPILED_CODE,\n    content: LazyGridScope.() -&gt; Unit\n): Unit\n</code></pre> <p>Y para los items en content:</p> <pre><code>public abstract fun items(\n    count: Int,\n    key: ((Int) -&gt; Any)? = COMPILED_CODE,\n    span: (LazyGridItemSpanScope.(Int) -&gt; GridItemSpan)? = COMPILED_CODE,\n    contentType: (Int) -&gt; Any? = COMPILED_CODE,\n    itemContent: @Composable() (LazyGridItemScope.(Int) -&gt; Unit)\n): Unit\n</code></pre> <p>Contenido adaptativo</p> <p>El par\u00e1metro <code>columns</code> en <code>LazyVerticalGrid</code> controla el modo en que se forman las celdas en columnas. En el siguiente ejemplo, se muestran elementos de una cuadr\u00edcula con <code>GridCells.Adaptive</code> para que cada columna tenga al menos 128.dp ancho:</p> <pre><code>@Composable\nfun PhotoGrid(photos: List&lt;Photo&gt;) {\n    LazyVerticalGrid(\n        columns = GridCells.Adaptive(minSize = 128.dp)\n    ) {\n        items(photos) { photo -&gt;\n            PhotoItem(photo)\n        }\n    }\n}\n</code></pre> <p>Se crearan tantas columnas como se puedan incluir en el espacio disponible con los 128.dp de cada columna.</p> <p>N\u00ba columnas fijo</p> <p>Tambi\u00e9n es posible forzar un n\u00famero de columnas fijo, adaptado el ancho , con <code>GridCells.Fixed</code>.</p> <p>Se puede personalizar el dise\u00f1o de columnas con <code>span</code> y <code>maxLineSpan</code> utilizandos con <code>item</code> e <code>items</code></p> <pre><code>LazyVerticalGrid(\n    // ...\n) {\n    item(span = {\n        // LazyGridItemSpanScope:\n        // maxLineSpan\n        GridItemSpan(maxLineSpan)\n    }) {\n        MiCard(\u201cFruits\u201d)\n    }\n    // ...\n}\n</code></pre> <p>Span</p> <ul> <li><code>span = { ... }</code>: Aqu\u00ed es donde la magia sucede.     Este bloque te permite definir cu\u00e1nto espacio en la cuadr\u00edcula ocupar\u00e1 tu elemento. </li> <li><code>GridItemSpan(maxLineSpan)</code>: Esto especifica el \"span\" de tu elemento. Por ejemplo, si tu cuadr\u00edcula tiene 4 columnas y pones GridItemSpan(2), tu elemento ocupar\u00e1 2 columnas. Si usas GridItemSpan(4), ocupar\u00e1 toda la fila. * <code>MiCard(\"Fruits\")</code>: </li> </ul> <p>Este es un ejemplo de contenido de tu elemento, puede ser cualquier composable que hayas creado, como una tarjeta que muestra una categor\u00eda.</p> <p>Lee este post para un ejemplo completo de uso de grids en Compose: Uso de Grids en Android con Jetpack Compose</p>"},{"location":"temas/02/2.6-mostrar-listas.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/02/2.6-mostrar-listas.html#proyecto-guiado-aplicacion-lista-de-cursos","title":"\ud83d\ude80 Proyecto guiado: Aplicaci\u00f3n \"Lista de cursos\"","text":"<p>Para esta pr\u00e1ctica, vamos a crear una sencilla aplicaci\u00f3n en la que vamos a mostrar en una cuadricula una lista de cursos.</p> <p>\u2b06\ufe0f Proyecto: Lista de cursos</p> <p>Proyecto. Lista de Cursos. Sigue las indicaciones aqu\u00ed.</p> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li>Codelab. Agregar una lista desplazable. Codelab.</li> <li>Codelab. C\u00f3mo cambiar el icono de la App. Codelab.</li> </ol>"},{"location":"temas/03/index.html","title":"Inicio","text":""},{"location":"temas/03/index.html#ut3-interfaz-de-usuario","title":"UT3. Interfaz de usuario","text":"<p>En este tema nos enfocaremos en el concepto de interfaz de usuario, accesibilidad, adaptaci\u00f3n a diferentes tama\u00f1os de pantalla, y exploraremos en profundidad una de las capas en cualquier arquitectura, como es la capa de UI.</p> <p>Tambi\u00e9n vamos a tratar el tema del dise\u00f1o de la interfaz de usuario, las l\u00edneas gu\u00eda que nos provee Android con su Material Design.</p> <p>\u00cdndice:</p> <ul> <li>3.1 Introducci\u00f3n a la interfaz de usuario</li> <li>3.2 Dise\u00f1o de la interfaz de usuario</li> <li>3.3 Elementos de la interfaz de usuario</li> </ul> <p></p>"},{"location":"temas/03/index.html#recursos","title":"\ud83d\udcc1 Recursos","text":"Android y Jetpack ComposeKotlin <ul> <li>Documentaci\u00f3n oficial de Jetpack Compose: La documentaci\u00f3n oficial de Jetpack Compose, que incluye gu\u00edas, tutoriales y ejemplos para aprender a usar Compose.</li> <li>Codelabs introductorios de Android: Codelabs introductorios de Android con Jetpack Compose para que puedas aprender a crear aplicaciones Android con Compose.  </li> </ul> <ul> <li>Curso: Android con Kotlin (youtube)</li> <li>Curso Kotlin con Jetpack Compose</li> <li>Curso: Jetpack Compose 2023</li> </ul>"},{"location":"temas/03/3.1-intro.html","title":"3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.1-intro.html#31-introduccion","title":"3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.1-intro.html#el-universo-de-material-design-3-en-jetpack-compose-creando-interfaces-modernas-y-personales","title":"El Universo de Material Design 3 en Jetpack Compose: Creando Interfaces Modernas y Personales","text":"<p>En el epicentro de esta revoluci\u00f3n se encuentra Material Design 3 (M3), la \u00faltima evoluci\u00f3n del lenguaje de dise\u00f1o de Google. Este documento tiene como objetivo desglosar los conceptos fundamentales de M3 y su implementaci\u00f3n en Jetpack Compose, proporcionando una gu\u00eda detallada para construir aplicaciones no solo funcionales y eficientes, sino tambi\u00e9n expresivas, adaptables y profundamente humanas.</p>"},{"location":"temas/03/3.1-intro.html#introduccion-a-los-conceptos-clave","title":"Introducci\u00f3n a los Conceptos Clave \ud83d\udda5\ufe0f","text":"<p>Para construir interfaces de usuario de alta calidad con Jetpack Compose, es imprescindible comprender los pilares sobre los que se asienta Material Design 3.</p>"},{"location":"temas/03/3.1-intro.html#que-es-material-design","title":"\u00bfQu\u00e9 es Material Design?","text":"<p>Material Design es un sistema de dise\u00f1o integral creado y mantenido por Google. Su prop\u00f3sito es unificar la experiencia de usuario a trav\u00e9s de todas las plataformas y dispositivos, proporcionando un conjunto coherente de directrices, componentes y herramientas para el dise\u00f1o de interfaces. Lejos de ser solo una gu\u00eda de estilo, es un lenguaje vivo que evoluciona para abordar las mejores pr\u00e1cticas de dise\u00f1o, usabilidad y accesibilidad. La versi\u00f3n 3, tambi\u00e9n conocida como \"Material You\", marca un cambio de paradigma hacia la personalizaci\u00f3n y la adaptabilidad.</p> <p></p> <p>La aplicaci\u00f3n de ejemplo \"Reply\" implementada enteramente con Material Design 3 en Compose.</p>"},{"location":"temas/03/3.1-intro.html#concepto-en-que-se-basa-material-design","title":"\ud83d\udd37 Concepto en que se Basa Material Design","text":"<p>El concepto central de Material Design se inspira en el mundo f\u00edsico y sus texturas, particularmente el papel y la tinta. Se basa en una \"met\u00e1fora material\" donde los elementos de la UI tienen superficies f\u00edsicas y bordes. Las sombras y la elevaci\u00f3n proporcionan pistas visuales sobre la jerarqu\u00eda y las interacciones posibles, indicando qu\u00e9 elementos se pueden tocar o mover. M3 expande esta idea con un enfoque en el movimiento expresivo y formas m\u00e1s org\u00e1nicas, haciendo que las interacciones se sientan m\u00e1s intuitivas y naturales.</p>"},{"location":"temas/03/3.1-intro.html#fundamentos","title":"\ud83d\udd37 Fundamentos","text":"<p>Los fundamentos de Material Design son los principios que sustentan todo el sistema. En M3, estos se centran en:</p> <ul> <li>Color: Un sistema de color din\u00e1mico y personalizable que puede adaptarse al fondo de pantalla del usuario.</li> <li>Tipograf\u00eda: Una escala de tipos adaptable que ajusta el tama\u00f1o de la fuente seg\u00fan el tama\u00f1o de la pantalla, mejorando la legibilidad.</li> <li>Forma: El uso de formas, como esquinas redondeadas, para transmitir personalidad y estado.</li> <li>Movimiento: Animaciones significativas que gu\u00edan al usuario y proporcionan retroalimentaci\u00f3n.</li> </ul>"},{"location":"temas/03/3.1-intro.html#diseno-adaptativo","title":"\ud83d\udd37 Dise\u00f1o Adaptativo","text":"<p>El dise\u00f1o adaptativo es la pr\u00e1ctica de crear layouts que se ajustan de manera inteligente a diferentes tama\u00f1os de pantalla, orientaciones y dispositivos. M3 no solo se enfoca en que las aplicaciones se \"vean bien\" en tel\u00e9fonos, tabletas o dispositivos plegables, sino que la experiencia de usuario sea \u00f3ptima en cada contexto. Esto se logra utilizando una combinaci\u00f3n de componentes flexibles, rejillas responsivas y patrones de dise\u00f1o espec\u00edficos.</p>"},{"location":"temas/03/3.1-intro.html#accesibilidad","title":"\ud83d\udd37 Accesibilidad","text":"<p>La accesibilidad es un pilar fundamental de Material Design. Consiste en dise\u00f1ar y construir aplicaciones que puedan ser utilizadas por personas con una amplia gama de habilidades y discapacidades (visuales, motoras, auditivas o cognitivas). M3 integra la accesibilidad desde su n\u00facleo, proporcionando componentes con el contraste de color adecuado, \u00e1reas t\u00e1ctiles de tama\u00f1o suficiente y soporte para tecnolog\u00edas de asistencia como los lectores de pantalla.</p>"},{"location":"temas/03/3.1-intro.html#colorscheme-y-sus-roles-de-color","title":"\ud83d\udd37 ColorScheme y sus Roles de Color","text":"<p>El <code>ColorScheme</code> es el coraz\u00f3n del sistema de color de Material 3 en Jetpack Compose. Es un conjunto de m\u00e1s de 20 roles de color que se utilizan para tematizar de manera consistente todos los componentes de la aplicaci\u00f3n. Lo revolucionario de M3 es que este esquema puede generarse din\u00e1micamente a partir del fondo de pantalla del usuario en Android 12 y versiones posteriores, una caracter\u00edstica clave de Material You.</p> <p>Los nombres de los roles son sem\u00e1nticos y describen su prop\u00f3sito en la UI, no un color espec\u00edfico. Esto facilita la creaci\u00f3n de temas coherentes. Los roles principales son:</p> <ul> <li>Primary: El color base de la marca, usado para componentes principales como botones prominentes y elementos activos.</li> <li>Secondary: Un color de acento que proporciona m\u00e1s formas de destacar elementos de la UI.</li> <li>Tertiary: Un color de acento contrastante que se puede usar para equilibrar los colores primarios y secundarios o para resaltar elementos de menor importancia.</li> <li>Neutral: Se utiliza para las superficies de la aplicaci\u00f3n, como los fondos y el texto.</li> <li>Neutral Variant: Una variante del color neutral, usada para elementos como bordes o divisores.</li> <li>Error: Se reserva para indicar errores, como en campos de texto con validaci\u00f3n incorrecta.</li> </ul> <p>Cada uno de estos roles principales tiene colores \"On\" (por ejemplo, <code>onPrimary</code>), que se usan para el contenido (texto, iconos) que se coloca encima de su color correspondiente, garantizando as\u00ed un contraste adecuado. Tambi\u00e9n existen colores para superficies (<code>surface</code>) y sus diferentes elevaciones.</p> <p>Los roles de color definen el prop\u00f3sito de un color en la UI. Fuente: Material Design</p>"},{"location":"temas/03/3.1-intro.html#canonical-layouts","title":"\ud83d\udd37 Canonical Layouts","text":"<p>Un \"layout\" define la estructura visual de una pantalla. En el contexto de M3 y el dise\u00f1o adaptativo, los Canonical Layouts (dise\u00f1os can\u00f3nicos) son plantillas de composici\u00f3n probadas y recomendadas que ayudan a organizar el contenido de manera efectiva en diferentes tama\u00f1os de pantalla. Estos dise\u00f1os son puntos de partida que abordan casos de uso comunes.</p> <p>Los tres dise\u00f1os can\u00f3nicos principales son:</p> <ol> <li>List-Detail: Ideal para aplicaciones que muestran una lista de elementos y el detalle de un elemento seleccionado, como una aplicaci\u00f3n de correo o un gestor de archivos. En pantallas compactas, la lista y el detalle ocupan pantallas separadas, mientras que en pantallas m\u00e1s grandes se muestran lado a lado.</li> <li>Supporting Pane: Divide la pantalla en un \u00e1rea de contenido principal y un panel secundario que ofrece informaci\u00f3n o controles contextuales. Un ejemplo ser\u00eda una aplicaci\u00f3n de calendario con la vista principal del mes y un panel lateral que muestra los detalles de un evento seleccionado.</li> <li>Feed: Organiza el contenido en una cuadr\u00edcula configurable, perfecta para explorar grandes cantidades de elementos equivalentes, como en una galer\u00eda de fotos o un feed de noticias.</li> </ol> <ul> <li> <p> </p><p>Feed Layout</p><p></p> </li> <li> <p> </p><p>Layout lista-detalle</p><p></p> </li> <li> <p> </p><p>Supporting Panel</p><p></p> </li> </ul> <p>De izquierda a derecha: Feed, List-Detail, Supporting Pane. Fuente: Material Design</p>"},{"location":"temas/03/3.1-intro.html#usabilidad","title":"\ud83d\udd37 Usabilidad","text":"<p>La usabilidad se refiere a la facilidad con la que un usuario puede interactuar con una aplicaci\u00f3n para alcanzar sus objetivos. Material Design promueve una alta usabilidad a trav\u00e9s de:</p> <ul> <li>Claridad: Interfaces limpias, jerarqu\u00eda visual clara y llamadas a la acci\u00f3n evidentes.</li> <li>Eficiencia: Permite a los usuarios realizar tareas de manera r\u00e1pida e intuitiva.</li> <li>Retroalimentaci\u00f3n: Proporciona respuestas visuales claras a las interacciones del usuario a trav\u00e9s de estados (ondulaciones al tocar, cambios de color) y movimiento.</li> </ul> <p>Importante</p> <p>En Jetpack Compose, estos principios se materializan a trav\u00e9s de componentes pre-construidos que ya incorporan estas mejores pr\u00e1cticas, permitiendo a los desarrolladores crear aplicaciones altamente usables con menos esfuerzo.</p> <p>Ejemplos Did\u00e1cticos en Jetpack Compose</p> <p>Veamos c\u00f3mo aplicar estos conceptos en el c\u00f3digo.</p> <p>Ejemplo 1: Aplicando un <code>ColorScheme</code> Din\u00e1mico</p> <p>Para que tu aplicaci\u00f3n adopte los colores del fondo de pantalla del usuario (en Android 12+), el c\u00f3digo es sorprendentemente simple.</p> <pre><code>@Composable\nfun MyAppTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -&gt; Unit\n) {\n    val context = LocalContext.current\n    val colorScheme = when {\n        // Soporte para color din\u00e1mico en Android 12+\n        Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            if (darkTheme) dynamicDarkColorScheme(context)\n            else dynamicLightColorScheme(context)\n        }\n        // Fallback a un tema personalizado para versiones anteriores\n        darkTheme -&gt; darkColorScheme(\n            primary = /* Tu color oscuro primario */,\n            secondary = /* Tu color oscuro secundario */\n            /* ... otros colores ... */\n        )\n        else -&gt; lightColorScheme(\n            primary = /* Tu color claro primario */,\n            secondary = /* Tu color claro secundario */\n            /* ... otros colores ... */\n        )\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = /* Tu tipograf\u00eda definida */,\n        content = content\n    )\n}\n</code></pre> <p>Al envolver tu UI con <code>MyAppTheme</code>, componentes como <code>Button</code>, <code>FloatingActionButton</code> o <code>Card</code> usar\u00e1n autom\u00e1ticamente los colores correctos del <code>colorScheme</code> (<code>primary</code> para el bot\u00f3n, <code>surface</code> para la tarjeta, etc.) sin necesidad de especificarlos manualmente.</p> <p>Ejemplo 2: Usando Roles de Color y Tipograf\u00eda</p> <p>Dentro de tus <code>Composables</code>, puedes acceder f\u00e1cilmente a los roles definidos en tu tema.</p> <pre><code>@Composable\nfun ProductCard(productName: String, productDescription: String) {\n    Card(\n        modifier = Modifier,\n        colors = CardDefaults.cardColors(\n            containerColor = MaterialTheme.colorScheme.surfaceVariant,\n        )\n    ) {\n        Text(\n            text = productName,\n            style = MaterialTheme.typography.titleLarge,\n            color = MaterialTheme.colorScheme.onSurface\n        )\n        Text(\n            text = productDescription,\n            style = MaterialTheme.typography.bodyMedium,\n            color = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n    }\n}\n</code></pre> <p>En este ejemplo, la tarjeta (<code>Card</code>) usa el color <code>surfaceVariant</code> para su fondo, y los textos usan <code>onSurface</code> y <code>onSurfaceVariant</code> respectivamente, asegurando la legibilidad. La tipograf\u00eda tambi\u00e9n se obtiene del tema, garantizando consistencia.</p> <p>Ejemplo 3: Componente Accesible - <code>Button</code> con Icono</p> <p>Material Design y Compose facilitan la creaci\u00f3n de componentes accesibles. Un bot\u00f3n con solo un icono debe tener una descripci\u00f3n de texto para los lectores de pantalla.</p> <pre><code>@Composable\nfun AddItemButton() {\n    IconButton(onClick = { /* Acci\u00f3n al hacer clic */ }) {\n        Icon(\n            imageVector = Icons.Filled.Add,\n            contentDescription = stringResource(R.string.add_item_description) // Descripci\u00f3n para accesibilidad\n        )\n    }\n}\n</code></pre> <p>El par\u00e1metro <code>contentDescription</code> es crucial. No es visible en la pantalla, pero proporciona a las herramientas de accesibilidad el contexto necesario para describir la funci\u00f3n del bot\u00f3n al usuario.</p> <p> </p> <p>Enlaces a la Documentaci\u00f3n Oficial:</p> <ul> <li>Introducci\u00f3n a Material Design 3: https://m3.material.io/</li> <li>Material Design 3 para Jetpack Compose: https://developer.android.com/jetpack/compose/design-systems/material3</li> <li>El Sistema de Color de M3: https://m3.material.io/styles/color/the-color-system</li> <li>Layouts Can\u00f3nicos: https://m3.material.io/foundations/layout/canonical-layouts</li> <li>Gu\u00eda de Accesibilidad: https://m3.material.io/foundations/accessibility</li> </ul>"},{"location":"temas/03/3.2-temas.html","title":"3.2. Temas","text":""},{"location":"temas/03/3.2-temas.html#32-temas-en-material-design-con-jetpack-compose","title":"3.2. Temas en Material Design con Jetpack Compose","text":""},{"location":"temas/03/3.2-temas.html#theming-en-jetpack-compose-con-material-design-3-una-arquitectura-de-estilo","title":"Theming en Jetpack Compose con Material Design 3: Una Arquitectura de Estilo","text":"<p>En el ecosistema de Android con Jetpack Compose, el pilar de esta coherencia es el sistema de Theming de Material Design 3. Un \"Theme\" (tema) es mucho m\u00e1s que una simple paleta de colores; es un sistema completo que define la apariencia y el comportamiento de tu aplicaci\u00f3n, encapsulando el color, la tipograf\u00eda y la forma para crear una identidad de marca \u00fanica y una experiencia de usuario consistente.</p> <p>En este punto se profundiza en c\u00f3mo aplicar y personalizar temas en Jetpack Compose, desde los conceptos b\u00e1sicos hasta la generaci\u00f3n de paletas de colores din\u00e1micas que dan vida a la filosof\u00eda de \"Material You\".</p>"},{"location":"temas/03/3.2-temas.html#1-la-anatomia-de-un-tema-en-compose","title":"\u2728 1. La Anatom\u00eda de un Tema en Compose","text":"<p>Cuando creas un nuevo proyecto de Jetpack Compose en Android Studio, se genera autom\u00e1ticamente un paquete <code>ui.theme</code> que contiene los tres pilares de tu tema:</p> <ul> <li><code>Color.kt</code>: Define los valores de color est\u00e1ticos que usar\u00e1s para construir tus esquemas de color.</li> <li><code>Type.kt</code>: Define la escala tipogr\u00e1fica de tu aplicaci\u00f3n, es decir, los diferentes estilos de texto (t\u00edtulos, cuerpos, etiquetas, etc.).</li> <li><code>Theme.kt</code>: Es el coraz\u00f3n del sistema. Aqu\u00ed es donde se unen el color, la tipograf\u00eda y la forma para crear el tema completo que se aplicar\u00e1 a tu aplicaci\u00f3n.</li> </ul> <p>El componente central es el composable <code>MaterialTheme</code>, que utiliza tres par\u00e1metros principales para configurar el tema:</p> <ol> <li><code>colorScheme</code>: Un esquema de color de Material 3 que asigna roles de color sem\u00e1nticos (como <code>primary</code>, <code>surface</code>, <code>onError</code>) a valores de color espec\u00edficos.</li> <li><code>typography</code>: Una escala de tipos que define el estilo para cada rol de texto (<code>displayLarge</code>, <code>bodyMedium</code>, <code>labelSmall</code>, etc.).</li> <li><code>shapes</code>: Define los atributos de forma, espec\u00edficamente el radio de las esquinas para componentes peque\u00f1os, medianos y grandes.</li> </ol> <p>Al envolver la UI de tu aplicaci\u00f3n con <code>MaterialTheme</code>, todos los componentes de Material que utilices dentro de \u00e9l (como <code>Button</code>, <code>Card</code>, <code>Scaffold</code>) heredar\u00e1n y aplicar\u00e1n autom\u00e1ticamente estos estilos, garantizando una consistencia visual sin esfuerzo.</p> <pre><code>// En tu Actividad principal o Composable ra\u00edz\nMyAppTheme { // Tu tema personalizado que configura MaterialTheme\n    Scaffold(...) {\n        // Todo el contenido aqu\u00ed dentro usar\u00e1 los colores,\n        // tipograf\u00eda y formas definidas en MyAppTheme\n    }\n}\n</code></pre>"},{"location":"temas/03/3.2-temas.html#12-colorscheme-o-esquema-de-color","title":"\ud83c\udfa8 1.2 ColorScheme o Esquema de Color","text":"<p>Imaginad que est\u00e1is pintando un cuadro. No usar\u00edais colores al azar, \u00bfverdad? Elegir\u00edais una paleta de colores que funcionen bien juntos para transmitir una emoci\u00f3n o un estilo. En el dise\u00f1o de interfaces, un esquema de color es exactamente eso: un conjunto de colores seleccionados cuidadosamente que se utilizan de manera coherente en toda la aplicaci\u00f3n.</p> <p>Este esquema define qu\u00e9 colores usar para los fondos, los botones, el texto, los iconos, etc. Un buen esquema de color ayuda a:</p> <ul> <li>Crear Jerarqu\u00eda Visual: Gu\u00eda la atenci\u00f3n del usuario hacia los elementos m\u00e1s importantes.[1]</li> <li>Mejorar la Usabilidad: Asegura que el texto sea legible y que los elementos interactivos se distingan.[3]</li> <li>Transmitir la Personalidad de la Marca: Los colores evocan emociones y pueden reforzar la identidad de vuestra aplicaci\u00f3n</li> <li>Proporcionar Coherencia: Ofrece una experiencia unificada y profesional al usuario.</li> </ul> <p>Material Design 3 y el Color Din\u00e1mico (\"Material You\")</p> <p>Con la llegada de Material Design 3, tambi\u00e9n conocido como Material You, el concepto de esquema de color ha evolucionado significativamente. La caracter\u00edstica estrella es el color din\u00e1mico.</p> <p>En dispositivos con Android 12 y versiones posteriores, el sistema puede extraer colores del fondo de pantalla del usuario para generar una paleta de colores \u00fanica y personalizada que se aplica a todo el sistema y a las aplicaciones compatibles. Esto crea una experiencia profundamente personal y cohesiva para el usuario. Como desarrolladores, Jetpack Compose nos facilita enormemente la implementaci\u00f3n de estos temas din\u00e1micos.</p> <p>Fundamental: Leer sobre Color Scheme y Color Roles</p> <p>Fundamental leer para entender conceptos como \"Color Schema\", \"Color Roles\"</p>"},{"location":"temas/03/3.2-temas.html#2-personalizando-tu-tema","title":"\ud83c\udf08 2. Personalizando tu Tema","text":"<p>La verdadera potencia del sistema de Theming reside en su facilidad de personalizaci\u00f3n. Veamos c\u00f3mo ajustar cada uno de los pilares.</p>"},{"location":"temas/03/3.2-temas.html#personalizar-el-color","title":"Personalizar el Color","text":"<p>La personalizaci\u00f3n del color se realiza en los archivos <code>Color.kt</code> y <code>Theme.kt</code>.</p> <ol> <li> <p>Define tus colores base en <code>Color.kt</code>: </p><pre><code>// ui/theme/Color.kt\nval Purple80 = Color(0xFFD0BCFF)\nval PurpleGrey80 = Color(0xFFCCC2DC)\nval Pink80 = Color(0xFFEFB8C8)\n\nval Purple40 = Color(0xFF6650a4)\nval PurpleGrey40 = Color(0xFF625b71)\nval Pink40 = Color(0xFF7D5260)\n</code></pre><p></p> </li> <li> <p>Asigna esos colores a los roles del <code>ColorScheme</code> en <code>Theme.kt</code>:     Material 3 proporciona las funciones <code>lightColorScheme</code> y <code>darkColorScheme</code> para construir tus paletas. Solo necesitas asignar tus colores base a los roles que desees.</p> <p></p><pre><code>// ui/theme/Theme.kt\nprivate val DarkColorScheme = darkColorScheme(\n    primary = Purple80,\n    secondary = PurpleGrey80,\n    tertiary = Pink80,\n    background = Color(0xFF1C1B1F),\n    surface = Color(0xFF1C1B1F)\n    // ... puedes personalizar todos los dem\u00e1s roles\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = Purple40,\n    secondary = PurpleGrey40,\n    tertiary = Pink40,\n    background = Color(0xFFFFFBFE),\n    surface = Color(0xFFFFFBFE)\n    // ... otros colores\n)\n</code></pre> La clave aqu\u00ed es usar los roles de color sem\u00e1nticamente. Por ejemplo, <code>primary</code> se usar\u00e1 para elementos prominentes como botones principales, mientras que <code>surface</code> se usar\u00e1 para el fondo de componentes como <code>Card</code> o <code>Dialog</code>.<p></p> </li> </ol>"},{"location":"temas/03/3.2-temas.html#personalizar-la-tipografia","title":"Personalizar la Tipograf\u00eda \ud83d\udccf","text":"<p>La tipograf\u00eda se define en <code>Type.kt</code>. Puedes ajustar la familia de fuentes, el grosor, el tama\u00f1o y otros atributos para cada estilo de la escala.</p> <ol> <li>Agrega tus fuentes: Coloca tus archivos de fuentes (por ejemplo, <code>.ttf</code> u <code>.otf</code>) en la carpeta <code>res/font</code>.</li> <li>Define la <code>FontFamily</code>: <pre><code>// ui/theme/Type.kt\nval Montserrat = FontFamily(\n    Font(R.font.montserrat_regular),\n    Font(R.font.montserrat_bold, FontWeight.Bold)\n)\n</code></pre></li> <li> <p>Crea tu objeto <code>Typography</code>: Asigna tu <code>FontFamily</code> personalizada a los estilos de la escala tipogr\u00e1fica.</p> <p></p><pre><code>// ui/theme/Type.kt\nval Typography = Typography(\n    bodyLarge = TextStyle(\n        fontFamily = Montserrat,\n        fontWeight = FontWeight.Normal,\n        fontSize = 16.sp,\n        lineHeight = 24.sp,\n        letterSpacing = 0.5.sp\n    ),\n    titleLarge = TextStyle(\n        fontFamily = Montserrat,\n        fontWeight = FontWeight.Bold,\n        fontSize = 22.sp,\n        lineHeight = 28.sp,\n        letterSpacing = 0.sp\n    )\n    /* Define otros estilos de texto que necesites */\n)\n</code></pre> Luego, en tu composable de tema (<code>Theme.kt</code>), simplemente pasa este objeto <code>Typography</code> al par\u00e1metro <code>typography</code> de <code>MaterialTheme</code>.<p></p> </li> </ol>"},{"location":"temas/03/3.2-temas.html#personalizar-la-forma","title":"Personalizar la Forma \ud83d\udcd0","text":"<p>Las formas de los componentes se personalizan a trav\u00e9s del objeto <code>Shapes</code> en <code>Theme.kt</code>. Puedes definir el radio de las esquinas para las tres categor\u00edas de tama\u00f1o.</p> <p></p><pre><code>// ui/theme/Theme.kt (o un archivo Shapes.kt dedicado)\nval Shapes = Shapes(\n    small = RoundedCornerShape(4.dp),\n    medium = RoundedCornerShape(8.dp),\n    large = RoundedCornerShape(16.dp)\n)\n</code></pre> Componentes como <code>Button</code> y <code>TextField</code> usar\u00e1n por defecto <code>Shapes.small</code> o <code>Shapes.medium</code>, mientras que un <code>ModalBottomSheet</code> podr\u00eda usar <code>Shapes.large</code>. Esta jerarqu\u00eda de formas ayuda a crear una coherencia visual en toda la aplicaci\u00f3n.<p></p>"},{"location":"temas/03/3.2-temas.html#3-generando-un-tema-completo-desde-un-unico-color","title":"\ud83c\udfa8 3. Generando un Tema Completo desde un \u00danico Color","text":"<p>La caracter\u00edstica m\u00e1s destacada de Material You es su capacidad para generar una paleta de colores rica y accesible a partir de un \u00fanico color semilla (seed color). Esto no solo es la base para el color din\u00e1mico (que se adapta al fondo de pantalla del usuario), sino que tambi\u00e9n es una herramienta incre\u00edblemente poderosa para los desarrolladores para crear temas de marca personalizados.</p> <p>La herramienta oficial para esto es el Material Theme Builder, disponible tanto en la web como en Figma.</p>"},{"location":"temas/03/3.2-temas.html#pasos-para-generar-y-aplicar-tu-tema","title":"Pasos para Generar y Aplicar tu Tema:","text":"<ol> <li>Abre el Material Theme Builder: Navega a la herramienta web oficial.</li> <li>Elige tu Color Semilla: En la secci\u00f3n \"Primary\", introduce el c\u00f3digo hexadecimal de tu color de marca principal.</li> <li>Observa la Magia: La herramienta genera instant\u00e1neamente una paleta tonal completa para los colores primarios, secundarios, terciarios</li> </ol>"},{"location":"temas/03/3.2-temas.html#actividades","title":"\ud83c\udfcb\ufe0f Actividades","text":""},{"location":"temas/03/3.2-temas.html#a-practicar-aplicacion-superheroes-y-30-dias","title":"\ud83d\ude80 A pr\u00e1cticar: Aplicaci\u00f3n \"Superh\u00e9roes\" y \"30 d\u00edas\"","text":"<p>Para aprender los conceptos, vamos a trabajar con dos proyectos pr\u00e1cticos.</p> <ul> <li> <p>\u2b06\ufe0f Pr\u00e1ctica 1:</p> <p>Proyecto. App de Superh\u00e9roes. Sigue las indicaciones aqu\u00ed.</p> </li> </ul> <p></p> <ul> <li> <p>\u2b06\ufe0f Pr\u00e1ctica 2:</p> <p>Proyecto. 30 d\u00edas. Sigue las indicaciones aqu\u00ed.</p> </li> </ul> <p></p> <p>Aprende los conceptos previos que aplican en los proyectos</p> <p>Para ello, realiza los siguientes proyectos guiados:</p> <ol> <li>Codelab. Temas de Material con Compose. Codelab.</li> <li>Codelab. Animaci\u00f3n simple con Compose. Codelab.</li> </ol>"},{"location":"temas/03/3.3-arquitectura.html","title":"3.3.1. Introducci\u00f3n","text":""},{"location":"temas/03/3.3-arquitectura.html#33-arquitectura","title":"3.3 Arquitectura","text":"<p>En Android, la arquitectura de una aplicaci\u00f3n se refiere a la estructura y organizaci\u00f3n de sus componentes, como las actividades, fragmentos, servicios y otros elementos que la componen.</p> <p>Una buena arquitectura es fundamental para crear aplicaciones robustas, escalables y f\u00e1ciles de mantener.</p> <p>Antes de continuar y realizar las actividades de este apartado, lee a la documentaci\u00f3n de concepto de arquitectura</p>"},{"location":"temas/03/3.3-arquitectura.html#331-principios-de-arquitectura","title":"3.3.1 Principios de Arquitectura","text":"<p>El dise\u00f1o de la arquitectura de una aplicaci\u00f3n define los l\u00edmites y las responsabilidades de sus partes. Para construir una aplicaci\u00f3n robusta que pueda crecer y adaptarse a diversos factores de forma, se deben seguir los siguientes principios:</p> <ol> <li> <p>Separaci\u00f3n de Problemas (El Principio Fundamental): </p> <p>Este es el principio m\u00e1s importante. Consiste en evitar escribir todo el c\u00f3digo en clases basadas en la IU, como <code>Activity</code> o <code>Fragment</code>. Estas clases solo deben contener la l\u00f3gica relacionada con las interacciones de la IU y del sistema operativo. Al mantenerlas limpias, se mitigan los problemas relacionados con su ciclo de vida vol\u00e1til, ya que el SO puede destruirlas en cualquier momento.</p> </li> <li> <p>Controlar la IU a partir de modelos de datos: </p> <p>La interfaz de usuario debe ser impulsada por modelos de datos, que idealmente deben ser persistentes. Estos modelos son independientes de la IU y del ciclo de vida de los componentes, lo que mejora la solidez y la capacidad de prueba de la aplicaci\u00f3n.</p> </li> <li> <p>Dise\u00f1os Adaptables: </p> <p>La aplicaci\u00f3n debe manejar correctamente los cambios de configuraci\u00f3n (como la orientaci\u00f3n vertical/horizontal y los diferentes tama\u00f1os de pantalla) para proporcionar una experiencia de usuario \u00f3ptima en m\u00faltiples factores de forma.</p> </li> </ol>"},{"location":"temas/03/3.3-arquitectura.html#arquitectura-moderna-de-apps","title":"Arquitectura moderna de Apps","text":"<p>La arquitectura moderna de apps promueve t\u00e9cnicas espec\u00edficas que se implementan en las capas anteriores para asegurar la robustez del sistema:</p> <ol> <li>Arquitectura adaptable y en capas.</li> <li>Flujo unidireccional de datos (UDF) en todas las capas.</li> <li>Uso de contenedores de estado en la capa de la IU para administrar la complejidad.</li> <li>Uso de Corrutinas y Flows (Flujos) para operaciones as\u00edncronas.</li> <li>Uso de las mejores pr\u00e1cticas para la inserci\u00f3n de dependencias (DI). Google recomienda seguir estos patrones y usar la biblioteca Hilt para construir autom\u00e1ticamente objetos y proporcionar verificaci\u00f3n de dependencias en tiempo de compilaci\u00f3n.</li> </ol>"},{"location":"temas/03/3.3-arquitectura.html#arquitectura-recomendada-en-android","title":"Arquitectura recomendada en Android","text":"<p>La arquitectura de aplicaciones recomendada por Android est\u00e1 dise\u00f1ada para gestionar las condiciones de lanzamiento variables y las restricciones de recursos de los dispositivos m\u00f3viles. Considerando los principios comunes, toda aplicaci\u00f3n debe tener al menos dos capas: la Capa de la IU y la Capa de Datos. Una tercera capa, la Capa de Dominio, es opcional.</p> <p>estructura jer\u00e1rquica de la aplicaci\u00f3n</p> <p>Diagrama de arquitectura de una app</p> <p>arquitectura de app t\u00edpica muestra la estructura jer\u00e1rquica de la aplicaci\u00f3n, donde las flechas representan las dependencias entre las clases. Por ejemplo, la Capa de Dominio depende de las clases de la Capa de Datos.</p>"},{"location":"temas/03/3.3-arquitectura.html#1-capa-de-la-iu-capa-de-presentacion","title":"1. Capa de la IU (Capa de Presentaci\u00f3n)","text":"<p><code>Funci\u00f3n:</code> Mostrar los datos de la aplicaci\u00f3n en la pantalla y actualizar la IU cuando los datos cambian, ya sea por interacci\u00f3n del usuario o entrada externa (como una respuesta de red). Sus elementos clave son:</p> <ul> <li> <p>Elementos de la IU: Componentes que renderizan los datos. Se pueden compilar con Vistas o con las funciones de Jetpack Compose. Ambas opciones admiten dise\u00f1os adaptables.</p> </li> <li> <p>Contenedores de estados (State holders): Clases (como ViewModel) que retienen los datos, los exponen a la IU y controlan la l\u00f3gica de la IU.</p> </li> </ul> <p>El rol de la capa de la IU en la arquitectura de la app.</p> <p></p>"},{"location":"temas/03/3.3-arquitectura.html#2-capa-de-datos","title":"2. Capa de Datos","text":"<p><code>Funci\u00f3n:</code> Contener la l\u00f3gica empresarial de la aplicaci\u00f3n, es decir, las reglas que determinan c\u00f3mo se crean, almacenan y modifican los datos de la aplicaci\u00f3n.</p> <p>Estructura: Est\u00e1 compuesta por Repositorios, que administran las Fuentes de Datos.</p> <p>Repositorios</p> <p>Las clases de repositorio son responsables de las siguientes tareas:</p> <ul> <li>Exponer datos al resto de la app</li> <li>Centralizar los cambios en los datos</li> <li>Resolver conflictos entre m\u00faltiples fuentes de datos</li> <li>Abstraer fuentes de datos del resto de la app</li> <li>Contener la l\u00f3gica empresarial</li> </ul> <ul> <li> <p>Repositorios: Debe haber una clase de repositorio para cada tipo de dato que se administre (por ejemplo, <code>MoviesRepository</code> o <code>PaymentsRepository</code>).</p> </li> <li> <p>Responsabilidades: Exponer datos al resto de la app, centralizar los cambios en los datos, resolver conflictos entre m\u00faltiples fuentes, abstraer las fuentes de datos y contener la l\u00f3gica empresarial.</p> </li> <li> <p>Fuentes de Datos: Cada fuente de datos es responsable de trabajar con una sola fuente de datos (una red, un archivo o una base de datos local).</p> </li> </ul> <p>El rol de la capa de la IU en la arquitectura de la app.</p> <p>La imagen ilusta el rol de la capa de datos en la arquitectura de la app10. Esta capa es vital para la solidez, pues fomenta una arquitectura que prioriza la condici\u00f3n sin conexi\u00f3n (offline first), donde la fuente de informaci\u00f3n de la aplicaci\u00f3n suele ser una base de datos.</p> <p></p>"},{"location":"temas/03/3.3-arquitectura.html#3-capa-de-dominio-opcional","title":"3. Capa de Dominio (Opcional)","text":"<ul> <li>Funci\u00f3n: Encapsular la l\u00f3gica empresarial compleja o la l\u00f3gica simple que se reutiliza en varios <code>ViewModels</code>.</li> <li>Naturaleza: Es una capa opcional que se utiliza \u00fanicamente cuando se necesita administrar la complejidad o favorecer la reutilizaci\u00f3n, ubic\u00e1ndose entre la capa de IU y la de datos.</li> <li>Estructura: Las clases de esta capa se conocen como casos de uso (use cases) o interactores13. Cada caso de uso debe enfocarse en una funcionalidad \u00fanica (ejemplo: una clase <code>GetTimeZoneUseCase</code> si varios ViewModels necesitan consultar la zona horaria).</li> </ul> <p>El rol de la capa de la dominio en la arquitectura de la app.</p> <p>La imagen muestra el rol de la capa de dominio en la arquitectura de la app, sirviendo como un mediador para la l\u00f3gica compleja antes de que los datos lleguen a la capa de presentaci\u00f3n.</p>"},{"location":"temas/03/3.3-elementos-menus.html","title":"3.3. Elementos Tipo Menus","text":""},{"location":"temas/03/3.3-elementos-menus.html#33-elementos-tipo-menus","title":"3.3. Elementos Tipo Menus","text":"<p>Se incluye:</p> <ul> <li>Scaffold</li> <li>Menu</li> <li>TopAppBar</li> <li>BottomBar</li> <li>FloatingActionButton</li> <li>Drawer</li> </ul> <p>El componente de layout usado con estos componentes es Scaffold</p>"},{"location":"temas/03/3.3-elementos-menus.html#1-scaffold","title":"1. Scaffold","text":"<p>Piensa en Scaffold como el esqueleto b\u00e1sico de tu interfaz de usuario en una aplicaci\u00f3n Compose. Proporciona una estructura est\u00e1ndar para implementar la mayor\u00eda de las interfaces de usuario comunes.</p> <p>Estructura de Scaffold:</p> <ul> <li> <p><code>slots</code> para diferentes partes de la interfaz, como la barra de aplicaciones (app bar), el contenido principal, un drawer (men\u00fa lateral), FABs (Floating Action Buttons), y barras de navegaci\u00f3n o snackbar.</p> </li> <li> <p>Barra de Aplicaciones: Scaffold te permite agregar f\u00e1cilmente una barra de aplicaciones en la parte superior de la pantalla, donde generalmente colocas el t\u00edtulo de la pantalla, men\u00fas, y otras acciones.</p> </li> <li>Contenido Principal: Aqu\u00ed es donde colocas el contenido principal de tu pantalla. Scaffold se encarga de posicionar este contenido de manera que no se superponga con otros elementos como la barra de aplicaciones o el FAB.</li> <li>Drawer (Cajon): men\u00fa lateral (como el men\u00fa de hamburguesa), Scaffold tiene un slot para esto. Es \u00fatil para la navegaci\u00f3n en la app.</li> <li>Floating Action Button (FAB): Para acciones primarias en tu pantalla, puedes usar un FAB. Scaffold te permite agregarlo en un lugar adecuado, generalmente en la esquina inferior derecha.</li> <li>Bottom Bar y Snackbar: Si necesitas una barra de navegaci\u00f3n en la parte inferior o mostrar mensajes temporales (snackbars), Scaffold tambi\u00e9n te ofrece espacios para ellos.</li> </ul> <p>Revisa la documentaci\u00f3n oficial:</p> <p>La documentaci\u00f3n oficial siempre es el mejor lugar para profundizar en los detalles y ver ejemplos actualizados. Aqu\u00ed tienes algunos enlaces \u00fatiles:</p> <ul> <li>Scaffold en Jetpack Compose</li> </ul> <p>El componente <code>Scaffold</code> es un contenedor que proporciona una estructura b\u00e1sica para la aplicaci\u00f3n. Incluye \u00e1reas para el <code>TopAppBar</code>, <code>BottomBar</code>, <code>FloatingActionButton</code> y el contenido principal de la pantalla.</p> <p>Ejemplo scaffold</p> <pre><code>@Composable\nfun ScaffoldExample() {\n    var presses by remember { mutableIntStateOf(0) }\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                colors = topAppBarColors(\n                    containerColor = MaterialTheme.colorScheme.primaryContainer,\n                    titleContentColor = MaterialTheme.colorScheme.primary,\n                ),\n                title = {\n                    Text(\"Top app bar\")\n                }\n            )\n        },\n        bottomBar = {\n            BottomAppBar(\n                containerColor = MaterialTheme.colorScheme.primaryContainer,\n                contentColor = MaterialTheme.colorScheme.primary,\n            ) {\n                Text(\n                    modifier = Modifier\n                        .fillMaxWidth(),\n                    textAlign = TextAlign.Center,\n                    text = \"Bottom app bar\",\n                )\n            }\n        },\n        floatingActionButton = {\n            FloatingActionButton(onClick = { presses++ }) {\n                Icon(Icons.Default.Add, contentDescription = \"Add\")\n            }\n        }\n    ) { innerPadding -&gt;\n        Column(\n            modifier = Modifier\n                .padding(innerPadding),\n            verticalArrangement = Arrangement.spacedBy(16.dp),\n        ) {\n            Text(\n                modifier = Modifier.padding(8.dp),\n                text =\n                \"\"\"\n                    This is an example of a scaffold. It uses the Scaffold composable's parameters to create a screen with a simple top app bar, bottom app bar, and floating action button.\n\n                    It also contains some basic inner content, such as this text.\n\n                    You have pressed the floating action button $presses times.\n                \"\"\".trimIndent(),\n            )\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, se incluyen otros componentes como:</p> <ul> <li>TopAppBar y CenterAlignedTopAppBar Es el equivalente b\u00e1sico de una toolbar. Puedes personalizar el t\u00edtulo, los botones de acci\u00f3n, y el estilo en general. Por ejemplo -BottomAppBar: Este no es exactamente una toolbar, pero se utiliza para una barra de navegaci\u00f3n en la parte inferior de la pantalla. Es com\u00fan en aplicaciones modernas, ofreciendo accesos directos a las funciones principales.</li> <li>Custom AppBar: Puedes crear tu propia AppBar personalizada usando Row o cualquier otro layout combinado con los componentes de Material Design como IconButton, Text, etc. Esto te da libertad total para dise\u00f1ar algo \u00fanico.</li> <li>FloatingActionButton : Este bot\u00f3n flotante es ideal para acciones principales en tus pantallas, como agregar un nuevo elemento, iniciar una nueva conversaci\u00f3n, etc.</li> <li>Drawer: caj\u00f3n lateral para navegaci\u00f3n adicional o configuraciones.</li> </ul> <p>Lee este post para un ejemplo completo de uso de Scaffold en Compose: Scaffold en Jetpack Compose: Estructura b\u00e1sica para tu UI</p>"},{"location":"temas/03/3.3-elementos-menus.html#2-menus","title":"2. Menus","text":"<p>Los men\u00fas son componentes de interfaz de usuario que permiten a los usuarios seleccionar opciones o acciones de una lista desplegable. En Jetpack Compose, puedes crear men\u00fas utilizando la funci\u00f3n <code>DropdownMenu</code> y <code>ExposedDropdownMenuBox</code>.</p> <p>Revisa la documentaci\u00f3n oficial:</p> <p>Documentaci\u00f3n oficial para profundizar en los detalles y ver ejemplos actualizados:</p> <ul> <li>Menus en Jetpack Compose</li> <li>Menus en Material Design</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#21-menu-desplegable-dropdownmenu","title":"2.1. Men\u00fa desplegable (DropdownMenu)","text":"<p>En este punto vamos a ver el uso de men\u00fas en Compose, con el fin de desplegar una lista de opciones en superficies que aparecen temporalmente hasta que el usuario selecciona una de ellas, o cancela la selecci\u00f3n.</p> <p>Tipos de men\u00fas en Material Design</p> <p>Existen dos tipos de men\u00fas: Dropdown Menu y Exposed Dropdown Menu. </p> <p>La siguiente es una tabla con m\u00e1s detalle sobre el contenido de la lecci\u00f3n:</p> <p>Dropdown Menu en Compose</p> <p>La funci\u00f3n composable <code>DropdownMenu</code> muestra un men\u00fa desplegable que aparece al hacer clic en un bot\u00f3n o cualquier otro elemento interactivo. Este men\u00fa puede contener varias opciones que el usuario puede seleccionar.</p> <pre><code>@Composable\nfun DropdownMenu(\n    expanded: Boolean!,\n    onDismissRequest: (() -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    offset: DpOffset! = DpOffset(0.dp, 0.dp),\n    properties: PopupProperties! = PopupProperties(focusable = true),\n    content: (@Composable @ExtensionFunctionType ColumnScope.() -&gt; Unit)?\n): Unit\n</code></pre> <p>Donde:</p> <ul> <li><code>expanded</code>: Indica si el men\u00fa est\u00e1 expandido (visible) o no.</li> <li><code>onDismissRequest</code>: Callback que se llama cuando el men\u00fa debe cerrarse.</li> <li><code>modifier</code>: Modificador para personalizar el men\u00fa.</li> <li><code>offset</code>: Desplazamiento del men\u00fa desde su posici\u00f3n predeterminada.</li> <li><code>properties</code>: Propiedades del popup que contiene el men\u00fa.</li> <li><code>content</code>: Contenido del men\u00fa, generalmente una lista de <code>DropdownMenuItem</code>.</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#agregar-elementos-al-menu","title":"Agregar elementos al men\u00fa","text":"<p>Dentro del contenido del <code>DropdownMenu</code>, puedes agregar elementos utilizando la funci\u00f3n <code>DropdownMenuItem</code>. Cada elemento representa una opci\u00f3n en el men\u00fa.</p> <pre><code>@Composable\nfun DropdownMenuItem(\n    onClick: (() -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    enabled: Boolean! = true,\n    contentPadding: PaddingValues! = PaddingValues(16.dp),\n    leadingIcon: (@Composable () -&gt; Unit)? = null,\n    trailingIcon: (@Composable () -&gt; Unit)? = null,\n    text: (@Composable () -&gt; Unit)?\n): Unit\n</code></pre> <p>Donde: - <code>onClick</code>: Callback que se llama cuando el elemento es seleccionado. - <code>modifier</code>: Modificador para personalizar el elemento. - <code>enabled</code>: Indica si el elemento est\u00e1 habilitado o deshabilitado. - <code>contentPadding</code>: Padding alrededor del contenido del elemento. - <code>leadingIcon</code>: Icono que aparece antes del texto. - <code>trailingIcon</code>: Icono que aparece despu\u00e9s del texto. - <code>text</code>: Contenido de texto del elemento.</p> DropdownMenu simple <p></p> <p>Ejemplo de Dropdown Menu</p> <p></p> <p>Supongamos que tenemos una App de tareas y deseamos incluir en su vista de lista un men\u00fa para realizar las siguientes acciones:</p> <ul> <li>Cambiar nombre</li> <li>Enviar por email</li> <li>Copiar enlace</li> <li>Ocultar subtareas completas</li> <li>Eliminar</li> </ul> <p>Para crear el men\u00fa debemos:</p> <ol> <li>Definir la expansi\u00f3n del men\u00fa como estado</li> <li>Declarar la lista de opciones</li> <li>Invocar a <code>DropdownMenu</code></li> <li>A\u00f1adir cinco elementos <code>DropdownMenuItem</code></li> </ol> <p>El c\u00f3digo de la soluci\u00f3n lo encuentras en la funci\u00f3n <code>TaskMenu()</code></p> <p></p><pre><code>@Composable\nfun TaskMenu(\n    expanded: Boolean, // (1)\n    onItemClick: (String) -&gt; Unit,\n    onDismiss: () -&gt; Unit\n) {\n\n    val options = listOf( // (2)\n        \"Cambiar nombre\",\n        \"Enviar por email\",\n        \"Copiar enlace\",\n        \"Ocultar subtareas completas\",\n        \"Eliminar\"\n    )\n\n    DropdownMenu( // (3)\n        expanded = expanded,\n        onDismissRequest = onDismiss\n    ) {\n        options.forEach { option -&gt;\n            DropdownMenuItem( // (4)\n                onClick = {\n                    onItemClick(option)\n                    onDismiss()\n                }\n            ) {\n                Text(text = option)\n            }\n        }\n    }\n}\n</code></pre> Como ves, hemos elevado el estado de la expansi\u00f3n y las funciones ejecutadas al clickear un \u00edtem y al descartar el men\u00fa. Estos valores son prove\u00eddos desde la funci\u00f3n TasksUi(), la cual se encarga de dibujar la tarea y el icono que muestra al men\u00fa:<p></p> <p></p><pre><code>@Composable\nfun TasksUi() {\n    var taskMenuOpen by remember { mutableStateOf(false) }\n    var action by remember { mutableStateOf(\"Ninguna\") }\n\n    Box(\n        Modifier\n            .border(width = 1.dp, shape = RectangleShape, color = Color.LightGray)\n            .padding(horizontal = 16.dp)\n            .fillMaxWidth()\n            .height(56.dp)\n\n    ) {\n        Row(\n            Modifier\n                .fillMaxWidth()\n                .align(Alignment.CenterStart),\n            verticalAlignment = Alignment.CenterVertically\n        ) {\n            Checkbox(\n                checked = false,\n                onCheckedChange = {},\n                modifier = Modifier\n                    .size(24.dp)\n            )\n            Spacer(modifier = Modifier.width(16.dp))\n            Column {\n\n                Text(\n                    text = \"Limpiar alacena\"\n                )\n                Text(text = \"Acci\u00f3n: $action\", style = MaterialTheme.typography.caption)\n            }\n\n        }\n        IconButton(\n            onClick = { taskMenuOpen = true },\n            modifier = Modifier\n                .size(24.dp)\n                .align(Alignment.CenterEnd)\n        ) {\n            Icon(\n                imageVector = Icons.Filled.MoreVert,\n                contentDescription = \"Acciones para tarea\"\n            )\n            TaskMenu(\n                expanded = taskMenuOpen,\n                onItemClick = { action = it },\n                onDismiss = {\n                    taskMenuOpen = false\n                }\n            )\n        }\n    }\n}\n</code></pre> Al ejecutar la aplicaci\u00f3n, veremos el siguiente resultado:<p></p> <p></p> <p>TaskUI() en acci\u00f3n</p> <p></p> Ejemplo: Item con icono, item deshabilitado y divisor <p></p> <p>DropdownMenu con \u00edtems personalizados</p> <p></p> <p>Probemos con un caso donde podamos personalizar los \u00edtems como el que se muestra en la imagen anterior.</p> <p>Consideremos una App donde permitamos al usuario desplegar un men\u00fa para un imagen que visualiza, cuando hace clic prolongado. Las opciones asociadas y las decoraciones son:</p> <ul> <li>Previsualizar (Icono)</li> <li>Compartir (Icono)</li> <li>Copiar Enlace (Icono)</li> <li>Descargar (Icono + Deshabilitado)</li> <li>Denunciar (Icono + Divisor)</li> </ul> <p>\u00bfC\u00f3mo enfrentar estos requerimientos de interfaz?</p> <ol> <li>Iconos: Usa el componente <code>Icon</code> en el par\u00e1metro <code>content</code> de los \u00edtems. Recuerda que este tiene un recibidor tipo <code>RowScope</code>, por lo que no es necesario a\u00f1adir un elemento <code>Row</code></li> <li>Estado Deshabilitado: Usa el par\u00e1metro <code>enabled</code> con el valor de <code>false</code> para deshabilitar un \u00edtem</li> <li>Divisor: Invoca al componente <code>Divider</code> entre los \u00edtems donde deseas visualizarlo. En nuestro caso es antes de \u00abDescargar\u00bb</li> </ol> <p>Los elementos previos podemos agruparlos en una clase de datos llamada <code>Option</code>. Adem\u00e1s, como deseamos tratar al divisor como otro \u00edtem, podemos crear una interfaz sellada <code>MenuItem</code> que contenga ambos tipos</p> <p></p><pre><code>sealed interface MenuItem {\n\n    data class Option(\n        val name: String,\n        val icon: ImageVector?,\n        val enabled: Boolean = true\n    ) : MenuItem\n\n    object Divider : MenuItem\n}\n</code></pre> Teniendo en cuenta lo anterior, te ser\u00e1 f\u00e1cil comprender la funci\u00f3n de ejemplo ImageMenu():<p></p> <pre><code>@Composable\nfun ImageMenu(\n    expanded: Boolean,\n    onItemClick: (Option) -&gt; Unit, // (1)\n    onDismiss: () -&gt; Unit\n) {\n    val options = listOf( // (2)\n        Option(\n            \"Previsualizar\",\n            ImageVector.vectorResource(R.drawable.ic_visibility)\n        ),\n        Option(\"Compartir\", Icons.Filled.Share),\n        Option(\"Copiar Enlace\", ImageVector.vectorResource(R.drawable.ic_link)),\n        Option(\"Descargar\", ImageVector.vectorResource(R.drawable.ic_file_download), false),\n        Divider,\n        Option(\"Denunciar\", ImageVector.vectorResource(R.drawable.ic_flag)),\n    )\n\n    DropdownMenu(\n        expanded = expanded,\n        onDismissRequest = onDismiss,\n        offset = DpOffset(50.dp, 250.dp),\n        modifier = Modifier.width(192.dp)\n    ) {\n        options.forEach { option -&gt;\n            when (option) { // (3)\n                is Option -&gt; {\n                    DropdownMenuItem(\n                        enabled = option.enabled,\n                        onClick = {\n                            onItemClick(option)\n                            onDismiss()\n                        }\n                    ) {\n                        option.icon?.let { // (4)\n                            val values = LocalContentAlpha provides\n                                    if (option.enabled)\n                                        ContentAlpha.medium\n                                    else ContentAlpha.disabled\n                            CompositionLocalProvider(values) {\n                                Icon(it, contentDescription = null)\n                            }\n                        }\n\n                        Spacer(Modifier.width(24.dp))\n\n                        Text(text = option.name)\n                    }\n                }\n                Divider -&gt; Divider() // (5)\n            }\n\n        }\n    }\n}\n</code></pre> <p>El en acci\u00f3n se ve as\u00ed:</p> <p></p> <p>ImageUI en acci\u00f3n</p> <p></p> <p> </p>"},{"location":"temas/03/3.3-elementos-menus.html#22-exposed-dropdown-menu","title":"2.2. Exposed Dropdown Menu","text":"<p>Exposed Dropdown Menu en Compose</p> <p>Usa la funci\u00f3n componible <code>ExposedDropdownMenuBox()</code> para mostrar un men\u00fa desplegable expuesto, con el objetivo de mantener visible la selecci\u00f3n actual por encima de las dem\u00e1s opciones.</p> <p>Esta es la firma de la funci\u00f3n:</p> <pre><code>@ExperimentalMaterialApi\n@Composable\nfun ExposedDropdownMenuBox(\n    expanded: Boolean!,\n    onExpandedChange: ((Boolean) -&gt; Unit)?,\n    modifier: Modifier! = Modifier,\n    content: (@Composable @ExtensionFunctionType ExposedDropdownMenuBoxScope.() -&gt; Unit)?\n): Unit\n</code></pre> <p>Nota: Como ves, en el momento que escribo este tutorial, a\u00fan est\u00e1 marcada como experimental.</p> <p>Sus par\u00e1metros son similares a <code>DropdownMenu</code>, salvo <code>onExpandedChange</code> que es una lambda que se ejecuta cuando el usuario hace clic sobre el men\u00fa.</p> Ejemplo: Expanded Dropdown Menu Simple <p></p> <p>Ejemplo de Exposed Dropdown Menu</p> <p></p> <p>Tomemos como ilustraci\u00f3n un men\u00fa expuesto que permite seleccionar el tipo de tel\u00e9fono que ser\u00e1 asociado a un contacto (figura 7), donde las posibles opciones son:</p> <ul> <li>Fijo</li> <li>M\u00f3vil</li> <li>Trabajo</li> <li>Otro</li> </ul> <p>\u00bfC\u00f3mo abordar este simple escenario?</p> <ol> <li>Declarar la lista de tipos de n\u00famero de tel\u00e9fonos</li> <li>Declarar estados tanto para la apertura del men\u00fa como para la selecci\u00f3n actual</li> <li>Invocar a <code>ExpandedDropdownMenuBox</code></li> <li>A\u00f1adir un <code>[TextField](https://www.develou.com/android-textfield-en-compose/)</code></li> <li>A\u00f1adir un <code>DropdownMenu</code> con los items</li> </ol> <p>La funci\u00f3n componible <code>PhoneNumberTypeMenu()</code> es la encargada de aplicar las tareas anteriores:</p> <pre><code>@OptIn(ExperimentalMaterialApi::class)\n@Composable\nfun PhoneNumberTypeMenu() {\n    val types = listOf(\"Fijo\", \"M\u00f3vil\", \"Trabajo\", \"Otro\")\n    val default = 0\n\n    var expanded by remember { mutableStateOf(false) }\n    var selectedType by remember { mutableStateOf(types[default]) } // (1)\n\n    ExposedDropdownMenuBox(\n        expanded = expanded,\n        onExpandedChange = {\n            expanded = !expanded // (2)\n        },\n        modifier = Modifier.width(150.dp)\n    ) {\n        TextField(\n            readOnly = true, // (3)\n            value = selectedType, // (4)\n            onValueChange = { },\n            label = { Text(\"Tipo\") },\n            trailingIcon = {\n                ExposedDropdownMenuDefaults.TrailingIcon( // (5)\n                    expanded = expanded\n                )\n            },\n            colors = ExposedDropdownMenuDefaults.textFieldColors()\n        )\n        ExposedDropdownMenu(\n            expanded = expanded,\n            onDismissRequest = {\n                expanded = false\n            }\n        ) {\n            types.forEach { selectionOption -&gt;\n                DropdownMenuItem(\n                    onClick = {\n                        selectedType = selectionOption\n                        expanded = false\n                    }\n                ) {\n                    Text(text = selectionOption)\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Puntos a tener en cuenta del c\u00f3digo preliminar:</p> <ol> <li>Es necesario recordar como estado la selecci\u00f3n actual del <code>TextField</code></li> <li>Modificamos el estado de expansi\u00f3n del men\u00fa desde <code>onExpandedChange</code></li> <li>Como no deseamos recibir texto, marcamos al <code>TextField</code> como solo lectura</li> <li>El valor del campo de texto es definido por la selecci\u00f3n actual</li> <li>El icono del final del campo de texto es prove\u00eddo por <code>ExposedDropdownMenuDefaults.TrailingIcon()</code>. Si revisas su implementaci\u00f3n, ver\u00e1s que se cambia la rotaci\u00f3n del icono de expansi\u00f3n seg\u00fan el valor pasado como par\u00e1metro</li> </ol> <p>Al previsualizar en modo de interacci\u00f3n el resultado es:</p> <p></p> <p><code>PhoneNumberTypeMenu()</code> en acci\u00f3n</p> <p></p>"},{"location":"temas/03/3.3-elementos-menus.html#3-topappbar-bottombar-y-floatingactionbutton","title":"3. TopAppBar, BottomBar y FloatingActionButton","text":""},{"location":"temas/03/3.3-elementos-menus.html#31-topappbar","title":"3.1. TopAppBar","text":"<p>La barra de aplicaciones superior (TopAppBar) es un componente clave en la interfaz de usuario de muchas aplicaciones. Proporciona un espacio para el t\u00edtulo de la pantalla, acciones y navegaci\u00f3n.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>TopAppBar en Jetpack Compose</li> <li>TopAppBar en Material Design</li> <li>TopAppBar playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#32-bottombar","title":"3.2. BottomBar","text":"<p>La barra inferior (BottomBar) es otro componente importante que se utiliza para la navegaci\u00f3n y las acciones en la parte inferior de la pantalla.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>BottomBar en Jetpack Compose</li> <li>BottomBar en Material Design</li> <li>BottomBar playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#33-floatingactionbutton","title":"3.3. FloatingActionButton","text":"<p>El bot\u00f3n de acci\u00f3n flotante (FloatingActionButton o FAB) es un componente que representa la acci\u00f3n principal en una pantalla. Suele ser un bot\u00f3n circular que flota sobre el contenido.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>Documentaci\u00f3n Jetpack Compose</li> <li>Material Design</li> <li>Playgroud</li> </ul>"},{"location":"temas/03/3.3-elementos-menus.html#34-drawer","title":"3.4. Drawer","text":"<p>El drawer (caj\u00f3n) es un componente de navegaci\u00f3n que se desliza desde el borde de la pantalla para mostrar opciones de navegaci\u00f3n adicionales.</p> <p>Revisa la siguiente documentaci\u00f3n para m\u00e1s detalles sobre su uso:</p> <ul> <li>Drawer en Jetpack Compose</li> <li>Drawer en Material Design</li> <li>Drawer playgroud</li> </ul>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html","title":"3.3.2 arquitectura.capa ui","text":""},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#332-capa-ui-arquitectura","title":"3.3.2 \ud83e\uddf1 Capa UI. Arquitectura","text":"<p>La capa de UI es la parte de tu aplicaci\u00f3n con la que el usuario interact\u00faa directamente. Su principal responsabilidad es mostrar los datos de la aplicaci\u00f3n en la pantalla y, a su vez, ser el punto de entrada para las acciones del usuario (clics, escritura, etc.).</p> <p>Piensa en ella como la cabina de un avi\u00f3n \u2708\ufe0f. El piloto (usuario) ve los instrumentos (la pantalla) y acciona los controles (botones, gestos). La cabina no sabe c\u00f3mo funciona el motor; solo muestra la velocidad y env\u00eda la orden \"acelerar\" a las capas internas.</p> <p>Esta capa se compone fundamentalmente de dos tipos de elementos:</p> <ol> <li> <p>Elementos de la UI (UI Elements): Son los componentes visuales que dibujan la pantalla. En Jetpack Compose, estos son tus funciones <code>@Composable</code>. Su \u00fanica misi\u00f3n es transformar un estado en una interfaz gr\u00e1fica. Son \"tontos\" por dise\u00f1o: reciben un estado y lo pintan. No toman decisiones de l\u00f3gica de negocio.</p> </li> <li> <p>Contenedores de Estado (State Holders): Son clases responsables de contener el estado, gestionar la l\u00f3gica de la UI y exponer los datos a los Elementos de la UI. La clase m\u00e1s com\u00fan para esto es el <code>ViewModel</code>. Este es el \"cerebro\" \ud83e\udde0 de la pantalla.</p> </li> </ol>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#el-flujo-de-datos-unidireccional-udf","title":"\u21aa\ufe0f El Flujo de Datos Unidireccional (UDF)","text":"<p>Para que todo funcione de forma ordenada y predecible, la comunicaci\u00f3n entre estos dos componentes sigue un patr\u00f3n estricto llamado Flujo de Datos Unidireccional (Unidirectional Data Flow o UDF).</p> <p>Es muy simple de entender:</p> <ul> <li> <p>El Estado fluye hacia abajo (State flows down) \ud83d\udc47: El <code>ViewModel</code> expone el estado (usando un <code>StateFlow</code>). El Composable lo recoge y se dibuja bas\u00e1ndose en \u00e9l.</p> </li> <li> <p>Los Eventos fluyen hacia arriba (Events flow up) \ud83d\udc46: El Composable no modifica el estado directamente. Cuando el usuario hace clic en un bot\u00f3n, el Composable notifica al <code>ViewModel</code> de este \"evento\" (ej: <code>viewModel.onIncrementarClick()</code>). El <code>ViewModel</code> es quien decide qu\u00e9 hacer y, si es necesario, actualiza su estado.</p> </li> </ul> <p>UDF: Flujo de datos unidireccional.</p> <p>Este ciclo crea un bucle predecible: <code>Evento -&gt; Actualizar Estado -&gt; Mostrar Nuevo Estado</code>.</p> <p>El flujo de datos unidireccional (UDF) es una t\u00e9cnica que se utiliza principalmente en la programaci\u00f3n reactiva funcional. Tambi\u00e9n se conoce como flujo de datos unidireccional, lo que significa que los datos solo pueden transferirse de una manera a otras partes de la aplicaci\u00f3n.</p> <p>La unidireccionalidad significa que no obtenemos nuestros datos solicit\u00e1ndolos directamente. La \u00fanica forma de obtenerlos es activando una acci\u00f3n desde nuestra vista a nuestra capa de datos. El efecto secundario de esta acci\u00f3n es actualizar el estado de nuestros datos.</p> <p>La vista es el resultado del estado de la aplicaci\u00f3n. El estado solo puede cambiar al activar acciones. Cuando se realizan acciones, el estado se actualiza.</p> <p>Acci\u00f3n del estado sobre la vista.</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#como-definir-el-estado-de-la-ui","title":"\u00bfC\u00f3mo definir el estado de la UI?","text":"<p>La IU es lo que ve el usuario, el estado de la IU es lo que la app dice que deber\u00eda ver. Al igual que dos caras de una moneda, la IU es la representaci\u00f3n visual del estado de la IU. Cualquier cambio en el estado de la IU se refleja de inmediato en la IU.</p> <p>La IU es el resultado de la vinculaci\u00f3n de sus elementos en la pantalla con el estado correspondiente..</p> <pre><code>data class NewsUiState(\n    val isSignedIn: Boolean = false,\n    val isPremium: Boolean = false,\n    val newsItems: List&lt;NewsItemUiState&gt; = listOf(),\n    val userMessages: List&lt;Message&gt; = listOf()\n)\n\ndata class NewsItemUiState(\n    val title: String,\n    val body: String,\n    val bookmarked: Boolean = false,\n    ...\n)\n</code></pre> <p>Inmutabilidad</p> <p>La inmutabilidad del estado significa que la UI tiene prohibido modificar los datos que recibe. Su \u00fanica misi\u00f3n es actuar como un espejo, reflejando fielmente el estado actual.</p> <p>Para realizar un cambio, no se \"edita\" el estado viejo, sino que se reemplaza por completo con una instancia nueva y actualizada.</p> <p>Esto impone un orden estricto, garantizando una \u00fanica fuente de verdad. As\u00ed se eliminan los errores impredecibles que ocurren cuando distintas partes del c\u00f3digo intentan modificar los mismos datos a la vez, resultando en una app mucho m\u00e1s estable y predecible.</p> <p>Inmutablidad de forma simple</p> <p>La inmutabilidad en Compose es crucial porque convierte el estado de tu pantalla en una fotograf\u00eda perfecta e inalterable de un momento concreto.</p> <p>Pi\u00e9nsalo con esta analog\u00eda:</p> <ul> <li>El Estado Inmutable es como un plano de una casa \ud83c\udfe0 sellado y firmado por el arquitecto.</li> <li>Jetpack Compose es el equipo de construcci\u00f3n \ud83d\udc77.</li> <li>El ViewModel es el arquitecto \ud83d\udcd0.</li> </ul> <p>Ahora, analicemos por qu\u00e9 esto es tan importante:</p> <ol> <li> <p>Claridad y Previsibilidad</p> <p>El equipo de construcci\u00f3n (Compose) recibe el plano (el objeto de estado) y su \u00fanica tarea es construir la casa exactamente como dice el plano. No tienen que adivinar nada. Saben que el plano que tienen en sus manos es la verdad absoluta en ese momento. Esto hace que su trabajo sea simple y predecible.</p> <p>Esto es lo que el texto quiere decir con: \"los objetos inmutables proporcionan garant\u00edas sobre el estado de la aplicaci\u00f3n en un momento determinado\".</p> </li> <li> <p>Evitar el Caos y los Errores</p> <p>Imagina que el estado fuera mutable (que se pudiera cambiar). Ser\u00eda como si, mientras los obreros construyen, \u00a1cualquiera de ellos pudiera coger un l\u00e1piz y modificar el plano sobre la marcha!</p> <ul> <li>\u00bfD\u00f3nde ir\u00eda esa pared ahora?</li> <li>\u00bfEl electricista estar\u00eda trabajando con el plano antiguo o con el nuevo que acaba de cambiar un fontanero?</li> </ul> <p>Ser\u00eda un caos absoluto. Tendr\u00edas varias versiones de la \"verdad\" al mismo tiempo, lo que llevar\u00eda a errores de construcci\u00f3n (bugs en tu app) muy dif\u00edciles de encontrar.</p> <p>Esto es a lo que se refiere el texto con: \"Infringir este principio genera varias fuentes ver\u00eddicas para la misma informaci\u00f3n, lo que genera inconsistencias en los datos y errores leves\".</p> </li> <li> <p>\u00bfC\u00f3mo se hacen los cambios entonces?</p> <p>Cuando el arquitecto (ViewModel) quiere hacer un cambio (por ejemplo, a\u00f1adir una ventana), no borra y redibuja sobre el plano viejo. Lo que hace es crear un plano completamente nuevo con la ventana a\u00f1adida y se lo entrega al equipo de construcci\u00f3n.</p> <p>El equipo de construcci\u00f3n ve el nuevo plano, lo compara con el anterior y de forma muy eficiente solo construye la parte nueva: la ventana.</p> </li> </ol> <p>Contenedores de estado</p> <p>Un State Holder (o \"contenedor de estado\") es simplemente una clase responsable de guardar y gestionar los datos que tu UI necesita para mostrar en pantalla.</p> <p>Su principal objetivo es separar la l\u00f3gica del dise\u00f1o visual. De esta forma, tus componentes de UI (<code>Composables</code>) se dedican \u00fanicamente a \"pintar\" el estado que reciben, mientras que el State Holder act\u00faa como el \"cerebro\" \ud83e\udde0 que procesa las acciones del usuario y decide qu\u00e9 datos se deben mostrar.</p> <p>En resumen, es el lugar donde vive el estado y la l\u00f3gica de tu pantalla, manteniendo tu c\u00f3digo de UI limpio, simple y f\u00e1cil de probar. El <code>ViewModel</code> es el tipo de State Holder m\u00e1s com\u00fan y recomendado en Android.</p> <p>Punto clave \ud83d\udca1</p> <p>El ViewModel es la implementaci\u00f3n recomendada para administrar el estado de la IU a nivel de pantalla con acceso a la capa de datos. Adem\u00e1s, sobrevive autom\u00e1ticamente a los cambios de configuraci\u00f3n. Las clases ViewModel definen la l\u00f3gica que se aplica a los eventos en la app y, como resultado, producen un estado actualizado.</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#mvvm-el-patron-arquitectonico-por-excelencia","title":"\ud83e\uddee MVVM: El Patr\u00f3n Arquitect\u00f3nico por Excelencia","text":"<p>MVVM son las siglas de Model-View-ViewModel. Es un patr\u00f3n de dise\u00f1o arquitect\u00f3nico que se adapta como un guante a los principios de la capa de UI y el flujo de datos unidireccional. Su objetivo es separar las responsabilidades de forma muy clara.</p> <p>Vamos a desglosar sus tres componentes:</p> <ol> <li> <p>Model (Modelo)</p> <ul> <li>\u00bfQu\u00e9 es? Es la capa de datos de tu aplicaci\u00f3n. Contiene la l\u00f3gica de negocio y es la fuente de la verdad.  </li> <li>\u00bfQu\u00e9 hace? Es responsable de obtener y manipular los datos, ya sea desde una base de datos local (Room), una API de red (Retrofit) o cualquier otra fuente.</li> <li>Componentes: Clases de datos (data classes), Repositorios, Casos de Uso, Fuentes de Datos (Data Sources).    </li> </ul> </li> <li> <p>View (Vista)</p> <ul> <li>\u00bfQu\u00e9 es? Es la interfaz de usuario (UI). Lo que el usuario ve y con lo que interact\u00faa.  </li> <li>\u00bfQu\u00e9 hace? Su \u00fanica responsabilidad es observar los datos expuestos por el ViewModel y dibujarse a s\u00ed misma. Captura las interacciones del usuario y las notifica al ViewModel como eventos.</li> <li>Componentes: En Android tradicional, eran los <code>Activities</code> y <code>Fragments</code> con XML. En el mundo moderno, son tus funciones <code>@Composable</code> en Jetpack Compose.</li> </ul> </li> <li> <p>ViewModel (Vista-Modelo)</p> <ul> <li>\u00bfQu\u00e9 es? Es el intermediario entre el Modelo y la Vista.  </li> <li>\u00bfQu\u00e9 hace? No tiene ninguna referencia a la Vista (\u00a1muy importante!), lo que lo hace f\u00e1cil de testear. Solicita datos al Modelo, aplica la l\u00f3gica de presentaci\u00f3n necesaria y expone el estado listo para ser consumido por la Vista (a trav\u00e9s de <code>StateFlow</code>). Tambi\u00e9n recibe los eventos de la Vista y decide qu\u00e9 acci\u00f3n pedirle al Modelo.</li> <li>Componentes: Clases que heredan de <code>androidx.lifecycle.ViewModel</code>.</li> </ul> </li> </ol> <p>Diagrama que ilustra el ciclo de eventos y datos en el flujo unidireccional de datos</p>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#tipos-de-logica","title":"Tipos de L\u00f3gica","text":"<p>La \"l\u00f3gica\" se refiere de manera general a las instrucciones, reglas y procesos algor\u00edtmicos que dictan el comportamiento de una aplicaci\u00f3n de software.</p> <p>El texto distingue principalmente entre dos tipos de l\u00f3gica esenciales en el desarrollo de aplicaciones: la l\u00f3gica empresarial y la l\u00f3gica de la Interfaz de Usuario (IU), a veces llamada l\u00f3gica de comportamiento de la IU.</p> <ul> <li> <p>L\u00f3gica Empresarial</p> <p>Representa la aplicaci\u00f3n de las reglas y requerimientos funcionales fundamentales del producto directamente sobre los datos de la aplicaci\u00f3n. Su prop\u00f3sito es definir qu\u00e9 debe hacer la aplicaci\u00f3n con la informaci\u00f3n para cumplir con sus objetivos de valor.</p> <ul> <li><code>Ubicaci\u00f3n:</code> Generalmente reside en las capas de dominio o datos, asegurando que est\u00e9 desacoplada de c\u00f3mo se presenta la informaci\u00f3n. </li> <li><code>Principio Clave:</code> Nunca debe ubicarse en la capa de la Interfaz de Usuario (IU).</li> </ul> </li> <li> <p>L\u00f3gica de la Interfaz de Usuario (IU) o Comportamiento de la IU</p> <p>Determina c\u00f3mo se manifiestan los cambios de estado o las acciones en la pantalla para el usuario. Se encarga de la gesti\u00f3n de la presentaci\u00f3n visual y la interacci\u00f3n.</p> <ul> <li> <p><code>Funci\u00f3n:</code> Incluye la preparaci\u00f3n de elementos para su visualizaci\u00f3n, la navegaci\u00f3n entre vistas como respuesta a interacciones, y la gesti\u00f3n de retroalimentaci\u00f3n visual al usuario (como mensajes temporales).</p> </li> <li> <p><code>Ubicaci\u00f3n:</code> Debe encontrarse en la capa de la IU (la Vista). Si esta l\u00f3gica se vuelve compleja, puede delegarse a una clase auxiliar dentro de la propia IU para mejorar la separaci\u00f3n de responsabilidades y la capacidad de prueba, manteniendo su v\u00ednculo al ciclo de vida de la IU.</p> </li> </ul> </li> </ul>"},{"location":"temas/03/3.3.2-arquitectura.capa-ui.html#aplicando-todo-ejemplos","title":"Aplicando todo. Ejemplos","text":"<p>El el \"Ejemplo 1\" tenemos una aplicaci\u00f3n simple \"Contador\", con un bot\u00f3n que incrementa un n\u00famero al darle click al Bot\u00f3n. El estado \"vive\" dentro del componente \"CounterScreen\".</p> Ejemplo 1: App contador simple <pre><code>// 1. Contador Simple (Estado Local)\n// El estado y la l\u00f3gica residen en el mismo Composable.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n// Funci\u00f3n de entrada para la aplicaci\u00f3n (simulando una actividad/main)\n@Composable\nfun CounterApp1() {\n    MaterialTheme {\n        CounterScreen()\n    }\n}\n\n@Composable\nfun CounterScreen(modifier: Modifier = Modifier) {\n    // 1. Definici\u00f3n del Estado: 'remember' conserva el valor, 'mutableStateOf' lo hace observable.\n    var count by remember { mutableStateOf(0) } // Estado del contador\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(24.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Text(\"Estado: LOCAL\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(32.dp))\n\n        Card(\n            modifier = Modifier.width(200.dp),\n            elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)\n        ) {\n            Column(\n                modifier = Modifier\n                    .padding(24.dp)\n                    .fillMaxWidth(),\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\n                    text = \"Contador \u00danico\",\n                    style = MaterialTheme.typography.headlineSmall\n                )\n                Spacer(modifier = Modifier.height(16.dp))\n\n                // Muestra el valor del estado\n                Text(\n                    text = \"$count\",\n                    style = MaterialTheme.typography.displayLarge,\n                    color = MaterialTheme.colorScheme.primary\n                )\n                Spacer(modifier = Modifier.height(24.dp))\n\n                // Bot\u00f3n que modifica el estado directamente\n                Button(\n                    onClick = { count++ },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Text(\"Aumentar (+1)\")\n                }\n                Spacer(modifier = Modifier.height(8.dp))\n\n                // Bot\u00f3n para reiniciar el estado\n                OutlinedButton(\n                    onClick = { count = 0 },\n                    modifier = Modifier.fillMaxWidth()\n                ) {\n                    Text(\"Reiniciar a 0\")\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>En esta ejemplo 2, la complejidad aumenta. Ahora tenemos tres piezas de estado (count1, count2, generalCount) y toda la l\u00f3gica que las conecta reside en el mismo componente CounterApp2.</p> Ejemplo 2: App 2 contadores <pre><code>// 2. Contadores M\u00faltiples y General (Todo Local)\n// Todos los estados (individuales y general) y la l\u00f3gica de negocio combinada residen\n// en el mismo componente ra\u00edz.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun CounterApp2() {\n    MaterialTheme {\n        CounterScreenWithCombinedState()\n    }\n}\n\n@Composable\nfun CounterScreenWithCombinedState(modifier: Modifier = Modifier) {\n    // Estados Individuales\n    var count1 by remember { mutableStateOf(0) }\n    var count2 by remember { mutableStateOf(0) }\n\n    // Estado General: Se mantiene localmente y se actualiza junto con los otros.\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: M\u00faltiples Estados LOCALES\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // L\u00f3gica para el Contador 1\n            CounterCard(\n                title = \"Contador #1\",\n                currentCount = count1,\n                onIncrement = {\n                    count1++\n                    generalCount++ // L\u00f3gica de negocio dentro de este Composable\n                },\n                onReset = { count1 = 0 },\n                modifier = Modifier.weight(1f)\n            )\n\n            // L\u00f3gica para el Contador 2\n            CounterCard(\n                title = \"Contador #2\",\n                currentCount = count2,\n                onIncrement = {\n                    count2++\n                    generalCount++ // L\u00f3gica de negocio dentro de este Composable\n                },\n                onReset = { count2 = 0 },\n                modifier = Modifier.weight(1f)\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        Button(onClick = {\n            count1 = 0\n            count2 = 0\n            generalCount = 0\n        }) {\n            Text(\"Reiniciar TODO\")\n        }\n    }\n}\n\n// Componente Reutilizable Simple (UI Pura)\n@Composable\nfun CounterCard(\n    title: String,\n    currentCount: Int,\n    onIncrement: () -&gt; Unit,\n    onReset: () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Spacer(modifier = Modifier.height(8.dp))\n            Text(\n                text = \"$currentCount\",\n                style = MaterialTheme.typography.headlineLarge,\n                color = MaterialTheme.colorScheme.primary\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(onClick = onIncrement, modifier = Modifier.fillMaxWidth()) {\n                Text(\"Aumentar (+1)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n            OutlinedButton(onClick = onReset, modifier = Modifier.fillMaxWidth()) {\n                Text(\"Reiniciar\")\n            }\n        }\n    }\n}\n</code></pre> <p>En esta ejemplo 3, es la versi\u00f3n m\u00e1s importante para entender la arquitectura.</p> <p>El estado que afecta a varios componentes se \"eleva\" al componente padre com\u00fan m\u00e1s cercano. El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.</p> Ejemplo 3: App 2 contadores con Elevaci\u00f3n del Estado (State Hoisting) <pre><code>// 3. Elevaci\u00f3n de Estado (State Hoisting)\n// El estado que afecta a varios componentes se \"eleva\" al componente padre com\u00fan m\u00e1s cercano.\n// El componente hijo solo gestiona su propio estado y emite eventos (callbacks) para que el padre lo modifique.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\n\n@Composable\nfun CounterApp3() {\n    MaterialTheme {\n        ParentCounterScreen()\n    }\n}\n\n// 1. Componente Padre: Responsable de los estados COMPARTIDOS\n@Composable\nfun ParentCounterScreen(modifier: Modifier = Modifier) {\n    // Estado General: Se define y gestiona en el padre porque afecta a toda la pantalla.\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ELEVACI\u00d3N DE ESTADO (State Hoisting)\", style = MaterialTheme.typography.titleMedium)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General (gestionada por el padre)\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por PADRE)\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // Contador 1 (Hijo): El padre pasa la funci\u00f3n callback\n            IndividualCounter(\n                title = \"Contador #1 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Cuando el hijo se incrementa, el padre reacciona.\n                onIncremented = { generalCount++ } \n            )\n\n            // Contador 2 (Hijo): El padre pasa la funci\u00f3n callback\n            IndividualCounter(\n                title = \"Contador #2 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Cuando el hijo se incrementa, el padre reacciona.\n                onIncremented = { generalCount++ }\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        // Bot\u00f3n global que el padre gestiona\n        Button(onClick = { generalCount = 0 }) {\n            Text(\"Reiniciar Contador General (El padre no puede resetear al hijo)\")\n        }\n    }\n}\n\n// 2. Componente Hijo: Responsable de su estado INDIVIDUAL\n@Composable\nfun IndividualCounter(\n    title: String,\n    onIncremented: () -&gt; Unit, // Callback para notificar al padre\n    modifier: Modifier = Modifier\n) {\n    // Estado Individual: El hijo gestiona su propio 'count'.\n    var count by remember { mutableStateOf(0) }\n\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $count\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                onClick = {\n                    count++ // 1. Actualiza su estado local\n                    onIncremented() // 2. Llama al callback para notificar al padre\n                }, \n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+1)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = { count = 0 },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p>En el ejemplo 4, le agregamos un TextField para permitir al usuario indicar la cantidad a incrementar.</p> Ejemplo 4: App 4. Contador con incremento por TextField <pre><code>// 4. Elevaci\u00f3n de Estado con Input (TextField)\n// El componente hijo gestiona su estado local (count y amount) y notifica al padre\n// la cantidad exacta que se ha a\u00f1adido para que el padre pueda actualizar el contador general.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.ui.text.input.KeyboardType\n\n@Composable\nfun CounterApp4() {\n    MaterialTheme {\n        ParentCounterScreenWithInput()\n    }\n}\n\n// 1. Componente Padre: Mantiene el estado COMPARTIDO (General Count)\n@Composable\nfun ParentCounterScreenWithInput(modifier: Modifier = Modifier) {\n    // Estado General: Se define y gestiona en el padre\n    var generalCount by remember { mutableStateOf(0) }\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ELEVACI\u00d3N DE ESTADO con Input\", style = MaterialTheme.typography.titleMedium)\n        Text(\"El Hijo notifica al Padre la cantidad sumada.\", style = MaterialTheme.typography.bodySmall)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por PADRE)\", style = MaterialTheme.typography.headlineSmall)\n                Text(\"$generalCount\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // Contador 1 (Hijo): El callback ahora recibe la cantidad sumada\n            IndividualCounterWithInput(\n                title = \"Contador #1 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Recibe la 'amount' y la suma al estado general\n                onIncremented = { amount -&gt; generalCount += amount } \n            )\n\n            // Contador 2 (Hijo)\n            IndividualCounterWithInput(\n                title = \"Contador #2 (Hijo)\",\n                modifier = Modifier.weight(1f),\n                // Callback: Recibe la 'amount' y la suma al estado general\n                onIncremented = { amount -&gt; generalCount += amount }\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        Button(onClick = { generalCount = 0 }) {\n            Text(\"Reiniciar Contador General\")\n        }\n    }\n}\n\n// 2. Componente Hijo: Ahora gestiona dos estados locales (count y incrementAmount)\n@Composable\nfun IndividualCounterWithInput(\n    title: String,\n    onIncremented: (amount: Int) -&gt; Unit, // Callback ahora espera un par\u00e1metro Int\n    modifier: Modifier = Modifier\n) {\n    // Estado 1: Valor actual del contador\n    var count by remember { mutableStateOf(0) }\n    // Estado 2: Valor del TextField (cantidad a incrementar)\n    var incrementAmountText by remember { mutableStateOf(\"1\") }\n\n    // Calcula la cantidad real a incrementar (parsea el texto a Int)\n    val incrementAmount = incrementAmountText.toIntOrNull() ?: 0 // Usa 0 si no es v\u00e1lido\n\n    Card(\n        modifier = modifier\n            .padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier\n                .padding(16.dp)\n                .fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $count\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            // TextField para modificar la cantidad\n            OutlinedTextField(\n                value = incrementAmountText,\n                onValueChange = { newValue -&gt;\n                    // Solo permite n\u00fameros enteros positivos en el estado\n                    if (newValue.all { it.isDigit() } || newValue.isEmpty()) {\n                        incrementAmountText = newValue\n                    }\n                },\n                label = { Text(\"Aumentar en\") },\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),\n                modifier = Modifier.fillMaxWidth()\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                // Deshabilita si el input no es un n\u00famero v\u00e1lido &gt; 0\n                enabled = incrementAmount &gt; 0, \n                onClick = {\n                    count += incrementAmount // 1. Actualiza su estado local\n                    onIncremented(incrementAmount) // 2. Llama al padre con la cantidad\n                }, \n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+ $incrementAmount)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = { \n                    count = 0 \n                },\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p>Ejemplo 5, versi\u00f3n final. Agregamos el ViewModel (VM)</p> Ejemplo 5: App 5. Contador con VM Explicaci\u00f3nC\u00f3digo <p>La aplicaci\u00f3n se divide en tres capas bien definidas:</p> <ol> <li> <p>La Capa de Estado (Data Layer)</p> <p>Aqu\u00ed es donde se define qu\u00e9 son los datos de la UI.</p> <ul> <li><code>data class CounterState</code>: Define el estado de un \u00fanico contador. No solo almacena el <code>count</code> (el n\u00famero actual), sino tambi\u00e9n el <code>amountText</code> (el texto que el usuario ve en el <code>TextField</code>) y el <code>incrementAmount</code> (el valor entero ya parseado).</li> <li> <p><code>data class CountersScreenState</code>: Es el contenedor de todo el estado que necesita la pantalla. Es una \u00fanica fuente de verdad que incluye:</p> <ul> <li><code>counter1</code>: El estado del primer contador (<code>CounterState</code>).        </li> <li><code>counter2</code>: El estado del segundo contador (<code>CounterState</code>).</li> <li><code>generalCount</code>: El estado del contador general.</li> </ul> </li> </ul> </li> <li> <p>La Capa de L\u00f3gica (ViewModel)</p> <p>Aqu\u00ed es donde se define c\u00f3mo cambian los datos.</p> <ul> <li> <p><code>class CounterViewModel : ViewModel()</code>:</p> <ul> <li> <p>Contiene el Estado Mutable: Utiliza <code>private val _state = MutableStateFlow(CountersScreenState())</code>. Este es el estado interno y mutable que solo el <code>ViewModel</code> puede modificar.</p> </li> <li> <p>Expone el Estado Observado: Utiliza <code>val state: StateFlow&lt;CountersScreenState&gt; = _state</code>. Este es el estado que la UI (los Composable) observa; es de solo lectura.</p> </li> <li> <p>Define los Eventos (L\u00f3gica de Negocio): Las funciones p\u00fablicas (<code>incrementCounter</code>, <code>setIncrementAmount</code>, <code>resetAll</code>) son los eventos o intenciones que la UI env\u00eda al <code>ViewModel</code>.</p> <ul> <li>Seguridad y Centralizaci\u00f3n: Cuando la UI llama a <code>incrementCounter</code>, el <code>ViewModel</code> usa <code>_state.update { ... }</code> para calcular el nuevo estado a partir del estado actual. Esto garantiza que toda la l\u00f3gica (incrementar el contador individual, validar el texto, y sumar al contador general) ocurre en un solo lugar, de forma segura.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>La Capa de Presentaci\u00f3n (Composable / UI)</p> <p>Aqu\u00ed es donde se define c\u00f3mo se muestra el estado y qu\u00e9 eventos se env\u00edan.</p> <ul> <li> <p><code>CounterScreenWithViewModel()</code>:</p> <ul> <li>Observaci\u00f3n: Usa <code>val state = viewModel.state.collectAsState().value</code> para leer el estado emitido por el <code>ViewModel</code>.      </li> <li>UI Pura: Toda la estructura de la pantalla es una funci\u00f3n pura de la variable <code>state</code>. Si <code>state</code> cambia, la UI se recompone.</li> <li>Delegaci\u00f3n: No contiene ninguna l\u00f3gica de <code>remember { mutableStateOf(...) }</code> ni de negocio. Simplemente llama a las funciones del <code>ViewModel</code> cuando hay interacci\u00f3n (ej: <code>Button(onClick = { viewModel.incrementCounter(1) })</code>).</li> </ul> </li> <li> <p><code>IndividualCounterWithInput_VM()</code> (Componente Hijo):</p> <ul> <li>Este es un componente completamente pasivo.</li> <li>Solo recibe el estado a trav\u00e9s de sus par\u00e1metros (<code>currentCount</code>, <code>incrementAmountText</code>).</li> <li>Solo emite eventos (callbacks) a su componente padre (<code>onIncrement</code>, <code>onAmountChange</code>). En este caso, el padre es el <code>CounterScreenWithViewModel</code>, que a su vez pasa la llamada al <code>ViewModel</code>.</li> </ul> </li> </ul> </li> </ol> <pre><code>// 5. Versi\u00f3n Final: Implementaci\u00f3n con ViewModel y StateFlow\n// Esta es la arquitectura recomendada: L\u00f3gica en el ViewModel, UI observando el estado.\n\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.ViewModel\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.update // Import necesario para actualizar el StateFlow de forma segura\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.foundation.text.KeyboardOptions\nimport androidx.compose.ui.text.input.KeyboardType\nimport androidx.lifecycle.viewmodel.compose.viewModel \n\n// ========== DATOS y VIEWMODEL (La capa de L\u00f3gica y Estado) ==========\n\n// 1. Definir el estado de un Contador individual\ndata class CounterState(\n    val count: Int = 0,\n    val incrementAmount: Int = 1,\n    val amountText: String = \"1\"\n)\n\n// 2. Definir el estado global de la Pantalla (Contenedor de todos los estados de la UI)\ndata class CountersScreenState(\n    val counter1: CounterState = CounterState(),\n    val counter2: CounterState = CounterState(),\n    val generalCount: Int = 0 \n)\n\n// 3. Implementar el ViewModel (Lugar de la L\u00d3GICA DE NEGOCIO)\nclass CounterViewModel : ViewModel() { // Clase renombrada\n    // StateFlow privado y mutable\n    private val _state = MutableStateFlow(CountersScreenState())\n    // StateFlow p\u00fablico (solo lectura)\n    val state: StateFlow&lt;CountersScreenState&gt; = _state\n\n    /**\n    * L\u00f3gica para incrementar un contador y el contador general.\n    * TODA la actualizaci\u00f3n del estado ocurre aqu\u00ed.\n    * @param counterId El ID del contador (1 o 2).\n    */\n    fun incrementCounter(counterId: Int) {\n        _state.update { currentState -&gt;\n            // 1. Determinar el valor de incremento y el nuevo estado del contador individual\n            val (newCounterState, incrementValue) = when (counterId) {\n                1 -&gt; {\n                    val amount = currentState.counter1.amountText.toIntOrNull() ?: 0\n                    Pair(currentState.counter1.copy(count = currentState.counter1.count + amount), amount)\n                }\n                2 -&gt; {\n                    val amount = currentState.counter2.amountText.toIntOrNull() ?: 0\n                    Pair(currentState.counter2.copy(count = currentState.counter2.count + amount), amount)\n                }\n                else -&gt; Pair(CounterState(), 0)\n            }\n\n            // 2. Retornar el nuevo estado de la pantalla\n            currentState.copy(\n                counter1 = if (counterId == 1) newCounterState else currentState.counter1,\n                counter2 = if (counterId == 2) newCounterState else currentState.counter2,\n                generalCount = currentState.generalCount + incrementValue // Actualiza el general\n            )\n        }\n    }\n\n    /**\n    * L\u00f3gica para actualizar el valor del TextField.\n    * @param counterId El ID del contador.\n    * @param amountText El nuevo texto ingresado.\n    */\n    fun setIncrementAmount(counterId: Int, amountText: String) {\n        // Validaci\u00f3n b\u00e1sica: solo permitir d\u00edgitos o cadena vac\u00eda\n        if (amountText.all { it.isDigit() } || amountText.isEmpty()) {\n            _state.update { currentState -&gt;\n                val newAmount = amountText.toIntOrNull() ?: 0\n                when (counterId) {\n                    1 -&gt; currentState.copy(\n                        counter1 = currentState.counter1.copy(\n                            amountText = amountText,\n                            incrementAmount = newAmount\n                        )\n                    )\n                    2 -&gt; currentState.copy(\n                        counter2 = currentState.counter2.copy(\n                            amountText = amountText,\n                            incrementAmount = newAmount\n                        )\n                    )\n                    else -&gt; currentState\n                }\n            }\n        }\n    }\n\n    /**\n    * L\u00f3gica para resetear todos los contadores.\n    */\n    fun resetAll() {\n        // Al resetear al estado inicial, se resetea toda la UI autom\u00e1ticamente.\n        _state.value = CountersScreenState()\n    }\n}\n\n\n// ========== COMPOSABLES (La capa de Presentaci\u00f3n/UI) ==========\n\n@Composable\nfun CounterApp_ViewModel() { // Funci\u00f3n principal renombrada\n    MaterialTheme {\n        // 4. Obtener el ViewModel. Compose se encarga de su ciclo de vida.\n        val viewModel: CounterViewModel = viewModel() // Renombrado aqu\u00ed\n        CounterScreenWithViewModel(viewModel)\n    }\n}\n\n@Composable\nfun CounterScreenWithViewModel(viewModel: CounterViewModel, modifier: Modifier = Modifier) {\n    // 5. Observar el estado. Transforma el StateFlow en un Compose State.\n    // La UI se recompone cuando el estado cambia.\n    val state = viewModel.state.collectAsState().value\n\n    Column(\n        modifier = modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Text(\"Arquitectura: ViewModel &amp; StateFlow\", style = MaterialTheme.typography.titleMedium)\n        Text(\"La UI solo LEE el estado y ENV\u00cdA eventos al ViewModel.\", style = MaterialTheme.typography.bodySmall)\n        Spacer(modifier = Modifier.height(16.dp))\n\n        // Tarjeta del Contador General\n        Card(\n            modifier = Modifier.fillMaxWidth().padding(8.dp),\n            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.tertiaryContainer)\n        ) {\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally,\n                modifier = Modifier.fillMaxWidth().padding(16.dp)\n            ) {\n                Text(\"Contador General (Manejado por ViewModel)\", style = MaterialTheme.typography.headlineSmall)\n                // 6. Mostrar el estado general\n                Text(\"${state.generalCount}\", style = MaterialTheme.typography.displaySmall)\n            }\n        }\n        Spacer(modifier = Modifier.height(16.dp))\n\n        Row(Modifier.fillMaxWidth()) {\n            // 7. Usar un componente puro (Hijo)\n            // Se le pasa el estado espec\u00edfico (state.counter1) y los callbacks (que llaman al VM)\n            IndividualCounterWithInput_VM(\n                title = \"Contador #1 (VM)\",\n                currentCount = state.counter1.count,\n                incrementAmountText = state.counter1.amountText,\n                onIncrement = { viewModel.incrementCounter(1) },\n                onAmountChange = { newText -&gt; viewModel.setIncrementAmount(1, newText) },\n                onReset = { viewModel.resetAll() }, \n                modifier = Modifier.weight(1f)\n            )\n\n            IndividualCounterWithInput_VM(\n                title = \"Contador #2 (VM)\",\n                currentCount = state.counter2.count,\n                incrementAmountText = state.counter2.amountText,\n                onIncrement = { viewModel.incrementCounter(2) },\n                onAmountChange = { newText -&gt; viewModel.setIncrementAmount(2, newText) },\n                onReset = { viewModel.resetAll() },\n                modifier = Modifier.weight(1f)\n            )\n        }\n\n        Spacer(modifier = Modifier.height(16.dp))\n        // 8. Llamar a la funci\u00f3n del ViewModel para resetear todo\n        Button(onClick = { viewModel.resetAll() }) {\n            Text(\"Reiniciar TODO (Llamando a VM)\")\n        }\n    }\n}\n\n// Componente Puro de UI: Solo recibe ESTADO y CALLBACKS (no tiene l\u00f3gica 'remember')\n@Composable\nfun IndividualCounterWithInput_VM(\n    title: String,\n    currentCount: Int,\n    incrementAmountText: String,\n    onIncrement: () -&gt; Unit,\n    onAmountChange: (String) -&gt; Unit,\n    onReset: () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    // La l\u00f3gica de c\u00e1lculo del 'incrementAmount' pasa al ViewModel.\n    val incrementAmount = incrementAmountText.toIntOrNull() ?: 0\n\n    Card(\n        modifier = modifier.padding(8.dp),\n        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surfaceVariant)\n    ) {\n        Column(\n            modifier = Modifier.padding(16.dp).fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            Text(text = title, style = MaterialTheme.typography.titleMedium)\n            Text(\"Estado: $currentCount\", style = MaterialTheme.typography.headlineLarge)\n\n            Spacer(modifier = Modifier.height(16.dp))\n\n            OutlinedTextField(\n                value = incrementAmountText,\n                onValueChange = onAmountChange, // Llama al callback que va al ViewModel\n                label = { Text(\"Aumentar en\") },\n                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),\n                modifier = Modifier.fillMaxWidth()\n            )\n            Spacer(modifier = Modifier.height(16.dp))\n\n            Button(\n                enabled = incrementAmount &gt; 0,\n                onClick = onIncrement, // Llama al callback que va al ViewModel\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Aumentar (+ $incrementAmount)\")\n            }\n            Spacer(modifier = Modifier.height(8.dp))\n\n            OutlinedButton(\n                onClick = onReset, // Llama al callback que va al ViewModel\n                modifier = Modifier.fillMaxWidth()\n            ) {\n                Text(\"Reiniciar Individual\")\n            }\n        }\n    }\n}\n</code></pre> <p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html","title":"3.3.3. Capas Datos/Dominio","text":""},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#333-capas-de-dominio-y-datos-el-cerebro-y-la-memoria","title":"3.3.3 \ud83e\udde0 Capas de Dominio y Datos. El Cerebro y la Memoria","text":"<p>Si la capa de UI es la \"cara bonita\" de la aplicaci\u00f3n, las capas de Dominio y Datos son el cerebro y la memoria que hacen que todo funcione. Sin ellas, nuestra app ser\u00eda una c\u00e1scara vac\u00eda.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#la-capa-de-datos-data-layer","title":"\ud83e\uddf1 La Capa de Datos (Data Layer)","text":"<p>Es la base de la pir\u00e1mide. Su responsabilidad es manejar los datos de la aplicaci\u00f3n. \u00bfDe d\u00f3nde vienen los datos? \u00bfC\u00f3mo se guardan? \u00bfQu\u00e9 pasa si no hay internet? La UI no deber\u00eda preocuparse por nada de esto; esa es tarea exclusiva de la Capa de Datos.</p> <p>Se compone de dos piezas clave:</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#1-data-sources-fuentes-de-datos","title":"1. Data Sources (Fuentes de Datos)","text":"<p>Son las clases de \"bajo nivel\" que saben hablar con una fuente espec\u00edfica.</p> <ul> <li>Remote Data Source: Sabe hablar con internet (APIs REST, Firebase, GraphQl).</li> <li>Local Data Source: Sabe hablar con el almacenamiento del tel\u00e9fono (Base de Datos Room, DataStore, Archivos).</li> </ul>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#2-repositorios-repositories","title":"2. Repositorios (Repositories)","text":"<p>Son los gestores o mediadores. Es la parte m\u00e1s importante de esta capa. El resto de la aplicaci\u00f3n (el Dominio o la UI) NUNCA deber\u00eda hablar directamente con un Data Source. Siempre deben pedirle los datos al Repositorio.</p> <p>\ud83d\udcda La Analog\u00eda del Bibliotecario</p> <p>Imagina que vas a una biblioteca a por un libro (\"Los Datos\"). T\u00fa no vas al almac\u00e9n del s\u00f3tano ni llamas a la editorial. T\u00fa hablas con el Bibliotecario (Repositorio).</p> <ul> <li>T\u00fa le pides el libro.</li> <li>El bibliotecario mira si lo tiene a mano en el mostrador (Cach\u00e9 en memoria).</li> <li>Si no, baja al archivo a buscarlo (Base de datos Local).</li> <li>Si no est\u00e1, llama a la editorial para pedir una copia (Red/API).</li> </ul> <p>A ti te da igual de d\u00f3nde lo haya sacado. T\u00fa solo quer\u00edas el libro y el bibliotecario te lo ha conseguido.</p> <p>Esta estrategia se llama Single Source of Truth (\u00danica Fuente de Verdad). El repositorio centraliza los datos para que nadie m\u00e1s tenga que adivinar de d\u00f3nde vienen.</p> <p>Video explicaci\u00f3n Capa de Datos</p> <p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#la-capa-de-dominio-domain-layer","title":"\ud83e\udde0 La Capa de Dominio (Domain Layer)","text":"<p>Nota: Esta capa es opcional en apps muy sencillas, pero recomendada en cuanto la app crece.</p> <p>Es la capa que contiene la L\u00f3gica de Negocio Pura. Son las reglas del juego que hacen que tu app sea \u00fanica, independientemente de si los botones son azules o rojos, o si los datos vienen de una API o de un Excel.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#casos-de-uso-use-cases-interactors","title":"Casos de Uso (Use Cases / Interactors)","text":"<p>Son clases que encapsulan una \u00fanica acci\u00f3n o tarea de negocio. Su nombre debe describir exactamente lo que hacen (verbo + sustantivo + UseCase).</p> <p>Ejemplos:</p> <ul> <li><code>LoginUserUseCase</code></li> <li><code>FormatDateUseCase</code></li> <li><code>GetLatestNewsUseCase</code></li> </ul> <p>\u00bfPor qu\u00e9 usarlos?</p> <ol> <li>Reutilizaci\u00f3n: Si varios ViewModels necesitan la misma l\u00f3gica (ej: formatear una fecha), no copias y pegas c\u00f3digo. Llamas al mismo UseCase.</li> <li>Legibilidad: Al abrir la carpeta de \"Dominio\", ves una lista de todo lo que HACE tu app (\"Code screams architecture\").</li> <li>Independencia: Los UseCases no saben nada de Android (ni de Views, ni de JSONs). Son c\u00f3digo Kotlin puro.</li> </ol>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#ejemplo-practico-app-de-noticias","title":"\ud83d\ude80 Ejemplo Pr\u00e1ctico: App de Noticias","text":"<p>Vamos a ver c\u00f3mo se conectan todas las piezas, desde que el dato sale de internet hasta que llega al ViewModel. Imagina una pantalla que muestra una lista de noticias recientes.</p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#1-data-source-el-especialista","title":"1. Data Source (El especialista)","text":"<p>Primero, necesitamos alguien que sepa descargar datos de la API. </p><pre><code>// Data Source (Retrofit)\ninterface NewsApiService {\n    @GET(\"news\")\n    suspend fun fetchNews(): List&lt;NewsDto&gt; // Devuelve datos \"feos\" (DTOs) de la red\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#2-repository-el-bibliotecario","title":"2. Repository (El bibliotecario)","text":"<p>El repositorio coordina. En este caso simple, solo llama a la API, pero podr\u00eda guardar en base de datos si quisi\u00e9ramos modo offline. </p><pre><code>class NewsRepository(\n    private val api: NewsApiService\n) {\n    // Devuelve listas del Dominio (News), no DTOs de red. Limpia los datos.\n    suspend fun getNews(): List&lt;News&gt; {\n        return try {\n            val apiData = api.fetchNews()\n            apiData.map { it.toDomain() } // Mapea a objetos limpios\n        } catch (e: Exception) {\n            emptyList() // O manejar el error\n        }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#3-use-case-la-logica-de-negocio","title":"3. Use Case (La l\u00f3gica de negocio)","text":"<p>Queremos mostrar noticias, pero una regla de negocio dice: \"Solo mostrar noticias de las \u00faltimas 24h y ordenadas por fecha\". El ViewModel no deber\u00eda saber calcular esto. </p><pre><code>class GetRecentNewsUseCase(\n    private val repository: NewsRepository\n) {\n    // El operador 'invoke' permite llamar a la clase como si fuera una funci\u00f3n\n    suspend operator fun invoke(): List&lt;News&gt; {\n        val allNews = repository.getNews()\n\n        // APLICAMOS L\u00d3GICA DE NEGOCIO AQU\u00cd\n        return allNews\n            .filter { it.date &gt; ayer() }\n            .sortedByDescending { it.date }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#4-viewmodel-el-consumidor","title":"4. ViewModel (El consumidor)","text":"<p>El ViewModel es mucho m\u00e1s simple ahora. Solo llama al UseCase y actualiza el estado. </p><pre><code>class NewsViewModel(\n    private val getRecentNewsUseCase: GetRecentNewsUseCase // Inyectamos el UseCase\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(NewsUiState())\n    val uiState = _uiState.asStateFlow()\n\n    fun loadNews() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n\n            // \u00a1Magia! Solo llamamos al caso de uso.\n            // No sabemos si viene de red, base de datos o si se ha filtrado.\n            val news = getRecentNewsUseCase() \n\n            _uiState.update { \n                it.copy(isLoading = false, news = news) \n            }\n        }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/03/3.3.3-arquitectura.capa-datos.html#resumen-del-flujo-de-datos","title":"Resumen del Flujo de Datos","text":"<ol> <li>UI (Composable): \"Usuario pulsa bot\u00f3n 'Recargar'\". Llama a <code>viewModel.loadNews()</code>.</li> <li>ViewModel: Llama a <code>GetRecentNewsUseCase()</code>.</li> <li>UseCase: Pide datos al <code>Repository</code> y aplica filtro de fecha.</li> <li>Repository: Pide datos al <code>NetworkDataSource</code> (API).</li> <li>Data Source: Descarga el JSON.</li> </ol> <p>\u00a1Y el camino de vuelta es igual pero con los datos ya procesados! \ud83d\udd04</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html","title":"Capa de Dominio","text":""},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#android-clean-architecture-entendiendo-la-capa-de-dominio","title":"Android Clean Architecture - Entendiendo la Capa de Dominio","text":"<p>A medida que las aplicaciones Android crecen en complejidad, una base de c\u00f3digo no estructurada puede conducir a un acoplamiento estrecho, l\u00f3gica duplicada y pruebas unitarias fr\u00e1giles, lo que en \u00faltima instancia ralentiza el desarrollo. Los principios de Clean Architecture abordan estos desaf\u00edos imponiendo una clara separaci\u00f3n de preocupaciones, haciendo que las aplicaciones sean m\u00e1s escalables, mantenibles y comprobables.</p> <p>En el coraz\u00f3n de esta arquitectura, la Capa de Dominio juega un papel crucial en la encapsulaci\u00f3n de la l\u00f3gica de negocio, asegurando un l\u00edmite distinto entre la interfaz de usuario y el manejo de datos. Este art\u00edculo profundiza en la Capa de Dominio, explicando su prop\u00f3sito, mejores pr\u00e1cticas y c\u00f3mo implementarla eficazmente en aplicaciones Android.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#que-es-la-capa-de-dominio","title":"\u00bfQu\u00e9 es la Capa de Dominio?","text":"<p>La Capa de Dominio es responsable de manejar la l\u00f3gica de negocio central de una aplicaci\u00f3n. Act\u00faa como una capa independiente, separada tanto de la Capa de Presentaci\u00f3n (que gestiona la interfaz de usuario y las interacciones del usuario) como de la Capa de Datos (que maneja el almacenamiento y recuperaci\u00f3n de datos de fuentes como bases de datos y APIs REST).</p> <p>Mientras que las Capas de Presentaci\u00f3n y de Datos dependen de la Capa de Dominio, esta permanece completamente desacoplada de ellas. Esto asegura que la l\u00f3gica de negocio permanezca inalterada por cambios en los frameworks de UI o fuentes de datos.</p> <p></p> <p>Disposici\u00f3n de Dependencias en Clean Architecture</p> <p>La Capa de Dominio contiene principalmente:</p> <ul> <li>Casos de Uso: Manejan piezas espec\u00edficas de l\u00f3gica de negocio, definiendo c\u00f3mo deben procesarse y usarse los datos dentro de la app.</li> <li>Modelos de Dominio: Representan entidades dentro del dominio del negocio.</li> <li>Interfaces de Repositorio: Definen c\u00f3mo se puede acceder a los datos sin especificar la fuente subyacente (como una base de datos o API REST), asegurando el desacoplamiento de los internos de la Capa de Datos.</li> </ul>    Representaci\u00f3n del Flujo de Datos en Android Clean Architecture"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#responsabilidades-clave-de-la-capa-de-dominio","title":"Responsabilidades Clave de la Capa de Dominio","text":"<p>\u2705 Encapsula la L\u00f3gica de Negocio y Promueve la Modularidad La Capa de Dominio centraliza y encapsula la l\u00f3gica de negocio, asegurando que est\u00e9 desacoplada tanto de la Capa de Presentaci\u00f3n como de la Capa de Datos. Define Casos de Uso, que representan flujos de trabajo de negocio espec\u00edficos como realizar un pedido o validar la entrada del usuario. Adem\u00e1s, al aislar la l\u00f3gica en esta capa, se puede compartir usando Kotlin Multiplatform (KMP), reduciendo la duplicaci\u00f3n de l\u00f3gica con iOS y otras plataformas.</p> <p>\u2705 Desacopla la L\u00f3gica de Negocio de las Fuentes de Datos La Capa de Dominio asegura que la l\u00f3gica de negocio permanezca independiente de las fuentes de datos al depender de abstracciones en lugar de implementaciones concretas. Esto permite flexibilidad en c\u00f3mo se obtienen o persisten los datos, por lo que cambios como cambiar de APIs REST a GraphQL o modificar proveedores de bases de datos no afectan la l\u00f3gica de negocio central.</p> <p>\u2705 Mejora la Testabilidad Al mantener la l\u00f3gica de negocio en clases peque\u00f1as y de responsabilidad \u00fanica, la Capa de Dominio mejora la testabilidad. Los Casos de Uso dependen de abstracciones (por ejemplo, interfaces de Repositorio), lo que hace f\u00e1cil simular dependencias y escribir pruebas unitarias en aislamiento. Este dise\u00f1o soporta el desarrollo guiado por pruebas (TDD) y asegura una alta cobertura de pruebas.</p> <p>\u2705 Reduce la Complejidad en la Capa de Presentaci\u00f3n Al manejar la l\u00f3gica de negocio y las transformaciones, la Capa de Dominio asegura que los ViewModels permanezcan ligeros, centr\u00e1ndose \u00fanicamente en gestionar el estado de la UI. Extraer la l\u00f3gica de los ViewModels a Casos de Uso nos permite reutilizarla en toda la aplicaci\u00f3n. Esto mejora la mantenibilidad, haciendo que la Capa de Presentaci\u00f3n sea m\u00e1s f\u00e1cil de probar.</p> <p>\u274c No es Responsable del Almacenamiento o Recuperaci\u00f3n de Datos La Capa de Dominio no maneja la persistencia o recuperaci\u00f3n de datos. Estas responsabilidades pertenecen a la Capa de Datos, que incluye componentes como Repositorios, Fuentes de Datos, APIs REST y Bases de Datos. La Capa de Dominio permanece agn\u00f3stica a c\u00f3mo se obtienen o persisten los datos.</p> <p>\u274c No es Responsable de la Gesti\u00f3n del Estado de la UI La Capa de Dominio no gestiona el estado de la UI, esto es manejado por la Capa de Presentaci\u00f3n (ViewModels). En su lugar, la Capa de Dominio ejecuta la l\u00f3gica de negocio y devuelve resultados inmutables.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#la-anatomia-de-un-caso-de-uso","title":"La Anatom\u00eda de un Caso de Uso","text":"<p>Un Caso de Uso es una clase que encapsula una sola operaci\u00f3n de negocio, haci\u00e9ndola reutilizable y f\u00e1cil de probar. Un Caso de Uso bien estructurado debe tener solo una funci\u00f3n p\u00fablica, ya que debe centrarse en una sola responsabilidad.</p> <p>Si un Caso de Uso tiene m\u00faltiples funciones p\u00fablicas, puede estar manejando demasiadas preocupaciones, violando el Principio de Responsabilidad \u00danica (SRP). En tales casos, considera dividir la l\u00f3gica en Casos de Uso separados y m\u00e1s enfocados.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#1-nombrando-casos-de-uso","title":"1. Nombrando Casos de Uso","text":"<p>El nombrado de Casos de Uso debe seguir el formato:</p> <p>[Verbo] + [_Sustantivo] + _UseCase</p> <p>Ejemplos:</p> <p>\u2705 <code>**_Get_**_CustomerBag_UseCase</code> \u2705 <code>**_Logout_**_User_UseCase</code>  \u2705 <code>**Cache**_OrderDetails_UseCase</code></p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#2-definiendo-la-logica-de-negocio","title":"2. Definiendo la L\u00f3gica de Negocio","text":"<p>La l\u00f3gica de negocio define las reglas y decisiones que controlan c\u00f3mo se comporta la app en diferentes situaciones. Determina:</p> <ul> <li>C\u00f3mo se procesan los datos \u2014 aplicando transformaciones antes de mostrarlos.</li> <li>Cu\u00e1ndo y c\u00f3mo deben realizarse las acciones \u2014 validando la entrada del usuario antes de guardarla.</li> <li>C\u00f3mo interact\u00faan las diferentes partes de la app \u2014 manteniendo las responsabilidades separadas.</li> </ul>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#3-dependencias-del-caso-de-uso","title":"3. Dependencias del Caso de Uso","text":"<p>Un Caso de Uso solo debe depender de abstracciones y construcciones puras de Kotlin, asegurando la independencia de la plataforma. A continuaci\u00f3n hay una gu\u00eda sobre qu\u00e9 incluir y evitar en los Casos de Uso:</p> <p>\u2705 Otros Casos de Uso \u2014 Para l\u00f3gica de negocio compartida (\u00fasalo con moderaci\u00f3n para evitar un encadenamiento excesivo).</p> <p>\u2705 Clases de Utilidad Puras de Kotlin \u2014 Para l\u00f3gica reutilizable como reglas de validaci\u00f3n, formato de n\u00fameros, etc.</p> <p>\u2705 Interfaces de Repositorio \u2014 Para interactuar con la Capa de Datos sin depender de implementaciones concretas.</p> <p>\u274c Dependencias de Android \u2014 Evita usar <code>Context</code>, <code>LiveData</code>, <code>Application</code>, etc. En lugar de usar <code>LiveData</code>, prefiere Kotlin <code>Flow</code> o funciones <code>suspend</code> para asegurar que la Capa de Dominio permanezca desacoplada del framework de Android.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#4-como-exponen-datos-los-casos-de-uso","title":"4. C\u00f3mo Exponen Datos los Casos de Uso","text":"<p>Los Casos de Uso proporcionan datos a la Capa de Presentaci\u00f3n a trav\u00e9s de diferentes mecanismos, dependiendo de c\u00f3mo se ejecute la operaci\u00f3n:</p> <ul> <li>Llamadas a funciones regulares \u2014 Para operaciones s\u00edncronas (por ejemplo, comprobaciones en memoria, c\u00e1lculos simples).</li> <li>Funciones suspend \u2014 Para operaciones as\u00edncronas de una sola vez (por ejemplo, solicitudes de red, consultas a base de datos).</li> <li>Flow \u2014 Para flujos reactivos que emiten actualizaciones a lo largo del tiempo (por ejemplo, observando cambios en la base de datos).</li> <li>Observables/Callbacks \u2014 Para arquitecturas basadas en RxJava.</li> </ul> <p>La elecci\u00f3n depende de si la operaci\u00f3n es inmediata y ligera o as\u00edncrona y de larga duraci\u00f3n.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#mejores-practicas-en-casos-de-uso","title":"Mejores Pr\u00e1cticas en Casos de Uso","text":""},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#1-el-operador-invoke","title":"1. El Operador Invoke","text":"<p>Dado que los Casos de Uso tienen una responsabilidad \u00fanica, podemos usar el operador <code>invoke</code> de Kotlin para hacerlos invocables como funciones, eliminando llamadas a m\u00e9todos redundantes.</p> <pre><code>class GetCustomerBagUseCase @Inject constructor(\n    private val userRepository: UserRepository, // interface\n    private val bagRepository: BagRepository // interface\n) {\n    suspend operator fun invoke(): Bag {\n        val userId = userRepository.getUserId()\n        return bagRepository.getCustomerBag(userId)\n    }\n}\n</code></pre> <p>Esto permite que la llamada en el ViewModel sea m\u00e1s concisa e intuitiva:</p> <pre><code>val customerBag = getCustomerBagUseCase()\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#2-seguridad-de-hilos-thread-safety","title":"2. Seguridad de Hilos (Thread Safety)","text":"<p>Los Casos de Uso deben ser seguros para el hilo principal (main-thread safe), lo que significa que pueden ser llamados desde el hilo principal sin bloquear la UI. Las operaciones de larga duraci\u00f3n, como llamadas a API REST o consultas a bases de datos, deben delegarse a la Capa de Datos.</p> <p>La Capa de Dominio no debe cambiar a hilos vinculados a E/S (como <code>Dispatchers.IO</code>). La Capa de Datos es responsable de gestionar los hilos y cambiar\u00e1 a un hilo en segundo plano tan cerca de la fuente de la llamada como sea posible. Sin embargo, para tareas intensivas de CPU como ordenaci\u00f3n y transformaciones, podemos usar <code>Dispatchers.Default</code> dentro de la Capa de Dominio.</p> <p>Imagina que necesitamos procesar un lote de productos obtenidos y aplicar ordenaci\u00f3n, formateando sus fechas de creaci\u00f3n y calculando descuentos.</p> <ul> <li>Obtenci\u00f3n de productos \u2192 Manejado en la Capa de Datos (por ejemplo, Repositorio obteniendo de API REST o base de datos).</li> <li>Ordenaci\u00f3n y Formato \u2192 L\u00f3gica de negocio que pertenece a la Capa de Dominio.</li> </ul> <p>Dado que procesar estos productos es intensivo en CPU, debe ejecutarse en un hilo en segundo plano para evitar bloqueos de la UI y errores de ANR (Application Not Responding).</p> <p>\u2705 Mejor Pr\u00e1ctica: Mover Computaci\u00f3n Pesada a un Hilo en Segundo Plano</p> <pre><code>class FormatProductListUseCase @Inject constructor(\n    private val productRepository: ProductRepository, // interface\n    private val formatDateUseCase: FormatDateUseCase,\n    private val calculateDiscountUseCase: CalculateDiscountUseCase,\n    @CoroutineDefault private val defaultDispatcher: CoroutineDispatcher\n) {\n   suspend operator fun invoke(): List&lt;Product&gt; = withContext(defaultDispatcher) {\n    productRepository.getProducts()\n        .sortedByDescending { it.price }\n        .map { product -&gt;\n            val formattedDate = formatDateUseCase(product.createdAt)\n            val discount = calculateDiscountUseCase(product.price)\n\n            product.copy(\n                createdAt = formattedDate,\n                discount = discount\n            )\n        }\n}\n\ndata class Product(\n    val id: String,\n    val name: String,\n    val price: Double,\n    val createdAt: String,\n    val discount: Double = 0.0\n)\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#por-que-funciona-esto","title":"Por Qu\u00e9 Funciona Esto","text":"<p>\u2705 Delega la Obtenci\u00f3n a la Capa de Datos La responsabilidad de obtener los productos es manejada por la Capa de Datos, manteniendo la l\u00f3gica de negocio centrada en la Capa de Dominio.</p> <p>\u2705 Usa <code>**Dispatchers.Default**</code> para Tareas Intensivas de CPU La ordenaci\u00f3n y las transformaciones se ejecutan en un hilo en segundo plano, mejorando el rendimiento y evitando bloqueos de la UI.</p> <p>\u2705 Inyecta <code>**CoroutineDispatcher**</code> para Testabilidad Esto permite un f\u00e1cil reemplazo con un despachador de prueba durante las pruebas unitarias. Esto asegura que las Corrutinas se ejecuten en un entorno controlado, haciendo que las pruebas sean m\u00e1s r\u00e1pidas, predecibles y aisladas de preocupaciones reales de hilos.</p> <p>\u2705 Mantiene la L\u00f3gica de Negocio Modular Al encapsular el formato de fecha y el c\u00e1lculo de descuentos en Casos de Uso separados y reutilizables, el c\u00f3digo permanece modular y m\u00e1s f\u00e1cil de mantener.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#3-combinando-datos-de-multiples-repositorios","title":"3. Combinando Datos de M\u00faltiples Repositorios","text":"<p>Aunque es posible fusionar datos de m\u00faltiples fuentes en un ViewModel o Repositorio, hacerlo puede hacer que estas clases sean complejas y dif\u00edciles de probar. En su lugar, es mejor crear un Caso de Uso que agregue datos de diferentes Repositorios, manteniendo la l\u00f3gica de negocio separada y reutilizable.</p> <p>\u2705 Mejor Pr\u00e1ctica: Combinando Productos Con Conteo de Bolsa de Usuario Usando Flows</p> <pre><code>class GetProductsWithBagCountUseCase @Inject constructor(\n    private val productsRepository: ProductsRepository, // interface\n    private val bagRepository: BagRepository, // interface\n    private val userRepository: UserRepository // interface\n) {\n    operator fun invoke(): Flow&lt;ProductsWithBagCount&gt; {\n        val userId = userRepository.getUserId()\n        return combine(\n            productsRepository.getUserProducts(userId),\n            bagRepository.getUserBagCount(userId)\n        ) { products, bagCount -&gt;\n            ProductsWithBagCount(products, bagCount)\n        }\n    }\n}\n\ndata class ProductsWithBagCount(\n    val products: List&lt;Products&gt;,\n    val bagCount: Int\n)\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#por-que-esto-es-mejor","title":"Por Qu\u00e9 Esto es Mejor","text":"<p>\u2705 Usa <code>**Flow.combine()**</code> Agrega datos reactivamente, asegurando que cualquier actualizaci\u00f3n de cualquiera de los Repositorios se propague autom\u00e1ticamente. <code>combine()</code> emite los \u00faltimos valores de todos los flows combinados.</p> <p>\u2705 Evita Bloquear Hilos La obtenci\u00f3n de datos es as\u00edncrona a trav\u00e9s de Flows, asegurando una ejecuci\u00f3n no bloqueante y eficiente.</p> <p>\u2705 Mantiene el ViewModel Enfocado El ViewModel solo recoge una \u00fanica fuente de verdad, en lugar de gestionar m\u00faltiples llamadas a Repositorios, haci\u00e9ndolo m\u00e1s simple y enfocado en el estado de la UI.</p> <p>\u2705 Los Repositorios Mantienen una Responsabilidad \u00danica Los Repositorios evitan dependencias entre s\u00ed, manteniendo una clara separaci\u00f3n de preocupaciones, lo que simplifica las pruebas y el mantenimiento.</p> <p>\u2705 Mejora la Testabilidad El Caso de Uso es m\u00e1s f\u00e1cil de simular en pruebas unitarias, eliminando la necesidad de manejar m\u00faltiples instancias de <code>StateFlow</code> o <code>Flow</code> directamente en el ViewModel.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#4-validacion-de-datos","title":"4. Validaci\u00f3n de Datos","text":"<p>La validaci\u00f3n de datos es un aspecto cr\u00edtico para asegurar la integridad y correctitud de los datos que fluyen a trav\u00e9s de tu aplicaci\u00f3n. Al manejar la l\u00f3gica de validaci\u00f3n dentro de la Capa de Dominio, logramos:</p> <p>\u2705 Consistencia Asegurar que los datos sean validados antes de ser procesados o presentados.</p> <p>\u2705 Reutilizaci\u00f3n Evitar l\u00f3gica de validaci\u00f3n redundante en diferentes partes de la app.</p> <p>\u2705 Separaci\u00f3n de Preocupaciones Mantener la validaci\u00f3n independiente de las Capas de Presentaci\u00f3n y de Datos.</p> <p>Validaci\u00f3n de Entrada Asegura que las entradas del usuario cumplan criterios espec\u00edficos antes de ser procesadas o almacenadas.</p> <ul> <li>Comprobar si un correo electr\u00f3nico sigue el formato correcto (por ejemplo, <code>user@example.com</code>).</li> <li>Verificar que una contrase\u00f1a cumpla con los requisitos m\u00ednimos de longitud y complejidad.</li> </ul> <p>Validaci\u00f3n de Reglas de Negocio Asegura que los datos cumplan con las reglas de negocio espec\u00edficas del dominio. La validaci\u00f3n en el frontend puede ayudar a mejorar la UX comprobando reglas de negocio antes de que se realice una acci\u00f3n, bas\u00e1ndose en los datos recibidos.</p> <ul> <li>Comprobar si un usuario tiene fondos suficientes antes de realizar un pedido para evitar llamadas innecesarias a la API REST.</li> <li>Asegurar que un producto est\u00e9 en stock antes de proceder con una compra. Si esta comprobaci\u00f3n falla, podr\u00edamos deshabilitar el bot\u00f3n \"Comprar\".</li> </ul> <p>Validaci\u00f3n de Formato Asegura que los datos sigan una estructura o patr\u00f3n predefinido.</p> <ul> <li>Validar que una cadena de fecha siga cierto formato como <code>YYYY-MM-DD</code>.</li> <li>Asegurar que un n\u00famero de tel\u00e9fono contenga el n\u00famero correcto de d\u00edgitos.</li> </ul> <p>\u2705 Mejor Pr\u00e1ctica: Validaci\u00f3n de Datos en la Capa de Dominio Consideremos un ejemplo donde necesitamos validar la direcci\u00f3n de correo electr\u00f3nico y la contrase\u00f1a de un usuario antes de permitirle registrarse.</p> <pre><code>class ValidateUserRegistrationUseCase @Inject constructor(\n    private val emailValidator: EmailValidator,\n    private val passwordValidator: PasswordValidator\n) {\n    suspend operator fun invoke(\n      email: String,\n      password: String\n    ): ValidationResult {\n        return when {\n            !emailValidator.isValid(email) -&gt; ValidationResult.InvalidEmail\n            !passwordValidator.isValid(password) -&gt; ValidationResult.InvalidPassword\n            else -&gt; ValidationResult.Valid\n        }\n    }\n}\n\nsealed interface ValidationResult {\n    data object Valid : ValidationResult\n    data object InvalidEmail : ValidationResult\n    data object InvalidPassword : ValidationResult\n}\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#resumen-de-validacion","title":"Resumen de Validaci\u00f3n","text":"<p>\u2705 Mant\u00e9n la L\u00f3gica de Validaci\u00f3n Simple y Enfocada Cada validador debe centrarse en una tarea espec\u00edfica (por ejemplo, validar formato de correo electr\u00f3nico o longitud de contrase\u00f1a).</p> <p>\u2705 Manejo de Errores Usa clases selladas o interfaces selladas para representar estados de validaci\u00f3n (v\u00e1lido/inv\u00e1lido), haciendo el manejo de errores m\u00e1s simple y legible.</p> <p>\u2705 Evita Duplicar L\u00f3gica de Validaci\u00f3n Mant\u00e9n la l\u00f3gica de validaci\u00f3n reutilizable para evitar duplicar c\u00f3digo en diferentes partes de la app.</p> <p>\u2705 Prueba la L\u00f3gica de Validaci\u00f3n Independientemente Dado que la l\u00f3gica de validaci\u00f3n es parte de las reglas de negocio, las pruebas unitarias deben centrarse en asegurar que la l\u00f3gica de validaci\u00f3n funcione correctamente en varios escenarios (por ejemplo, formatos de correo electr\u00f3nico inv\u00e1lidos, contrase\u00f1as cortas, etc.).</p> <p>\u274c Codificar Mensajes de Error Evita codificar mensajes de error. En su lugar, define estados de error para asegurar consistencia en toda la app.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#gestionando-casos-de-uso-inyeccion-ciclo-de-vida-y-ejecucion","title":"Gestionando Casos de Uso: Inyecci\u00f3n, Ciclo de Vida y Ejecuci\u00f3n","text":"<p>En una arquitectura basada en ViewModel, los Casos de Uso se inyectan en el ViewModel y se ejecutan seg\u00fan sea necesario. Hilt puede proporcionar autom\u00e1ticamente un Caso de Uso si tiene una sola implementaci\u00f3n. Para asegurar que el Caso de Uso viva tanto como el ViewModel, an\u00f3talo con <code>**@ViewModelScoped**</code>. Esto asegura que la instancia del Caso de Uso se cree una vez cuando se inicializa el ViewModel y permanezca igual durante todo el ciclo de vida del ViewModel, evitando recreaciones innecesarias.</p> <pre><code>@ViewModelScoped\nclass GetCustomerBagUseCase @Inject constructor() {}\n</code></pre> <p>Algunos Casos de Uso pueden beneficiarse de tener un alcance <code>**@Singleton**</code>, lo que asegura que existe una \u00fanica instancia durante el ciclo de vida de la app. Esto puede ser \u00fatil para l\u00f3gica de negocio persistente como la autenticaci\u00f3n.</p> <p>Si un Caso de Uso tiene m\u00faltiples implementaciones o sigue una abstracci\u00f3n basada en interfaces, vincula la implementaci\u00f3n en un <code>@Module</code> e inst\u00e1lalo en <code>ViewModelComponent</code>.</p> <pre><code>@Module\n@InstallIn(ViewModelComponent::class)\nabstract class BagModule {\n    @Binds\n    @ViewModelScoped\n    abstract fun bindGetCustomerBagUseCase(\n        impl: GetCustomerBagUseCaseImpl\n    ): GetCustomerBagUseCase\n}\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#metodos-de-inyeccion-estandar-vs-lazy","title":"M\u00e9todos de Inyecci\u00f3n: Est\u00e1ndar vs Lazy","text":"<p>Hay dos formas principales de inyectar Casos de Uso:</p> <ul> <li>Inyecci\u00f3n est\u00e1ndar para Casos de Uso usados frecuentemente</li> <li>Inyecci\u00f3n diferida (Lazy) para Casos de Uso que solo se necesitan condicionalmente</li> </ul>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#1-inyeccion-estandar-para-casos-de-uso-usados-frecuentemente","title":"1. Inyecci\u00f3n Est\u00e1ndar (Para Casos de Uso Usados Frecuentemente)","text":"<p>Para Casos de Uso que se usan frecuentemente, podemos inyectarlos en el constructor directamente en el ViewModel. La instancia se crea una vez cuando se inicializa el ViewModel y permanece activa durante todo el ciclo de vida del ViewModel.</p> <pre><code>@HiltViewModel\nclass BagViewModel @Inject constructor(\n    private val getCustomerBagUseCase: GetCustomerBagUseCase\n) : ViewModel() {\n\n    private val _customerBag = MutableStateFlow&lt;CustomerBag?&gt;(null)\n    val customerBag: StateFlow&lt;CustomerBag?&gt; = _customerBag.asStateFlow()\n\n    fun getCustomerBag() {\n        viewModelScope.launch {\n            _customerBag.update { getCustomerBagUseCase() }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#2-inyeccion-lazy-para-casos-de-uso-usados-selectivamente","title":"2. Inyecci\u00f3n Lazy (Para Casos de Uso Usados Selectivamente)","text":"<p>Para Casos de Uso que solo se usan en escenarios espec\u00edficos, la inyecci\u00f3n lazy retrasa la instanciaci\u00f3n hasta que se necesita. Esto reduce la creaci\u00f3n de objetos innecesarios y evita inyectar dependencias que podr\u00edan no usarse.</p> <pre><code>import dagger.Lazy\n\n@HiltViewModel\nclass BagViewModel @Inject constructor(\n    private val saveItemToWishListUseCase: Lazy&lt;SaveItemToWishListUseCase&gt;\n) : ViewModel() {\n\n    fun saveItemToWishList(item: Item) {\n        viewModelScope.launch {\n            saveItemToWishListUseCase.get().invoke(item)\n        }\n    }\n}\n</code></pre> <p>Aqu\u00ed, <code>SaveItemToWishListUseCase</code> no se instancia hasta que se llama a <code>get()</code>, reduciendo el uso de memoria y mejorando el rendimiento de la app cuando el Caso de Uso no siempre es necesario.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#usa-viewmodelscope-para-gestion-de-corrutinas","title":"Usa <code>viewModelScope</code> para Gesti\u00f3n de Corrutinas \ud83d\ude80","text":"<p>Al ejecutar Casos de Uso dentro de un ViewModel, usa siempre <code>viewModelScope.launch{}</code>. Esto asegura:</p> <ul> <li>Las Corrutinas se cancelan autom\u00e1ticamente cuando se destruye el ViewModel, previniendo fugas de memoria.</li> <li>Las tareas en segundo plano terminan correctamente cuando la UI ya no est\u00e1 activa.</li> </ul> <p>Por defecto, <code>viewModelScope.launch{}</code> usa el Main Dispatcher, haci\u00e9ndolo ideal para operaciones relacionadas con la UI.</p> <p>Ten en cuenta que <code>_@ViewModelScoped_</code> controla el ciclo de vida de la instancia del Caso de Uso. Asegura una \u00fanica instancia de Caso de Uso por ciclo de vida del ViewModel, mientras que <code>_viewModelScope.launch{}_</code> gestiona la ejecuci\u00f3n y cancelaci\u00f3n de Corrutinas. Aunque se nombran de forma similar, son preocupaciones separadas.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#puntos-clave","title":"Puntos Clave","text":"<p>\u2705 Los Casos de Uso persisten con el ViewModel Dar un alcance a un Caso de Uso con <code>@ViewModelScoped</code> asegura que viva tanto como el ViewModel, evitando recreaciones innecesarias.</p> <p>\u2705 Aprovecha <code>**viewModelScope.launch{}**</code> en ViewModels Se ejecuta en el Main Dispatcher por defecto, haci\u00e9ndolo adecuado para operaciones de UI y garantiza la cancelaci\u00f3n autom\u00e1tica de Corrutinas cuando se borra el ViewModel, previniendo fugas de memoria.</p> <p>\u2705 Elige el m\u00e9todo de inyecci\u00f3n correcto basado en el uso Inyecci\u00f3n est\u00e1ndar para Casos de Uso usados frecuentemente e inyecci\u00f3n lazy para Casos de Uso opcionales para diferir la instanciaci\u00f3n y reducir la sobrecarga de memoria.</p> <p>\u274c No inyectes Casos de Uso en la Capa de Datos Los Casos de Uso pertenecen a la Capa de Dominio y deben ser invocados desde la Capa de Presentaci\u00f3n u otros Casos de Uso cuando sea necesario. No deben inyectarse en la Capa de Datos (por ejemplo, Repositorios, Fuentes de Datos o Mappers) ya que esto viola los principios de Clean Architecture al introducir dependencias innecesarias y aumentar el acoplamiento entre capas.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#restricciones-de-acceso-a-datos-en-la-capa-de-dominio","title":"Restricciones de Acceso a Datos en la Capa de Dominio","text":"<p>Una pregunta com\u00fan en Clean Architecture es:</p> <p>\u00bfDeber\u00edan los ViewModels y otros componentes de la Capa de Presentaci\u00f3n acceder directamente a los Repositorios, o todo el acceso a datos deber\u00eda pasar por Casos de Uso?</p> <p>Restringir el acceso a datos a la Capa de Dominio tiene sus ventajas y desventajas:</p> <p>\u2705 Asegura una Ejecuci\u00f3n Consistente de la L\u00f3gica de Negocio Los Casos de Uso hacen cumplir reglas como el seguimiento de an\u00e1lisis, validaci\u00f3n y transformaciones de datos, asegurando que la l\u00f3gica de negocio se aplique consistentemente y previniendo el acceso inconsistente a datos brutos de la Capa de Datos.</p> <p>\u2705 Soporta la Modularizaci\u00f3n En proyectos modularizados por API/Implementaci\u00f3n, los m\u00f3dulos de caracter\u00edsticas exponen interfaces de Caso de Uso en el m\u00f3dulo <code>:api</code>. Esto mantiene m\u00ednimas las dependencias entre m\u00f3dulos y simplifica la arquitectura general.</p> <p>\u2705 Simplifica las Pruebas de ViewModel Dado que los ViewModels dependen solo de Casos de Uso en lugar de Repositorios, las pruebas se vuelven m\u00e1s f\u00e1ciles. No hay necesidad de simular Repositorios en pruebas de ViewModel, permitiendo pruebas unitarias m\u00e1s aisladas, enfocadas y mantenibles.</p> <p>\u274c Introduce Sobrecarga para Obtenciones Simples Cuando un Caso de Uso simplemente envuelve una llamada a Repositorio sin agregar l\u00f3gica de negocio, puede sentirse redundante e introducir complejidad innecesaria.</p> <p>En ASOS, seguimos la estrategia de modularizaci\u00f3n API/Implementaci\u00f3n, donde restringir el acceso directo a datos a la Capa de Dominio se alinea naturalmente con nuestra arquitectura. Esto asegura un manejo consistente de datos, reduce el acoplamiento y simplifica la mantenibilidad a largo plazo a medida que el proyecto escala.</p>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#estructura-de-paquetes","title":"Estructura de Paquetes","text":"<p>A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo se puede estructurar la Capa de Dominio. Esta es una representaci\u00f3n simple y podr\u00eda cambiar en una app modularizada.</p> <pre><code>\ud83d\udcc2 domain\n\u251c\u2500\u2500 \ud83d\udcc2 model\n\u2502    \u251c\u2500\u2500 ProductsWithBagCount.kt\n\u2502    \u251c\u2500\u2500 Bag.kt\n\u2502    \u251c\u2500\u2500 Product.kt\n\u2502\n\u251c\u2500\u2500 \ud83d\udcc2 repository\n\u2502    \u251c\u2500\u2500 ProductsRepository.kt  //interface\n\u2502    \u251c\u2500\u2500 BagRepository.kt  //interface\n\u2502\n\u251c\u2500\u2500 \ud83d\udcc2 usecase\n\u2502    \u251c\u2500\u2500 AddItemToBagUseCase.kt\n\u2502    \u251c\u2500\u2500 RemoveItemFromBagUseCase.kt\n</code></pre>"},{"location":"temas/03/3.3.3.2-CapaDominio-es.html#conclusion","title":"Conclusi\u00f3n","text":"<p>Incorporar la Capa de Dominio en tu aplicaci\u00f3n Android ofrece numerosos beneficios, incluyendo escalabilidad, testabilidad y mantenibilidad. Al aislar la l\u00f3gica de negocio dentro de la Capa de Dominio, aseguras que el ViewModel y otros componentes de UI permanezcan ligeros y centrados \u00fanicamente en renderizar la UI, sin la carga de operaciones complejas o gesti\u00f3n de datos. Esta separaci\u00f3n de preocupaciones ayuda a crear una arquitectura robusta y f\u00e1cilmente extensible, especialmente a medida que la app crece en tama\u00f1o y complejidad.</p> <p>Al estructurar adecuadamente los Casos de Uso, manejar la hiler\u00eda eficientemente y decidir sabiamente sobre las restricciones de acceso, puedes construir una arquitectura de app mantenible que resista el paso del tiempo.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html","title":"Capa de Datos","text":""},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#android-clean-architecture-capa-de-datos","title":"Android Clean Architecture - Capa de Datos","text":"<p>La Capa de Datos se encarga de todo el trabajo entre bastidores cuando se trata de manejar datos en la aplicaci\u00f3n. Ya sea obteniendo datos de una API remota, leyendo de una base de datos local o gestionando una cach\u00e9 en memoria, esta capa hace el trabajo pesado. Su trabajo es proporcionar datos de una manera consistente para que el resto de la app no tenga que preocuparse de d\u00f3nde vinieron o c\u00f3mo se almacenaron.</p> <p>En Clean Architecture, una regla clave es que la Capa de Datos no debe ser accedida directamente por la Capa de Presentaci\u00f3n (como ViewModels o componentes de UI). En su lugar, habla solo con la Capa de Dominio, que define las reglas de negocio en las que conf\u00eda la aplicaci\u00f3n. Esta separaci\u00f3n mantiene las cosas modulares y flexibles, por lo que si alguna vez necesitas cambiar APIs remotas o cambiar la configuraci\u00f3n de almacenamiento, puedes hacerlo sin afectar al resto de la aplicaci\u00f3n.</p> <p>Presiona enter o haz clic para ver la imagen en tama\u00f1o completo</p>    Disposici\u00f3n de Dependencias en Clean Architecture"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#anatomia-de-la-capa-de-datos","title":"Anatom\u00eda de la Capa de Datos","text":""},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#fuentes-de-datos-data-sources","title":"Fuentes de Datos (Data Sources)","text":"<p>Definen c\u00f3mo se recuperan los datos, ya sea de APIs remotas, bases de datos o cach\u00e9s en memoria. A menudo se categorizan en RemoteDataSources (Remotas) y LocalDataSources (Locales).</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#repositorios","title":"Repositorios","text":"<p>Sirven como el punto de entrada para el acceso a datos, actuando como la interfaz entre la Capa de Datos y la Capa de Dominio. Los Repositorios orquestan datos de Fuentes de Datos remotas o locales.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#interfaces-de-api-remota","title":"Interfaces de API Remota","text":"<p>Definen el contrato para la comunicaci\u00f3n de red. Especifican m\u00e9todos HTTP (como <code>@GET</code>, <code>@POST</code>), rutas de endpoint, par\u00e1metros de consulta/ruta, cabeceras y los modelos de respuesta esperados. Esto asegura una interacci\u00f3n consistente y segura en tipos con APIs remotas.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#objetos-de-acceso-a-datos-daos","title":"Objetos de Acceso a Datos (DAOs)","text":"<p>Proporcionan una capa de abstracci\u00f3n sobre la base de datos. Definen las consultas SQL y operaciones de datos usadas para realizar acciones CRUD (Crear, Leer, Actualizar y Borrar).</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#objetos-de-transferencia-de-datos-dtos","title":"Objetos de Transferencia de Datos (DTOs)","text":"<p>Son representaciones estructuradas de datos externos como respuestas de API REST.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#entidades-entities","title":"Entidades (Entities)","text":"<p>Son representaciones de base de datos que se mapean directamente a tablas. Definen el esquema de la base de datos.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#mappers","title":"Mappers","text":"<p>Transforman datos entre DTOs, Entidades y Modelos de Dominio. Los Mappers son necesarios para evitar dependencias directas entre las Capas de Datos y de Dominio.</p> <p>Presiona enter o haz clic para ver la imagen en tama\u00f1o completo</p>    Representaci\u00f3n del Flujo de Datos en Android Clean Architecture"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#responsabilidades-clave-de-la-capa-de-datos","title":"Responsabilidades Clave de la Capa de Datos","text":"<p>\u2705 Obtenci\u00f3n, Persistencia y Cach\u00e9 de Datos La Capa de Datos maneja operaciones CRUD de fuentes de datos remotas como APIs REST, y puede persistir datos localmente usando herramientas como Room (para bases de datos), DataStore (para pares clave-valor), o cach\u00e9 en memoria (para datos temporales) cuando es necesario.</p> <p>\u2705 Manejo de Respuestas de Red La Capa de Datos procesa y valida respuestas de red. Asegura que los datos de fuentes externas como APIs REST sean v\u00e1lidos, completos y est\u00e9n en el formato correcto antes de ser pasados a la Capa de Dominio.</p> <p>\u2705 L\u00f3gica de Reintento y Manejo de Fallos La Capa de Datos maneja condiciones de red poco fiables implementando estrategias de reintento como espera exponencial (exponential back-off) y gestionando elegantemente los fallos para evitar interrumpir la experiencia del usuario.</p> <p>\u2705 Registro y Reporte de Errores Cuando las operaciones fallan, capturar esos fallos en la fuente es importante. La Capa de Datos debe registrar excepciones y opcionalmente reportarlas usando herramientas de reporte de fallos para facilitar la depuraci\u00f3n y el an\u00e1lisis.</p> <p>\u2705 Hiler\u00eda (Threading) Bibliotecas como Retrofit, Room y DataStore manejan autom\u00e1ticamente la hiler\u00eda cuando se usan Corrutinas, asegurando que las operaciones de datos no bloqueen el hilo principal. Si se usa una biblioteca diferente, la responsabilidad de cambiar hilos para trabajo de E/S pertenece a la Capa de Datos.</p> <p>\u2705 Mapeo de DTOs y Entidades a Modelos de Dominio Transformar datos brutos (como respuestas de API REST o entidades de base de datos) en modelos de dominio utilizables es una responsabilidad clave de esta capa. Esta separaci\u00f3n ayuda a mantener un l\u00edmite claro entre los formatos de datos externos y la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> <p>\u2705 Asegurar la Consistencia de Datos Las Fuentes de Datos deben devolver datos inmutables para asegurar la consistencia y prevenir condiciones de carrera o corrupci\u00f3n de datos. Los datos inmutables garantizan que los datos pasados a las capas superiores de la aplicaci\u00f3n sean fiables.</p> <p>\u2705 Seguridad y Privacidad de Datos Aunque la seguridad es una responsabilidad compartida a trav\u00e9s de las capas, la Capa de Datos juega un papel importante. Ya sea cifrando el almacenamiento local o asegurando la transmisi\u00f3n segura de datos a trav\u00e9s de la red, esta capa ayuda a proteger los datos y la privacidad del usuario.</p> <p>\u274c No Debe Contener L\u00f3gica de Negocio La Capa de Datos se centra en la gesti\u00f3n de datos, no en la toma de decisiones. La l\u00f3gica de negocio debe residir dentro de la Capa de Dominio para mantener la separaci\u00f3n de preocupaciones y la mantenibilidad.</p> <p>\u274c No Debe Ser Accedida Directamente por la Capa de Presentaci\u00f3n El acceso a la Capa de Datos est\u00e1 restringido a trav\u00e9s de la Capa de Dominio para asegurar que la l\u00f3gica de negocio se aplique consistentemente y para prevenir un acceso inconsistente a la Capa de Datos en toda la aplicaci\u00f3n.</p> <p>\ud83d\udca1 En proyectos m\u00e1s peque\u00f1os donde se omite una Capa de Dominio, este l\u00edmite podr\u00eda ser m\u00e1s relajado. Pero en apps escalables, adherirse a esta separaci\u00f3n conduce a una base de c\u00f3digo m\u00e1s mantenible.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#patron-repositorio-en-clean-architecture","title":"Patr\u00f3n Repositorio en Clean Architecture","text":"<p>Los Repositorios act\u00faan como la capa intermedia entre la Capa de Dominio y las Fuentes de Datos (como APIs REST o bases de datos locales). Su trabajo es exponer una interfaz estable y centrada en el dominio que oculta la complejidad subyacente de c\u00f3mo y d\u00f3nde se obtienen o almacenan los datos.</p> <p>T\u00edpicamente no manejan mapeo, hiler\u00eda o manejo de errores de bajo nivel. Esas preocupaciones viven en las clases de Fuente de Datos remota y local. Sin embargo, si tu aplicaci\u00f3n no usa clases de Fuente de Datos (proyectos m\u00e1s peque\u00f1os) es aceptable que el Repositorio asuma estas responsabilidades. Los Repositorios se centran en orquestar datos entre fuentes (remotas y locales), y decidir c\u00f3mo combinar o priorizar datos antes de devolver el resultado a la Capa de Dominio.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-nombrando-repositorios","title":"1. Nombrando Repositorios","text":"<p>Los Repositorios deben seguir el formato:</p> <p>[Tipo de Dato] + Repository</p> <p>Por ejemplo: \u2705 <code>**Bag**Repository</code> \u2705 <code>**Checkout**Repository</code></p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-responsabilidades-clave-de-los-repositorios","title":"2. Responsabilidades Clave de los Repositorios","text":"<p>\u2705 Orquestaci\u00f3n de Datos Los Repositorios coordinan entre m\u00faltiples fuentes de datos. Por ejemplo, obteniendo de la cach\u00e9 local primero y recurriendo a remoto si es necesario (o viceversa). Deciden de d\u00f3nde obtener los datos, no c\u00f3mo obtenerlos.</p> <p>\u2705 Devolver Modelos de Dominio Los Repositorios siempre exponen Modelos de Dominio a la Capa de Dominio. Cualquier mapeo de DTOs o Entidades de base de datos ocurre en las clases de Fuente de Datos remota o local. Si tu aplicaci\u00f3n omite clases de Fuente de Datos, el Repositorio puede asumir la responsabilidad del mapeo.</p> <p>\u2705 Seguridad del Hilo Principal Los Repositorios no deben realizar operaciones de larga duraci\u00f3n en el hilo principal. Pero tampoco deben ser responsables de la hiler\u00eda. Si se requiere cambio de hilos, esa responsabilidad pertenece a la Fuente de Datos que realiza la operaci\u00f3n. Si tu aplicaci\u00f3n omite clases de Fuente de Datos, es aceptable que el Repositorio maneje la hiler\u00eda.</p> <p>\u274c Contener L\u00f3gica de Negocio La l\u00f3gica de negocio pertenece a la Capa de Dominio (Casos de Uso). Los Repositorios son responsables de la orquestaci\u00f3n de datos, no de la toma de decisiones sobre c\u00f3mo deben usarse los datos.</p> <p>\u274c Depender de Casos de Uso Esto crea una dependencia circular entre las capas de Datos y Dominio. En su lugar, deja que el Caso de Uso re\u00fana todas las entradas requeridas antes de llamar al Repositorio.</p> <p>\u274c Depender de Otros Repositorios Los Repositorios no deben depender de otros Repositorios. Cada Repositorio es responsable de manejar una Fuente de Datos espec\u00edfica o tipo de dato. Introducir dependencias entre repositorios conduce a un acoplamiento estrecho. Si necesitas datos de m\u00faltiples fuentes, agr\u00e9galos en un Caso de Uso en la Capa de Dominio.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#3-cache-en-repositorios","title":"3. Cach\u00e9 en Repositorios","text":"<p>Los Repositorios son un buen lugar para activar el almacenamiento en cach\u00e9, siempre y cuando no se necesite aplicar l\u00f3gica de negocio antes de que se almacenen los datos. Si una respuesta de API REST es directamente cacheable, el Repositorio debe almacenarla inmediatamente despu\u00e9s de la recuperaci\u00f3n.</p> <pre><code>internal class NavigationRepositoryImpl @Inject constructor(\n    private val navigationRemoteDataSource: NavigationRemoteDataSource, // interface\n    private val navigationLocalDataSource: NavigationLocalDataSource, // interface\n) : NavigationRepository {\n\n    override suspend fun getNavigationApi(): Result&lt;Unit&gt; {\n        return when (val result = navigationRemoteDataSource.getNavigationApi()) {\n            is Result.Success -&gt; insertNavigationToCache(result.data)\n            is Result.Error -&gt; Result.Error(result.error)\n        }\n    }\n\n    private suspend fun insertNavigationToCache(navigationModel: NavigationModel): Result&lt;Unit&gt; {\n        return when (val result = navigationLocalDataSource.insert(navigationModel) {\n            is Result.Success -&gt; Result.Success(Unit)\n            is Result.Error -&gt; Result.Error(result.error)\n        }\n    }\n\n}\n</code></pre> <p>En este ejemplo, el Repositorio delega tanto la obtenci\u00f3n remota como la inserci\u00f3n en cach\u00e9 a sus respectivas Fuentes de Datos. No maneja c\u00f3mo se hacen esas operaciones, solo cu\u00e1ndo y en qu\u00e9 orden ocurren.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#procesando-datos-antes-de-cachear","title":"Procesando Datos Antes de Cachear","text":"<p>Si los datos necesitan ser transformados, validados o enmendados antes de ser cacheados. Por ejemplo, si la l\u00f3gica de negocio determina qu\u00e9 partes de los datos almacenar o si deben combinarse con otra fuente, entonces ese trabajo debe ocurrir en la Capa de Dominio, dentro de un Caso de Uso.</p> <p>Deja que el Caso de Uso realice las transformaciones necesarias, luego pasa el resultado final de dominio de vuelta al Repositorio para ser persistido. Esto mantiene la l\u00f3gica de negocio fuera de la Capa de Datos y asegura una separaci\u00f3n de preocupaciones.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#estrategias-de-cache","title":"Estrategias de Cach\u00e9","text":"<p>El almacenamiento en cach\u00e9 es una parte clave de la Capa de Datos, pero no hay un enfoque \u00fanico para todos. Tu estrategia debe depender de cu\u00e1n frescos necesiten ser los datos. Por ejemplo, contenido est\u00e1tico como configuraciones de la app se beneficia del cach\u00e9, mientras que datos en tiempo real (por ejemplo, carritos de compra, niveles de stock) no deben ser cacheados para evitar servir informaci\u00f3n desactualizada. \ud83d\udd17 Consulta la documentaci\u00f3n oficial de Android Developers para una visi\u00f3n completa de las estrategias de cach\u00e9 en Android.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#4-multiples-repositorios-y-agregacion-de-dependencias","title":"4. M\u00faltiples Repositorios y Agregaci\u00f3n de Dependencias","text":"<p>Los Repositorios no deben contener l\u00f3gica de negocio o comunicaci\u00f3n entre repositorios. Permitir que los Repositorios se comuniquen directamente entre s\u00ed puede conducir a un acoplamiento estrecho. Si necesitas agregar datos de m\u00faltiples Repositorios utiliza un Caso de Uso.</p> <p>Por Qu\u00e9 los Casos de Uso Agregan Datos Cuando una pantalla o caracter\u00edstica necesita datos de m\u00e1s de una fuente, el Caso de Uso sabe c\u00f3mo coordinar esas llamadas, aplicar cualquier l\u00f3gica de negocio y devolver el resultado de una manera que tenga sentido para la Capa de Presentaci\u00f3n. Esto mantiene la arquitectura modular y m\u00e1s f\u00e1cil de mantener a medida que la aplicaci\u00f3n crece.</p> <p>\u274c Ejemplo Incorrecto: Agregando Datos en un Repositorio</p> <pre><code>internal class StockRepositoryImpl @Inject constructor(\n    private val pricingRepository: PricingRepository, // \u274c Dependencia entre repositorios\n    private val stockRemoteDataSource: StockRemoteDataSource\n) : StockRepository {\n\n    override suspend fun getStockSummary(productId: String): StockSummary {\n        val price = pricingRepository.getPriceForProduct(productId) // \u274c No relacionado con stock\n        val stockLevel = stockRemoteDataSource.getStockLevel(productId)\n        return StockSummary(productId, stockLevel, price)\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#por-que-es-esto-incorrecto","title":"\u00bfPor qu\u00e9 es esto incorrecto?","text":"<p>\u274c Viola el Principio de Responsabilidad \u00danica (SRP) El Repositorio es ahora responsable de obtener datos de stock y precio, lo que introduce un acoplamiento innecesario.</p> <p>\u274c Acopla Estrechamente los Repositorios Si PricingRepository cambia, StockRepository podr\u00eda necesitar modificaciones, aunque no est\u00e9 relacionado con datos de precios.</p> <p>\u274c Aumenta la Complejidad de las Pruebas Las pruebas unitarias para StockRepository ahora necesitan simular o falsificar el PricingRepository, haciendo las pruebas m\u00e1s engorrosas.</p> <p>\u2705 Ejemplo Correcto: Agregar Datos en el Caso de Uso El enfoque correcto es dejar que los Repositorios se centren en sus propias preocupaciones de datos y mover cualquier l\u00f3gica de coordinaci\u00f3n o transformaci\u00f3n a un Caso de Uso.</p> <pre><code>internal class GetStockSummaryUseCase @Inject constructor(\n    private val pricingRepository: PricingRepository, // interface\n    private val stockRepository: StockRepository // interface\n) {\n    suspend operator fun invoke(productId: String): StockSummary {\n        val price = pricingRepository.getPriceForProduct(productId)\n        val stockLevel = stockRepository.getStockLevel(productId)\n        return StockSummary(productId, stockLevel, price)\n        // \u2705 Mantiene las responsabilidades claramente separadas\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#por-que-es-esto-correcto","title":"\u00bfPor qu\u00e9 es esto correcto?","text":"<p>\u2705 Los Repositorios permanecen independientes Cada repositorio hace una cosa (stock o precio), y no depende del otro.</p> <p>\u2705 El Caso de Uso Maneja la Coordinaci\u00f3n El GetStockSummaryUseCase orquesta los datos de ambos Repositorios, aplica cualquier regla de negocio (si es necesario), y devuelve el resultado final a la Capa de Presentaci\u00f3n.</p> <p>\u2705 M\u00e1s F\u00e1cil de Probar y Mantener Los Repositorios son m\u00e1s f\u00e1ciles de probar en aislamiento, y los cambios en la l\u00f3gica de precios no impactar\u00e1n al StockRepository.</p> <p>\ud83d\udd17 Consulta el art\u00edculo anterior de la serie para una inmersi\u00f3n profunda en la Capa de Dominio y Casos de Uso.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#entendiendo-las-fuentes-de-datos","title":"Entendiendo las Fuentes de Datos","text":""},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-que-es-una-fuente-de-datos","title":"1. \u00bfQu\u00e9 es una Fuente de Datos?","text":"<p>Una Fuente de Datos es responsable de acceder y gestionar datos de una ubicaci\u00f3n espec\u00edfica, ya sea a trav\u00e9s de la red, en almacenamiento local o desde una cach\u00e9 en memoria. Abstrae los detalles de c\u00f3mo se recuperan o persisten esos datos, ofreciendo una interfaz enfocada para realizar operaciones CRUD.</p> <p>Las Fuentes de Datos tambi\u00e9n manejan la transformaci\u00f3n de datos, mapeando respuestas en bruto (como DTOs o entidades de base de datos) en modelos amigables con el dominio antes de pasarlos aguas abajo.</p> <p>\ud83d\udca1 Si tu arquitectura no usa clases de Fuente de Datos expl\u00edcitas, entonces el trabajo de mapeo y transformaci\u00f3n usualmente se desplazar\u00e1 al Repositorio. Aunque eso puede funcionar para apps m\u00e1s peque\u00f1as, tener clases de Fuente de Datos separadas ofrece l\u00edmites m\u00e1s claros y mejor escalabilidad.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-tipos-de-fuentes-de-datos","title":"2. Tipos de Fuentes de Datos","text":"<p>T\u00edpicamente hay dos tipos principales de Fuentes de Datos</p> <p>Fuentes de Datos Remotas Manejan la comunicaci\u00f3n con APIs remotas. Son responsables de enviar solicitudes, analizar respuestas y mapear resultados de API en modelos de dominio.</p> <p>Fuentes de Datos Locales Gestionan el acceso al almacenamiento en el dispositivo, como bases de datos, sistemas de archivos o almacenes de preferencias. Estas fuentes manejan la persistencia local, y t\u00edpicamente usan herramientas como Room o DataStore.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#3-como-estructurar-fuentes-de-datos","title":"3. C\u00f3mo Estructurar Fuentes de Datos","text":"<p>Cada Fuente de Datos debe centrarse en una sola entidad de datos. Por ejemplo, un <code>UserRemoteDataSourceImpl</code> trabajar\u00eda con un <code>UserDto</code>, mientras que un <code>UserLocalDataSourceImpl</code> manejar\u00eda una <code>UserEntity</code> de Room.</p> <p>Aunque es ideal separar por tipo de almacenamiento (p.ej. Room vs. DataStore), tambi\u00e9n es perfectamente v\u00e1lido combinarlos detr\u00e1s de una \u00fanica interfaz de fuente de datos local, siempre y cuando las responsabilidades permanezcan cohesivas y el Repositorio no est\u00e9 expuesto a los detalles de almacenamiento subyacentes.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#4-nombrando-fuentes-de-datos","title":"4. Nombrando Fuentes de Datos","text":"<p>El nombrado de Fuentes de Datos debe seguir el formato:</p> <p>[Tipo de Dato] + [_tipo de fuente] + _DataSource</p> <p>Ejemplos: \u2705 <code>**_Bag_**_Remote_DataSource</code> \u2705 <code>**Checkout**_Local_DataSource</code></p> <p>\ud83d\udeab Evita nombres de interfaz espec\u00edficos de implementaci\u00f3n(p.ej. <code>_BagSharedPreferencesDataSource_</code>). Los Repositorios no deben ser conscientes del mecanismo de almacenamiento subyacente, permitiendo flexibilidad en cambios futuros.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#mejores-practicas-para-implementar-fuentes-de-datos","title":"Mejores Pr\u00e1cticas para Implementar Fuentes de Datos","text":""},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-separacion-de-preocupaciones","title":"1. Separaci\u00f3n de Preocupaciones","text":"<p>Una Fuente de Datos nunca debe ser accedida directamente por otras capas de tu aplicaci\u00f3n, como Casos de Uso o ViewModels. En su lugar, todos los datos fluyen a trav\u00e9s de un Repositorio, que sirve como un puente entre las Fuentes de Datos y la Capa de Dominio.</p> <p>Mantener las Fuentes de Datos detr\u00e1s de interfaces te da la flexibilidad de intercambiar mecanismos de almacenamiento o APIs REST sin impactar al resto de la aplicaci\u00f3n. Por ejemplo, cambiar de Firebase a una API REST o de Room a DataStore no deber\u00eda requerir cambios fuera de la clase Implementaci\u00f3n de Fuente de Datos. Tambi\u00e9n facilita pruebas m\u00e1s f\u00e1ciles permiti\u00e9ndonos intercambiar las implementaciones reales por falsificaciones de prueba.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-mapeo","title":"2. Mapeo","text":"<p>El mapeo entre DTOs, Entidades y Modelos de Dominio es necesario para mantener la separaci\u00f3n de preocupaciones y evitar acoplamiento estrecho entre capas.</p> <p>\u00bfD\u00f3nde Deber\u00eda Ocurrir el Mapeo? El mapeo deber\u00eda ocurrir idealmente dentro de las clases de Fuente de Datos. Esto asegura que para cuando los datos lleguen al Repositorio, ya est\u00e9n en forma de Modelo de Dominio. Esto mantiene a los Repositorios centrados puramente en la orquestaci\u00f3n.</p> <p>Si tu proyecto no tiene clases de Fuente de Datos expl\u00edcitas, es aceptable que el Repositorio asuma esta responsabilidad. Si tus Repositorios se vuelven hinchados y complejos, considera mover la l\u00f3gica de mapeo a la Fuente de Datos.</p> <p>\u00bfC\u00f3mo Deber\u00edas Mapear? Hay dos enfoques est\u00e1ndar para el mapeo:</p> <ul> <li>Usar una clase mapper dedicada</li> <li>Usar una funci\u00f3n de extensi\u00f3n de Kotlin</li> </ul> <p>\u00bfCu\u00e1l Deber\u00edas Elegir?</p> <ul> <li>Si el mapper tiene dependencias usa una clase mapper independiente.</li> <li>Si el mapper no tiene dependencias usa una funci\u00f3n de extensi\u00f3n de Kotlin.</li> </ul> <p>Funciones de Extensi\u00f3n de Mapeo Cuando uses funciones de extensi\u00f3n para mapeo, col\u00f3calas en un archivo Kotlin claramente nombrado como UserMappingExtensionFunctions.kt, ubicado en el paquete /data/mapper. Este archivo contiene funciones de mapeo entre un UserDto, UserModel y UserEntity. Estas funciones deben ser probadas unitariamente, igual que los mappers independientes. Crea una clase de prueba correspondiente junto a ellas.</p> <pre><code>// Ejemplo de una funci\u00f3n de extensi\u00f3n de mapeo de Kotlin\nfun UserDto.toDomain() = User(\n    id = this.id,\n    name = this.name,\n    email = this.email\n)\n\n// Ejemplo de una clase mapper independiente\nclass UserDtoToDomainMapper @Inject constructor() {\n    fun map(dto: UserDto): User {\n        return User(\n            id = dto.id,\n            name = dto.name,\n            email = dto.email\n        )\n    }\n}\n</code></pre> <p>\ud83d\udca1 Evita usar valores por defecto para enmascarar datos faltantes (p.ej. cadenas vac\u00edas o valores cero) a menos que est\u00e9s manejando intencionalmente campos opcionales. Fallar silenciosamente puede conducir a errores dif\u00edciles de rastrear en la UI o Capa de Dominio.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#3-manejo-de-errores-y-registro-logging","title":"3. Manejo de Errores y Registro (Logging)","text":"<p>Las Fuentes de Datos son el lugar correcto para capturar y registrar excepciones. Sin embargo, nunca deben exponer excepciones en bruto al Repositorio o Capa de Dominio. En su lugar, deben mapear esas excepciones a tipos de error amigables con el dominio.</p> <p>Esto permite al Repositorio pasar informaci\u00f3n de error estructurada y significativa a la Capa de Presentaci\u00f3n, que luego puede responder de maneras que mejoren la experiencia del usuario. Por ejemplo, mostrando un mensaje de error, deshabilitando un bot\u00f3n o activando un reintento.</p> <p>El principio clave aqu\u00ed es que las excepciones en bruto como c\u00f3digos de error HTTP nunca deben exponerse directamente a las Capas de Dominio o Presentaci\u00f3n. En su lugar, las excepciones deben mapearse a tipos de error espec\u00edficos que tengan sentido en el dominio de la aplicaci\u00f3n.</p> <p>Usando una Clase Result Personalizada Usamos una interfaz sellada personalizada llamada <code>BagResult</code> para representar el resultado de una operaci\u00f3n. Esto ayuda a unificar la forma en que manejamos tanto el \u00e9xito como el fracaso.</p> <pre><code>// Ejemplo de una clase Result personalizada\nsealed interface BagResult {\n    data class Success(val data: Bag) : BagResult\n    data class Error(val error: BagError) : BagResult\n}\n</code></pre> <ul> <li>Success: Contiene los datos devueltos de la operaci\u00f3n (de una llamada a API REST o consulta de base de datos).</li> <li>Error: Contiene un <code>BagError</code>, que es una clase amigable con el dominio que contiene errores predefinidos que podr\u00edan ocurrir al interactuar con la API de Bolsa.</li> </ul> <p>La clase <code>BagResult</code> nos permite manejar tanto el \u00e9xito como el fracaso de una operaci\u00f3n de manera consistente, simplificando la propagaci\u00f3n de errores a trav\u00e9s de diferentes capas de la app.</p> <p>Mapeando a Tipos de Error Espec\u00edficos del Dominio Para mantener el manejo de errores en la capa de datos claro y enfocado en el dominio, usamos una enum class para definir tipos de error. Aqu\u00ed hay un ejemplo de c\u00f3mo definimos una clase de error personalizada para manejar diferentes tipos de errores relacionados con una API REST de bolsa de compras.</p> <pre><code>enum class BagError {\n    NetworkError,\n    InvalidRequest,\n    Unauthorized,\n    Forbidden,\n    NotFound,\n    InternalServerError,\n    UndefinedError\n    // se pueden agregar casos adicionales...\n}\n</code></pre> <p>El enum <code>BagError</code> captura condiciones de error espec\u00edficas que podr\u00edan ocurrir en el contexto de obtener o gestionar datos de la bolsa. El beneficio de usar tal enfoque es que podemos diferenciar claramente entre varios tipos de errores (p.ej. problemas de red, solicitudes inv\u00e1lidas o errores del servidor). Esto hace que sea m\u00e1s f\u00e1cil responder a los errores apropiadamente en la UI, como mostrar mensajes de error relevantes, redirigir al usuario a la pantalla de inicio de sesi\u00f3n, etc.</p> <p>En este caso, usamos un <code>BagErrorMapper.kt</code> con una funci\u00f3n de nivel superior para mapear excepciones en bruto al tipo de error espec\u00edfico del dominio:</p> <pre><code>internal fun mapToBagError(exception: Throwable): BagError {\n    return when (exception) {\n        is IOException -&gt; BagError.NetworkError\n        is HttpException -&gt; mapHttpErrorCode(exception)\n        else -&gt; BagError.UndefinedError\n    }\n\n    private fun mapHttpErrorCode(exception: HttpException): BagError {\n        return when (exception.code()) {\n            400 -&gt; BagError.InvalidRequest\n            401 -&gt; BagError.Unauthorized\n            403 -&gt; BagError.Forbidden\n            404 -&gt; BagError.NotFound\n            in 500..599 -&gt; BagError.InternalServerError\n            else -&gt; BagError.UndefinedError\n        }\n    }\n}\n</code></pre> <p>Al manejar errores en el nivel de Fuente de Datos, nosotros: \u2705 Aseguramos consistencia registrando errores en el punto de fallo. \u2705 Proporcionamos errores significativos a las capas de Dominio y Presentaci\u00f3n. \u2705 Tipos de error predecibles facilitan pruebas m\u00e1s f\u00e1ciles. \u2705 Evitamos registros redundantes a trav\u00e9s de m\u00faltiples Repositorios. \u2705 Mantenemos los Repositorios centrados en la orquestaci\u00f3n.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#manejo-de-cancellationexception","title":"Manejo de CancellationException","text":"<p>\u26a0\ufe0f Importante: Si usas runCatching, asegura que expl\u00edcitamente relanzas CancellationExceptions. Si una Corrutina se cancela debido a un tiempo de espera o cancelaci\u00f3n de trabajo, debe propagarse aguas abajo en lugar de ser tragada. No hacerlo puede conducir a un comportamiento inesperado como estados de carga infinita o UIs que no responden.</p> <p>Usamos una funci\u00f3n auxiliar para relanzar autom\u00e1ticamente la CancellationException.</p> <pre><code>suspend fun &lt;R&gt; runSuspendCatching(block: suspend () -&gt; R): Result&lt;R&gt; {\n    return try {\n        Result.success(block())\n    } catch(c: CancellationException) {\n        throw c\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#4-inyeccion-de-dependencias","title":"4. Inyecci\u00f3n de Dependencias","text":"<p>Usa inyecci\u00f3n de constructor est\u00e1ndar para cualquier Fuente de Datos que se requiera inmediatamente. Si la Fuente de Datos es opcional o raramente usada (una cach\u00e9 que solo se golpea en ciertos flujos), puedes usar inyecci\u00f3n lazy. Esto difiere la instanciaci\u00f3n hasta que realmente se necesita, lo que ayuda a reducir el uso de memoria y mejorar el tiempo de inicio de la app.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#5-hileria-threading","title":"5. Hiler\u00eda (Threading)","text":"<p>En Corrutinas, bibliotecas como Retrofit, Ktor, Room y DataStore usan internamente <code>Dispatchers.IO</code> para operaciones de red/disco as\u00ed que no es necesario cambiar hilos manualmente. Sin embargo, si est\u00e1s leyendo/escribiendo de archivos de almacenamiento local o cualquier otra soluci\u00f3n de almacenamiento personalizada necesitar\u00e1s cambiar manualmente a un hilo en segundo plano usando Dispatcher.IO en la clase DataSource antes de que ocurra la operaci\u00f3n.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#implementando-fuentes-de-datos-remotas","title":"Implementando Fuentes de Datos Remotas","text":"<p>Las Fuentes de Datos Remotas manejan la comunicaci\u00f3n con fuentes remotas, m\u00e1s com\u00fanmente APIs REST. Bibliotecas como Retrofit o Ktor se usan com\u00fanmente para manejar solicitudes de red. Cada Fuente de Datos Remota debe definir una interfaz que especifique c\u00f3mo interact\u00faa con la API REST.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-nombrando-interfaces-de-api-rest","title":"1. Nombrando Interfaces de API REST","text":"<p>Las interfaces de API REST deben seguir el formato:</p> <p>[Caracter\u00edstica] + Api</p> <p>Ejemplos: \u2705 <code>**Bag**Api</code> \u2705 <code>**Checkout**Api</code></p> <pre><code>interface BagApi {\n    @GET(\"bags/{bagId}\")\n    suspend fun getBagByBagId(\n        @Path(\"bagId\") bagId: String,\n    ): BagDto\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-ejemplo-incorrecto-de-una-fuente-de-datos-remota","title":"2. \u274c Ejemplo Incorrecto de una Fuente de Datos Remota","text":"<p>Aqu\u00ed hay una implementaci\u00f3n de Fuente de Datos Remota que viola los l\u00edmites de Clean Architecture e introduce complejidad innecesaria.</p> <pre><code>internal class BagRemoteDataSourceImpl @Inject constructor(\n    private val bagApi: BagApi, // interface\n    private val bagDtoToDomainMapper: BagDtoToDomainMapper,\n    private val userRepository: UserRepository, // \u274c No permitido\n    @IODispatcher private val ioDispatcher: CoroutineDispatcher // \u274c Innecesario\n) : BagRemoteDataSource {\n\n    override suspend fun getBag(): BagResult&lt;Bag&gt; {\n      return withContext(ioDispatcher) { // \u274c Retrofit maneja la hiler\u00eda internamente\n          runCatching { // \u274c Usa runSuspendCatching para relanzar auto CancellationExceptions\n            bagApi.getBag(userRepository.getUserId()) // \u274c El id de usuario debe pasarse en getBag()\n          }.fold(\n              onSuccess = { result -&gt;\n                  BagResult.Success(bagDtoToDomainMapper.map(result)) // \u274c Cualquier error de json malformado puede bloquear la app\n              }\n          },\n              onFailure = { exception -&gt;\n                  val bagError = mapToBagError(exception)\n                  // \u274c Sin registro de errores a herramientas de reporte de fallos\n                  BagResult.Error(bagError)\n              }\n           )\n        }\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#por-que-es-esto-incorrecto_1","title":"\u00bfPor qu\u00e9 es esto incorrecto?","text":"<p>\u274c Dependencia Circular La Fuente de Datos depende de un Repositorio (<code>UserRepository</code>). Esto rompe el flujo de datos unidireccional y crea una dependencia circular. Valores como el id de usuario deben ser recuperados por la Capa de Dominio y pasados como par\u00e1metros.</p> <p>\u274c Gesti\u00f3n de Hilos Innecesaria Se inyecta y usa un <code>CoroutineDispatcher</code> expl\u00edcito v\u00eda <code>withContext</code>. Esto es innecesario cuando se usa Retrofit con Corrutinas, ya que Retrofit ya maneja llamadas de red fuera del hilo principal.</p> <p>\u274c Sin Registro de Errores Es importante que registremos errores usando herramientas de reporte de fallos para que podamos monitorear las APIs REST en producci\u00f3n.</p> <p>\u274c Errores de Mapeo No Capturados Cualquier NullPointerException lanzado durante el mapeo debido a JSON malformado bloquear\u00e1 la app ya que el mapeo ocurre fuera del runCatching. Un ejemplo de esto podr\u00eda ser un problema con el contrato que no se respeta y devuelve datos diferentes a los esperados.</p> <p>\u274c Usando runCatching Es preferible usar la funci\u00f3n auxiliar runSuspendCatching mencionada anteriormente ya que esto relanzar\u00e1 CancellationExceptions por ti, negando la necesidad de que los desarrolladores recuerden hacer esto manualmente.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#3-ejemplo-correcto-de-una-fuente-de-datos-remota","title":"3. \u2705 Ejemplo Correcto de una Fuente de Datos Remota","text":"<p>La siguiente versi\u00f3n respeta los principios de Clean Architecture y evita anti-patrones.</p> <pre><code>internal class BagRemoteDataSourceImpl @Inject constructor(\n    private val bagApi: BagApi, // interface\n    private val crashLogger: CrashLogger, // interface\n    private val eventLogger: EventLogger, // interface\n    private val bagDtoToDomainMapper: BagDtoToDomainMapper\n) : BagRemoteDataSource {\n\n    override suspend fun getBag(userId: String): BagResult&lt;Bag&gt; { // \u2705 Id de usuario pasado como param\n      return runSuspendCatching { // \u2705 runSuspendCatching relanza CancellationExceptions\n          val result = bagApi.getBag(userId) // \u2705 Sin cambio de hilo\n          bagDtoToDomainMapper.map(result) // \u2705 Mapea en el runSuspendCatching para capturar json malformado\n        }.fold(\n            onSuccess = { mappedResult -&gt;\n                BagResult.Success(mappedResult)\n            }\n        },\n            onFailure = { exception -&gt;\n                val bagError = mapToBagError(exception) // \u2705 Usa funci\u00f3n mapper para convertir throwable en bruto a tipo de error de dominio\n                logError(exception, bagError) // \u2705 Registra excepciones\n                BagResult.Error(bagError)\n            }\n        )\n    }\n\n    private fun logError(\n        exception: Throwable,\n        bagError: BagError\n    ) {\n        Log.e(this.javaClass.simpleName, exception.message.toString())\n        crashLogger.logException(exception)\n\n        eventLogger.logEvent(\n            eventAttributes = mapOf(\n                NAME to bagError.name,\n                DESCRIPTION to exception.message.orEmpty()\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#por-que-es-esto-correcto_1","title":"\u00bfPor qu\u00e9 es esto correcto?","text":"<p>\u2705 Sin Dependencias Circulares El id de usuario se pasa como un par\u00e1metro en lugar de obtenerse de un Repositorio, lo cual viola los principios de Clean Architecture. Esto mantiene la Fuente de Datos libre de l\u00f3gica de negocio y dependencias externas.</p> <p>\u2705 Delegaci\u00f3n de Hiler\u00eda La hiler\u00eda se delega y gestiona internamente por Retrofit, eliminando la necesidad de inyectar un despachador o cambiar hilos manualmente. Esto simplifica la configuraci\u00f3n y las pruebas.</p> <p>\u2705 Mapeo El DTO se convierte a un modelo de dominio antes de que el resultado se devuelva al Repositorio.</p> <p>\u2705 Registro de Errores Los errores se registran en la fuente y se mapean a tipos espec\u00edficos del dominio permitiendo el monitoreo en producci\u00f3n. Las herramientas de registro se abstraen a trav\u00e9s de interfaces desacopladas. Esto hace que la implementaci\u00f3n sea f\u00e1cil de probar y reemplazar si las herramientas de registro cambian en el futuro.</p> <p>\u2705 Usa runSuspendCatching Usar runSuspendCatching relanza CancellationExceptions por nosotros autom\u00e1ticamente y preserva la concurrencia estructurada.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#implementando-fuentes-de-datos-locales","title":"Implementando Fuentes de Datos Locales","text":"<p>Las Fuentes de Datos Locales son responsables de interactuar con datos almacenados en el dispositivo. Siguen la misma estructura de Clean Architecture que las Fuentes de Datos Remotas pero en su lugar interact\u00faan con mecanismos de almacenamiento local como bases de datos, archivos o almacenes de clave-valor.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-opciones-de-almacenamiento","title":"1. Opciones de Almacenamiento","text":"<p>La elecci\u00f3n del almacenamiento local depende del tipo de datos y c\u00f3mo se acceder\u00e1 a ellos:</p> <ul> <li>Room / SQLDelight     Usa una base de datos cuando tus datos sean estructurados, relacionales y requieran persistencia a largo plazo. Las bases de datos permiten consultas complejas como uniones, filtros y transacciones.</li> <li>DataStore     DataStore es el reemplazo moderno respaldado por Corrutinas para SharedPreferences. Es el m\u00e1s adecuado para peque\u00f1os conjuntos de datos como configuraciones de usuario, banderas o preferencias que no requieren consultas complejas.</li> <li>Archivos (JSON, CSV, XML, etc)     Los archivos son adecuados para configuraciones, registros o datos exportables que no requieren consultas.</li> <li>Cach\u00e9 en Memoria     Este es almacenamiento temporal para objetos de datos accedidos frecuentemente que no esperan persistir si la app se mata o reinicia.</li> </ul> <p>\u26a0\ufe0f Ten cuidado con las cach\u00e9s en memoria. Si la app se coloca en segundo plano y ocurre una muerte de proceso, el sistema puede matar el proceso para reclamar recursos. Cuando el usuario regresa a la app, intentar\u00e1 restaurar el estado anterior, pero la cach\u00e9 en memoria se habr\u00e1 borrado. Esto puede resultar en estados de UI no intencionados y bloqueos.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-nombrando-interfaces-dao","title":"2. Nombrando Interfaces DAO","text":"<p>Cuando usas una base de datos como Room, un DAO es donde defines c\u00f3mo la app interact\u00faa con las tablas locales (inserciones, consultas, borrados, etc).</p> <p>El nombrado de interfaz DAO debe seguir el formato:</p> <p>[Tipo de Dato] + Dao</p> <p>Ejemplos: \u2705 <code>**Navigation**Dao</code> \u2705 <code>**SearchHistory**Dao</code></p> <pre><code>@Dao\ninterface NavigationDao {\n\n    @Query(\"SELECT * FROM navigation WHERE id = :id\")\n    suspend fun getNavigation(id: String): NavigationEntity?\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE) // reemplaza entradas duplicadas\n    suspend fun insertNavigation(navigation: NavigationEntity)\n\n    @Delete\n    suspend fun deleteNavigation(navigation: NavigationEntity)\n}\n</code></pre> <p>\ud83d\udca1 Los m\u00e9todos DAO usando funciones suspend corren autom\u00e1ticamente en un hilo en segundo plano gracias al soporte de Corrutinas de Room, as\u00ed que no necesitas gestionar expl\u00edcitamente la hiler\u00eda.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#3-ejemplo-de-fuente-de-datos-local","title":"3. Ejemplo de Fuente de Datos Local","text":"<p>Las Fuentes de Datos Locales y Remotas comparten una estructura similar: inyecci\u00f3n de dependencias, manejo de errores, envoltura de resultados y mapeo a modelos de dominio. Para estos patrones compartidos, consulta la secci\u00f3n de Fuente de Datos Remota arriba. La diferencia clave es que en lugar de inyectar una interfaz de API REST, inyectas la interfaz DAO cuando usas Room, o una interfaz apropiada cuando trabajas con DataStore u otros mecanismos de almacenamiento local.</p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#entendiendo-los-modelos-de-la-capa-de-datos","title":"Entendiendo los Modelos de la Capa de Datos","text":"<p>En la Capa de Datos, se usan dos tipos principales de modelos:</p> <ul> <li>DTOs representan modelos de respuesta de API REST. Deben permanecer inmutables y mapear estrechamente a la respuesta de la API REST.</li> <li>Entidades representan tablas de base de datos y persisten datos dentro de la base de datos local. T\u00edpicamente se anotan con <code>@Entity</code> cuando se usa Room. \ud83d\udd17 Consulta la documentaci\u00f3n oficial de Room para m\u00e1s detalles sobre estructuraci\u00f3n de Entidades.</li> </ul>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#1-nombrando-modelos-de-datos","title":"1. Nombrando Modelos de Datos","text":"<p>Los modelos de datos deben seguir el formato:</p> <p>[Tipo de Dato] + Dto/Entity</p> <p>Por ejemplo: \u2705 <code>**Navigation**Dto</code> \u2705 <code>**Navigation**Entity</code></p>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#2-mejores-practicas-para-dtos","title":"2. Mejores Pr\u00e1cticas para DTOs","text":"<p>\u2705 Clases de Datos Inmutables Haz los DTOs inmutables usando solo propiedades <code>val</code>. Esto ayuda a evitar cambios accidentales y mantiene tus datos consistentes.</p> <p>\u2705 Manejo de Nulabilidad Coincide la nulabilidad de las propiedades DTO con la especificaci\u00f3n de la API REST. Maneja cualquier nulo durante el mapeo para evitar bloqueos m\u00e1s tarde en la app.</p> <p>\u2705 Mappers para Transformaci\u00f3n Usa un mapper dedicado para transformar DTOs a Entidades o Modelos de Dominio. Esto asegura que ning\u00fan detalle innecesario de la API REST se filtre a las otras capas.</p> <p>\u2705 Serializaci\u00f3n y Mapeo de Campos Si tus nombres de campo JSON difieren de tus nombres de propiedad Kotlin, usa la anotaci\u00f3n <code>@SerialName</code> de Kotlin Serialization. Kotlin Serialization es preferido sobre Gson debido a su mejor rendimiento y soporte nativo de Kotlin.</p> <p>\u26a0\ufe0f Ten en cuenta que <code>@SerialName</code> ayuda a prevenir la ofuscaci\u00f3n de propiedades cuando se usan herramientas como R8.</p> <p>\u2705 Evita Campos Espec\u00edficos de API Excluye cualquier campo de metadatos de API como c\u00f3digos de estado o marcas de tiempo que no se necesiten. Mant\u00e9n los DTOs centrados solo en los datos requeridos.</p> <p>\u2705 Separaci\u00f3n de Preocupaciones Los DTOs deben centrarse solo en la representaci\u00f3n de datos. Evita incrustar l\u00f3gica de negocio o incluir funciones de mapeo dentro de clases DTO.</p> <pre><code>import kotlinx.serialization.SerialName\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class NavigationDto(\n    @SerialName(\"navigation_id\")\n    val id: String?,\n    @SerialName(\"navigation_title\")\n    val title: String?,\n    @SerialName(\"navigation_url\")\n    val url: String?\n)\n</code></pre>"},{"location":"temas/03/3.3.3.3-CapaDatos-es.html#estructura-de-paquetes","title":"Estructura de Paquetes","text":"<p>A continuaci\u00f3n se muestra un ejemplo de c\u00f3mo se puede estructurar la Capa de Datos. Esta es una representaci\u00f3n simple y podr\u00eda cambiar en una app modularizada.</p> <pre><code>\ud83d\udcc2 data\n \u251c\u2500\u2500 \ud83d\udcc2 local\n \u2502    \u251c\u2500\u2500 BagDao.kt\n \u2502    \u251c\u2500\u2500 BagEntity.kt\n \u2502    \u251c\u2500\u2500 BagEntityMapper.kt\n \u2502    \u251c\u2500\u2500 BagLocalDataSourceImpl.kt\n \u2502\n \u251c\u2500\u2500 \ud83d\udcc2 remote\n \u2502    \u251c\u2500\u2500 BagApi.kt\n \u2502    \u251c\u2500\u2500 BagDto.kt\n \u2502    \u251c\u2500\u2500 BagErrorMapper.kt\n \u2502    \u251c\u2500\u2500 BagDtoMapper.kt\n \u2502    \u251c\u2500\u2500 BagRemoteDataSourceImpl.kt\n \u2502\n \u251c\u2500\u2500 \ud83d\udcc2 repository\n \u2502    \u251c\u2500\u2500 BagLocalDataSource.kt  // interface\n \u2502    \u251c\u2500\u2500 BagRemoteDataSource.kt. // interface\n \u2502    \u251c\u2500\u2500 BagRepositoryImpl.kt\n\n\ud83d\udcc2 domain\n \u251c\u2500\u2500 \ud83d\udcc2 repository\n \u2502    \u251c\u2500\u2500 BagRepository.kt // interface\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html","title":"Introducci\u00f3n","text":""},{"location":"temas/04/4.0-persistencia.html#40-persistencia-de-datos-en-android","title":"4.0 Persistencia de Datos en Android","text":"<p>En Android, \"persistencia\" significa guardar datos para que no se pierdan cuando el usuario cierra la aplicaci\u00f3n o reinicia el tel\u00e9fono.</p> <p>Elegir la herramienta correcta es vital para el rendimiento de la app. No es lo mismo guardar un simple \"Modo Oscuro: Activado\" que guardar una lista de 5,000 pel\u00edculas con su sinopsis.</p>"},{"location":"temas/04/4.0-persistencia.html#guia-rapida-de-eleccion","title":"\ud83d\udcca Gu\u00eda R\u00e1pida de Elecci\u00f3n","text":"Herramienta Tipo de Datos Caso de Uso Ideal Jetpack DataStore Clave-Valor (Simples) Preferencias de usuario, flags, tokens de sesi\u00f3n. Room Estructurados (Relacionales) Listas de objetos, datos complejos, cach\u00e9 offline. Ficheros Datos binarios/grandes Fotos, PDFs, audio, logs largos. SharedPreferences Clave-Valor (Legacy) Obsoleto. Usar solo en proyectos antiguos."},{"location":"temas/04/4.0-persistencia.html#1-jetpack-datastore-el-estandar-moderno","title":"1. \ud83d\ude80 Jetpack DataStore (El Est\u00e1ndar Moderno)","text":"<p>DataStore es la soluci\u00f3n moderna para guardar pares clave-valor (como <code>settings: true</code>). Est\u00e1 construido desde cero usando Corrutinas y Flow, lo que garantiza que las operaciones de disco nunca bloqueen el Hilo Principal (UI Thread).</p>"},{"location":"temas/04/4.0-persistencia.html#por-que-sustituye-a-sharedpreferences","title":"\u00bfPor qu\u00e9 sustituye a SharedPreferences?","text":"<ul> <li>\u2705 As\u00edncrono: Todo funciona con <code>suspend</code> y <code>Flow</code>.</li> <li>\u2705 Seguro: Maneja los errores de I/O por ti.</li> <li>\u2705 Transaccional: Las operaciones son at\u00f3micas (todo o nada).</li> </ul>"},{"location":"temas/04/4.0-persistencia.html#implementacion-preferences-datastore","title":"Implementaci\u00f3n (Preferences DataStore)","text":""},{"location":"temas/04/4.0-persistencia.html#a-dependencias-y-creacion","title":"A. Dependencias y Creaci\u00f3n","text":"<p>A\u00f1ade la librer\u00eda en <code>build.gradle.kts</code> e instancia el DataStore. Lo ideal es tener una sola instancia para toda la app (Singleton o Extensi\u00f3n global).</p> <pre><code>// En tu fichero de dependencias (libs.versions.toml) o build.gradle\n// implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n\n// En un fichero Kotlin (ej: DataStoreModule.kt)\nval Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = \"settings\")\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#b-guardar-datos-escritura","title":"B. Guardar datos (Escritura)","text":"<p>Usamos <code>edit</code> dentro de una corrutina. </p><pre><code>suspend fun guardarToken(context: Context, token: String) {\n    val TOKEN_KEY = stringPreferencesKey(\"auth_token\")\n\n    context.dataStore.edit { preferences -&gt;\n        preferences[TOKEN_KEY] = token\n    }\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#c-leer-datos-lectura","title":"C. Leer datos (Lectura)","text":"<p>DataStore expone los datos como un <code>Flow</code>. Esto significa que si el dato cambia, la UI se actualiza autom\u00e1ticamente. </p><pre><code>val TOKEN_KEY = stringPreferencesKey(\"auth_token\")\n\nval tokenFlow: Flow&lt;String?&gt; = context.dataStore.data\n    .map { preferences -&gt;\n        preferences[TOKEN_KEY] // Devuelve null si no existe\n    }\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#2-room-base-de-datos-robusta","title":"2. \ud83c\udfdb\ufe0f Room (Base de Datos Robusta)","text":"<p>Room es una librer\u00eda que nos facilita enormemente el uso de bases de datos SQLite en Android. En lugar de escribir SQL crudo y manejar cursores manualmente (propenso a errores), Room nos permite usar Objetos Kotlin.</p> <p>Room verifica tus consultas SQL en tiempo de compilaci\u00f3n. Si escribes mal el nombre de una tabla, la app no compilar\u00e1 (\u00a1lo cual es genial!).</p> <p>Consta de 3 componentes principales:</p>"},{"location":"temas/04/4.0-persistencia.html#a-la-entidad-entity","title":"A. La Entidad (<code>@Entity</code>)","text":"<p>Representa una tabla en la base de datos. </p><pre><code>@Entity(tableName = \"usuarios\")\ndata class Usuario(\n    @PrimaryKey(autoGenerate = true) val id: Int = 0,\n    @ColumnInfo(name = \"nombre_completo\") val nombre: String,\n    val edad: Int\n)\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#b-el-dao-data-access-object-dao","title":"B. El DAO (Data Access Object) (<code>@Dao</code>)","text":"<p>Define c\u00f3mo accedemos a los datos. Es una interfaz donde declaramos nuestros m\u00e9todos. Room genera el c\u00f3digo por nosotros. </p><pre><code>@Dao\ninterface UsuarioDao {\n    // Lectura reactiva: Si la tabla cambia, emite una nueva lista autom\u00e1ticamente\n    @Query(\"SELECT * FROM usuarios ORDER BY nombre ASC\")\n    fun getAllUsuarios(): Flow&lt;List&lt;Usuario&gt;&gt;\n\n    // Operaci\u00f3n as\u00edncrona simple\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insert(usuario: Usuario)\n\n    @Delete\n    suspend fun delete(usuario: Usuario)\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#c-la-base-de-datos-database","title":"C. La Base de Datos (<code>@Database</code>)","text":"<p>El punto de entrada principal. Debe ser abstracta y extender <code>RoomDatabase</code>. </p><pre><code>@Database(entities = [Usuario::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun usuarioDao(): UsuarioDao\n}\n</code></pre><p></p>"},{"location":"temas/04/4.0-persistencia.html#3-sharedpreferences-legacy","title":"3. \ud83d\uddc4\ufe0f SharedPreferences (Legacy)","text":"<p>Era la forma antigua de guardar datos simples. Aunque sigue funcionando, Google recomienda migrar a DataStore.</p> <ul> <li>Problema principal: Su m\u00e9todo <code>apply()</code> es as\u00edncrono pero no seguro, y <code>commit()</code> es s\u00edncrono y puede bloquear la UI. Adem\u00e1s, al iniciar la app, carga TODO el fichero en memoria de golpe, lo que puede causar lag.</li> </ul> <pre><code>// Ejemplo r\u00e1pido (OBSOLETO - Solo referencia)\nval sharedPref = activity?.getPreferences(Context.MODE_PRIVATE) ?: return\nwith (sharedPref.edit()) {\n    putInt(\"puntuacion_alta\", 500)\n    apply()\n}\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#4-ficheros-almacenamiento-crudo","title":"4. \ud83d\udcc1 Ficheros (Almacenamiento Crudo)","text":"<p>A veces necesitas guardar un PDF, una imagen editada o un audio. Para esto usamos el sistema de ficheros de Android.</p> <ul> <li>Almacenamiento Interno (<code>filesDir</code>): Privado de tu app. Nadie m\u00e1s puede verlo. Si el usuario desinstala la app, se borra.</li> <li>Almacenamiento Externo / Cach\u00e9: Para datos temporales o p\u00fablicos.</li> </ul> <pre><code>// Escribir un fichero en almacenamiento interno\nfun guardarTexto(context: Context, nombreFichero: String, contenido: String) {\n    context.openFileOutput(nombreFichero, Context.MODE_PRIVATE).use {\n        it.write(contenido.toByteArray())\n    }\n}\n\n// Leer un fichero\nfun leerTexto(context: Context, nombreFichero: String): String {\n    return context.openFileInput(nombreFichero).bufferedReader().useLines { lines -&gt;\n        lines.fold(\"\") { some, text -&gt; \"$some\\n$text\" }\n    }\n}\n</code></pre>"},{"location":"temas/04/4.0-persistencia.html#resumen-cual-uso","title":"Resumen: \u00bfCu\u00e1l uso?","text":"<ol> <li>\u00bfEs un ajuste? (ej: \"Sonido on/off\") -&gt; DataStore.</li> <li>\u00bfSon mis datos principales? (ej: \"Notas\", \"Tareas\") -&gt; Room.</li> <li>\u00bfEs una foto o archivo descargado? -&gt; Ficheros.</li> </ol>"},{"location":"temas/04/4.1-room.html","title":"4.1. Room","text":""},{"location":"temas/04/4.1-room.html#41-room-base-de-datos-sql-en-android","title":"4.1 Room: Base de Datos SQL en Android","text":"<p>Room es una de las librer\u00edas m\u00e1s importantes de Android Jetpack. Act\u00faa como una capa de abstracci\u00f3n sobre SQLite, permiti\u00e9ndote usar toda la potencia de una base de datos relacional pero con una sintaxis fluida en Kotlin y verificaci\u00f3n de errores en tiempo de compilaci\u00f3n.</p> VIDEO: Bases de datos con Room | Persistencia de datos en Android con Kotlin y Jetpack Compose <p></p>"},{"location":"temas/04/4.1-room.html#que-es-room","title":"\u00bfQu\u00e9 es Room?","text":"<p>Room es una biblioteca de persistencia de datos que forma parte de Jetpack, el conjunto de bibliotecas y herramientas recomendadas por Google para el desarrollo de aplicaciones Android. Room proporciona una capa de abstracci\u00f3n sobre SQLite, la base de datos relacional integrada en Android, y facilita el acceso a la base de datos y la gesti\u00f3n de los datos de la aplicaci\u00f3n.</p> <p>Room se compone de tres componentes principales:</p> <ul> <li> <p>Database: Representa la base de datos de la aplicaci\u00f3n y contiene la l\u00f3gica para crear y acceder a las tablas de la base de datos.</p> </li> <li> <p>Entity: Representa una tabla de la base de datos y contiene la definici\u00f3n de las columnas y los tipos de datos de la tabla.</p> </li> <li> <p>DAO (Data Access Object): Define las operaciones de acceso a la base de datos, como la inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos.</p> </li> </ul> <p></p>"},{"location":"temas/04/4.1-room.html#implementacion-de-room-en-jetpack-compose","title":"Implementaci\u00f3n de Room en Jetpack Compose","text":""},{"location":"temas/04/4.1-room.html#1-agregar-las-dependencias-de-room","title":"1. Agregar las dependencias de Room[","text":"<p>Para utilizar Room en una aplicaci\u00f3n Android con Jetpack Compose, primero debemos agregar las dependencias necesarias en el archivo <code>build.gradle.kts</code> del proyecto y del m\u00f3dulo de la aplicaci\u00f3n:</p> <p>build.gradle.kts (Project) </p><pre><code>plugins {\n    // Add this line\n    id(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre><p></p> <p>build.gradle.kts (Module) </p><pre><code>plugins {\n    // Add this line\n    id(\"com.google.devtools.ksp\")\n}\n\ndependencies {\n    //Room (add the following dependencies)\n    implementation(libs.androidx.room.runtime)\n    implementation(libs.androidx.room.ktx)\n    ksp(libs.androidx.room.compiler)\n}\n</code></pre><p></p> <p>KSP es una API simple y potente para analizar las anotaciones de Kotlin.</p> <p>Hay que tener en cuenta que la versi\u00f3n utilizada de KSP debe ser compatible con la versi\u00f3n de Kotlin que se est\u00e9 utilizando en el proyecto, la compatibilidad entre las diferentes versiones puede consultarse en la documentaci\u00f3n.</p> <p>La versi\u00f3n utilizada en el ejemplo es compatible con la versi\u00f3n 2.0.21 de Kotlin.</p>"},{"location":"temas/04/4.1-room.html#2-definir-la-entidad","title":"2. Definir la entidad","text":"<p>La clase <code>Entity</code> representa una tabla de la base de datos y contiene la definici\u00f3n de las columnas y los tipos de datos de la tabla. Para definir una entidad en Room, debemos crear una clase que anote con <code>@Entity</code> y que contenga las propiedades correspondientes a las columnas de la tabla. Por ejemplo, la siguiente clase <code>User</code> representa una entidad de usuario con las columnas <code>id</code>, <code>name</code> y <code>email</code>:</p> <pre><code>@Entity(tableName = \"users\")data class User(    @PrimaryKey val id: Int,    val name: String,    val email: String)\n</code></pre> <p>En este ejemplo, la clase <code>User</code> representa una tabla de la base de datos con las columnas <code>id</code>, <code>name</code> y <code>email</code>. La propiedad <code>id</code> se anota con <code>@PrimaryKey</code> para indicar que es la clave primaria de la tabla.</p> <p></p> <p>Anotaciones de Room</p> <p>Room proporciona varias anotaciones que se pueden utilizar para personalizar la definici\u00f3n de la entidad, como <code>@Entity</code>, <code>@PrimaryKey</code>, <code>@ColumnInfo</code>, <code>@Ignore</code>, <code>@ForeignKey</code>, entre otras.</p> <p>Las anotaciones tienen los siguientes significados:</p> <ul> <li><code>@Entity</code>: Indica que la clase es una entidad de la base de datos.</li> <li><code>@PrimaryKey</code>: Indica que la propiedad es la clave primaria de la tabla.</li> <li><code>@ColumnInfo</code>: Permite personalizar el nombre de la columna en la tabla.</li> <li><code>@Ignore</code>: Indica que la propiedad no se debe incluir en la tabla.</li> <li><code>@ForeignKey</code>: Permite definir una clave for\u00e1nea en la tabla.</li> </ul> <p>Ejemplo de ForeignKey</p> <pre><code>@Entity(tableName = \"users\")\ndata class User(\n    @PrimaryKey val id: Int,\n    val name: String,\n    val email: String,\n    @ForeignKey(entity = Company::class, parentColumns = [\"id\"], childColumns = [\"company_id\"])\n    val companyId: Int\n)\n</code></pre> <p>En este ejemplo, la propiedad <code>companyId</code> se anota con <code>@ForeignKey</code> para indicar que es una clave for\u00e1nea que hace referencia a la tabla <code>Company</code> y a la columna <code>id</code>.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Entity Es recomendable tener las clases Entity en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#3-definir-el-dao","title":"3. Definir el DAO","text":"<p>La interfaz <code>DAO</code> (Data Access Object) define las operaciones de acceso a la base de datos, como la inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos.</p> <p>El Data Access Object (DAO) es un patr\u00f3n de dise\u00f1o que permite separar la l\u00f3gica de acceso a los datos de la l\u00f3gica de negocio de una aplicaci\u00f3n.</p> <p>La funci\u00f3n del DAO es ocultar todas las complejidades relacionadas con las operaciones de acceso a los datos, como la conexi\u00f3n a la base de datos, la creaci\u00f3n de consultas SQL y la gesti\u00f3n de transacciones.</p> <p>Esto nos permite intercambiar f\u00e1cilmente la fuente de datos subyacente sin tener que modificar la l\u00f3gica de negocio de la aplicaci\u00f3n.</p> <p></p> <p>Para definir un DAO en Room, debemos crear una interfaz que anote con <code>@Dao</code> y que contenga las operaciones de acceso a la base de datos.</p> <p>Por ejemplo, la siguiente interfaz <code>UserDao</code> define las operaciones de acceso a la tabla de usuarios:</p> <pre><code>@Dao\ninterface UserDao {\n    @Query(\"SELECT * FROM users\")\n    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;\n\n    @Insert\n    suspend fun insertUser(user: User)\n\n    @Update\n    suspend fun updateUser(user: User)\n\n    @Delete\n    suspend fun deleteUser(user: User)\n}\n</code></pre> <p>En este ejemplo, la interfaz <code>UserDao</code> define las operaciones <code>getUsers()</code>, <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> para acceder a la tabla de usuarios.</p> <p>Como se puede obversar, antes de cada funci\u00f3n se anota con la operaci\u00f3n que se va a realizar, ya sea <code>@Query</code>, <code>@Insert</code>, <code>@Update</code> o <code>@Delete</code>.</p> <p>Estas operaciones definen las consultas SQL que se ejecutar\u00e1n en la base de datos para realizar las operaciones correspondientes:</p> <ul> <li><code>@Query</code>: Permite definir una consulta SQL personalizada para recuperar datos de la base de datos.</li> <li><code>@Insert</code>: Permite definir una operaci\u00f3n de inserci\u00f3n de datos en la base de datos.</li> <li><code>@Update</code>: Permite definir una operaci\u00f3n de actualizaci\u00f3n de datos en la base de datos.</li> <li><code>@Delete</code>: Permite definir una operaci\u00f3n de eliminaci\u00f3n de datos en la base de datos.</li> </ul> <p>\ud83d\udca1Ubicaci\u00f3n del archivo DAO Es recomendable tener las interfaces DAO en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo puede estar en el mismo paquete que la base de datos o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#4-definir-la-base-de-datos","title":"4. Definir la base de datos","text":"<p>La clase <code>Database</code> representa la base de datos de la aplicaci\u00f3n y contiene la l\u00f3gica para crear y acceder a las tablas de la base de datos.</p> <p>Para definir una base de datos en Room, debemos crear una clase que extienda de <code>RoomDatabase</code> y que contenga las definiciones de las entidades y los DAOs de la base de datos.</p> <p>Por ejemplo, la siguiente clase <code>AppDatabase</code> define una base de datos con la tabla de usuarios y el DAO correspondiente:</p> <pre><code>@Database(entities = [User::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n}\n</code></pre> <p>En este ejemplo, la clase <code>AppDatabase</code> representa una base de datos con la tabla de usuarios y el DAO <code>UserDao</code>.</p> <p>La anotaci\u00f3n <code>@Database</code> se utiliza para indicar que la clase es una base de datos de Room y para especificar las entidades y la versi\u00f3n de la base de datos.</p> <p>La clase <code>AppDatabase</code> debe ser abstracta y extender de <code>RoomDatabase</code>. Tambi\u00e9n debe contener una funci\u00f3n abstracta que devuelva el DAO correspondiente a la tabla de usuarios.</p> <p>Si queremos que no se conserven copias de seguridad del historial de versiones podemos a\u00f1adir <code>exportSchema = false</code> a la anotaci\u00f3n <code>@Database</code>.</p> <p>Adem\u00e1s, es interesante definir un <code>companion object</code> para obtener una instancia de la base de datos de forma segura y eficiente:</p> <pre><code>@Database(entities = [User::class], version = 1, exportSchema = false)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n\n    companion object {\n        @Volatile\n        private var INSTANCE: AppDatabase? = null\n\n        fun getDatabase(context: Context): AppDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    AppDatabase::class.java,\n                    \"app_database\"\n                ).build()\n                .also { INSTANCE = it }\n                instance\n            }\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, el <code>companion object</code> de la clase <code>AppDatabase</code> define una funci\u00f3n <code>getDatabase()</code> que devuelve una instancia de la base de datos de forma segura y eficiente.</p> <p>La funci\u00f3n <code>getDatabase()</code> utiliza una variable <code>INSTANCE</code> para almacenar la instancia de la base de datos y la inicializa si es <code>null</code>.</p> <p>La funci\u00f3n <code>getDatabase()</code> tambi\u00e9n utiliza la funci\u00f3n <code>databaseBuilder()</code> para crear una instancia de la base de datos con el contexto de la aplicaci\u00f3n, la clase de la base de datos y el nombre de la base de datos.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Database Es recomendable tener la clase Database en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el mismo paquete que las clases Entity y DAO o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>\ud83d\udca1Sobre la anotaci\u00f3n @Volatile La anotaci\u00f3n <code>@Volatile</code> se utiliza para indicar que la variable <code>INSTANCE</code> es vol\u00e1til y que su valor puede cambiar en cualquier momento. Esto garantiza que la variable <code>INSTANCE</code> siempre se lea desde la memoria principal y no desde la cach\u00e9 de un subprocesos, lo que evita problemas de concurrencia.</p> <p>En general, las variables vol\u00e1tiles se utilizan para garantizar la coherencia de la memoria en entornos multiproceso o multihilo.</p> <p>En este caso, la variable <code>INSTANCE</code> se utiliza para almacenar la instancia de la base de datos y garantizar que solo se cree una instancia de la base de datos en la aplicaci\u00f3n.</p> <p>Esto se utiliza adem\u00e1s en un bloque <code>synchronized</code> para garantizar que solo se cree una instancia de la base de datos en entornos multiproceso o multihilo.</p>"},{"location":"temas/04/4.1-room.html#5-implementar-un-repositorio","title":"5. Implementar un repositorio","text":"<p>El repositorio es una capa intermedia entre la capa de datos y la capa de presentaci\u00f3n de la aplicaci\u00f3n.</p> <p>El repositorio se encarga de gestionar la obtenci\u00f3n de datos de la base de datos y de proporcionar los datos a la capa de presentaci\u00f3n de la aplicaci\u00f3n.</p> <p>El repositorio tambi\u00e9n puede realizar operaciones de red, almacenamiento en cach\u00e9 y otras operaciones relacionadas con la obtenci\u00f3n y el almacenamiento de datos.</p> <p>Para implementar un repositorio en Room, debemos crear una clase que contenga las operaciones de acceso a la base de datos y que proporcione los datos a la capa de presentaci\u00f3n.</p> <p>Para este ejemplo, crearemos una interfaz <code>UserRepository</code> que defina las operaciones de acceso a la tabla de usuarios, es decir, las operaciones del DAO <code>UserDao</code>:</p> <pre><code>import kotlinx.coroutines.flow.Flowinterface UserRepository {    fun getUsers(): Flow&lt;List&lt;User&gt;&gt;    suspend fun insertUser(user: User)    suspend fun updateUser(user: User)    suspend fun deleteUser(user: User)}\n</code></pre> <p>Debajo de la declaraci\u00f3n de la interfaz <code>UserRepository</code>, creamos una clase <code>UserRepositoryImpl</code> que implementa la interfaz <code>UserRepository</code> y que contiene las operaciones de acceso a la base de datos:</p> <pre><code>class MyApplication : Application() {\n    val appContainer by lazy { AppContainer(this) }\n\n    override fun onCreate() {\n        super.onCreate()\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserRepositoryImpl</code> implementa la interfaz <code>UserRepository</code> y contiene las operaciones <code>getUsers()</code>, <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> que acceden a la tabla de usuarios a trav\u00e9s del DAO <code>UserDao</code>.</p> <p>La clase <code>UserRepositoryImpl</code> recibe una instancia de <code>UserDao</code> como par\u00e1metro en su constructor y utiliza el DAO para realizar las operaciones de acceso a la base de datos.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Repository Es recomendable tener la clase Repository en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete <code>data</code> o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#6-implementar-la-clase-appcontainer","title":"6. Implementar la clase AppContainer","text":"<p>La clase <code>AppContainer</code> es una clase de contenedor que se utiliza para proporcionar instancias de las dependencias de la aplicaci\u00f3n a las clases que las necesitan.</p> <p>La clase <code>AppContainer</code> se utiliza para gestionar la creaci\u00f3n y la inyecci\u00f3n de dependencias en la aplicaci\u00f3n y para garantizar que las dependencias se creen y se proporcionen de forma segura y eficiente.</p> <p>Para implementar la clase <code>AppContainer</code>, debemos crear una clase que contenga las instancias de las dependencias de la aplicaci\u00f3n y que proporcione m\u00e9todos para obtener las instancias de las dependencias.</p> <p>Por ejemplo, la siguiente clase <code>AppContainer</code> define las instancias de la base de datos, el DAO y el repositorio de la aplicaci\u00f3n:</p> <pre><code>class AppContainer(context: Context) {    private val appDatabase = AppDatabase.getDatabase(context)    private val userDao = appDatabase.userDao()    private val userRepository = UserRepositoryImpl(userDao)    fun provideUserRepository(): UserRepository {        return userRepository    }}\n</code></pre> <p>En este ejemplo, la clase <code>AppContainer</code> define las instancias de la base de datos, el DAO y el repositorio de la aplicaci\u00f3n y proporciona un m\u00e9todo <code>provideUserRepository()</code> para obtener la instancia del repositorio.</p> <p>La clase <code>AppContainer</code> recibe el contexto de la aplicaci\u00f3n como par\u00e1metro en su constructor y utiliza el contexto para crear la instancia de la base de datos y el DAO.</p> <p>La clase <code>AppContainer</code> tambi\u00e9n utiliza la instancia del DAO para crear la instancia del repositorio y proporcionarla a las clases que la necesitan.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo AppContainer Es recomendable tener la clase AppContainer en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete <code>data</code> o en un paquete separado, dependiendo de la estructura del proyecto.</p>"},{"location":"temas/04/4.1-room.html#7-inyectar-dependencias-en-la-aplicacion","title":"7. Inyectar dependencias en la aplicaci\u00f3n","text":"<p>Una vez que hemos definido las entidades, los DAOs, la base de datos, el repositorio y la clase <code>AppContainer</code>, podemos inyectar las dependencias en la aplicaci\u00f3n para acceder a los datos de la base de datos.</p> <p>Para inyectar las dependencias en la aplicaci\u00f3n, debemos crear una instancia de la clase <code>AppContainer</code> en la clase de aplicaci\u00f3n de la aplicaci\u00f3n y utilizarla para obtener las instancias de las dependencias.</p> <p>Por ejemplo, la siguiente clase <code>MyApplication</code> define una instancia de la clase <code>AppContainer</code> y la utiliza para obtener la instancia del repositorio de usuarios:</p> <pre><code>class MyApplication : Application() {\n    val appContainer by lazy { AppContainer(this) }\n\n    override fun onCreate() {\n        super.onCreate()\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>MyApplication</code> define una instancia de la clase <code>AppContainer</code> utilizando la funci\u00f3n <code>lazy()</code> para crear la instancia de forma diferida.</p> <p>La clase <code>MyApplication</code> utiliza la instancia de <code>AppContainer</code> para obtener la instancia del repositorio de usuarios a trav\u00e9s del m\u00e9todo <code>provideUserRepository()</code>.</p> <p>La clase <code>MyApplication</code> tambi\u00e9n puede utilizar la instancia de <code>AppContainer</code> para obtener otras instancias de dependencias, como la base de datos y el DAO.</p> <p>\ud83d\udca1Ubicaci\u00f3n del archivo Application Es recomendable tener la clase Application en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete application o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>\u2139\ufe0fSobre la funci\u00f3n lazy() La funci\u00f3n lazy() se utiliza para crear una instancia de una clase de forma diferida, es decir, la instancia se crea solo cuando se accede por primera vez a ella. Esto permite inicializar las dependencias de la aplicaci\u00f3n de forma segura y eficiente, ya que las dependencias se crean solo cuando se necesitan y no antes. En este caso, la funci\u00f3n lazy() se utiliza para crear la instancia de la clase AppContainer de forma diferida y para garantizar que la instancia se cree solo cuando se accede a ella por primera vez. Esto es \u00fatil para evitar la creaci\u00f3n innecesaria de instancias de dependencias en la aplicaci\u00f3n y para mejorar el rendimiento de la aplicaci\u00f3n.</p> <p>Tambi\u00e9n se podr\u00eda crear el contenedor con lateinit:</p> <pre><code>class MyApplication : Application() {\n    private lateinit var appContainer: AppContainer\n\n    override fun onCreate() {\n        super.onCreate()\n        appContainer = AppContainer(this)\n        // Inicializar la base de datos y otras dependencias\n        val userRepository = appContainer.provideUserRepository()\n    }\n}\n</code></pre> <p>En este caso, se inicializa la variable <code>appContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y se utiliza para obtener la instancia del repositorio de usuarios.</p> <p>Esta forma de inicializaci\u00f3n es \u00fatil cuando se necesita inicializar la instancia de la clase <code>AppContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y no antes.</p> <p>\u2139\ufe0f Sobre lateinit La palabra clave <code>lateinit</code> se utiliza para indicar que una variable se inicializar\u00e1 m\u00e1s tarde, es decir, que su valor se asignar\u00e1 en alg\u00fan momento antes de que se acceda a ella por primera vez. Esto permite diferir la inicializaci\u00f3n de la variable y garantizar que se inicialice solo cuando sea necesario. En este caso, la palabra clave <code>lateinit</code> se utiliza para inicializar la variable <code>appContainer</code> en el m\u00e9todo <code>onCreate()</code> de la clase <code>MyApplication</code> y para garantizar que la instancia de la clase <code>AppContainer</code> se cree solo cuando se acceda a ella por primera vez. Esto es \u00fatil para evitar la inicializaci\u00f3n innecesaria de la variable <code>appContainer</code> y para mejorar el rendimiento de la aplicaci\u00f3n.</p>"},{"location":"temas/04/4.1-room.html#8-acceder-a-los-datos-de-la-base-de-datos-desde-un-viewmodel","title":"8. Acceder a los datos de la base de datos desde un ViewModel","text":"<p>Una vez que hemos inyectado las dependencias en la aplicaci\u00f3n, podemos acceder a los datos de la base de datos desde un ViewModel de Jetpack Compose.</p> <p>Para acceder a los datos de la base de datos desde un ViewModel, debemos crear una clase que extienda de <code>ViewModel</code> y que contenga las operaciones de acceso a los datos.</p> <p>Por ejemplo, la siguiente clase <code>UserViewModel</code> define un ViewModel que accede a los datos de la base de datos a trav\u00e9s del repositorio de usuarios:</p> <pre><code>class UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n    val users: Flow&lt;List&lt;User&gt;&gt; = usersRepository.getUsers().asFlow()\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserViewModel</code> define un ViewModel que accede a los datos de la base de datos a trav\u00e9s del repositorio de usuarios y proporciona los datos a la capa de presentaci\u00f3n.</p> <p>La clase <code>UserViewModel</code> recibe una instancia del repositorio de usuarios como par\u00e1metro en su constructor y utiliza el repositorio para obtener los datos de la base de datos.</p> <p>La clase <code>UserViewModel</code> tambi\u00e9n define una propiedad <code>users</code> que contiene los datos de los usuarios como un flujo de datos (<code>Flow</code>) y que se puede observar desde la capa de UI.</p> <p>\ud83d\udca1 Ubicaci\u00f3n del archivo ViewModel Es recomendable tener la clase ViewModel en un archivo separado, para mantener la organizaci\u00f3n del c\u00f3digo. Este archivo suele estar en el paquete ui o en un paquete separado, dependiendo de la estructura del proyecto.</p> <p>Si quisieramos tambi\u00e9n implementar la funcionalidad para insertar, borrar o actualizar un usuario, podr\u00edamos hacerlo de la siguiente manera:</p> <pre><code>class UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n    val users: Flow&lt;List&lt;User&gt;&gt; = usersRepository.getUsers().asFlow()\n\n    fun insertUser(user: User) {\n        viewModelScope.launch {\n            userRepository.insertUser(user)\n        }\n    }\n\n    fun updateUser(user: User) {\n        viewModelScope.launch {\n            userRepository.updateUser(user)\n        }\n    }\n\n    fun deleteUser(user: User) {\n        viewModelScope.launch {\n            userRepository.deleteUser(user)\n        }\n    }\n}\n</code></pre> <p>En este caso, se han a\u00f1adido las funciones <code>insertUser()</code>, <code>updateUser()</code> y <code>deleteUser()</code> al ViewModel para insertar, actualizar y eliminar un usuario en la base de datos.</p> <p>Sobre los datos a guardar, borrar o actualizar en la base de datos</p> <p>Es importante tener en cuenta que las operaciones de inserci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de datos en la base de datos deben realizarse en un hilo de fondo para evitar bloquear el hilo principal de la aplicaci\u00f3n.</p> <p>Adem\u00e1s, estas operaciones deben realizarse dentro de un bloque <code>viewModelScope.launch</code> para garantizar que se realicen de forma segura y eficiente.</p> <p>En general, es recomendable utilizar corutinas para realizar operaciones as\u00edncronas en la base de datos y para garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>Tambi\u00e9n es importante comprobar que los datos introducidos en la base de datos sean v\u00e1lidos y est\u00e9n correctamente formateados antes de realizar las operaciones de inserci\u00f3n, actualizaci\u00f3n o eliminaci\u00f3n.</p> <p>Para ello, se pueden utilizar validaciones y comprobaciones de datos en el ViewModel o en el repositorio antes de realizar las operaciones en la base de datos.</p>"},{"location":"temas/04/4.1-room.html#9-observar-los-datos-en-la-capa-de-ui","title":"9. Observar los datos en la capa de UI","text":"<p>Una vez que hemos definido el ViewModel y hemos accedido a los datos de la base de datos, podemos observar los datos en la capa de UI de Jetpack Compose.</p> <p>Para observar los datos en la capa de UI, debemos utilizar la funci\u00f3n collectAsState() para convertir el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI.</p> <p>Por ejemplo, la siguiente funci\u00f3n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel:</p> <pre><code>@Composable\nfun UserListScreen(userViewModel: UserViewModel) {\n    val users by userViewModel.users.collectAsState(emptyList())\n\n    LazyColumn {\n        items(users) { user -&gt;\n            UserItem(user = user)\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n UserListScreen define una pantalla que muestra la lista de usuarios y que observa los datos del ViewModel a trav\u00e9s de la propiedad users.</p> <p>La propiedad users se convierte en un estado que se puede observar desde la capa de UI utilizando la funci\u00f3n collectAsState().</p> <p>La funci\u00f3n collectAsState() convierte el flujo de datos (Flow) en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambian los datos.</p> <p>Esto permite mostrar los datos de la base de datos en la pantalla y actualizar la pantalla autom\u00e1ticamente cuando cambian los datos.</p> <p>Si quisieramos crear un peque\u00f1o formulario para insertar un usuario, podr\u00edamos hacerlo de la siguiente manera:</p> <pre><code>@Composable\nfun AddUserScreen(userViewModel: UserViewModel) {\n    var name by remember { mutableStateOf(\"\") }\n    var email by remember { mutableStateOf(\"\") }\n\n    Column {\n        TextField(\n            value = name,\n            onValueChange = { name = it },\n            label = { Text(\"Name\") }\n        )\n        TextField(\n            value = email,\n            onValueChange = { email = it },\n            label = { Text(\"Email\") }\n        )\n        Button(onClick = { \n            userViewModel.insertUser(User(name = name, email = email))\n        }) {\n            Text(\"Add User\")\n        }\n    }\n}\n</code></pre> <p>En este caso, se han definido dos variables name y email para almacenar el nombre y el email del usuario introducidos en el formulario.</p> <p>Sobre las variables en la UI</p> <p>Aclarar que en este ejemplo, por hacerlo m\u00e1s ameno, no se han inclu\u00eddo las variables <code>name</code> y <code>email</code> en un ViewModel, lo cual ser\u00eda lo recomendable para mantener la l\u00f3gica de la aplicaci\u00f3n separada de la capa de UI.</p> <p>En general, es recomendable utilizar un ViewModel para gestionar la l\u00f3gica de la aplicaci\u00f3n y para mantener la capa de UI lo m\u00e1s simple y desacoplada posible.</p> <p>La funci\u00f3n <code>TextField</code> se utiliza para mostrar los campos de texto para introducir el nombre y el email del usuario y para actualizar las variables <code>name</code> y <code>email</code> cuando se introducen los datos.</p> <p>La funci\u00f3n <code>Button</code> se utiliza para mostrar un bot\u00f3n que permite insertar un usuario en la base de datos cuando se hace clic en \u00e9l.</p> <p>Tambi\u00e9n podr\u00edamos a\u00f1adir a la lista de usuarios un bot\u00f3n para eliminar un usuario:</p> <pre><code>@Composable\nfun UserItem(user: User, onDeleteUser: (User) -&gt; Unit) {\n    Row {\n        Text(text = user.name)\n        Text(text = user.email)\n        Button(onClick = { onDeleteUser(user) }) {\n            Text(\"Delete\")\n        }\n    }\n}\n</code></pre> <p>En este caso, se ha a\u00f1adido un bot\u00f3n a la lista de usuarios que permite eliminar un usuario de la base de datos cuando se hace clic en \u00e9l.</p> <p>La funci\u00f3n <code>UserItem</code> recibe un par\u00e1metro <code>onDeleteUser</code> que es una funci\u00f3n de tipo <code>(User) -&gt; Unit</code> que se llama cuando se hace clic en el bot\u00f3n de eliminar.</p> <p>La funci\u00f3n <code>onDeleteUser</code> se utiliza para eliminar un usuario de la base de datos a trav\u00e9s del ViewModel.</p> <p>Sobre la eliminaci\u00f3n de un usuario</p> <p>Es importante tener en cuenta que la eliminaci\u00f3n de un usuario de la base de datos debe realizarse de forma segura y eficiente para evitar problemas de integridad de los datos.</p> <p>Antes de eliminar un usuario de la base de datos, es recomendable comprobar que el usuario existe y que los datos son v\u00e1lidos y est\u00e1n correctamente formateados.</p> <p>Tambi\u00e9n es importante tener en cuenta que la eliminaci\u00f3n de un usuario de la base de datos puede afectar a otras tablas relacionadas, por lo que es importante gestionar las relaciones entre las tablas de forma adecuada.</p> <p>En general, es recomendable utilizar corutinas para realizar operaciones as\u00edncronas en la base de datos y para garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>La lambda que le pasar\u00edamos a la funci\u00f3n UserItem ser\u00eda la siguiente:</p> <pre><code>@Composable\nfun UserListScreen(userViewModel: UserViewModel) {\n    val users by userViewModel.users.collectAsState(emptyList())\n\n    LazyColumn {\n        items(users) { user -&gt;\n            UserItem(user = user) {\n                userViewModel.deleteUser(it)\n            }\n        }\n    }\n}\n</code></pre> <p>En este caso, se ha pasado una lambda a la funci\u00f3n UserItem que llama a la funci\u00f3n deleteUser() del ViewModel cuando se hace clic en el bot\u00f3n de eliminar.</p> <p>La lambda recibe un par\u00e1metro it que es el usuario que se va a eliminar de la base de datos.</p>"},{"location":"temas/04/4.1-room.html#consultar-el-contenido-de-las-bases-de-datos-con-el-inspector-en-android-studio","title":"Consultar el contenido de las bases de datos con el inspector en Android Studio","text":"<p>Para consultar el contenido de las bases de datos de Room en Android Studio, podemos utilizar el inspector de bases de datos integrado en Android Studio.</p> <p>El inspector de bases de datos permite ver y modificar los datos de las tablas de la base de datos, ejecutar consultas SQL personalizadas y realizar otras operaciones relacionadas con la base de datos.</p> <p>Para abrir el inspector de bases de datos en Android Studio, debemos seguir los siguientes pasos:</p> <ol> <li>Abrir el panel de herramientas de Android Studio.</li> <li>Seleccionar la pesta\u00f1a <code>Device File Explorer</code>.</li> <li>Navegar a la carpeta <code>/data/data/&lt;nombre del paquete de la aplicaci\u00f3n&gt;/databases/</code>.</li> <li>Hacer clic con el bot\u00f3n derecho en el archivo de la base de datos y seleccionar <code>Database Inspector</code>.</li> </ol>"},{"location":"temas/04/4.1-room.html#guardado-de-preferencias-con-datastore","title":"Guardado de preferencias con DataStore","text":"<p>DataStore es una biblioteca de Jetpack que proporciona una forma sencilla y eficiente de almacenar y recuperar datos de preferencias en una aplicaci\u00f3n Android.</p> <p>DataStore reemplaza a SharedPreferences como la forma recomendada de almacenar y recuperar datos de preferencias en una aplicaci\u00f3n Android y proporciona una API reactiva y segura para trabajar con datos de preferencias.</p> <p>A diferencia de los datos guardados con Room, que tienden a ser m\u00e1s complejos y pesados, DataStore es m\u00e1s ligero y est\u00e1 pensado para guardar datos de preferencias de forma sencilla y eficiente.</p> <p>Es decir, utilizaremos las preferencias para guardar datos simples como configuraciones de la aplicaci\u00f3n, preferencias del usuario, etc.</p> <p>DataStore tiene dos implmenetaciones:</p> <ul> <li>Preferences DataStore: Almacena y recupera datos de preferencias clave-valor de forma as\u00edncrona y reactiva.<ul> <li>Los datos almacenados con preferencias solo pueden ser de tipo primitivo o String.</li> <li>No se pueden almacenar ocnjuntos de datos complejos.</li> <li>No se requiere un esquema predeterminado.</li> </ul> </li> <li>Proto DataStore: Almacena y recupera datos de preferencias en formato de mensajes protobuf de forma as\u00edncrona y reactiva.<ul> <li>Permite almacenar y recuperar datos de preferencias m\u00e1s complejos.</li> <li>Requiere un esquema definido.</li> </ul> </li> </ul> <p>Para utilizar DataStore en una aplicaci\u00f3n Android, debemos agregar las dependencias necesarias en el archivo <code>build.gradle.kts</code> del m\u00f3dulo de la aplicaci\u00f3n:</p> <pre><code>dependencies {\n    // DataStore\n    implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n}\n</code></pre> <p>Para implementar las preferencias empezaremos creando una nueva clase en el paquete <code>data</code> llamada <code>UserPreferencesRepository</code>.</p> <p>En esta clase definiremos una propiedad privada para representar una instancia de DataStore de tipo Preferences.</p> <p>Este objeto almacenar\u00e1 pares clave-valor. Para ello, debemos definir una clave, crearemos un objeto companion y usaremos las funciones <code>stringPreferencesKey()</code> e <code>intPreferencesKey()</code> para definir las claves de las preferencias.</p> <p>Tamnbi\u00e9n crearemos una funci\u00f3n una funci\u00f3n <code>writeUserPreferences()</code> para escribir las preferencias del usuario y dos flujos de datos para observar los cambios en las preferencias del usuario.</p> <pre><code>class UserPreferencesRepository(\n    private val dataStore: DataStore&lt;Preferences&gt;\n) {\n    private companion object {\n        val USER_NAME_KEY = stringPreferencesKey(\"user_name\")\n        val USER_AGE_KEY = intPreferencesKey(\"user_age\")\n    }\n\n    val userNameFlow: Flow&lt;String&gt; = dataStore.data.map { preferences -&gt;\n        preferences[USER_NAME_KEY] ?: \"\"\n    }\n\n    val userAgeFlow: Flow&lt;Int&gt; = dataStore.data.map { preferences -&gt;\n        preferences[USER_AGE_KEY] ?: 0\n    }\n\n    suspend fun writeUserPreferences(userName: String, userAge: Int) {\n        dataStore.edit { preferences -&gt;\n            preferences[USER_NAME_KEY] = userName\n            preferences[USER_AGE_KEY] = userAge\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la clase <code>UserPreferencesRepository</code> define una propiedad <code>dataStore</code> que representa una instancia de DataStore de tipo Preferences y que se utiliza para almacenar y recuperar los datos de preferencias del usuario.</p> <p>Al utilizar archivos de preferencias estamos interactuando con el sistema de archivos, y esto puede darnos alg\u00fan que otro problema.</p> <p>Para lidiar con los posibles problemas es recomendable capturar las posibles excepciones que puedan surgir al interactuar con el sistema de archivos.</p> <p>Podemos usar el operador catch para capturar las excepciones y manejarlas de forma adecuada.</p> <pre><code>val userNameFlow: Flow&lt;String&gt; = dataStore.data\n    .catch { exception -&gt;\n        if (exception is IOException) {\n            emit(emptyPreferences())\n        } else {\n            throw exception\n        }\n    }\n    .map { preferences -&gt;\n        preferences[USER_NAME_KEY] ?: \"\"\n    }\n</code></pre> <p>En este ejemplo, se ha a\u00f1adido un bloque <code>catch</code> al flujo de datos <code>userNameFlow</code> para capturar las excepciones de tipo <code>IOException</code> que puedan surgir al interactuar con el sistema de archivos.</p> <p>Si se produce una excepci\u00f3n de tipo <code>IOException</code>, se emite un valor predeterminado (<code>emptyPreferences()</code>) en el flujo de datos para evitar que la aplicaci\u00f3n se bloquee o se cierre.</p> <p>Esto permite manejar las excepciones de forma adecuada y garantizar que la aplicaci\u00f3n sea reactiva y eficiente.</p> <p>Para utilizar el <code>UserPreferencesRepository</code> en la aplicaci\u00f3n, debemos crear una instancia de la clase en la clase de aplicaci\u00f3n y utilizarla para acceder a los datos de preferencias del usuario.</p> <pre><code>private const val USER_PREFERENCES_NAME = \"user_preferences\"\nprivate val Context.dataStore: DataStore&lt;Preferences&gt; by preferencesDataStore(name = USER_PREFERENCES_NAME)\n\nclass MyApplication : Application() {\n    lateinit var userPreferencesRepository: UserPreferencesRepository\n\n    override fun onCreate() {\n        super.onCreate()\n        userPreferencesRepository = UserPreferencesRepository(dataStore)\n    }\n}\n</code></pre> <p>Actualizar archivo AndroidManifest.xml</p> <p>Para poder utilizar la clase <code>MyApplication</code> como clase de aplicaci\u00f3n, debemos actualizar el archivo <code>AndroidManifest.xml</code> y a\u00f1adir la propiedad <code>android:name</code> al elemento <code>&lt;application&gt;</code> para indicar la clase de aplicaci\u00f3n.</p> <pre><code>&lt;application\n    android:name=\".MyApplication\"\n    android:icon=\"@mipmap/ic_launcher\"\n    android:label=\"@string/app_name\"\n    android:theme=\"@style/AppTheme\"&gt;\n    ...\n&lt;/application&gt;\n</code></pre> <p>Una vez hecho esto ya podemos proporcionar el <code>UserPreferencesRepository</code> a las clases que lo necesiten, como por ejemplo un ViewModel.</p> <p>Haremos que este repositorio sea una propiedad del constructor del ViewModel y crearemos una funci\u00f3n para escribir las preferencias del usuario.</p> <p>Adem\u00e1s, tambi\u00e9n crearemos un companion object para obtener una instancia de la clase de forma segura y eficiente.</p> <pre><code>class UserViewModel(\n    private val userPreferencesRepository: UserPreferencesRepository\n) : ViewModel() {\n    val userNameFlow: Flow&lt;String&gt; = userPreferencesRepository.userNameFlow\n    val userAgeFlow: Flow&lt;Int&gt; = userPreferencesRepository.userAgeFlow\n\n    fun writeUserPreferences(userName: String, userAge: Int) {\n        viewModelScope.launch {\n            userPreferencesRepository.writeUserPreferences(userName, userAge)\n        }\n    }\n\n    companion object {\n        val Factory: ViewModelProvider.Factory = viewModelFactory {\n            initializer  {\n                val application = (this[APLICATION_KEY] as MyApplication)\n                UserViewModel(application.userPreferencesRepository)\n            }\n        }\n    }\n}\n</code></pre> <p>Para leer la preferencia podemos crear un uiState en el ViewModel para reflejar el flujo de datos de la preferencia.</p> <pre><code>val uiState: StateFlow&lt;UiState&gt; = \n    userPreferencesRepository.userName.map {\n        UiState(userName = it)\n    }.stateIn(\n        scope = viewModelScope,\n        started = SharingStarted.WhileSubscribed(5_000),\n        initialValue = UiState()\n    )\n</code></pre> <p>Sobre funci\u00f3n StateIn</p> <p>La funci\u00f3n <code>stateIn()</code> se utiliza para convertir un flujo de datos en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambian los datos.</p> <p>La funci\u00f3n <code>stateIn()</code> toma varios par\u00e1metros, como el \u00e1mbito de la corutina, el tiempo de inicio, el valor inicial y otros par\u00e1metros, para configurar el estado y garantizar que se actualice de forma segura y eficiente.</p> <p>En este caso, la funci\u00f3n <code>stateIn()</code> se utiliza para convertir el flujo de datos <code>userName</code> en un estado que se puede observar desde la capa de UI y que se actualiza autom\u00e1ticamente cuando cambia el nombre de usuario.</p> <p>Esto permite mostrar el nombre de usuario en la pantalla y actualizar la pantalla autom\u00e1ticamente cuando cambia el nombre de usuario.</p> <p>Los par\u00e1metros sirven para lo siguiente:</p> <ul> <li><code>scope</code>: El \u00e1mbito de la corutina en el que se ejecutar\u00e1 el estado.</li> <li><code>started</code>: El tiempo de inicio del estado.</li> <li><code>initialValue</code>: El valor inicial del estado.</li> </ul>"},{"location":"temas/04/4.2-conexion-internet.html","title":"4.2. Conexi\u00f3n a Internet","text":""},{"location":"temas/04/4.2-conexion-internet.html#42-conexion-a-internet","title":"4.2 Conexi\u00f3n a internet","text":"Corrutinas en Android <p>Las corutinas en Android son una forma de escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y concisa. Las corutinas te permiten ejecutar tareas en segundo plano de forma eficiente y reactiva, sin bloquear el hilo principal de la aplicaci\u00f3n. Las corutinas en Android se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona, como una petici\u00f3n HTTP o una consulta a la base de datos.</p> <p>Las corutinas en Android se utilizan principalmente para realizar operaciones as\u00edncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Las corutinas te permiten escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas en Android se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona.</p> <p>Para implementar una clase que se ejecute en segundo plano debe crearse una suspend function, que es una funci\u00f3n que puede pausar su ejecuci\u00f3n. Para ello, se utiliza la palabra clave <code>suspend</code> antes de la declaraci\u00f3n de la funci\u00f3n.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un objeto que comienza un conteo en segundo plano y lo actualiza cada segundo:</p> <pre><code>object Timer {\n    suspend fun start(callback: (Int) -&gt; Unit) {\n        var count = 0\n        while (true) {\n            delay(1000)\n            count++\n            callback(count)\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n <code>start</code> es una suspend function que inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.</p> <p>La funci\u00f3n <code>delay</code> se utiliza para pausar la ejecuci\u00f3n de la tarea durante un segundo.</p> <p>Para llamar a una suspend function desde una funci\u00f3n principal, se utiliza la funci\u00f3n <code>runBlocking</code>, que crea un bloque de c\u00f3digo que ejecuta la tarea de forma s\u00edncrona. Por ejemplo, el siguiente c\u00f3digo muestra c\u00f3mo llamar a la funci\u00f3n <code>start</code> desde una funci\u00f3n principal:</p> <pre><code>fun main() {\n    runBlocking {\n        Timer.start { count -&gt;\n            println(\"Count: $count\")\n        }\n    }\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n <code>main</code> llama a la funci\u00f3n <code>start</code> de forma s\u00edncrona utilizando <code>runBlocking</code>. La funci\u00f3n <code>start</code> inicia un conteo en segundo plano y llama a un callback cada segundo con el valor actual del contador.</p> <p>Las corutinas en Android te permiten escribir c\u00f3digo as\u00edncrono de forma m\u00e1s sencilla y reactiva, sin tener que utilizar callbacks o interfaces de usuario complejas. Las corutinas se basan en el concepto de suspensi\u00f3n, que te permite pausar la ejecuci\u00f3n de una tarea hasta que se complete una operaci\u00f3n as\u00edncrona.</p> <p></p> <p>\ud83d\udca1 La palabra clave suspend La palabra clave suspend en kotlin se utiliza para marcar una funci\u00f3n que puede pausar su ejecuci\u00f3n y reanudarla m\u00e1s tarde. Las funciones suspendidas se utilizan en las corutinas para realizar operaciones as\u00edncronas de forma reactiva y eficiente.</p>"},{"location":"temas/04/4.2-conexion-internet.html#launchedeffect-para-ejecutar-tareas-en-segundo-plano-en-jetpack-compose","title":"LaunchedEffect para ejecutar tareas en segundo plano en Jetpack Compose","text":"<p>LaunchedEffect es una funci\u00f3n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu\u00eda de composici\u00f3n.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que muestra un contador que se actualiza cada segundo:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        while (true) {\n            delay(1000)\n            count++\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> muestra un contador que se actualiza cada segundo. La funci\u00f3n <code>LaunchedEffect</code> se utiliza para iniciar un bucle infinito que actualiza el contador cada segundo. La funci\u00f3n <code>delay</code> se utiliza para pausar la ejecuci\u00f3n del bucle durante un segundo.</p>"},{"location":"temas/04/4.2-conexion-internet.html#alcance-de-las-corutinas-en-jetpack-compose","title":"Alcance de las corutinas en Jetpack Compose","text":"<p>En Jetpack Compose, las corutinas se ejecutan en el alcance de un composable, lo que significa que una corutina se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. Esto garantiza que las corutinas se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina cuando se coloca en la jerarqu\u00eda de composici\u00f3n y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        while (true) {\n            delay(1000)\n            count++\n        }\n    }\n\n    DisposableEffect(Unit) {\n        onDispose {\n            // Cancela la corutina cuando el composable se elimina\n            coroutineContext.cancel()\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina cuando se coloca en la jerarqu\u00eda de composici\u00f3n utilizando <code>LaunchedEffect</code> y la cancela cuando se elimina utilizando <code>DisposableEffect</code>. La funci\u00f3n <code>onDispose</code> se utiliza para realizar tareas de limpieza cuando el composable se elimina, como cancelar la corutina.</p>"},{"location":"temas/04/4.2-conexion-internet.html#coroutinescope-en-jetpack-compose","title":"CoroutineScope en Jetpack Compose","text":"<p>En Jetpack Compose, puedes utilizar <code>coroutineScope</code> para crear un alcance de corutina que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. <code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina utilizando <code>coroutineScope</code> y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    coroutineScope {\n        launch {\n            while (true) {\n                delay(1000)\n                count++\n            }\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina utilizando <code>coroutineScope</code> y la cancela autom\u00e1ticamente cuando el composable se elimina. La funci\u00f3n <code>launch</code> se utiliza para iniciar una corutina en el alcance de <code>coroutineScope</code> que actualiza el contador cada segundo.</p> <p><code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina. <code>coroutineScope</code> es \u00fatil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.</p>"},{"location":"temas/04/4.2-conexion-internet.html#coroutinescope-en-un-launchedeffect","title":"CoroutineScope en un LaunchedEffect","text":"<p>En Jetpack Compose, puedes utilizar <code>coroutineScope</code> en un <code>LaunchedEffect</code> para crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. <code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina.</p> <p>Por ejemplo, el siguiente c\u00f3digo muestra un composable que inicia una corutina utilizando <code>coroutineScope</code> en un <code>LaunchedEffect</code> y la cancela cuando se elimina:</p> <pre><code>@Composable\nfun Timer() {\n    var count by remember { mutableStateOf(0) }\n\n    LaunchedEffect(Unit) {\n        coroutineScope {\n            launch {\n                while (true) {\n                    delay(1000)\n                    count++\n                }\n            }\n        }\n    }\n\n    Text(text = \"Count: $count\")\n}\n</code></pre> <p>En este ejemplo, el composable <code>Timer</code> inicia una corutina utilizando <code>coroutineScope</code> en un <code>LaunchedEffect</code> y la cancela autom\u00e1ticamente cuando el composable se elimina. La funci\u00f3n <code>launch</code> se utiliza para iniciar una corutina en el alcance de <code>coroutineScope</code> que actualiza el contador cada segundo.</p> <p><code>coroutineScope</code> es una funci\u00f3n de Jetpack Compose que te permite crear un alcance de corutina local que se cancela autom\u00e1ticamente cuando el composable se elimina. <code>coroutineScope</code> es \u00fatil para iniciar corutinas en un composable y garantizar que se cancelen de forma segura y eficiente cuando ya no son necesarias.</p> <p>Un ejemplo de uso podemos encontrarlo en el siguiente Codelab en el que se implemmenta una carrera ficticia entre dos jugadores:</p> <p>Codelab: Carrera de coches ficticia</p> <p>\u2139\ufe0f CoroutineContext El contexto de la corrutina es un objeto que proporciona informaci\u00f3n sobre la corutina, como su alcance, su trabajo y su estado. El contexto de la corutina se utiliza para gestionar la ejecuci\u00f3n de la corutina y proporcionar informaci\u00f3n sobre su estado y progreso.</p> <p>\ud83d\udca1LaunchedEffect LaunchedEffect es una funci\u00f3n de Jetpack Compose que te permite ejecutar una tarea en segundo plano cuando un composable se coloca en la jerarqu\u00eda de composici\u00f3n. LaunchedEffect es \u00fatil para realizar operaciones as\u00edncronas, como peticiones HTTP, consultas a la base de datos y operaciones de E/S. Una de las principales ventajas del uso de LaunchedEffect es que se ejecuta en el alcance de un composable, lo que significa que se cancela autom\u00e1ticamente cuando el composable se elimina de la jerarqu\u00eda de composici\u00f3n. Esto garantiza que las tareas en segundo plano se cancelen de forma segura y eficiente cuando ya no son necesarias, evitando posibles fugas de memoria y problemas de rendimiento. Esto hace que no sea necesario preocuparse por la cancelaci\u00f3n manual de las tareas en segundo plano, ya que Jetpack Compose se encarga de ello de forma autom\u00e1tica. Tampoco debemos preocuparnos de proporcionar un componente Dispatcher de forma expl\u00edcita, ya que LaunchedEffect utiliza el Dispatcher predeterminado de la corrutina para ejecutar la tarea en segundo plano.</p>"},{"location":"temas/04/4.2-conexion-internet.html#formas-de-conectarse-a-internet-desde-una-app","title":"Formas de conectarse a internet desde una app","text":"<p>Para conectarse a internet en una aplicaci\u00f3n Android con Jetpack Compose, puedes utilizar las siguientes opciones (existen m\u00e1s opciones, pero estas son las m\u00e1s comunes):</p> <ul> <li> <p>Retrofit: Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi\u00f3n a servicios web RESTful. Puedes utilizar Retrofit para realizar peticiones HTTP a un servidor y obtener los datos necesarios para tu aplicaci\u00f3n.</p> </li> <li> <p>Ktor: Ktor es un framework de cliente y servidor web en Kotlin que te permite crear aplicaciones web</p> </li> <li> <p>Volley: Volley es una biblioteca de red que facilita la conexi\u00f3n a servicios web en Android. Puedes utilizar Volley para realizar peticiones HTTP y gestionar las respuestas de forma sencilla.</p> </li> </ul> <p>Vamos a centrarnos en la primera opci\u00f3n, Retrofit, que es una de las bibliotecas m\u00e1s utilizadas para conectarse a servicios web en Android.</p> <p></p>"},{"location":"temas/04/4.2-conexion-internet.html#que-es-retrofit","title":"\u00bfQu\u00e9 es Retrofit?","text":"<p>Retrofit es una biblioteca de cliente HTTP para Android y Java que facilita la conexi\u00f3n a servicios web RESTful. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio, como las peticiones GET, POST, PUT y DELETE. Retrofit se encarga de convertir las respuestas del servidor en objetos Java/Kotlin y de gestionar la comunicaci\u00f3n con el servidor de forma eficiente.</p> <p>Tipos de peticiones habituales HTTP</p> <ul> <li>GET: Se utiliza para obtener datos del servidor. Por ejemplo, puedes utilizar una petici\u00f3n GET para obtener una lista de usuarios de un servidor.</li> <li>POST: Se utiliza para enviar datos al servidor. Por ejemplo, puedes utilizar una petici\u00f3n POST para enviar un formulario con los datos de un nuevo usuario al servidor.</li> <li>PUT: Se utiliza para actualizar datos en el servidor. Por ejemplo, puedes utilizar una petici\u00f3n PUT para actualizar los datos de un usuario existente en el servidor.</li> <li>DELETE: Se utiliza para eliminar datos del servidor. Por ejemplo, puedes utilizar una petici\u00f3n DELETE para eliminar un usuario del servidor.</li> </ul> <p> </p>"},{"location":"temas/04/4.2-conexion-internet.html#implementacion-de-retrofit-en-jetpack-compose","title":"Implementaci\u00f3n de Retrofit en Jetpack Compose","text":"<p>Para implementar Retrofit en una aplicaci\u00f3n Android con Jetpack Compose, puedes seguir los siguientes pasos:</p> <ol> <li> <p>Definir la interfaz de servicio web: Define una interfaz que contenga las operaciones disponibles en el servicio web y an\u00f3tala con las anotaciones de Retrofit, como <code>@GET</code>, <code>@POST</code>, <code>@PUT</code> y <code>@DELETE</code>. Por ejemplo, puedes definir una interfaz <code>ApiService</code> que contenga m\u00e9todos para obtener y enviar datos al servidor.</p> </li> <li> <p>Crear una instancia de Retrofit: Crea una instancia de Retrofit utilizando el constructor de <code>Retrofit.Builder</code> y configura la URL base del servicio web y el convertidor de JSON. Por ejemplo, puedes crear una instancia de Retrofit que se conecte a un servidor en <code>https://api.example.com</code> y utilice el convertidor de JSON de Gson.</p> </li> <li> <p>Crear una instancia del servicio web: Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit. Por ejemplo, puedes crear una instancia del servicio web a partir de la interfaz <code>ApiService</code> y la instancia de Retrofit.</p> </li> <li> <p>Realizar peticiones HTTP: Utiliza la instancia del servicio web para realizar peticiones HTTP al servidor y obtener los datos necesarios para tu aplicaci\u00f3n. Por ejemplo, puedes utilizar el m\u00e9todo <code>getUsers()</code> de la interfaz <code>ApiService</code> para obtener una lista de usuarios del servidor.</p> </li> </ol> <p> </p>"},{"location":"temas/04/4.2-conexion-internet.html#ejemplo-sencillo-de-implementacion","title":"Ejemplo sencillo de implementaci\u00f3n","text":"<p>A continuaci\u00f3n, se muestra un ejemplo de implementaci\u00f3n de Retrofit en una aplicaci\u00f3n Android con Jetpack Compose:</p> <pre><code>// Define la interfaz de servicio web con las operaciones disponibles\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List&lt;User&gt;\n}\n\n// Crea una instancia de Retrofit con la URL base y el convertidor de JSON\nval retrofit = Retrofit.Builder()\n    .baseUrl(\"https://api.example.com\")\n    .addConverterFactory(GsonConverterFactory.create())\n    .build()\n\n// Crea una instancia del servicio web a partir de la interfaz de servicio web y la instancia de Retrofit\nval apiService = retrofit.create(ApiService::class.java)\n\n// Realiza una petici\u00f3n HTTP al servidor para obtener una lista de usuarios\nval users = apiService.getUsers()\n</code></pre> <p>En este ejemplo, se define una interfaz <code>ApiService</code> con el m\u00e9todo <code>getUsers()</code> que realiza una petici\u00f3n GET al servidor para obtener una lista de usuarios. Se crea una instancia de Retrofit con la URL base <code>https://api.example.com</code> y el convertidor de JSON de Gson. A continuaci\u00f3n, se crea una instancia del servicio web a partir de la interfaz <code>ApiService</code> y la instancia de Retrofit. Por \u00faltimo, se utiliza la instancia del servicio web para realizar una petici\u00f3n HTTP al servidor y obtener una lista de usuarios.</p> <p>Con Retrofit, puedes conectarte a servicios web RESTful de forma sencilla y eficiente en una aplicaci\u00f3n Android con Jetpack Compose. Retrofit te permite definir una interfaz de servicio web con anotaciones que describen las operaciones disponibles en el servicio y gestionar la comunicaci\u00f3n con el servidor de forma autom\u00e1tica.</p> <p>Todo este c\u00f3digo suele ordenarse y distribuirse en diferentes archivos y paquetes para mantener una estructura limpia y organizada. A continuaci\u00f3n veremos cada uno de estos pasos en detalle.</p>"},{"location":"temas/04/4.2-conexion-internet.html#implementacion-de-retrofit-en-android","title":"Implementaci\u00f3n de Retrofit en Android\u200b","text":""},{"location":"temas/04/4.2-conexion-internet.html#permiso-de-internet","title":"Permiso de Internet","text":"<p>Para conectarse a internet en una aplicaci\u00f3n Android, debes a\u00f1adir el permiso de internet al archivo <code>AndroidManifest.xml</code> de la aplicaci\u00f3n. Puedes hacerlo a\u00f1adiendo la siguiente l\u00ednea al archivo <code>AndroidManifest.xml</code>:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n</code></pre> <p>Este permiso permite que la aplicaci\u00f3n se conecte a internet y realice peticiones HTTP al servidor. Sin este permiso, la aplicaci\u00f3n no podr\u00e1 conectarse a internet y no podr\u00e1 realizar peticiones HTTP al servidor.</p>"},{"location":"temas/04/4.2-conexion-internet.html#importar-las-dependencias-de-retrofit","title":"Importar las dependencias de Retrofit","text":"<p>Para utilizar Retrofit en una aplicaci\u00f3n Android, primero debes importar las dependencias de Retrofit en el archivo <code>build.gradle</code> del m\u00f3dulo de la aplicaci\u00f3n. Puedes hacerlo a\u00f1adiendo las siguientes l\u00edneas al archivo <code>build.gradle</code>:</p> <pre><code>dependencies {\n    // Retrofit\n    implementation(\"com.squareup.retrofit2:retrofit:2.9.0\")\n    // Retrofit with Scalar Converter\n    implementation(\"com.squareup.retrofit2:converter-scalars:2.9.0\")\n}\n</code></pre> <p>Estas l\u00edneas importan las dependencias de Retrofit y el convertidor de escalares en la aplicaci\u00f3n. El convertidor de escalares se utiliza para convertir las respuestas del servidor en cadenas de texto.</p>"},{"location":"temas/04/4.2-conexion-internet.html#definir-la-interfaz-de-servicio-web","title":"Definir la interfaz de servicio web","text":"<p>A continuaci\u00f3n, debes definir una interfaz de servicio web que contenga las operaciones disponibles en el servicio. Puedes hacerlo creando una interfaz en un archivo Kotlin y anot\u00e1ndola con las anotaciones de Retrofit, como <code>@GET</code>, <code>@POST</code>, <code>@PUT</code> y <code>@DELETE</code>. Por ejemplo, puedes definir una interfaz <code>ApiService</code> que contenga m\u00e9todos para obtener y enviar datos al servidor:</p> <pre><code>import retrofit2.http.GET\n\ninterface ApiService {\n    @GET(\"users\")\n    suspend fun getUsers(): List&lt;User&gt;\n}\n</code></pre> <p>En este ejemplo, la interfaz ApiService contiene un m\u00e9todo getUsers() que realiza una petici\u00f3n GET al servidor para obtener una lista de usuarios.</p> <p>\ud83d\udca1Ubicaci\u00f3n de la interfaz de servicio web. La interfaz de servicio web suele ubicarse en un paquete de datos, network o servicios del proyecto para mantener una estructura limpia y organizada. \u27a1\ufe0f Anotaciones de Retrofit. Las anotaciones de Retrofit se utilizan para describir las operaciones disponibles en el servicio web. Por ejemplo, la anotaci\u00f3n @GET se utiliza para realizar una petici\u00f3n GET al servidor, la anotaci\u00f3n @POST se utiliza para realizar una petici\u00f3n POST al servidor, y as\u00ed sucesivamente</p>"},{"location":"temas/04/4.4-Injeccion-dependencias.html","title":"4.4 Injeccion dependencias","text":""},{"location":"temas/proyectos/GameVault/index.html","title":"Introducci\u00f3n","text":""},{"location":"temas/proyectos/GameVault/index.html#proyecto-mygamestore","title":"\ud83d\udcc4 Proyecto \"MyGameStore\"","text":"<p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/index.html#1-vision-general","title":"1. Visi\u00f3n General","text":"<p>MyGameStore es una aplicaci\u00f3n nativa de Android dise\u00f1ada para amantes de los videojuegos. El objetivo principal es ofrecer un cat\u00e1logo online actualizado (consultando la API de RAWG) y permitir a los usuarios gestionar su propia biblioteca personal de forma local.</p> <p>El reto principal de este proyecto no es solo que la aplicaci\u00f3n \"funcione\", sino que est\u00e9 construida bajo los est\u00e1ndares de la industria actual: Escalabilidad, Modularidad y C\u00f3digo Limpio.</p>"},{"location":"temas/proyectos/GameVault/index.html#2-funcionalidad-de-la-aplicacion","title":"2. Funcionalidad de la Aplicaci\u00f3n","text":"<p>La aplicaci\u00f3n simular\u00e1 un entorno multi-usuario en un mismo dispositivo, gestionando la persistencia de datos y sesiones.</p>"},{"location":"temas/proyectos/GameVault/index.html#modulo-de-autenticacion-local","title":"\ud83d\udd10 M\u00f3dulo de Autenticaci\u00f3n (Local)","text":"<ul> <li>Login: El usuario debe poder iniciar sesi\u00f3n con sus credenciales.</li> <li>Registro: Posibilidad de crear una cuenta nueva. Los datos se guardan en la base de datos interna del dispositivo.</li> <li>Gesti\u00f3n de Sesi\u00f3n: La aplicaci\u00f3n recordar\u00e1 al usuario activo. Si cierras la app y vuelves a entrar, no debes loguearte de nuevo (Auto-login).</li> </ul>"},{"location":"temas/proyectos/GameVault/index.html#modulo-de-exploracion-remoto","title":"\ud83c\udfae M\u00f3dulo de Exploraci\u00f3n (Remoto)","text":"<ul> <li>Cat\u00e1logo: Visualizaci\u00f3n de una lista de videojuegos populares obtenidos de internet.</li> <li>Detalle: Al pulsar en un juego, se muestra informaci\u00f3n detallada: descripci\u00f3n, fecha de lanzamiento, imagen en alta calidad y valoraci\u00f3n.</li> </ul>"},{"location":"temas/proyectos/GameVault/index.html#modulo-de-biblioteca-local-privado","title":"\ud83d\udcda M\u00f3dulo de Biblioteca (Local &amp; Privado)","text":"<ul> <li>Favoritos: El usuario puede marcar/desmarcar juegos como favoritos desde el detalle.</li> <li>Privacidad de Datos:<ul> <li>Si el Usuario A guarda \"Zelda\", y luego inicia sesi\u00f3n el Usuario B, el Usuario B NO debe ver \"Zelda\" en su lista.</li> <li>Cada biblioteca es exclusiva del usuario logueado.</li> </ul> </li> </ul>"},{"location":"temas/proyectos/GameVault/index.html#3-requisitos-tecnicos-el-tech-stack","title":"3. Requisitos T\u00e9cnicos (El \"Tech Stack\")","text":"<p>Para este proyecto utilizaremos las tecnolog\u00edas m\u00e1s demandadas actualmente en el desarrollo Android moderno.</p>"},{"location":"temas/proyectos/GameVault/index.html#interfaz-de-usuario-ui","title":"\ud83c\udfa8 Interfaz de Usuario (UI)","text":"<ul> <li>Jetpack Compose: Todo el dise\u00f1o se realizar\u00e1 de forma declarativa.</li> <li>Material Design 3: Uso de temas (Claro/Oscuro), tipograf\u00edas y componentes est\u00e1ndar.</li> <li>Navegaci\u00f3n por Estado (Navigation 3): No usaremos el <code>NavHost</code> cl\u00e1sico basado en XML o Strings. Implementaremos un sistema de navegaci\u00f3n robusto basado en una pila de estado (<code>mutableStateListOf</code>) y objetos tipados (<code>AppRoutes</code>).</li> </ul>"},{"location":"temas/proyectos/GameVault/index.html#arquitectura","title":"\ud83c\udfd7\ufe0f Arquitectura","text":"<p>El proyecto debe seguir estrictamente Clean Architecture separando el c\u00f3digo en tres capas: 1.  Presentation (UI): Composables y ViewModels. 2.  Domain: Casos de uso (L\u00f3gica de negocio pura) y Modelos. 3.  Data: Repositorios, Fuentes de datos (API y BBDD) y Mappers.</p>"},{"location":"temas/proyectos/GameVault/index.html#inyeccion-de-dependencias","title":"\ud83d\udc89 Inyecci\u00f3n de Dependencias","text":"<ul> <li>Koin: Se utilizar\u00e1 para gestionar la creaci\u00f3n e inyecci\u00f3n de componentes (Repositorios en ViewModels, Retrofit en Repositorios, etc.).</li> </ul>"},{"location":"temas/proyectos/GameVault/index.html#gestion-de-datos","title":"\ud83d\udcbe Gesti\u00f3n de Datos","text":"<ul> <li>Remoto (API): Retrofit 2 para consumir la API de RAWG.io.</li> <li>Local (BBDD): Room para almacenar usuarios y la biblioteca de juegos.</li> <li>Sesi\u00f3n: DataStore (Preferences) para almacenar el token o ID del usuario actual de forma ligera.</li> <li>Im\u00e1genes: Coil para la carga as\u00edncrona de car\u00e1tulas.</li> </ul>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html","title":"1. Configuraci\u00f3n proyecto","text":""},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#1-configuracion-de-proyecto-y-primeros-pasos","title":"1. Configuraci\u00f3n de proyecto y primeros pasos","text":"<p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Esta gu\u00eda describe paso a paso c\u00f3mo completar configuraci\u00f3n del proyecto de MyGameStore. Incluye dependencias, estructura de carpetas, rutas de navegaci\u00f3n, integraci\u00f3n en MainActivity, tema con dise\u00f1o adaptativo (Dimens) y el esqueleto de pantallas.</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#resumen","title":"Resumen","text":"<ul> <li>Proyecto base con Jetpack Compose y Material 3</li> <li>Navigation 3</li> <li>Rutas en <code>AppRoutes</code></li> <li>Integraci\u00f3n de navegaci\u00f3n en <code>MainActivity</code></li> <li>Tema y dise\u00f1o adaptativo: <code>Dimens</code> + inyecci\u00f3n v\u00eda <code>CompositionLocal</code></li> <li>Paleta de colores de la app definida en <code>Color.kt</code> y <code>colors.xml</code></li> <li>Esqueleto de pantallas b\u00e1sicas</li> </ul>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#1-configuracion-del-proyecto-y-dependencias","title":"1) Configuraci\u00f3n del proyecto y dependencias","text":"<p>Usaremos Version Catalog (archivo <code>gradle/libs.versions.toml</code>) para gestionar versiones y coordenadas.</p> <p>1.1. Edita <code>gradle/libs.versions.toml</code> y aseg\u00farate de tener (o a\u00f1ade) estas versiones y librer\u00edas m\u00ednimas para la parte 1\u00aa:</p> <pre><code>[versions]\nagp = \"8.13.2\"\nkotlin = \"2.1.21\"\ncoreKtx = \"1.17.0\"\nlifecycleRuntimeKtx = \"2.10.0\"\nactivityCompose = \"1.12.2\"\ncomposeBom = \"2024.09.00\"\nnavigationCompose = \"2.8.4\"\njunit = \"4.13.2\"\njunitVersion = \"1.3.0\"\nespressoCore = \"3.7.0\"\n\n# Navigation-3\nnav3Core = \"1.0.0\"\nnav3lifecycleVM = \"2.9.4\"\nkotlinxSerialization = \"1.7.3\"\n\n[libraries]\nandroidx-core-ktx = { group = \"androidx.core\", name = \"core-ktx\", version.ref = \"coreKtx\" }\nandroidx-lifecycle-runtime-ktx = { group = \"androidx.lifecycle\", name = \"lifecycle-runtime-ktx\", version.ref = \"lifecycleRuntimeKtx\" }\nandroidx-activity-compose = { group = \"androidx.activity\", name = \"activity-compose\", version.ref = \"activityCompose\" }\nandroidx-compose-bom = { group = \"androidx.compose\", name = \"compose-bom\", version.ref = \"composeBom\" }\nandroidx-compose-ui = { group = \"androidx.compose.ui\", name = \"ui\" }\nandroidx-compose-ui-graphics = { group = \"androidx.compose.ui\", name = \"ui-graphics\" }\nandroidx-compose-ui-tooling = { group = \"androidx.compose.ui\", name = \"ui-tooling\" }\nandroidx-compose-ui-tooling-preview = { group = \"androidx.compose.ui\", name = \"ui-tooling-preview\" }\nandroidx-compose-ui-test-manifest = { group = \"androidx.compose.ui\", name = \"ui-test-manifest\" }\nandroidx-compose-ui-test-junit4 = { group = \"androidx.compose.ui\", name = \"ui-test-junit4\" }\nandroidx-compose-material3 = { group = \"androidx.compose.material3\", name = \"material3\" }\n\n# Nav3: Core Navigation 3 libraries\nandroidx-navigation3-runtime = { module = \"androidx.navigation3:navigation3-runtime\", version.ref = \"nav3Core\" }\nandroidx-navigation3-ui = { module = \"androidx.navigation3:navigation3-ui\", version.ref = \"nav3Core\" }\nandroidx-lifecycle-viewmodel-navigation3 = { module = \"androidx.lifecycle:lifecycle-viewmodel-navigation3\", version.ref = \"nav3lifecycleVM\" }\nkotlinx-serialization-json = { module = \"org.jetbrains.kotlinx:kotlinx-serialization-json\", version.ref = \"kotlinxSerialization\" }\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n\nkotlin-serialization = { id = \"org.jetbrains.kotlin.plugin.serialization\", version.ref = \"kotlin\" }\n</code></pre> <p>Nota: en este proyecto trabajamos la navegaci\u00f3n con un <code>NavDisplay</code> propio para entender conceptos base. La dependencia <code>navigation-compose</code> puede a\u00f1adirse ya (para futuras versiones o comparativas), pero en esta 1\u00aa parte no es estrictamente necesaria.</p> <p>1.2. Revisa <code>app/build.gradle.kts</code> del m\u00f3dulo <code>app</code>. Debe incluir Compose y Material 3, m\u00e1s (opcionalmente) Navigation:</p> <pre><code>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.kotlin.serialization)\n}\n\n\n\ndependencies {\n    // Core Android\n    implementation(libs.androidx.core.ktx)\n    implementation(libs.androidx.lifecycle.runtime.ktx)\n\n    // Compose base\n    implementation(libs.androidx.activity.compose)\n    implementation(platform(libs.androidx.compose.bom))\n    implementation(libs.androidx.compose.ui)\n    implementation(libs.androidx.compose.ui.graphics)\n    implementation(libs.androidx.compose.ui.tooling.preview)\n    implementation(libs.androidx.compose.material3)\n\n    //Navigation\n    implementation(libs.androidx.navigation3.runtime)\n    implementation(libs.androidx.navigation3.ui)\n    implementation(libs.androidx.lifecycle.viewmodel.navigation3)\n    implementation(libs.kotlinx.serialization.json)\n\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#2-estructura-de-carpetas-clean-architecture-esqueleto-completo","title":"2) Estructura de carpetas (Clean Architecture \u2014 esqueleto completo)","text":"<p>Para que los alumnos visualicen desde el principio la organizaci\u00f3n, creamos TODAS las carpetas, aunque en esta 1\u00aa parte varias quedar\u00e1n vac\u00edas. En esta versi\u00f3n s\u00f3lo utilizaremos activamente <code>presentation/ui</code>.</p> <p>Sugerencia: cuando una carpeta vaya a quedar vac\u00eda, crea un archivo <code>.keep</code> (vac\u00edo) o <code>README.md</code> con 1\u20132 l\u00edneas para que el control de versiones conserve el directorio.</p> <pre><code>app/\n\u2514\u2500 src/\n   \u251c\u2500 main/\n   \u2502  \u251c\u2500 AndroidManifest.xml\n   \u2502  \u251c\u2500 java/com/pmdm/mygamestore/\n   \u2502  \u2502  \u251c\u2500 MyGameStoreApp.kt\n   \u2502  \u2502  \u251c\u2500 presentation/\n   \u2502  \u2502  \u2502  \u251c\u2500 ui/\n   \u2502  \u2502  \u2502  \u2502  \u251c\u2500 navigation/          (AppRoutes, NavDisplay)\n   \u2502  \u2502  \u2502  \u2502  \u251c\u2500 screens/             (Splash, Login, Register, Home, Library, Profile, Detail)\n   \u2502  \u2502  \u2502  \u2502  \u251c\u2500 components/          (componentes reutilizables)              [vac\u00edo en esta 1\u00aa parte]\n   \u2502  \u2502  \u2502  \u2502  \u2514\u2500 theme/               (Color, Dimens, Theme, Type)\n   \u2502  \u2502  \u2502  \u2514\u2500 viewmodel/              (ViewModels)                             [vac\u00edo en esta 1\u00aa parte]\n   \u2502  \u2502  \u251c\u2500 domain/                     (capa de dominio)                        [vac\u00edo en esta 1\u00aa parte]\n   \u2502  \u2502  \u2502  \u251c\u2500 model/                  (entidades del dominio)\n   \u2502  \u2502  \u2502  \u251c\u2500 repository/             (contratos de repositorios)\n   \u2502  \u2502  \u2502  \u2514\u2500 usecase/                (casos de uso)\n   \u2502  \u2502  \u2514\u2500 data/                       (capa de datos)                           [vac\u00edo en esta 1\u00aa parte]\n   \u2502  \u2502     \u251c\u2500 remote/\n   \u2502  \u2502     \u2502  \u251c\u2500 api/                 (interfaces Retrofit)\n   \u2502  \u2502     \u2502  \u2514\u2500 dto/                 (modelos de red)\n   \u2502  \u2502     \u251c\u2500 local/\n   \u2502  \u2502     \u2502  \u251c\u2500 db/                  (RoomDatabase)\n   \u2502  \u2502     \u2502  \u2514\u2500 dao/                 (DAOs)\n   \u2502  \u2502     \u2514\u2500 repository/             (impl. de repositorios)\n   \u2502  \n   \u251c\u2500 test/java/com/pmdm/mygamestore/        (tests unitarios)\n   \u2514\u2500 androidTest/java/com/pmdm/mygamestore/ (tests instrumentados)\n</code></pre> <p>Objetivo did\u00e1ctico: presentar capas desde el inicio. En esta 1\u00aa parte no hay l\u00f3gica de <code>domain</code> ni <code>data</code>, pero se dejan listas las carpetas para versiones posteriores.</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#3-rutas-de-navegacion-con-approutes","title":"3) Rutas de navegaci\u00f3n con <code>AppRoutes</code>","text":"<p>Definimos un <code>sealed interface</code> con todas las rutas de la app. Ventaja: tipos seguros y par\u00e1metros claros.</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/presentation/ui/navigation/AppRoutes.kt\nsealed interface AppRoutes: NavKey {\n    @Serializable\n    data object Splash : AppRoutes\n    @Serializable\n    data object Login : AppRoutes\n    @Serializable\n    data object Register : AppRoutes\n    @Serializable\n    data object Home : AppRoutes\n    @Serializable\n    data object Library : AppRoutes\n    @Serializable\n    data object Profile : AppRoutes\n    @Serializable\n    data class Detail(val gameId: Int) : AppRoutes\n}\n</code></pre> <p>Concepto clave: <code>sealed</code> permite que el compilador conozca todas las variantes y nos fuerce a manejarlas al navegar o renderizar.</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#4-motor-de-navegacion-navigation-v3","title":"4) Motor de navegaci\u00f3n: <code>Navigation v3</code>","text":"<p>Navigation v3 simplifica la navegaci\u00f3n tratando las rutas como un estado (una lista de objetos). Sus componentes principales son:</p> <ul> <li><code>NavKey</code>: Interfaz que deben implementar nuestras rutas (como <code>AppRoutes</code>).</li> <li><code>NavDisplay</code>: El componente de UI que observa el <code>backStack</code> y muestra la pantalla correspondiente.</li> <li><code>entryProvider</code>: Mapea cada ruta a su pantalla.</li> </ul> <p>Video explicaci\u00f3n de Navigation 3 en Compose</p> <p></p> <p>Navegaci\u00f3n explicada a nivel de estructura usada</p> <p>\u00bfC\u00f3mo funcion la navegaci\u00f3n?</p> <ul> <li>Se define un grafo de navegaci\u00f3n que mapea cada ruta a su pantalla. </li> <li>Se define un <code>NavDisplay</code> que observa el <code>backStack</code> y muestra la pantalla correspondiente.</li> <li>En el <code>NavDisplay</code> se define un <code>entryProvider</code> que mapea, con una <code>NavKey</code> (que es la ruta), cada ruta a su pantalla.</li> </ul> <p>El funcionamiento es sencillo:</p> <ul> <li>El <code>rememberNavBackStack</code> es una lista y a su vez un estado que permite recomposici\u00f3n, cada vez que se modifique esta lista.</li> <li>Para ir hac\u00eda atr\u00e1s, se utiliza la acci\u00f3n de back, eliminando el \u00faltimo elemento de la lista.</li> <li>Para navegar hacia adelante, simplemente se a\u00f1ade la ruta a la lista, y se recompone la pantalla. El NavDisplay tiene un <code>entryProvider</code> para cada una de esas rutas, y devuelve un <code>Composable</code> que se encarga de mostrar la pantalla correspondiente.</li> </ul> <p>Por ahora, la navegaci\u00f3n es b\u00e1sica, m\u00e1s adelante se incorporar\u00e1n m\u00e1s funcionalidades.</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/presentation/ui/navigation/NavGraph.kt\n\n// Este objeto permitir\u00e1 a cualquier pantalla acceder al backStack\nval LocalNavStack = staticCompositionLocalOf&lt;MutableList&lt;NavKey&gt;&gt; {\n    error(\"No se ha proporcionado el BackStack. Aseg\u00farate de envolver tu contenido en un CompositionLocalProvider.\")\n}\n\n@Composable\nfun AppNavigation() {\n    // Gestiona el historial de navegaci\u00f3n, comenzando con la pantalla (la que se indique por defecto)\n    val backStack = rememberNavBackStack(AppRoutes.Home)\n\n    //Envolvemos la navegaci\u00f3n con el BackStack, permitiendo obtener el `backStack` desde el contexto.\n    CompositionLocalProvider(LocalNavStack provides backStack) {\n        // Configura el sistema de navegaci\u00f3n de la aplicaci\u00f3n\n        NavDisplay(\n            // Pasa el historial de navegaci\u00f3n\n            backStack = backStack,\n            // Funci\u00f3n para manejar el bot\u00f3n de retroceso\n            onBack = { backStack.removeLastOrNull() },\n            // Define las rutas y pantallas disponibles\n            entryProvider = entryProvider {\n                // Pantalla inicial de carga\n                entry(AppRoutes.Splash) {\n                    SplashScreen()\n                }\n                // Pantalla de inicio de sesi\u00f3n\n                entry(AppRoutes.Login) {\n                    LoginScreen()\n                }\n                // Pantalla de registro de usuario\n                entry(AppRoutes.Register) {\n                    RegisterScreen()\n                }\n                // Pantalla principal con cat\u00e1logo de juegos\n                entry(AppRoutes.Home) {\n                    HomeScreen()\n                }\n                // Pantalla de biblioteca personal\n                entry(AppRoutes.Library) {\n                    LibraryScreen()\n                }\n                // Pantalla de perfil de usuario\n                entry(AppRoutes.Profile) {\n                    ProfileScreen()\n                }\n                // Pantalla de detalles de un juego espec\u00edfico\n                entry&lt;AppRoutes.Detail&gt; { route -&gt;\n                    DetailScreen(route.gameId)\n                }\n            }\n        )\n    }\n}\n</code></pre> <p>Concepto clave: patr\u00f3n de \u201ctabla de rutas\u201d para asociar tipos de <code>AppRoutes</code> con <code>@Composable</code> concretos.</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#5-integracion-en-mainactivity","title":"5) Integraci\u00f3n en <code>MainActivity</code>","text":"<p>Ahora, llamamos al NavGraph desde <code>MainActivity</code>:</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/MainActivity.kt\nclass MainActivity : ComponentActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        enableEdgeToEdge()\n        setContent {\n            MyGameStoreTheme {\n                // Se llama al grafo de navegaci\u00f3n.\n                AppNavigation()\n            }\n        }\n    }\n}\n</code></pre> <p>Sugerencia did\u00e1ctica: a\u00f1ade botones en pantallas para empujar nuevas rutas al <code>backStack</code> y practicar navegaci\u00f3n.</p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#6-tema-y-diseno-adaptativo-dimens-inyeccion","title":"6) Tema y dise\u00f1o adaptativo: <code>Dimens</code> + inyecci\u00f3n","text":"<p>La <code>inyecci\u00f3n</code> de informaci\u00f3n en el contexto en Android es una t\u00e9cnica muy utilizada para pasar elementos a trav\u00e9s del todo el \u00e1rbol de elementos de la interfaz.</p> <p>Paso de informaci\u00f3n a trav\u00e9s del \u00e1rbol de Compose</p> <p>Queremos que la UI adapte espacios/paddings seg\u00fan el ancho de pantalla. Creamos un set de dimensiones y lo inyectamos por <code>CompositionLocal</code>.</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/presentation/ui/theme/Dimens.kt\ndata class Dimens(\n val extraSmall: Dp = 4.dp,\n    val small: Dp = 8.dp,\n    val medium: Dp = 16.dp,\n    val large: Dp = 24.dp,\n    val extraLarge: Dp = 32.dp,\n    val paddingSmall: Dp = 8.dp,\n    val paddingMedium: Dp = 16.dp,\n    val paddingLarge: Dp = 24.dp,\n    val cardElevation: Dp = 4.dp,\n\n    // Alturas de botones\n    val buttonHeightSmall: Dp = 36.dp,      // Botones peque\u00f1os/compactos\n    val buttonHeightMedium: Dp = 48.dp,     // Altura est\u00e1ndar (recomendada)\n    val buttonHeightLarge: Dp = 56.dp,      // Botones destacados\n\n    // Esquinas redondeadas de botones\n    val buttonCornerRadius: Dp = 20.dp,     // Para botones est\u00e1ndar\n    val buttonCornerRadiusSmall: Dp = 12.dp, // Para botones peque\u00f1os\n\n    // Padding interno del bot\u00f3n\n    val buttonPaddingHorizontal: Dp = 24.dp,\n    val buttonPaddingVertical: Dp = 10.dp,\n\n    // Espaciado entre botones\n    val buttonSpacing: Dp = 12.dp\n)\n\nval CompactDimens = Dimens(\n    extraSmall = 4.dp,\n    small = 8.dp,\n    medium = 16.dp,\n    large = 24.dp,\n    extraLarge = 32.dp,\n    paddingSmall = 8.dp,\n    paddingMedium = 16.dp,\n    paddingLarge = 24.dp,\n    cardElevation = 4.dp,\n\n    // Botones para m\u00f3viles\n    buttonHeightSmall = 36.dp,\n    buttonHeightMedium = 48.dp,      // Altura m\u00ednima t\u00e1ctil recomendada\n    buttonHeightLarge = 56.dp,\n    buttonCornerRadius = 20.dp,\n    buttonCornerRadiusSmall = 12.dp,\n    buttonPaddingHorizontal = 24.dp,\n    buttonPaddingVertical = 10.dp,\n    buttonSpacing = 12.dp\n)\n\nval MediumDimens = Dimens(\n     extraSmall = 6.dp,\n    small = 12.dp,\n    medium = 20.dp,\n    large = 28.dp,\n    extraLarge = 40.dp,\n    paddingSmall = 12.dp,\n    paddingMedium = 24.dp,\n    paddingLarge = 36.dp,\n    cardElevation = 6.dp,\n\n    // Botones para tablets peque\u00f1as\n    buttonHeightSmall = 40.dp,\n    buttonHeightMedium = 52.dp,\n    buttonHeightLarge = 60.dp,\n    buttonCornerRadius = 24.dp,\n    buttonCornerRadiusSmall = 14.dp,\n    buttonPaddingHorizontal = 28.dp,\n    buttonPaddingVertical = 12.dp,\n    buttonSpacing = 16.dp\n)\n\nval ExpandedDimens = Dimens(\n    extraSmall = 8.dp,\n    small = 16.dp,\n    medium = 24.dp,\n    large = 32.dp,\n    extraLarge = 48.dp,\n    paddingSmall = 16.dp,\n    paddingMedium = 32.dp,\n    paddingLarge = 48.dp,\n    cardElevation = 8.dp,\n\n    // Botones para tablets grandes/escritorio\n    buttonHeightSmall = 44.dp,\n    buttonHeightMedium = 56.dp,\n    buttonHeightLarge = 64.dp,\n    buttonCornerRadius = 28.dp,\n    buttonCornerRadiusSmall = 16.dp,\n    buttonPaddingHorizontal = 32.dp,\n    buttonPaddingVertical = 14.dp,\n    buttonSpacing = 20.dp\n)\n</code></pre> <p>Integraci\u00f3n en el tema para seleccionar el set en funci\u00f3n del ancho:</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/presentation/ui/theme/Theme.kt\n@Composable\nfun MyGameStoreTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    dynamicColor: Boolean = true,\n    content: @Composable () -&gt; Unit\n) {\n    val colorScheme = when {\n        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n        darkTheme -&gt; DarkColorScheme\n        else -&gt; LightColorScheme\n    }\n\n    // L\u00f3gica para dise\u00f1o adaptativo: seleccionamos dimensiones seg\u00fan el ancho de la pantalla\n    // Siguiendo las recomendaciones de Material Design (Window Size Classes)\n    val density = LocalDensity.current\n    val windowInfo = LocalWindowInfo.current\n    val screenWidthDp = with(density) {\n        windowInfo.containerSize.width.toDp()\n    }\n\n    val dimens = when {\n        screenWidthDp &lt; 600.dp -&gt; CompactDimens\n        screenWidthDp &lt; 840.dp -&gt; MediumDimens\n        else -&gt; ExpandedDimens\n    }\n\n    // CompositionLocalProvider inyecta las dimensiones en el \u00e1rbol de Compose\n    ProvideDimensions(\n        dimens = dimens,\n        content = {\n            MaterialTheme(\n                colorScheme = colorScheme,\n                typography = Typography,\n                content = content\n            )\n        }\n    )\n}\n</code></pre> <p>Se crea la funci\u00f3n <code>ProvideDimensions</code> para poder reutilizar la inyecci\u00f3n de dimensiones en otras partes de la app. Se usa un remember para evitar volver a crear el set de dimensiones cada vez que se renderiza la pantalla.</p> <pre><code>@Composable\nfun ProvideDimensions(\n    dimens: Dimens,\n    content: @Composable () -&gt; Unit) {\n\n    val dimensionSet = remember { dimens }\n\n    // Permite proporcionar las dimensiones a lo largo del arbol de compose.\n    CompositionLocalProvider(LocalDimens provides dimensionSet, content = content)\n}\n</code></pre> <p>Adem\u00e1s para facilitar el acceso a las dimensiones desde cualquier parte de la app, se crea el <code>LocalDimens</code>:</p> <pre><code>// app/src/main/java/com/pmdm/mygamestore/presentation/ui/theme/Dimens.kt\n/**\n * CompositionLocal que permite propagar las dimensiones a trav\u00e9s del \u00e1rbol de Compose\n * sin tener que pasarlas manualmente como par\u00e1metros en cada funci\u00f3n.\n */\nprivate val LocalDimens = staticCompositionLocalOf { Dimens() }\n</code></pre> <p>y adem\u00e1s se crea una propiedad de extensi\u00f3n para MaterialTheme que permite acceder a nuestras dimensiones personalizadas de forma sencilla: MaterialTheme.dimens.paddingMedium</p> <pre><code>/**\n * Propiedad de extensi\u00f3n para MaterialTheme que permite acceder a nuestras dimensiones\n * personalizadas de forma sencilla: MaterialTheme.dimens.paddingMedium\n */\nval MaterialTheme.dimens: Dimens\n    @Composable\n    @ReadOnlyComposable\n    get() = LocalDimens.current\n</code></pre> <p>y uso en pantallas:</p> <pre><code>Text(\n    text = \"Home Screen\",\n    modifier = Modifier.padding(MaterialTheme.dimens.paddingMedium)\n)\n</code></pre> <p>y por \u00faltimo lo \u00fanico que queda es <code>Envolver</code> con un nuevo <code>contexto</code>, MaterialTheme proveyendo las Dimensiones a todo el \u00e1rbol de Compose.</p> <p>Paso de informaci\u00f3n a trav\u00e9s del \u00e1rbol de Compose</p> <p>De tal forma, que el fichero <code>Theme</code> quedar\u00e1 de la siguiente forma:</p> <pre><code>/**\n * CompositionLocal que permite propagar las dimensiones a trav\u00e9s del \u00e1rbol de Compose\n * sin tener que pasarlas manualmente como par\u00e1metros en cada funci\u00f3n.\n */\nprivate val LocalDimens = staticCompositionLocalOf { Dimens() }\n\n/**\n * Provides a custom set of dimensions to the CompositionLocal hierarchy.\n * This allows child composables to access and use specific dimension configurations\n * such as padding, spacing, or elevation, tailored for the screen size or design requirements.\n *\n * @param dimens A `Dimens` instance defining the dimension values to provide.\n * @param content A composable lambda that will have access to the provided dimensions.\n */\n@Composable\nfun ProvideDimensions(\n    dimens: Dimens,\n    content: @Composable () -&gt; Unit) {\n\n    val dimensionSet = remember { dimens }\n\n    // Permite proporcionar las dimensiones a lo largo del arbol de compose.\n    CompositionLocalProvider(LocalDimens provides dimensionSet, content = content)\n}\n\n/**\n * Funci\u00f3n Composable que proporciona el tema principal de la aplicaci\u00f3n MyGameStore.\n * Gestiona el esquema de colores (incluyendo colores din\u00e1micos en Android 12+) \n * y las dimensiones adaptativas seg\u00fan el tama\u00f1o de la pantalla.\n *\n * @param darkTheme Indica si se debe usar el tema oscuro. Por defecto usa la configuraci\u00f3n del sistema.\n * @param dynamicColor Indica si se deben usar colores din\u00e1micos (disponible en Android 12+).\n * @param content El contenido Composable que ser\u00e1 envuelto por este tema.\n */\n@Composable\nfun MyGameStoreTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    // Los colores din\u00e1micos est\u00e1n disponibles a partir de Android 12 (S)\n    dynamicColor: Boolean = true,\n    content: @Composable () -&gt; Unit\n) {\n    // Selecci\u00f3n del esquema de colores\n    val colorScheme = when {\n        dynamicColor &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S -&gt; {\n            val context = LocalContext.current\n            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)\n        }\n\n        darkTheme -&gt; DarkColorScheme\n        else -&gt; LightColorScheme\n    }\n\n    // L\u00f3gica para dise\u00f1o adaptativo: seleccionamos dimensiones seg\u00fan el ancho de la pantalla\n    // Siguiendo las recomendaciones de Material Design (Window Size Classes)\n    val density = LocalDensity.current\n    val windowInfo = LocalWindowInfo.current\n    val screenWidthDp = with(density) {\n        windowInfo.containerSize.width.toDp()\n    }\n\n    val dimens = when {\n        screenWidthDp &lt; 600.dp -&gt; CompactDimens\n        screenWidthDp &lt; 840.dp -&gt; MediumDimens\n        else -&gt; ExpandedDimens\n    }\n\n    // CompositionLocalProvider inyecta las dimensiones en el \u00e1rbol de Compose\n    ProvideDimensions(\n        dimens = dimens,\n        content = {\n            MaterialTheme(\n                colorScheme = colorScheme,\n                typography = Typography,\n                content = content\n            )\n        }\n    )\n}\n\n/**\n * Propiedad de extensi\u00f3n para MaterialTheme que permite acceder a nuestras dimensiones\n * personalizadas de forma sencilla: MaterialTheme.dimens.paddingMedium\n */\nval MaterialTheme.dimens: Dimens\n    @Composable\n    @ReadOnlyComposable\n    get() = LocalDimens.current\n</code></pre>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#7-paleta-de-colores-de-la-app","title":"7) Paleta de colores de la app","text":"<p>Sustituimos los colores de plantilla por una paleta propia. Define los colores en <code>Color.kt</code> y, opcionalmente, en <code>colors.xml</code> si necesitas recursos XML.</p> <p>Se deben definir los colores de nuestra App tanto en modo claro como modo oscuro. Estos colores los definiremos seg\u00fan el rol que tendr\u00e1n en la App.</p> <p>En <code>Color.kt</code>:</p> <pre><code>// Brand \u2014 MyGameStore. Colores compartidos para modo Light y modo Dark\nval GsPurple = Color(0xFF7C2CF2)          // Primary\nval GsPurpleDark = Color(0xFF6D28D9)      // Tertiary / \u00e9nfasis\nval GsPurpleLight = Color(0xFFA78BFA)     // Secondary\n\n// **** MODO LIGHT ****\n\n// Containers &amp; variants\nval GsPurpleContainer = Color(0xFFE7D7FF) // PrimaryContainer\nval GsPurpleContainerOn = Color(0xFF2E1065) // onPrimaryContainer\nval GsSecondaryContainer = Color(0xFFF1EAFE) // SecondaryContainer\nval GsOnSecondaryContainer = Color(0xFF2E1065)\n\n// Superficies\nval GsBackground = Color(0xFFF7F3FA)\nval GsSurface = Color(0xFFF7F3FA)\nval GsSurfaceVariant = Color(0xFFE9DEF6)\n\n// Texto\nval GsOnPrimary = Color(0xFFFFFFFF)\nval GsOnBackground = Color(0xFF1B1B1F)\nval GsOnSurface = Color(0xFF1B1B1F)\nval GsOnSurfaceVariant = Color(0xFF4A4458)\n\n// Borde\nval GsOutline = Color(0xFFD9C7F0)\n\n\n// **** MODO DARK ****\n\n// Superficies (dark)\nval GsDarkBackground = Color(0xFF15101B)\nval GsDarkSurface = Color(0xFF15101B)\nval GsDarkSurfaceVariant = Color(0xFF2A2133)\n\n// Texto (dark)\nval GsDarkOnBackground = Color(0xFFEAE6F0)\nval GsDarkOnSurface = Color(0xFFEAE6F0)\nval GsDarkOnSurfaceVariant = Color(0xFFC9BEDA)\n\n// Containers (opcionales usados por campos/tonos sutiles en dark)\nval GsDarkPrimaryContainer = Color(0xFF3A2459)\nval GsDarkOnPrimaryContainer = Color(0xFFECDCFF)\nval GsDarkSecondary = Color(0xFFC4B1FF)\nval GsDarkSecondaryContainer = Color(0xFF35274F)\nval GsDarkOnSecondaryContainer = Color(0xFFECDCFF)\n\n// Borde (dark)\nval GsDarkOutline = Color(0xFF4A3A55)\n</code></pre> <p>Se definen los colores para el modo Dark y modo Ligth. El prefijo <code>Gs</code> es un acr\u00f3nimo de GameStore.</p> <p>Mapea en <code>Theme.kt</code> los esquemas Light/Dark:</p> <pre><code>private val DarkColorScheme = darkColorScheme(\n    primary = GsPurple,\n    onPrimary = GsOnPrimary,\n    primaryContainer = GsDarkPrimaryContainer,\n    onPrimaryContainer = GsDarkOnPrimaryContainer,\n\n    background = GsDarkBackground,\n    onBackground = GsDarkOnBackground,\n\n    surface = GsDarkSurface,\n    onSurface = GsDarkOnSurface,\n    surfaceVariant = GsDarkSurfaceVariant,\n    onSurfaceVariant = GsDarkOnSurfaceVariant,\n    outline = GsDarkOutline,\n\n    secondary = GsDarkSecondary,\n    onSecondary = Color(0xFF1B1329),\n    secondaryContainer = GsDarkSecondaryContainer,\n    onSecondaryContainer = GsDarkOnSecondaryContainer,\n\n    tertiary = GsPurpleDark,\n    onTertiary = Color(0xFFFFFFFF)\n)\n\nprivate val LightColorScheme = lightColorScheme(\n    primary = GsPurple,\n    onPrimary = GsOnPrimary,\n    primaryContainer = GsPurpleContainer,\n    onPrimaryContainer = GsPurpleContainerOn,\n\n    background = GsBackground,\n    onBackground = GsOnBackground,\n\n    surface = GsSurface,\n    onSurface = GsOnSurface,\n    surfaceVariant = GsSurfaceVariant,\n    onSurfaceVariant = GsOnSurfaceVariant,\n    outline = GsOutline,\n\n    secondary = GsPurpleLight,\n    onSecondary = Color(0xFF1F1147),\n    secondaryContainer = GsSecondaryContainer,\n    onSecondaryContainer = GsOnSecondaryContainer,\n\n    tertiary = GsPurpleDark,\n    onTertiary = Color(0xFFFFFFFF)\n)\n</code></pre> <p>Si usas recursos XML, a\u00f1ade en <code>app/src/main/res/values/colors.xml</code>:</p> <pre><code>&lt;resources&gt;\n    &lt;!-- MyGameStore \u2014 Light scheme --&gt;\n    &lt;color name=\"gs_purple\"&gt;#FF7C2CF2&lt;/color&gt;\n    &lt;color name=\"gs_purple_dark\"&gt;#FF6D28D9&lt;/color&gt;\n    &lt;color name=\"gs_purple_light\"&gt;#FFA78BFA&lt;/color&gt;\n\n    &lt;color name=\"gs_on_primary\"&gt;#FFFFFFFF&lt;/color&gt;\n\n    &lt;color name=\"gs_purple_container\"&gt;#FFE7D7FF&lt;/color&gt;\n    &lt;color name=\"gs_purple_container_on\"&gt;#FF2E1065&lt;/color&gt;\n    &lt;color name=\"gs_secondary_container\"&gt;#FFF1EAFE&lt;/color&gt;\n    &lt;color name=\"gs_on_secondary_container\"&gt;#FF2E1065&lt;/color&gt;\n\n    &lt;color name=\"gs_background\"&gt;#FFF7F3FA&lt;/color&gt;\n    &lt;color name=\"gs_surface\"&gt;#FFF7F3FA&lt;/color&gt;\n    &lt;color name=\"gs_surface_variant\"&gt;#FFE9DEF6&lt;/color&gt;\n    &lt;color name=\"gs_on_background\"&gt;#FF1B1B1F&lt;/color&gt;\n    &lt;color name=\"gs_on_surface\"&gt;#FF1B1B1F&lt;/color&gt;\n    &lt;color name=\"gs_on_surface_variant\"&gt;#FF4A4458&lt;/color&gt;\n    &lt;color name=\"gs_outline\"&gt;#FFD9C7F0&lt;/color&gt;\n\n    &lt;!-- GameVault \u2014 Dark scheme --&gt;\n    &lt;color name=\"gs_dark_background\"&gt;#FF15101B&lt;/color&gt;\n    &lt;color name=\"gs_dark_surface\"&gt;#FF15101B&lt;/color&gt;\n    &lt;color name=\"gs_dark_surface_variant\"&gt;#FF2A2133&lt;/color&gt;\n    &lt;color name=\"gs_dark_on_background\"&gt;#FFEAE6F0&lt;/color&gt;\n    &lt;color name=\"gs_dark_on_surface\"&gt;#FFEAE6F0&lt;/color&gt;\n    &lt;color name=\"gs_dark_on_surface_variant\"&gt;#FFC9BEDA&lt;/color&gt;\n\n    &lt;color name=\"gs_dark_primary_container\"&gt;#FF3A2459&lt;/color&gt;\n    &lt;color name=\"gs_dark_on_primary_container\"&gt;#FFECDCFF&lt;/color&gt;\n    &lt;color name=\"gs_dark_secondary\"&gt;#FFC4B1FF&lt;/color&gt;\n    &lt;color name=\"gs_dark_secondary_container\"&gt;#FF35274F&lt;/color&gt;\n    &lt;color name=\"gs_dark_on_secondary_container\"&gt;#FFECDCFF&lt;/color&gt;\n    &lt;color name=\"gs_dark_outline\"&gt;#FF4A3A55&lt;/color&gt;\n\n  &lt;/resources&gt;\n</code></pre>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#pantalla-de-splash","title":"Pantalla de Splash","text":"<p>La pantalla de Splash es la primera que se muestra al iniciar la app. Simplemente muestra un logo y espera unos segundos antes de navegar a la pantalla de inicio. Para ello se utiliza <code>delay</code> dentro de un <code>LaunchedEffect</code>. El LaunchEffect se ejecuta cada vez que cambia el par\u00e1metro pasado como par\u00e1metro. En este caso <code>Unit</code> indicando que solo se va a ejecutar una vez.</p> <p>Para poner el logo con vuestra imagen, cambia la imagen en <code>R.drawable.ic_launcher_foreground</code>.</p> <pre><code>@Composable\nfun SplashScreen() {\n\n    // Obtenemos el acceso a la navegaci\u00f3n\n    val navStack = LocalNavStack.current\n\n    // Efecto para navegar autom\u00e1ticamente despu\u00e9s de un delay\n    LaunchedEffect(Unit) {\n        delay(2000) // Espera 2 segundos\n        navStack.add(AppRoutes.Home)  // Navega a Home\n    }\n\n    // UI del Splash Screen\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.ic_launcher_foreground), // Cambia esto por tu imagen\n            contentDescription = \"Logo de la aplicaci\u00f3n\",\n            modifier = Modifier.size(200.dp)\n        )\n    }\n}\n</code></pre> <p>Para navegar a otra pantalla, llamamos a </p>"},{"location":"temas/proyectos/GameVault/01-configuracion-proyecto.html#8-esqueleto-basico-de-pantallas-scaffold-paddings","title":"8) Esqueleto b\u00e1sico de pantallas (Scaffold + paddings)","text":"<p>Cada pantalla puede empezar con un <code>Scaffold</code> simple y usar <code>MaterialTheme.dimens</code> para espaciados.</p> <pre><code>@Composable\nfun HomeScreen(onNavigateToDetail: (Int) -&gt; Unit = {}) {\n    Scaffold { innerPadding -&gt;\n        Column(\n            modifier = Modifier\n                .padding(innerPadding)\n                .padding(MaterialTheme.dimens.paddingMedium)\n        ) {\n            Text(text = \"Home Screen\", style = MaterialTheme.typography.titleLarge)\n            Spacer(Modifier.height(MaterialTheme.dimens.small))\n            Button(onClick = { onNavigateToDetail(42) }) {\n                Text(\"Ir a detalle\")\n            }\n        }\n    }\n}\n\n\n### 9) Pantallas de prototipado r\u00e1pido (Home, Library y Profile con BottomBar)\n\nPara comprobar la l\u00f3gica de navegaci\u00f3n, es \u00fatil tener versiones m\u00ednimas pero funcionales de algunas pantallas. Ya que en esta 1\u00aa parte el foco es la navegaci\u00f3n y el dise\u00f1o adaptativo, vamos a usar `Scaffold`, `NavigationBar` (BottomBar) y `MaterialTheme.dimens`.\n\nObjetivo did\u00e1ctico: practicar el patr\u00f3n \u201cpantallas principales con BottomBar\u201d y c\u00f3mo se empujan rutas con `LocalNavStack`.\n\n---\n\nModelo simple para items de BottomBar:\n\n```kotlin\n// Puede ir al final de HomeScreen.kt o como snippet independiente en la gu\u00eda\ndata class BottomNavItem(\n    val label: String,\n    val icon: ImageVector,\n    val route: AppRoutes\n)\n</code></pre> <p>HomeScreen (con BottomBar):</p> <pre><code>@Composable\nfun HomeScreen() {\n    val navStack = LocalNavStack.current\n    var selectedItem by remember { mutableIntStateOf(0) }\n\n    val items = listOf(\n        BottomNavItem(\"Home\", Icons.Filled.Home, AppRoutes.Home),\n        BottomNavItem(\"Library\", Icons.Filled.Favorite, AppRoutes.Library),\n        BottomNavItem(\"Profile\", Icons.Filled.Person, AppRoutes.Profile)\n    )\n\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                items.forEachIndexed { index, item -&gt;\n                    NavigationBarItem(\n                        icon = { Icon(item.icon, contentDescription = item.label) },\n                        label = { Text(item.label) },\n                        selected = selectedItem == index,\n                        onClick = {\n                            selectedItem = index\n                            when (item.route) {\n                                AppRoutes.Home -&gt; { /* ya estamos en Home */ }\n                                AppRoutes.Library -&gt; navStack.add(AppRoutes.Library)\n                                AppRoutes.Profile -&gt; navStack.add(AppRoutes.Profile)\n                                else -&gt; {}\n                            }\n                        }\n                    )\n                }\n            }\n        }\n    ) { innerPadding -&gt;\n        Box(\n            modifier = Modifier\n                .padding(innerPadding)\n                .padding(MaterialTheme.dimens.paddingMedium),\n            contentAlignment = Alignment.Center\n        ) {\n            Text(\"Home Screen - Cat\u00e1logo de Juegos\", style = MaterialTheme.typography.headlineMedium)\n        }\n    }\n}\n</code></pre> <p>LibraryScreen (marca el segundo item como seleccionado y navega a Home/Profile):</p> <pre><code>@Composable\nfun LibraryScreen() {\n    val navStack = LocalNavStack.current\n    var selectedItem by remember { mutableIntStateOf(1) }\n\n    val items = listOf(\n        BottomNavItem(\"Home\", Icons.Filled.Home, AppRoutes.Home),\n        BottomNavItem(\"Library\", Icons.Filled.Favorite, AppRoutes.Library),\n        BottomNavItem(\"Profile\", Icons.Filled.Person, AppRoutes.Profile)\n    )\n\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                items.forEachIndexed { index, item -&gt;\n                    NavigationBarItem(\n                        icon = { Icon(item.icon, contentDescription = item.label) },\n                        label = { Text(item.label) },\n                        selected = selectedItem == index,\n                        onClick = {\n                            selectedItem = index\n                            when (item.route) {\n                                AppRoutes.Home -&gt; navStack.add(AppRoutes.Home)\n                                AppRoutes.Library -&gt; { /* ya estamos en Library */ }\n                                AppRoutes.Profile -&gt; navStack.add(AppRoutes.Profile)\n                                else -&gt; {}\n                            }\n                        }\n                    )\n                }\n            }\n        }\n    ) { innerPadding -&gt;\n        Box(\n            modifier = Modifier\n                .padding(innerPadding)\n                .padding(MaterialTheme.dimens.paddingMedium),\n            contentAlignment = Alignment.Center\n        ) {\n            Text(\"Library Screen - Mi Biblioteca\", style = MaterialTheme.typography.headlineMedium)\n        }\n    }\n}\n</code></pre> <p>ProfileScreen (marca el tercer item como seleccionado y navega a Home/Library):</p> <pre><code>@Composable\nfun ProfileScreen() {\n    val navStack = LocalNavStack.current\n    var selectedItem by remember { mutableIntStateOf(2) }\n\n    val items = listOf(\n        BottomNavItem(\"Home\", Icons.Filled.Home, AppRoutes.Home),\n        BottomNavItem(\"Library\", Icons.Filled.Favorite, AppRoutes.Library),\n        BottomNavItem(\"Profile\", Icons.Filled.Person, AppRoutes.Profile)\n    )\n\n    Scaffold(\n        bottomBar = {\n            NavigationBar {\n                items.forEachIndexed { index, item -&gt;\n                    NavigationBarItem(\n                        icon = { Icon(item.icon, contentDescription = item.label) },\n                        label = { Text(item.label) },\n                        selected = selectedItem == index,\n                        onClick = {\n                            selectedItem = index\n                            when (item.route) {\n                                AppRoutes.Home -&gt; navStack.add(AppRoutes.Home)\n                                AppRoutes.Library -&gt; navStack.add(AppRoutes.Library)\n                                AppRoutes.Profile -&gt; { /* ya estamos en Profile */ }\n                                else -&gt; {}\n                            }\n                        }\n                    )\n                }\n            }\n        }\n    ) { innerPadding -&gt;\n        Box(\n            modifier = Modifier\n                .padding(innerPadding)\n                .padding(MaterialTheme.dimens.paddingMedium),\n            contentAlignment = Alignment.Center\n        ) {\n            Text(\"Profile Screen - Mi Perfil\", style = MaterialTheme.typography.headlineMedium)\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html","title":"2. Pantalla Login","text":""},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#2-funcionalidad-completa-de-login","title":"2. Funcionalidad completa de Login","text":"<p>En esta 2\u00aa parte del proyecto, vamos a crear la pantalla de login, desde el dise\u00f1o de la interfaz hasta la implementaci\u00f3n de la l\u00f3gica, la navegaci\u00f3n.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#resumen","title":"Resumen","text":"<ol> <li>Crear la pantalla de login</li> <li>Extraer componentes comunes</li> <li>Crear ViewModel y UiState asociados </li> <li>Crear Repositorio y vincular con ViewModel</li> <li>Implementar navegaci\u00f3n</li> </ol>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#1-creacion-de-la-pantalla-de-login","title":"1) Creaci\u00f3n de la pantalla de login","text":"<p>En la 1\u00aa parte ya configuramos los colores y la tipograf\u00eda. Ahora vamos a crear la interfaz de nuestra primera pantalla, la pantalla de Iniciar sesi\u00f3n o login a la que vamos a llamar LoginScreen.</p> <ul> <li> <p>C\u00f3digo LoginScreen</p> <p></p><pre><code>@Composable\nfun LoginScreen() {\n\n    var username by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n\n    Scaffold(\n        topBar = {},\n        modifier = Modifier.padding(MaterialTheme.dimens.paddingMedium)\n    ) { innerPadding -&gt;\n\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n        ) {\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .navigationBarsPadding(),\n                verticalArrangement = Arrangement.Top,\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n                Text(\n                    text = stringResource(R.string.app_name),\n                    style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.SemiBold),\n                    color = MaterialTheme.colorScheme.onBackground\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.extraLarge))\n\n                //Campo Username ccon etiqueta\n\n                LabeledTextFieldGS(\n                    label = \"Username\",\n                    value = username,\n                    onValueChange = { username = it },\n                    placeholder = \"Enter your username\",\n                    modifier = Modifier.fillMaxWidth()\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.small))\n\n                // Campo de Password con etiqueta\n\n                LabeledTextFieldGS(\n                    label = \"Password\",\n                    value = password,\n                    onValueChange = { password = it },\n                    placeholder = \"Enter your password\",\n                    modifier = Modifier.fillMaxWidth(),\n                    visualTransformation = PasswordVisualTransformation()\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n\n                RoundedButton(\n                    texto = \"Login\",\n                    colorFondo = MaterialTheme.colorScheme.primary,\n                    modifier = Modifier.fillMaxWidth().height(MaterialTheme.dimens.buttonHeightMedium),\n                    onClick = {}\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n\n                // Bot\u00f3n Registro\n                Text(\n                    text = \"Register\",\n                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold),\n                    color = MaterialTheme.colorScheme.onBackground\n                )\n\n                Spacer(modifier = Modifier.weight(1f))\n\n                // Texto al final de la p\u00e1gina\n                Text(\n                    text = stringResource(R.string.app_name),\n                    style = MaterialTheme.typography.bodyLarge,\n                    color = MaterialTheme.colorScheme.secondary,\n                    modifier = Modifier.padding(bottom = MaterialTheme.dimens.paddingMedium)\n                )\n            }\n        }\n\n    }\n}\n</code></pre> -   Pantalla de registro<p></p> <p></p> </li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#2-extraer-componentes-comunes","title":"2) Extraer componentes comunes","text":"<p>Para facilitar la reutilizaci\u00f3n de los componentes, se han extraido como componentes comunes los siguientes:</p> <ul> <li>TextFieldGS: Para introducir texto</li> <li>RoundedButton: Para los botones redondeados</li> <li>LabeledTextFieldGS: Para los campos de texto con etiqueta</li> </ul> <p>En todos ellos se utiliza el tema MaterialTheme y las dimensiones definidas indicadas para cada tipo de componente.</p> <ul> <li>TextFieldGS <pre><code>@Composable\nfun TextFieldGS(\n    value: String,\n    onValueChange: (String) -&gt; Unit,\n    placeholder: String,\n    modifier: Modifier = Modifier,\n    singleLine: Boolean = true,\n    visualTransformation: VisualTransformation = VisualTransformation.None,\n    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,\n    shape: RoundedCornerShape = RoundedCornerShape(MaterialTheme.dimens.medium),\n    focusedBorderColor: Color = MaterialTheme.colorScheme.primary,\n    unfocusedBorderColor: Color = MaterialTheme.colorScheme.outline,\n    cursorColor: Color = MaterialTheme.colorScheme.primary,\n    placeholderColor: Color = MaterialTheme.colorScheme.secondary\n) {\n    OutlinedTextField(\n        value = value,\n        onValueChange = onValueChange,\n        placeholder = {\n            Text(\n                text = placeholder,\n                color = placeholderColor\n            )\n        },\n        singleLine = singleLine,\n        shape = shape,\n        visualTransformation = visualTransformation,\n        keyboardOptions = keyboardOptions,\n        modifier = modifier,\n        colors = OutlinedTextFieldDefaults.colors(\n            focusedBorderColor = focusedBorderColor,\n            unfocusedBorderColor = unfocusedBorderColor,\n            cursorColor = cursorColor\n        )\n    )\n}\n</code></pre></li> <li> <p>LabeledTextFieldGS</p> <pre><code>@Composable\nfun LabeledTextFieldGS(\n    label: String,\n    value: String,\n    onValueChange: (String) -&gt; Unit,\n    placeholder: String,\n    modifier: Modifier = Modifier,\n    singleLine: Boolean = true,\n    visualTransformation: VisualTransformation = VisualTransformation.None,\n    keyboardOptions: KeyboardOptions = KeyboardOptions.Default,\n    shape: RoundedCornerShape = RoundedCornerShape(16.dp),\n    focusedBorderColor: Color = MaterialTheme.colorScheme.primary,\n    unfocusedBorderColor: Color = MaterialTheme.colorScheme.outline,\n    cursorColor: Color = MaterialTheme.colorScheme.primary,\n    placeholderColor: Color = MaterialTheme.colorScheme.secondary,\n    labelColor: Color = MaterialTheme.colorScheme.onBackground,\n    spacerHeight: Dp = MaterialTheme.dimens.small\n) {\n    val dimens = MaterialTheme.dimens\n\n    Column(modifier = modifier) {\n        // Label\n        Text(\n            text = label,\n            style = MaterialTheme.typography.titleMedium,\n            color = labelColor,\n            modifier = Modifier.fillMaxWidth()\n        )\n\n        Spacer(modifier = Modifier.height(spacerHeight))\n\n        // TextField\n        TextFieldGS(\n            value = value,\n            onValueChange = onValueChange,\n            placeholder = placeholder,\n            modifier = Modifier.fillMaxWidth(),\n            singleLine = singleLine,\n            visualTransformation = visualTransformation,\n            keyboardOptions = keyboardOptions,\n            shape = shape,\n            focusedBorderColor = focusedBorderColor,\n            unfocusedBorderColor = unfocusedBorderColor,\n            cursorColor = cursorColor,\n            placeholderColor = placeholderColor\n        )\n    }\n}\n</code></pre> </li> </ul> <ul> <li> <p>RoundedButton</p> <pre><code>@Composable\nfun BaseBoton(\n    texto: String,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    colorFondo: Color = MaterialTheme.colorScheme.primary, // Color por defecto\n    colorTexto: Color = MaterialTheme.colorScheme.onPrimary,\n    shape: RoundedCornerShape\n) {\n    Button(\n        onClick = onClick,\n        modifier = modifier,\n        colors = ButtonDefaults.buttonColors(\n            containerColor = colorFondo,\n            contentColor = colorTexto\n        ),\n        shape = shape\n    ) {\n        Text(text = texto,style = MaterialTheme.typography.titleMedium)\n    }\n}\n\n@Composable\nfun RoundedButton(\n    texto: String,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier,\n    shape: RoundedCornerShape = RoundedCornerShape(MaterialTheme.dimens.small),\n    colorFondo: Color = MaterialTheme.colorScheme.primary, // Color por defecto\n    colorTexto: Color = MaterialTheme.colorScheme.onPrimary,\n) {\n    BaseBoton(\n        texto = texto,\n        onClick = onClick,\n        colorFondo = colorFondo,\n        colorTexto = colorTexto,\n        shape = shape,\n        modifier = modifier\n    )\n}\n</code></pre> </li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#3-crear-viewmodel-y-uistate","title":"3) Crear ViewModel y UiState","text":""},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#1-por-que-necesitamos-un-viewmodel","title":"1. \u00bfPor qu\u00e9 necesitamos un ViewModel?","text":"<p>El problema inicial</p> <p>Problemas con estado local en Composables</p> <pre><code>@Composable\nfun LoginScreen() {\n    var username by remember { mutableStateOf(\"\") }\n    var password by remember { mutableStateOf(\"\") }\n\n    // \u274c Problemas:\n    // 1. El estado se pierde al rotar la pantalla\n    // 2. La l\u00f3gica de negocio est\u00e1 mezclada con la UI\n    // 3. Dif\u00edcil de testear\n    // 4. No se puede compartir estado entre pantallas\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#la-solucion-arquitectura-mvvm","title":"La soluci\u00f3n: Arquitectura MVVM","text":"<pre><code>graph LR\n    A[Screen/UI] --&gt;|observa| B[ViewModel]\n    B --&gt;|usa| C[Repository]\n    A --&gt;|eventos| B\n    B --&gt;|estado| A</code></pre> <p>Arquitectura MVVM en Android</p> <ul> <li>Video: Arquitectura MVVM en Android</li> <li>Video: Aplicando MVVM y State B\u00e1sico en Jetpack Compose</li> </ul> <p>Ventajas de MVVM</p> <ul> <li>\u2705 Separaci\u00f3n de responsabilidades: UI solo renderiza, ViewModel maneja l\u00f3gica</li> <li>\u2705 Supervivencia al ciclo de vida: El estado sobrevive a rotaciones</li> <li>\u2705 Testeable: Se puede testear la l\u00f3gica sin UI</li> <li>\u2705 Reutilizable: Un ViewModel puede servir a m\u00faltiples pantallas</li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#2-creando-el-uistate","title":"2. Creando el UiState","text":"<p>\u00bfQu\u00e9 es un UiState?</p> <p>Concepto clave</p> <p>El UiState es una fotograf\u00eda inmutable del estado completo de tu pantalla. Es como un contrato de datos que define todos los estados posibles.</p> <p>Paso 1: Definir la data class</p> <pre><code>/**\n * \ud83c\udfa8 UiState: Representa el estado completo de la pantalla de Login\n * \n * @property username Nombre de usuario ingresado\n * @property password Contrase\u00f1a ingresada\n * @property isLoading Indica si hay una operaci\u00f3n en curso\n * @property errorMessage Mensaje de error (null si no hay error)\n * @property isLoginSuccessful Indica si el login fue exitoso\n */\ndata class LoginUiState(\n    val username: String = \"\",\n    val password: String = \"\",\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null,\n    val isLoginSuccessful: Boolean = false\n)\n</code></pre> <p>\u00bfPor qu\u00e9 usar data class?</p> InmutabilidadCopy f\u00e1cilComparaci\u00f3n autom\u00e1tica <pre><code>// \u2705 Valores inmutables (val)\ndata class LoginUiState(\n    val username: String = \"\"\n)\n\n// \u274c Evitar valores mutables (var)\ndata class BadState(\n    var username: String = \"\"\n)\n</code></pre> <pre><code>val oldState = LoginUiState(username = \"admin\")\n\n// Crear nuevo estado con cambios espec\u00edficos\nval newState = oldState.copy(\n    password = \"1234\"\n)\n\nprintln(oldState.username)  // \"admin\"\nprintln(oldState.password)  // \"\"\nprintln(newState.username)  // \"admin\"\nprintln(newState.password)  // \"1234\"\n</code></pre> <pre><code>val state1 = LoginUiState(username = \"admin\")\nval state2 = LoginUiState(username = \"admin\")\nval state3 = LoginUiState(username = \"user\")\n\nprintln(state1 == state2)  // true\nprintln(state1 == state3)  // false\n</code></pre> <p>Buenas pr\u00e1cticas</p> <ul> <li>Usar <code>val</code> en lugar de <code>var</code></li> <li>Proporcionar valores por defecto</li> <li>Usar tipos nullables (<code>String?</code>) para valores opcionales</li> <li>Documentar cada propiedad</li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#3-creando-el-viewmodel","title":"3. Creando el ViewModel","text":"<p>Paso 1: Extender de ViewModel</p> <pre><code>import androidx.lifecycle.ViewModel\n\nclass LoginViewModel : ViewModel() {\n    // La l\u00f3gica va aqu\u00ed\n}\n</code></pre> <p>\u00bfPor qu\u00e9 heredar de ViewModel?</p> <ul> <li>\ud83d\udd04 Sobrevive a rotaciones de pantalla</li> <li>\u267b\ufe0f Tiene un ciclo de vida atado a la navegaci\u00f3n</li> <li>\ud83e\uddf9 Se limpia autom\u00e1ticamente (<code>onCleared()</code>)</li> <li>\ud83c\udfaf Proporciona <code>viewModelScope</code> para coroutines</li> </ul> <p>Paso 2: Crear el StateFlow</p> <p>Gu\u00eda completa de Kotlin Flows</p> <p></p> <pre><code>import kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\n\nclass LoginViewModel : ViewModel() {\n\n    // \ud83d\udd12 Estado PRIVADO (mutable) - Solo el ViewModel puede modificarlo\n    private val _uiState = MutableStateFlow(LoginUiState())\n\n    // \ud83d\udd13 Estado P\u00daBLICO (inmutable) - La UI solo puede leerlo\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n}\n</code></pre> <p>Analog\u00eda del restaurante \ud83c\udf7d\ufe0f</p> <pre><code>graph TD\n    A[Cocina - ViewModel] --&gt;|prepara| B[_uiState MutableStateFlow]\n    B --&gt;|asStateFlow| C[Ventana/Mostrador]\n    C --&gt;|observa| D[Mesa - Screen]\n    D --&gt;|no puede modificar| C\n\n    style A fill:#ff6b6b\n    style B fill:#ffd93d\n    style C fill:#6bcf7f\n    style D fill:#4d96ff</code></pre> <p>Patr\u00f3n de encapsulamiento</p> <pre><code>class LoginViewModel : ViewModel() {\n    // \u274c MAL: Exponer MutableStateFlow directamente\n    val uiState = MutableStateFlow(LoginUiState())\n\n    // \u2705 BIEN: Exponer solo lectura\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n}\n</code></pre> <p>Paso 3: Crear funciones para actualizar el estado</p> <pre><code>import kotlinx.coroutines.flow.update\n\nclass LoginViewModel : ViewModel() {\n\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n\n    /**\n     * \ud83d\udcdd Actualiza el username en el estado\n     * \n     * @param newUsername Nuevo valor del username\n     */\n    fun onUsernameChange(newUsername: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                username = newUsername,\n                errorMessage = null  // Limpia el error al escribir\n            )\n        }\n    }\n\n    /**\n     * \ud83d\udd12 Actualiza el password en el estado\n     * \n     * @param newPassword Nuevo valor del password\n     */\n    fun onPasswordChange(newPassword: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                password = newPassword,\n                errorMessage = null\n            )\n        }\n    }\n}\n</code></pre> <p>\u00bfC\u00f3mo funciona <code>.update()</code>?</p> <pre><code>sequenceDiagram\n    participant U as Usuario\n    participant VM as ViewModel\n    participant S as StateFlow\n    participant UI as Screen\n\n    U-&gt;&gt;VM: onUsernameChange(\"admin\")\n    VM-&gt;&gt;S: _uiState.update { }\n    S-&gt;&gt;S: Estado actual: username=\"\"\n    S-&gt;&gt;S: Crear copia: username=\"admin\"\n    S-&gt;&gt;UI: Emitir nuevo estado\n    UI-&gt;&gt;UI: Recomposici\u00f3n autom\u00e1tica \u2728</code></pre> <p>Ventajas de .update()</p> <ul> <li>Thread-safe: Maneja concurrencia autom\u00e1ticamente</li> <li>At\u00f3mico: La actualizaci\u00f3n se completa o no se hace</li> <li>Reactivo: Notifica a todos los observadores</li> </ul> <p>Paso 4: Implementar la l\u00f3gica del login</p> <pre><code>import androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.launch\n\nclass LoginViewModel : ViewModel() {\n\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n\n    /**\n     * \ud83d\ude80 Ejecuta el proceso de login\n     */\n    fun onLoginClick() {\n        // \ud83d\udd0d PASO 1: Validaciones\n        if (_uiState.value.username.isBlank()) {\n            _uiState.update { \n                it.copy(errorMessage = \"Username cannot be empty\") \n            }\n            return\n        }\n\n        if (_uiState.value.password.isBlank()) {\n            _uiState.update { \n                it.copy(errorMessage = \"Password cannot be empty\") \n            }\n            return\n        }\n\n        // \ud83d\ude80 PASO 2: Iniciar proceso as\u00edncrono\n        viewModelScope.launch {\n\n            // Mostrar loading\n            _uiState.update { \n                it.copy(isLoading = true, errorMessage = null) \n            }\n\n            try {\n                // \ud83c\udf10 PASO 3: Llamada as\u00edncrona (simula API)\n                delay(2000)\n\n                val isValid = validateCredentials(\n                    _uiState.value.username,\n                    _uiState.value.password\n                )\n\n                // \u2705 PASO 4: Actualizar seg\u00fan resultado\n                if (isValid) {\n                    _uiState.update { \n                        it.copy(\n                            isLoading = false,\n                            isLoginSuccessful = true\n                        )\n                    }\n                } else {\n                    _uiState.update { \n                        it.copy(\n                            isLoading = false,\n                            errorMessage = \"Invalid username or password\"\n                        )\n                    }\n                }\n\n            } catch (e: Exception) {\n                // \u274c PASO 5: Manejar errores\n                _uiState.update { \n                    it.copy(\n                        isLoading = false,\n                        errorMessage = \"Network error: ${e.message}\"\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * Simula la validaci\u00f3n de credenciales\n     * TODO: Reemplazar con la l\u00f3gica real de autenticaci\u00f3n\n     */\n    private suspend fun validateCredentials(\n        username: String, \n        password: String\n    ): Boolean {\n        return username == \"admin\" &amp;&amp; password == \"1234\"\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#diagrama-de-estados","title":"Diagrama de estados","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; Idle: Estado inicial\n    Idle --&gt; Validating: Usuario click Login\n    Validating --&gt; Loading: Validaciones OK\n    Validating --&gt; Error: Validaciones fallan\n    Loading --&gt; Success: Credenciales v\u00e1lidas\n    Loading --&gt; Error: Credenciales inv\u00e1lidas\n    Loading --&gt; Error: Error de red\n    Success --&gt; [*]\n    Error --&gt; Idle: Usuario corrige</code></pre> <p>viewModelScope</p> <pre><code>viewModelScope.launch {\n    // Esta coroutine:\n    // - Se ejecuta en el contexto del ViewModel\n    // - Se cancela autom\u00e1ticamente cuando el ViewModel es destruido\n    // - Usa Dispatchers.Main por defecto\n}\n</code></pre> <p>Paso 5: Funciones auxiliares</p> <pre><code>class LoginViewModel : ViewModel() {\n\n    // ... c\u00f3digo anterior ...\n\n    /**\n     * \ud83e\uddf9 Limpia el mensaje de error\n     */\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n\n    /**\n     * \ud83d\udd04 Resetea el estado de login exitoso\n     */\n    fun resetLoginSuccess() {\n        _uiState.update { it.copy(isLoginSuccessful = false) }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#4-conectando-el-viewmodel-con-la-screen","title":"4. Conectando el ViewModel con la Screen","text":"<p>Paso 1: Obtener instancia del ViewModel</p> <pre><code>import androidx.lifecycle.viewmodel.compose.viewModel\n\n@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(),  // \ud83c\udfaf Crea/recupera ViewModel\n    onLoginSuccess: () -&gt; Unit = {}           // \ud83d\ude80 Callback de navegaci\u00f3n\n) {\n    // ...\n}\n</code></pre> <p>\u00bfQu\u00e9 hace <code>viewModel()</code>?</p> <ul> <li>Primera vez: Crea una nueva instancia del ViewModel</li> <li>Recomposiciones: Devuelve la misma instancia</li> <li>Rotaci\u00f3n de pantalla: Devuelve la misma instancia (sobrevive)</li> <li>Navegaci\u00f3n atr\u00e1s: Destruye el ViewModel</li> </ul> <p>Paso 2: Observar el estado con collectAsState()</p> <pre><code>import androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\n\n@Composable\nfun LoginScreen(viewModel: LoginViewModel = viewModel()) {\n\n    // \ud83d\udc40 Observar el estado y recomponer cuando cambie\n    val uiState by viewModel.uiState.collectAsState()\n\n    // Ahora puedes usar:\n    // - uiState.username\n    // - uiState.isLoading\n    // - uiState.errorMessage\n    // etc.\n}\n</code></pre> <p>Flujo de datos</p> <pre><code>graph LR\n    A[ViewModel emite nuevo estado] --&gt; B[StateFlow]\n    B --&gt; C[collectAsState]\n    C --&gt; D[Compose detecta cambio]\n    D --&gt; E[Recomposici\u00f3n autom\u00e1tica \u2728]</code></pre> <p>Paso 3: Vincular el estado con la UI</p> <pre><code>@Composable\nfun LoginScreen(viewModel: LoginViewModel = viewModel()) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    Scaffold(\n        modifier = Modifier.padding(MaterialTheme.dimens.paddingMedium)\n    ) { innerPadding -&gt;\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n        ) {\n            // Campo Username\n            LabeledTextFieldGS(\n                label = \"Username\",\n                value = uiState.username,  // \ud83d\udcd6 Leer del estado\n                onValueChange = { newValue -&gt; viewModel.onUsernameChange(newValue)},  // \u270f\ufe0f Escribir al ViewModel\n                placeholder = \"Enter your username\",\n                modifier = Modifier.fillMaxWidth(),\n                enabled = !uiState.isLoading  // \ud83d\udd12 Deshabilitar durante loading\n            )\n\n            Spacer(modifier = Modifier.height(MaterialTheme.dimens.small))\n\n            // Campo Password\n            LabeledTextFieldGS(\n                label = \"Password\",\n                value = uiState.password,\n                onValueChange = { newValue -&gt; viewModel.onPasswordChange(newValue)},\n                placeholder = \"Enter your password\",\n                modifier = Modifier.fillMaxWidth(),\n                visualTransformation = PasswordVisualTransformation(),\n                enabled = !uiState.isLoading\n            )\n\n            Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n\n            // Bot\u00f3n Login\n            RoundedButton(\n                texto = if (uiState.isLoading) \"Loading...\" else \"Login\",\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .height(MaterialTheme.dimens.buttonHeightMedium),\n                onClick = { viewModel.onLoginClick() },\n                enabled = !uiState.isLoading\n            )\n\n            // Loading indicator\n            if (uiState.isLoading) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .align(Alignment.CenterHorizontally)\n                        .padding(top = MaterialTheme.dimens.medium)\n                )\n            }\n        }\n    }\n}\n</code></pre> <p>Flujo bidireccional de datos</p> <pre><code>sequenceDiagram\n    participant VM as ViewModel\n    participant TF as TextField\n    participant U as Usuario\n\n    Note over VM: username = \"a\"\n    VM-&gt;&gt;TF: Emite estado\n    TF-&gt;&gt;TF: Muestra \"a\"\n    U-&gt;&gt;TF: Escribe \"b\"\n    TF-&gt;&gt;VM: onValueChange(\"ab\")\n    VM-&gt;&gt;VM: username = \"ab\"\n    VM-&gt;&gt;TF: Emite nuevo estado\n    TF-&gt;&gt;TF: Muestra \"ab\"</code></pre> <p>Paso 4: Reaccionar a eventos con LaunchedEffect</p> <pre><code>import androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.material3.SnackbarHostState\n\n@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(),\n    onLoginSuccess: () -&gt; Unit = {}\n) {\n    val uiState by viewModel.uiState.collectAsState()\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // \ud83d\udea8 Mostrar errores\n    LaunchedEffect(uiState.errorMessage) {\n        uiState.errorMessage?.let { error -&gt;\n            snackbarHostState.showSnackbar(error)\n            viewModel.clearError()\n        }\n    }\n\n    // \ud83d\ude80 Navegar cuando login exitoso\n    LaunchedEffect(uiState.isLoginSuccessful) {\n        if (uiState.isLoginSuccessful) {\n            onLoginSuccess()\n            viewModel.resetLoginSuccess()\n        }\n    }\n\n    Scaffold(\n        snackbarHost = { SnackbarHost(hostState = snackbarHostState) }\n    ) { innerPadding -&gt;\n        // ... UI ...\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 LaunchedEffect?</p> <ul> <li>Se ejecuta en un contexto de coroutine</li> <li>Se cancela y reinicia cuando cambia la key</li> <li>Es seguro para operaciones suspendidas como <code>showSnackbar()</code></li> </ul> <pre><code>LaunchedEffect(key) {\n    // Se ejecuta cuando:\n    // 1. El composable entra en la composici\u00f3n\n    // 2. La key cambia\n\n    // Se cancela cuando:\n    // 1. El composable sale de la composici\u00f3n\n    // 2. La key cambia (antes de ejecutar con la nueva key)\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#5-flujo-completo-del-login","title":"5. Flujo Completo del Login","text":""},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#caso-de-uso-usuario-hace-login","title":"Caso de uso: Usuario hace login","text":"<pre><code>sequenceDiagram\n    participant U as Usuario\n    participant S as Screen\n    participant VM as ViewModel\n    participant R as Repository\n\n    U-&gt;&gt;S: Escribe \"admin\"\n    S-&gt;&gt;VM: onUsernameChange(\"admin\")\n    VM-&gt;&gt;VM: _uiState.update { username = \"admin\" }\n    VM-&gt;&gt;S: Emite nuevo estado\n    S-&gt;&gt;S: Recomposici\u00f3n\n\n    U-&gt;&gt;S: Escribe \"1234\"\n    S-&gt;&gt;VM: onPasswordChange(\"1234\")\n    VM-&gt;&gt;VM: _uiState.update { password = \"1234\" }\n    VM-&gt;&gt;S: Emite nuevo estado\n\n    U-&gt;&gt;S: Click en \"Login\"\n    S-&gt;&gt;VM: onLoginClick()\n    VM-&gt;&gt;VM: Validaciones\n    VM-&gt;&gt;VM: _uiState.update { isLoading = true }\n    VM-&gt;&gt;S: Emite estado (loading)\n    S-&gt;&gt;S: Muestra CircularProgressIndicator\n\n    VM-&gt;&gt;R: validateCredentials()\n    R--&gt;&gt;VM: Resultado (success)\n    VM-&gt;&gt;VM: _uiState.update { isLoginSuccessful = true }\n    VM-&gt;&gt;S: Emite estado (success)\n    S-&gt;&gt;S: LaunchedEffect detecta success\n    S-&gt;&gt;S: onLoginSuccess() \u2192 Navega</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#estados-posibles","title":"Estados posibles","text":"Estado InicialUsuario escribiendoLoadingErrorSuccess <pre><code>LoginUiState(\n    username = \"\",\n    password = \"\",\n    isLoading = false,\n    errorMessage = null,\n    isLoginSuccessful = false\n)\n</code></pre> <pre><code>LoginUiState(\n    username = \"admin\",\n    password = \"12\",\n    isLoading = false,\n    errorMessage = null,\n    isLoginSuccessful = false\n)\n</code></pre> <pre><code>LoginUiState(\n    username = \"admin\",\n    password = \"1234\",\n    isLoading = true,  // \u23f3\n    errorMessage = null,\n    isLoginSuccessful = false\n)\n</code></pre> <pre><code>LoginUiState(\n    username = \"admin\",\n    password = \"wrong\",\n    isLoading = false,\n    errorMessage = \"Invalid username or password\",  // \u274c\n    isLoginSuccessful = false\n)\n</code></pre> <pre><code>LoginUiState(\n    username = \"admin\",\n    password = \"1234\",\n    isLoading = false,\n    errorMessage = null,\n    isLoginSuccessful = true  // \u2705\n)\n</code></pre> <p>Ventajas de uso de ViewModel</p> <ul> <li>\u2705 Estado sobrevive a rotaciones</li> <li>\u2705 L\u00f3gica separada de la UI</li> <li>\u2705 Testeable sin UI</li> <li>\u2705 C\u00f3digo organizado y mantenible</li> <li>\u2705 viewModelScope maneja el ciclo de vida</li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#4-crear-repositorio-e-integrar-repositorio","title":"4) Crear Repositorio e integrar repositorio","text":""},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#41-crear-repositorio","title":"4.1) Crear Repositorio","text":"<p>\u00bfQu\u00e9 es un Repository?</p> <p>Concepto clave</p> <p>El Repository es una capa de abstracci\u00f3n que se encarga de manejar el acceso y la gesti\u00f3n de datos. Act\u00faa como intermediario entre el ViewModel y las fuentes de datos, permitiendo que el ViewModel no necesite saber de d\u00f3nde provienen los datos ni c\u00f3mo se obtienen.</p> <p></p> <p>Analog\u00eda simple:</p> <p>Imagina que el ViewModel es un chef de cocina y el Repository es el almac\u00e9n de ingredientes. El chef no necesita saber si los ingredientes vienen del mercado local, de un proveedor internacional o del huerto del restaurante. Solo pide \"tomates\" y el almac\u00e9n se encarga de conseguirlos.</p> <p>Arquitectura actualizada</p> <pre><code>graph LR\n    A[Screen/UI] --&gt;|observa| B[ViewModel]\n    B --&gt;|solicita datos| C[Repository]\n    C --&gt;|devuelve resultado| B\n\n    style A fill:#4d96ff\n    style B fill:#ff6b6b\n    style C fill:#6bcf7f</code></pre> <p>Beneficios de usar Repositorio</p> <ul> <li>\u2705 Separaci\u00f3n de responsabilidades: El ViewModel no sabe de d\u00f3nde vienen los datos</li> <li>\u2705 Testeable: Podemos crear implementaciones falsas (mocks) para testing</li> <li>\u2705 Reutilizable: M\u00faltiples ViewModels pueden usar el mismo Repository</li> <li>\u2705 Mantenible: Cambiar la fuente de datos no afecta al ViewModel</li> <li>\u2705 Escalable: F\u00e1cil de evolucionar cuando agreguemos APIs o bases de datos</li> </ul> <p>Paso 1: Crear la interfaz AuthRepository</p> <p>Primero definimos un contrato (interfaz) que especifica qu\u00e9 operaciones puede hacer nuestro repositorio:</p> <pre><code>package com.pmdm.mygamestore.data.repository\n\n/**\n * \ud83d\udccb Interfaz que define las operaciones de autenticaci\u00f3n\n * \n * Usar una interfaz permite:\n * - Cambiar la implementaci\u00f3n sin modificar el ViewModel\n * - Crear implementaciones de prueba para testing\n * - Aplicar el principio de Inversi\u00f3n de Dependencias\n */\ninterface AuthRepository {\n    /**\n     * Intenta autenticar a un usuario\n     * \n     * @param username Nombre de usuario\n     * @param password Contrase\u00f1a\n     * @return LoginResult indicando \u00e9xito o error\n     */\n    suspend fun login(username: String, password: String): LoginResult\n}\n</code></pre> <p>\u00bfPor qu\u00e9 usar una interfaz?</p> <ul> <li>Flexibilidad: Podemos tener diferentes implementaciones (local, API, mock para tests)</li> <li>Testeable: En tests podemos crear un <code>FakeAuthRepository</code> sin tocar el c\u00f3digo real</li> <li>Principio SOLID: Inversi\u00f3n de dependencias - dependemos de abstracciones, no de implementaciones concretas</li> </ul> <p>Paso 2: Crear LoginResult con sealed class</p> <p>Antes de implementar el Repository, necesitamos definir c\u00f3mo representamos los resultados del login:</p> <pre><code>package com.pmdm.mygamestore.data.repository\n\n//data/repository/Result.kt\n/**\n * \ud83c\udfaf Sealed class que representa los posibles resultados de un login\n * \n * Una sealed class permite:\n * - Definir un conjunto cerrado y conocido de posibilidades\n * - Usar when exhaustivo (el compilador verifica que cubrimos todos los casos)\n * - Evitar errores con null o excepciones no controladas\n */\nsealed class LoginResult {\n    /**\n     * Login exitoso\n     * @param username Nombre del usuario autenticado\n     */\n    data class Success(val username: String) : LoginResult()\n\n    /**\n     * Login fallido\n     * @param message Mensaje describiendo el error\n     */\n    data class Error(val message: String) : LoginResult()\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#por-que-sealed-class-en-lugar-de-otras-alternativas","title":"\u00bfPor qu\u00e9 sealed class en lugar de otras alternativas?","text":"\u274c Opci\u00f3n 1: Boolean\u274c Opci\u00f3n 2: Excepciones\u274c Opci\u00f3n 3: Nullable\u2705 Opci\u00f3n 4: Sealed Class <pre><code>// \u274c MAL: Solo sabemos si funcion\u00f3 o no\nsuspend fun login(username: String, password: String): Boolean\n\n// Problemas:\n// - No sabemos QU\u00c9 fall\u00f3\n// - No podemos devolver datos adicionales del usuario\n// - Limitado a dos estados (true/false)\n</code></pre> <pre><code>// \u274c MAL: Usar excepciones para flujo normal\nsuspend fun login(username: String, password: String): User {\n    if (invalid) throw LoginException(\"Invalid credentials\")\n    return user\n}\n\n// Problemas:\n// - Las excepciones son para casos excepcionales, no flujo normal\n// - Dificulta el testing\n// - Menos performante\n// - No sabemos qu\u00e9 excepciones puede lanzar sin leer el c\u00f3digo\n</code></pre> <pre><code>// \u274c MAL: User nullable\nsuspend fun login(username: String, password: String): User?\n\n// Problemas:\n// - null puede significar muchas cosas (\u00bferror de red?, \u00bfcredenciales inv\u00e1lidas?)\n// - No podemos devolver informaci\u00f3n sobre el error\n</code></pre> <pre><code>// \u2705 BIEN: Estados expl\u00edcitos y tipados\nsuspend fun login(username: String, password: String): LoginResult\n\n// Ventajas:\n// - Estados claros y expl\u00edcitos\n// - Compilador verifica que manejamos todos los casos\n// - Podemos incluir datos espec\u00edficos en cada caso\n// - F\u00e1cil de extender (agregar estado Loading, etc.)\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#uso-de-when-exhaustivo-con-sealed-class","title":"Uso de when exhaustivo con sealed class","text":"<pre><code>when (result) {\n    is LoginResult.Success -&gt; {\n        // El compilador sabe que result.username existe\n        println(\"Bienvenido ${result.username}\")\n    }\n    is LoginResult.Error -&gt; {\n        // El compilador sabe que result.message existe\n        println(\"Error: ${result.message}\")\n    }\n    // \u2705 No necesitamos 'else' - el compilador verifica que cubrimos todos los casos\n}\n</code></pre> <p>Sealed class vs Enum</p> <ul> <li>Enum: Todos los casos son instancias simples sin datos</li> <li>Sealed class: Cada caso puede tener datos diferentes</li> </ul> <pre><code>// Enum: Todos iguales\nenum class Status { SUCCESS, ERROR }\n\n// Sealed: Cada uno con sus datos\nsealed class LoginResult {\n    data class Success(val username: String) : LoginResult()\n    data class Error(val message: String) : LoginResult()\n}\n</code></pre> <p>Paso 3: Implementar AuthRepositoryImpl</p> <p>Ahora creamos la implementaci\u00f3n concreta del repositorio:</p> <pre><code>package com.pmdm.mygamestore.data.repository\n\nimport kotlinx.coroutines.delay\n\n/**\n * \ud83d\udd27 Implementaci\u00f3n local del repositorio de autenticaci\u00f3n\n * \n * Esta implementaci\u00f3n valida credenciales contra una lista local.\n * Simula el comportamiento de una fuente de datos real con delay.\n */\nclass AuthRepositoryImpl : AuthRepository {\n\n    /**\n     * Usuarios v\u00e1lidos para login (simulaci\u00f3n local)\n     * En un escenario real, esto vendr\u00eda de una API o base de datos\n     */\n    private val validUsers = mapOf(\n        \"admin\" to \"1234\",\n        \"user\" to \"password\"\n    )\n\n    /**\n     * Valida las credenciales del usuario\n     * \n     * @param username Nombre de usuario\n     * @param password Contrase\u00f1a\n     * @return LoginResult.Success si las credenciales son correctas,\n     *         LoginResult.Error en caso contrario\n     */\n    override suspend fun login(username: String, password: String): LoginResult {\n        // Simula el tiempo que tomar\u00eda una operaci\u00f3n real\n        // (consulta a API, lectura de base de datos, etc.)\n        delay(1500)\n\n        // Validar credenciales\n        return if (validUsers[username] == password) {\n            LoginResult.Success(username = username)\n        } else {\n            LoginResult.Error(message = \"Invalid username or password\")\n        }\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 el delay?</p> <p>El <code>delay(1500)</code> simula que la operaci\u00f3n tarda tiempo, como pasar\u00eda con: - Una llamada a una API remota - Una consulta a base de datos - Procesamiento de encriptaci\u00f3n \u00ba Esto ayuda a: - Ver el estado de <code>isLoading</code> en acci\u00f3n - Preparar el c\u00f3digo para operaciones as\u00edncronas reales - Hacer la simulaci\u00f3n m\u00e1s realista</p>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#42-integrar-repositorio-en-viewmodel","title":"4.2) Integrar repositorio en ViewModel","text":"<p>Paso 4: Refactorizar el ViewModel</p> <p>Ahora modificamos el ViewModel para usar el Repository en lugar de validar directamente:</p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.pmdm.mygamestore.data.repository.AuthRepository\nimport com.pmdm.mygamestore.data.repository.AuthRepositoryImpl\nimport com.pmdm.mygamestore.data.repository.LoginResult\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\n\ndata class LoginUiState(\n    val username: String = \"\",\n    val password: String = \"\",\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null,\n    val isLoginSuccessful: Boolean = false\n)\n\n/**\n * ViewModel para gestionar el estado y la l\u00f3gica de la pantalla de Login\n * \n * @param authRepository Repositorio para operaciones de autenticaci\u00f3n\n */\nclass LoginViewModel(\n    private val authRepository: AuthRepository = AuthRepositoryImpl()\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n\n    fun onUsernameChange(newUsername: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                username = newUsername,\n                errorMessage = null\n            )\n        }\n    }\n\n    fun onPasswordChange(newPassword: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                password = newPassword,\n                errorMessage = null\n            )\n        }\n    }\n\n    /**\n     * Ejecuta el proceso de login usando el Repository\n     */\n    fun onLoginClick() {\n        // Validaciones de UI\n        if (_uiState.value.username.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Username cannot be empty\") }\n            return\n        }\n\n        if (_uiState.value.password.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Password cannot be empty\") }\n            return\n        }\n\n        // Proceso de login\n        viewModelScope.launch {\n            // Mostrar loading\n            _uiState.update { it.copy(isLoading = true, errorMessage = null) }\n\n            // Llamar al Repository\n            val result = authRepository.login(\n                username = _uiState.value.username,\n                password = _uiState.value.password\n            )\n\n            // Manejar resultado con when exhaustivo\n            when (result) {\n                is LoginResult.Success -&gt; {\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            isLoginSuccessful = true,\n                            errorMessage = null\n                        )\n                    }\n                }\n\n                is LoginResult.Error -&gt; {\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            isLoginSuccessful = false,\n                            errorMessage = result.message\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n\n    fun resetLoginSuccess() {\n        _uiState.update { it.copy(isLoginSuccessful = false) }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#43-flujo-completo-de-datos","title":"4.3) Flujo completo de datos","text":"<pre><code>sequenceDiagram\n    participant U as Usuario\n    participant S as Screen\n    participant VM as ViewModel\n    participant R as Repository\n\n    U-&gt;&gt;S: Ingresa credenciales\n    U-&gt;&gt;S: Click \"Login\"\n    S-&gt;&gt;VM: onLoginClick()\n\n    Note over VM: Validaciones de UI\n\n    VM-&gt;&gt;VM: _uiState.update { isLoading = true }\n    VM-&gt;&gt;S: Emite estado (loading)\n    S-&gt;&gt;S: Muestra CircularProgressIndicator\n\n    VM-&gt;&gt;R: login(username, password)\n\n    Note over R: delay(1500)&lt;br/&gt;Valida credenciales\n\n    alt Credenciales v\u00e1lidas\n        R--&gt;&gt;VM: LoginResult.Success(username)\n        VM-&gt;&gt;VM: _uiState.update { isLoginSuccessful = true }\n        VM-&gt;&gt;S: Emite estado (success)\n        S-&gt;&gt;S: Navega a Home\n    else Credenciales inv\u00e1lidas\n        R--&gt;&gt;VM: LoginResult.Error(\"Invalid...\")\n        VM-&gt;&gt;VM: _uiState.update { errorMessage = \"...\" }\n        VM-&gt;&gt;S: Emite estado (error)\n        S-&gt;&gt;S: Muestra Snackbar con error\n    end</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#44-comparacion-antes-vs-despues","title":"4.4) Comparaci\u00f3n: Antes vs Despu\u00e9s","text":"\u274c Antes (sin Repository)\u2705 Despu\u00e9s (con Repository) <pre><code>class LoginViewModel : ViewModel() {\n\n    fun onLoginClick() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n\n            delay(2000)\n\n            // \u274c L\u00f3gica de validaci\u00f3n en el ViewModel\n            val isValid = (username == \"admin\" &amp;&amp; password == \"1234\")\n\n            if (isValid) {\n                _uiState.update { it.copy(isLoginSuccessful = true) }\n            } else {\n                _uiState.update { it.copy(errorMessage = \"Invalid\") }\n            }\n        }\n    }\n}\n</code></pre> <p>Problemas: - L\u00f3gica de datos mezclada con l\u00f3gica de presentaci\u00f3n - Dif\u00edcil de testear sin ejecutar coroutines - No reutilizable - Dif\u00edcil de cambiar la fuente de datos</p> <pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository = AuthRepositoryImpl()\n) : ViewModel() {\n\n    fun onLoginClick() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n\n            // \u2705 Delegamos al Repository\n            val result = authRepository.login(username, password)\n\n            when (result) {\n                is LoginResult.Success -&gt; { /* ... */ }\n                is LoginResult.Error -&gt; { /* ... */ }\n            }\n        }\n    }\n}\n</code></pre> <p>Ventajas de uso de Repository</p> <ul> <li>\u2705 Responsabilidades separadas</li> <li>\u2705 F\u00e1cil de testear (mock del Repository)</li> <li>\u2705 Reutilizable (otros ViewModels pueden usar AuthRepository)</li> <li>\u2705 F\u00e1cil de evolucionar</li> </ul>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#responsabilidades-de-cada-capa","title":"Responsabilidades de cada capa","text":"Capa Responsabilidades NO debe hacer Screen - Mostrar UI- Capturar eventos- Navegar - L\u00f3gica de negocio- Acceder a datos ViewModel - Mantener estado de UI- Validaciones de UI- Coordinar operaciones - Acceso directo a datos- L\u00f3gica de fuentes de datos Repository - Acceder a fuentes de datos- Validar credenciales- Transformar datos - Conocer detalles de UI- Mantener estado de UI <p>Arquitectura actual con ViewModel y Repositorio:</p> <pre><code>graph TD\n    A[LoginScreen] --&gt;|eventos| B[LoginViewModel]\n    B --&gt;|solicita| C[AuthRepository Interface]\n    C --&gt;|implementa| D[AuthRepositoryImpl]\n    D --&gt;|devuelve| E[LoginResult]\n    E --&gt;|Success/Error| B\n    B --&gt;|estado| A\n\n    style A fill:#4d96ff\n    style B fill:#ff6b6b\n    style C fill:#a29bfe\n    style D fill:#6bcf7f\n    style E fill:#ffd93d</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#5-implementar-navegacion","title":"5) Implementar navegaci\u00f3n","text":""},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#como-funciona-la-navegacion","title":"\u00bfC\u00f3mo funciona la navegaci\u00f3n?","text":"<p>Concepto clave</p> <p>La navegaci\u00f3n en Jetpack Compose se maneja mediante un backStack (pila de navegaci\u00f3n) que mantiene el historial de pantallas visitadas. Cada pantalla se comunica con el sistema de navegaci\u00f3n mediante callbacks (funciones que se ejecutan cuando ocurre un evento).</p> <p>Paso 1: Entender el flujo de navegaci\u00f3n</p> <p>La navegaci\u00f3n tras un login exitoso sigue estos pasos:</p> <pre><code>sequenceDiagram\n    participant VM as ViewModel\n    participant LS as LoginScreen\n    participant NG as NavGraph\n    participant BS as BackStack\n    participant HS as HomeScreen\n\n    VM-&gt;&gt;VM: isLoginSuccessful = true\n    VM-&gt;&gt;LS: Emite nuevo estado\n    LS-&gt;&gt;LS: LaunchedEffect detecta cambio\n    LS-&gt;&gt;NG: onLoginSuccess()\n    NG-&gt;&gt;BS: backStack.clear()\n    NG-&gt;&gt;BS: backStack.add(AppRoutes.Home)\n    BS-&gt;&gt;HS: Navega y muestra pantalla</code></pre>"},{"location":"temas/proyectos/GameVault/02-LoginScreen.html#conceptos-clave","title":"Conceptos clave","text":"CallbackBackStackLaunchedEffect <pre><code>// Un callback es una funci\u00f3n que se pasa como par\u00e1metro\n@Composable\nfun LoginScreen(\n    onLoginSuccess: () -&gt; Unit = {}  // \ud83d\udc48 Callback\n) {\n    // Cuando algo sucede, ejecutamos el callback\n    onLoginSuccess()\n}\n</code></pre> <p>\u00bfPara qu\u00e9 sirve?</p> <ul> <li>Permite que LoginScreen notifique eventos sin conocer los detalles</li> <li>Separa la responsabilidad: LoginScreen no sabe c\u00f3mo navegar</li> <li>Hace el componente reutilizable</li> </ul> <pre><code>// El backStack es una lista de pantallas\nval backStack = rememberNavBackStack(AppRoutes.Login)\n\n// Agregar pantalla\nbackStack.add(AppRoutes.Home)\n\n// Volver atr\u00e1s\nbackStack.removeLastOrNull()\n\n// Limpiar todo el historial\nbackStack.clear()\n</code></pre> <p>Funcionamiento: </p><pre><code>Estado inicial:  [Login]\nUsuario navega:  [Login, Home]\nUsuario vuelve:  [Login]\n</code></pre><p></p> <pre><code>LaunchedEffect(uiState.isLoginSuccessful) {\n    if (uiState.isLoginSuccessful) {\n        onLoginSuccess()  // Ejecuta navegaci\u00f3n\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 LaunchedEffect?</p> <ul> <li>Se ejecuta cuando cambia la key (<code>isLoginSuccessful</code>)</li> <li>Perfecto para efectos secundarios (navegaci\u00f3n, mostrar mensajes)</li> <li>Evita ejecutar la navegaci\u00f3n en cada recomposici\u00f3n</li> </ul> <p>Paso 2: Implementar el callback en LoginScreen</p> <p>En <code>LoginScreen.kt</code>, ya tenemos implementado el mecanismo de navegaci\u00f3n:</p> <pre><code>@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(),\n    onLoginSuccess: () -&gt; Unit = {}  // \ud83d\udc48 Callback de navegaci\u00f3n\n) {\n    val uiState by viewModel.uiState.collectAsState()\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // \ud83d\ude80 Detecta cuando el login es exitoso\n    LaunchedEffect(uiState.isLoginSuccessful) {\n        if (uiState.isLoginSuccessful) {\n            onLoginSuccess()  // \ud83d\udc48 Ejecuta el callback\n            viewModel.resetLoginSuccess()  // Resetea el estado\n        }\n    }\n\n    // ... resto del c\u00f3digo de UI\n}\n</code></pre> <p>\u00bfPor qu\u00e9 resetear el estado?</p> <pre><code>viewModel.resetLoginSuccess()\n</code></pre> <p>Despu\u00e9s de navegar, reseteamos <code>isLoginSuccessful</code> a <code>false</code> para evitar: - Navegaciones m\u00faltiples si el usuario vuelve atr\u00e1s - Estados inconsistentes - Loops de navegaci\u00f3n</p> <p>Paso 3: Configurar la navegaci\u00f3n en NavGraph</p> <p>ubicaci\u00f3n:: <code>presentation/ui/navigation/NavGraph.kt</code></p> <p>Ahora configuramos qu\u00e9 sucede cuando se ejecuta <code>onLoginSuccess</code>:</p> <pre><code>@Composable\nfun AppNavigation() {\n    val backStack = rememberNavBackStack(AppRoutes.Login)\n\n    CompositionLocalProvider(LocalNavStack provides backStack) {\n        NavDisplay(\n            backStack = backStack,\n            onBack = { backStack.removeLastOrNull() },\n            entryProvider = entryProvider {\n\n                // Pantalla de Login\n                entry(AppRoutes.Login) {\n                    val navStack = LocalNavStack.current  // \ud83d\udc48 Acceso al backStack\n\n                    LoginScreen(\n                        onLoginSuccess = {\n                            // \ud83e\uddf9 Limpiar historial de navegaci\u00f3n\n                            navStack.clear()\n\n                            // \ud83c\udfe0 Navegar a Home\n                            navStack.add(AppRoutes.Home)\n                        }\n                    )\n                }\n\n                // Pantalla de Home\n                entry(AppRoutes.Home) {\n                    HomeScreen()\n                }\n\n                // ... otras pantallas\n            }\n        )\n    }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 limpiar el backStack?</p> <pre><code>navStack.clear()  // Elimina todo el historial\nnavStack.add(AppRoutes.Home)  // Solo queda Home\n</code></pre> <p>Dos estrategias de navegaci\u00f3n:</p> Sin limpiar (\u274c)Limpiando (\u2705) <pre><code>onLoginSuccess = {\n    navStack.add(AppRoutes.Home)  // \u274c Login queda en el historial\n}\n</code></pre> <p>Resultado: </p><pre><code>BackStack: [Login, Home]\n</code></pre><p></p> <p>Problema:</p> <ul> <li>Usuario presiona \"Atr\u00e1s\" \u2192 Vuelve a Login</li> <li>Mala experiencia: ya est\u00e1 logueado</li> <li>Comportamiento inesperado</li> </ul> <pre><code>onLoginSuccess = {\n    navStack.clear()\n    navStack.add(AppRoutes.Home)  // \u2705 Solo queda Home\n}\n</code></pre> <p>Resultado: </p><pre><code>BackStack: [Home]\n</code></pre><p></p> <p>Ventajas:</p> <ul> <li>Usuario presiona \"Atr\u00e1s\" \u2192 Sale de la app</li> <li>Comportamiento esperado</li> <li>Usuario no puede volver a Login sin cerrar sesi\u00f3n</li> </ul> <p>Paso 4: Flujo completo de navegaci\u00f3n</p> <pre><code>sequenceDiagram\n    Note over U,LS: App inicia\n    U-&gt;&gt;LS: Ingresa credenciales\n    U-&gt;&gt;LS: Click \"Login\"\n    LS-&gt;&gt;VM: onLoginClick()\n\n    Note over VM: Validaciones\n    VM-&gt;&gt;VM: username/password OK \u2713\n\n    VM-&gt;&gt;VM: isLoading = true\n    VM-&gt;&gt;LS: Emite estado (loading)\n    LS-&gt;&gt;LS: Muestra CircularProgressIndicator\n\n    VM-&gt;&gt;R: login(username, password)\n    Note over R: delay(1500ms)&lt;br/&gt;Valida credenciales\n    R--&gt;&gt;VM: LoginResult.Success\n\n    VM-&gt;&gt;VM: isLoginSuccessful = true\n    VM-&gt;&gt;LS: Emite nuevo estado\n\n    Note over LS: LaunchedEffect detecta cambio\n    LS-&gt;&gt;NG: onLoginSuccess()\n    VM-&gt;&gt;VM: resetLoginSuccess()\n\n    NG-&gt;&gt;BS: navStack.clear()\n    Note over BS: \u274c Elimina Login del historial&lt;br/&gt;Usuario no puede volver atr\u00e1s\n\n    NG-&gt;&gt;BS: navStack.add(AppRoutes.Home)\n    BS-&gt;&gt;HS: Navega y muestra HomeScreen\n\n    Note over U,HS: Usuario en Home\n    U-&gt;&gt;HS: Presiona bot\u00f3n \"Atr\u00e1s\"\n    HS--&gt;&gt;U: Sale de la app (no hay m\u00e1s pantallas)</code></pre> <p>Prevenir navegaci\u00f3n atr\u00e1s: Problemas de seguridad y UX</p> <ul> <li>\ud83d\udd12 Seguridad: Usuario ya est\u00e1 autenticado, no tiene sentido volver a Login</li> <li>\ud83d\udd04 Estado inconsistente: \u00bfQu\u00e9 pasa si vuelve a Login? \u00bfSigue logueado?</li> <li>\ud83d\ude15 Confusi\u00f3n: Usuario no entiende por qu\u00e9 ve Login si ya ingres\u00f3</li> <li>\ud83d\udc1b Bugs potenciales: Doble login, sesiones duplicadas</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html","title":"3. Preferencias","text":""},{"location":"temas/proyectos/GameVault/03-Preferences.html#3-persistencia-y-navegacion-completa-del-login","title":"3. Persistencia y Navegaci\u00f3n Completa del Login","text":"<p>En esta 3\u00aa parte del proyecto, vamos a resolver c\u00f3mo y donde almacenar la informaci\u00f3n de la sesi\u00f3n del usuario, y c\u00f3mo integrarla dentro de la App, teniendo en cuenta los casos de uso del Login e inicio de la App en funci\u00f3n de si el usuario est\u00e1 logueado o no.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#resumen","title":"Resumen","text":"<ol> <li>Guardar preferencias de Usuario con DataStore</li> <li>Integrar la navegaci\u00f3n en el flujo del Login</li> </ol>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#1-guardar-preferencias-de-usuario-con-datastore","title":"1. Guardar Preferencias de Usuario con DataStore","text":""},{"location":"temas/proyectos/GameVault/03-Preferences.html#11-que-es-la-persistencia-de-sesion","title":"1.1. \u00bfQu\u00e9 es la persistencia de sesi\u00f3n?","text":"<p>Concepto clave</p> <p>La persistencia de sesi\u00f3n es la capacidad de la aplicaci\u00f3n de \"recordar\" que un usuario ya se autentic\u00f3, incluso despu\u00e9s de cerrar y volver a abrir la app. Esto mejora la experiencia del usuario al no obligarlo a iniciar sesi\u00f3n constantemente.</p> <p>Ejemplos de uso:</p> <ul> <li>Usuario hace login \u2192 Cierra la app \u2192 Abre la app \u2192 Va directo a Home \u2705</li> <li>Usuario hace logout \u2192 Cierra la app \u2192 Abre la app \u2192 Ve pantalla de Login \u2705</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#12-que-es-datastore","title":"1.2. \u00bfQu\u00e9 es DataStore?","text":"<p>DataStore es la soluci\u00f3n moderna de Android para almacenar datos de preferencias de forma as\u00edncrona, segura y eficiente.</p>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#comparacion-con-sharedpreferences","title":"Comparaci\u00f3n con SharedPreferences","text":"SharedPreferences (\u274c Antiguo)DataStore (\u2705 Moderno) <pre><code>// \u274c S\u00edncrono (bloquea el hilo principal)\nval prefs = getSharedPreferences(\"user_prefs\", MODE_PRIVATE)\nprefs.edit().putBoolean(\"is_logged_in\", true).apply()\n\n// \u274c No type-safe\nval isLoggedIn = prefs.getBoolean(\"is_logged_in\", false)\n\n// \u274c Puede causar ANR (Application Not Responding)\n</code></pre> <pre><code>// \u2705 As\u00edncrono (no bloquea)\ndataStore.edit { preferences -&gt;\n    preferences[IS_LOGGED_IN] = true\n}\n\n// \u2705 Type-safe con keys tipadas\nval isLoggedIn: Flow&lt;Boolean&gt; = dataStore.data\n    .map { it[IS_LOGGED_IN] ?: false }\n\n// \u2705 Reactivo con Flow\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#tipos-de-datastore","title":"Tipos de DataStore","text":"Tipo Uso Complejidad Preferences DataStore Datos simples (clave-valor) \u2b50 Baja Proto DataStore Datos estructurados (objetos) \u2b50\u2b50\u2b50 Alta <p>Usaremos Preferences DataStore</p> <p>Para guardar el estado de sesi\u00f3n (logueado/no logueado y username), Preferences DataStore es perfecto y m\u00e1s simple.</p> <p>M\u00e1s informaci\u00f3n</p> <ul> <li>Documentaci\u00f3n oficial de DataStore</li> <li>Migrar de SharedPreferences a DataStore</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#13-agregar-dependencias","title":"1.3. Agregar dependencias","text":"<p>Paso 1: Abre <code>libs.versions.toml</code> y agrega la versi\u00f3n en la secci\u00f3n [versions].</p> <pre><code>[versions]\n# ... otras versiones\ndatastore = \"1.2.0\"\n</code></pre> <p>y la libreria en la secci\u00f3n de [liraries]:</p> <pre><code>[libraries]\n# ... otras librer\u00edas\n\n# DataStore Preferences\nandroidx-datastore-preferences = { group = \"androidx.datastore\", name = \"datastore-preferences\", version.ref = \"datastore\" }\n</code></pre> <p>Paso 2: Abre el archivo <code>build.gradle.kts</code> del m\u00f3dulo <code>app</code>:</p> <pre><code>// app/build.gradle.kts\ndependencies {\n    // ... otras dependencias\n\n    // DataStore Preferences\n    implementation(libs.androidx.datastore.preferences)\n}\n</code></pre> <p>Paso 2: Sincroniza el proyecto haciendo clic en \"Sync Now\".</p> <p>Versi\u00f3n de DataStore</p> <p>Aseg\u00farate de usar la versi\u00f3n <code>1.0.0</code> o superior. Si usas versiones anteriores (0.x), la API puede ser diferente.</p>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#14-crear-la-interfaz-sessionmanager","title":"1.4. Crear la interfaz SessionManager","text":"<p>Al igual que hicimos con <code>AuthRepository</code>, creamos primero una interfaz para definir el contrato:</p> <p>Ubicaci\u00f3n: <code>data/local/SessionManager.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.local\n\nimport kotlinx.coroutines.flow.Flow\n\n/**\n * \ud83d\udccb Interfaz que define las operaciones de gesti\u00f3n de sesi\u00f3n\n * \n * Usar una interfaz permite:\n * - Cambiar la implementaci\u00f3n (DataStore, Room, etc.) sin modificar el c\u00f3digo que la usa\n * - Crear implementaciones de prueba para testing\n * - Aplicar el principio de Inversi\u00f3n de Dependencias\n */\ninterface SessionManager {\n\n    /**\n     * Guarda la sesi\u00f3n del usuario\n     * \n     * @param username Nombre del usuario autenticado\n     */\n    suspend fun saveSession(username: String)\n\n    /**\n     * Verifica si hay un usuario con sesi\u00f3n activa\n     * \n     * @return Flow que emite true si hay sesi\u00f3n activa, false en caso contrario\n     */\n    fun isUserLoggedIn(): Flow&lt;Boolean&gt;\n\n    /**\n     * Obtiene el nombre del usuario de la sesi\u00f3n activa\n     * \n     * @return Flow que emite el username o null si no hay sesi\u00f3n\n     */\n    fun getUsername(): Flow&lt;String?&gt;\n\n    /**\n     * Limpia la sesi\u00f3n del usuario (logout)\n     */\n    suspend fun clearSession()\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#por-que-usar-flow","title":"\u00bfPor qu\u00e9 usar Flow?","text":"<p>Flow vs suspend fun</p> <pre><code>// \u274c suspend fun devuelve un valor \u00fanico\nsuspend fun isUserLoggedIn(): Boolean\n\n// \u2705 Flow emite valores continuamente\nfun isUserLoggedIn(): Flow&lt;Boolean&gt;\n</code></pre> <p>Ventajas de Flow:</p> <ul> <li>Reactivo: Cuando cambia el valor en DataStore, Flow emite el nuevo valor autom\u00e1ticamente</li> <li>Observable: M\u00faltiples observadores pueden escuchar cambios</li> <li>Lifecycle-aware: Se puede convertir a State en Compose con <code>collectAsState()</code></li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#15-entendiendo-context-en-android","title":"1.5. Entendiendo Context en Android","text":""},{"location":"temas/proyectos/GameVault/03-Preferences.html#que-es-context","title":"\u00bfQu\u00e9 es Context?","text":"<p>Concepto clave</p> <p>Context es una clase fundamental de Android que proporciona acceso a recursos de la aplicaci\u00f3n, servicios del sistema, y funcionalidades espec\u00edficas del entorno de ejecuci\u00f3n. Es como un \"puente\" entre tu c\u00f3digo y el sistema operativo Android.</p> <p>Analog\u00eda:</p> <p>Imagina que Context es como tu tarjeta de identificaci\u00f3n en una gran empresa:</p> <ul> <li>Te permite acceder a diferentes departamentos (recursos, bases de datos, preferencias)</li> <li>Te identifica dentro del sistema (nombre del paquete, informaci\u00f3n de la app)</li> <li>Te da permisos para usar servicios (archivos, red, sensores)</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#tipos-de-context","title":"Tipos de Context","text":"<p>Android proporciona diferentes tipos de Context seg\u00fan el alcance y ciclo de vida:</p> Application ContextActivity ContextCompose Context <pre><code>val appContext = context.applicationContext\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u2705 Vive durante toda la vida de la aplicaci\u00f3n</li> <li>\u2705 Es un singleton (una sola instancia)</li> <li>\u2705 No est\u00e1 atado a ninguna Activity espec\u00edfica</li> <li>\u2705 Perfecto para servicios de larga duraci\u00f3n (DataStore, Repositories)</li> </ul> <p>Cu\u00e1ndo usarlo:</p> <ul> <li>DataStore, SharedPreferences</li> <li>Repositories</li> <li>Singletons que viven toda la app</li> </ul> <p>Cu\u00e1ndo NO usarlo:</p> <ul> <li>\u274c Para inflar vistas (layouts)</li> <li>\u274c Para mostrar di\u00e1logos</li> </ul> <pre><code>class LoginActivity : ComponentActivity() {\n    // 'this' es el Activity Context\n    val context: Context = this\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\u23f1\ufe0f Vive mientras la Activity existe</li> <li>\ud83c\udfa8 Tiene informaci\u00f3n del tema (Theme)</li> <li>\ud83d\udcf1 Vinculado a la pantalla actual</li> </ul> <p>Cu\u00e1ndo usarlo:</p> <ul> <li>Inflar layouts</li> <li>Mostrar di\u00e1logos</li> <li>Acceder a recursos con tema</li> </ul> <p>Cu\u00e1ndo NO usarlo: - \u274c En objetos que viven m\u00e1s que la Activity (memory leak)</p> <pre><code>@Composable\nfun MyScreen() {\n    val context = LocalContext.current\n}\n</code></pre> <p>Caracter\u00edsticas:</p> <ul> <li>\ud83c\udfaf Context del composable actual</li> <li>\ud83d\udd04 Cambia al recomponer si es necesario</li> <li>\u2705 Seguro para usar en Compose</li> </ul> <p>Cu\u00e1ndo usarlo:</p> <ul> <li>Acceder a recursos (@string, @drawable)</li> <li>Mostrar Toasts o navegar</li> </ul> <p>Context en nuevo proyecto</p> <p>En el nuevo proyecto, SessionManager necesita Context para acceder a DataStore, y la mejore forma es pasarle el <code>applicationContext</code>.</p> <p>Obtener Context en Compose</p> <p>En Jetpack Compose, obtenemos el Context usando <code>LocalContext.current</code>:</p> <p>\u00bfQu\u00e9 es <code>LocalContext</code>?</p> <p><code>LocalContext</code> proporciona acceso al Context actual en el \u00e1rbol de composici\u00f3n.</p> <pre><code>// Definido por Compose\nval LocalContext = staticCompositionLocalOf&lt;Context&gt; {\n    error(\"No Context provided\")\n}\n\n// Uso\n@Composable\nfun MyComposable() {\n    val context = LocalContext.current  // \u2705 Context seguro\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#comparacion-de-enfoques","title":"Comparaci\u00f3n de enfoques","text":"Aspecto Activity Context Application Context Ciclo de vida Mientras vive la Activity Toda la vida de la app Acceso a recursos \u2705 Con tema aplicado \u26a0\ufe0f Sin tema Mostrar UI \u2705 Di\u00e1logos, Toasts \u274c No recomendado DataStore \u26a0\ufe0f Riesgo de leak \u2705 Perfecto Repositories \u274c Memory leak \u2705 Correcto Obtenci\u00f3n <code>this</code> en Activity <code>context.applicationContext</code>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#16-crear-extension-para-datastore","title":"1.6. Crear extensi\u00f3n para DataStore","text":"<p>Antes de implementar <code>SessionManager</code>, necesitamos crear una extensi\u00f3n de <code>Context</code> para acceder a DataStore:</p> <p>\u00bfPor qu\u00e9 crear una extensi\u00f3n para DataStore?</p> <p>Crear una extensi\u00f3n de <code>Context</code> usando <code>by preferencesDataStore</code> es el patr\u00f3n oficial recomendado por Google. Esta delegaci\u00f3n garantiza tres aspectos cr\u00edticos: </p> <ul> <li>singleton (solo existe una instancia de DataStore por nombre, evitando que m\u00faltiples creaciones provoquen errores de escritura concurrente), </li> <li>lazy initialization (el DataStore solo se crea cuando realmente se usa, no al instanciar la clase), y thread-safety (maneja autom\u00e1ticamente el acceso concurrente desde m\u00faltiples hilos). </li> </ul> <p>La extensi\u00f3n convierte algo complejo en una simple propiedad: <code>context.dataStorePreferences</code>, haciendo el c\u00f3digo m\u00e1s limpio y seguro.</p> <pre><code>// \u2705 Extensi\u00f3n: Singleton autom\u00e1tico, lazy, thread-safe\nval Context.dataStorePreferences by preferencesDataStore(name = \"user_session\")\n\n// \u274c Sin extensi\u00f3n: Verboso, propenso a errores, sin garant\u00edas de singleton\nprivate val dataStore = PreferenceDataStoreFactory.create(\n    produceFile = { context.preferencesDataStoreFile(\"user_session\") }\n)\n// \u26a0\ufe0f Riesgo: Si creas m\u00faltiples instancias \u2192 Corrupci\u00f3n de datos\n</code></pre> <p>Ubicaci\u00f3n: <code>data/local/DataStoreExt.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.local\n\nimport android.content.Context\nimport androidx.datastore.core.DataStore\nimport androidx.datastore.preferences.core.Preferences\nimport androidx.datastore.preferences.preferencesDataStore\n\n/**\n * \ud83d\udd27 Extensi\u00f3n de Context para acceder a DataStore de preferencias\n * \n * La funci\u00f3n `by preferencesDataStore` crea una instancia singleton de DataStore\n * asociada al contexto de la aplicaci\u00f3n.\n * \n * @param name Nombre del archivo de preferencias (\"user_session.preferences_pb\")\n */\nval Context.dataStorePreferences: DataStore&lt;Preferences&gt; by preferencesDataStore(\n    name = \"user_session\"\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#que-hace-esta-extension","title":"\u00bfQu\u00e9 hace esta extensi\u00f3n?","text":"ConceptoExtension FunctionDelegaci\u00f3n (by) <pre><code>// Convierte esto:\ncontext.dataStorePreferences\n\n// En esto internamente:\npreferencesDataStore(name = \"user_session\").getValue(context, property)\n</code></pre> <p>Una extension function permite agregar funcionalidades a clases existentes sin modificarlas:</p> <pre><code>// Extiende Context con una propiedad\nval Context.dataStorePreferences: DataStore&lt;Preferences&gt;\n\n// Ahora cualquier Context puede usarla\nval dataStore = context.dataStorePreferences\n</code></pre> <p>La palabra clave <code>by</code> delega la creaci\u00f3n del DataStore:</p> <pre><code>by preferencesDataStore(name = \"user_session\")\n\n// Esto garantiza:\n// 1. Singleton (una sola instancia)\n// 2. Creaci\u00f3n lazy (solo cuando se usa)\n// 3. Thread-safe\n</code></pre> <p>Archivo generado</p> <p>DataStore crear\u00e1 un archivo llamado <code>user_session.preferences_pb</code> en: </p><pre><code>/data/data/com.pmdm.mygamestore/files/datastore/\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#17-implementar-sessionmanagerimpl","title":"1.7. Implementar SessionManagerImpl","text":"<p>Ahora creamos la implementaci\u00f3n concreta:</p> <p>Ubicaci\u00f3n: <code>data/local/SessionManagerImpl.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.local\n\nimport android.content.Context\nimport androidx.datastore.preferences.core.booleanPreferencesKey\nimport androidx.datastore.preferences.core.edit\nimport androidx.datastore.preferences.core.stringPreferencesKey\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.map\n\n/**\n * \ud83d\udd27 Implementaci\u00f3n de SessionManager usando DataStore\n * \n * @param context Contexto de la aplicaci\u00f3n para acceder a DataStore\n */\nclass SessionManagerImpl(\n    private val context: Context\n) : SessionManager {\n\n    // Acceso al DataStore a trav\u00e9s de la extensi\u00f3n\n    private val dataStore = context.dataStorePreferences\n\n    companion object {\n        /**\n         * Keys tipadas para acceder a las preferencias\n         * Usar keys garantiza type-safety y evita errores de tipeo\n         */\n        private val IS_LOGGED_IN = booleanPreferencesKey(\"is_logged_in\")\n        private val USERNAME = stringPreferencesKey(\"username\")\n    }\n\n    /**\n     * Guarda la sesi\u00f3n del usuario en DataStore\n     */\n    override suspend fun saveSession(username: String) {\n        dataStore.edit { preferences -&gt;\n            preferences[IS_LOGGED_IN] = true\n            preferences[USERNAME] = username\n        }\n    }\n\n    /**\n     * Verifica si el usuario tiene sesi\u00f3n activa\n     * \n     * @return Flow que emite true si est\u00e1 logueado, false en caso contrario\n     */\n    override fun isUserLoggedIn(): Flow&lt;Boolean&gt; {\n        return dataStore.data.map { preferences -&gt;\n            preferences[IS_LOGGED_IN] ?: false\n        }\n    }\n\n    /**\n     * Obtiene el nombre del usuario de la sesi\u00f3n activa\n     * \n     * @return Flow que emite el username o null si no hay sesi\u00f3n\n     */\n    override fun getUsername(): Flow&lt;String?&gt; {\n        return dataStore.data.map { preferences -&gt;\n            preferences[USERNAME]\n        }\n    }\n\n    /**\n     * Limpia toda la sesi\u00f3n del usuario\n     */\n    override suspend fun clearSession() {\n        dataStore.edit { preferences -&gt;\n            preferences.clear()\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#conceptos-clave","title":"Conceptos clave","text":"<p>1. Preferences Keys:</p> <pre><code>private val IS_LOGGED_IN = booleanPreferencesKey(\"is_logged_in\")\nprivate val USERNAME = stringPreferencesKey(\"username\")\n</code></pre> <p>Type-safe keys</p> <p>Las keys tipadas previenen errores:</p> <pre><code>// \u274c SharedPreferences: Sin type-safety\nprefs.putString(\"is_logged_in\", \"true\")  // Error: String en vez de Boolean\n\n// \u2705 DataStore: Type-safe\npreferences[IS_LOGGED_IN] = \"true\"  // \u274c Error de compilaci\u00f3n\npreferences[IS_LOGGED_IN] = true    // \u2705 Correcto\n</code></pre> <p>2. Operaciones de escritura:</p> <pre><code>dataStore.edit { preferences -&gt;\n    preferences[IS_LOGGED_IN] = true\n    preferences[USERNAME] = username\n}\n</code></pre> <ul> <li><code>edit</code> es una funci\u00f3n <code>suspend</code> (as\u00edncrona)</li> <li>Los cambios se aplican de forma at\u00f3mica (todo o nada)</li> <li>Thread-safe autom\u00e1ticamente</li> </ul> <p>3. Operaciones de lectura:</p> <pre><code>dataStore.data.map { preferences -&gt;\n    preferences[IS_LOGGED_IN] ?: false\n}\n</code></pre> <ul> <li><code>dataStore.data</code> es un <code>Flow&lt;Preferences&gt;</code></li> <li><code>map</code> transforma el Flow para obtener el valor espec\u00edfico</li> <li><code>?: false</code> proporciona un valor por defecto si no existe</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#18-modificar-loginviewmodel-para-guardar-sesion","title":"1.8. Modificar LoginViewModel para guardar sesi\u00f3n","text":"<p>Ahora integramos <code>SessionManager</code> en el ViewModel:</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/LoginViewModel.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.pmdm.mygamestore.data.repository.SessionManager\nimport com.pmdm.mygamestore.data.repository.SessionManagerImpl\nimport com.pmdm.mygamestore.data.repository.AuthRepository\nimport com.pmdm.mygamestore.data.repository.AuthRepositoryImpl\nimport com.pmdm.mygamestore.data.repository.LoginResult\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\n\ndata class LoginUiState(\n    val username: String = \"\",\n    val password: String = \"\",\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null,\n    val isLoginSuccessful: Boolean = false\n)\n\n/**\n * ViewModel para gestionar el estado y la l\u00f3gica de la pantalla de Login\n * \n * @param context Contexto para crear SessionManager\n * @param authRepository Repositorio para operaciones de autenticaci\u00f3n\n * @param sessionManager Manager para persistir la sesi\u00f3n del usuario\n */\nclass LoginViewModel(\n    context: Context,\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(LoginUiState())\n    val uiState: StateFlow&lt;LoginUiState&gt; = _uiState.asStateFlow()\n\n    fun onUsernameChange(newUsername: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                username = newUsername,\n                errorMessage = null\n            )\n        }\n    }\n\n    fun onPasswordChange(newPassword: String) {\n        _uiState.update { currentState -&gt;\n            currentState.copy(\n                password = newPassword,\n                errorMessage = null\n            )\n        }\n    }\n\n    /**\n     * Ejecuta el proceso de login y guarda la sesi\u00f3n\n     */\n    fun onLoginClick() {\n        // Validaciones de UI\n        if (_uiState.value.username.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Username cannot be empty\") }\n            return\n        }\n\n        if (_uiState.value.password.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Password cannot be empty\") }\n            return\n        }\n\n        // Proceso de login\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true, errorMessage = null) }\n\n            // Llamar al Repository\n            val result = authRepository.login(\n                username = _uiState.value.username,\n                password = _uiState.value.password\n            )\n\n            // Manejar resultado\n            when (result) {\n                is LoginResult.Success -&gt; {\n                    // \ud83d\udcbe Guardar sesi\u00f3n en DataStore\n                    sessionManager.saveSession(result.username)\n\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            isLoginSuccessful = true,\n                            errorMessage = null\n                        )\n                    }\n                }\n\n                is LoginResult.Error -&gt; {\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            isLoginSuccessful = false,\n                            errorMessage = result.message\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n\n    fun resetLoginSuccess() {\n        _uiState.update { it.copy(isLoginSuccessful = false) }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#cambios-realizados","title":"Cambios realizados","text":"<p>1. Agregar SessionManager al constructor:</p> <pre><code>class LoginViewModel(\n    context: Context,  // \ud83d\udc48 Nuevo: necesitamos Context\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),\n    private val sessionManager: SessionManager = SessionManagerImpl(context)  // \ud83d\udc48 Nuevo\n)\n</code></pre> <p>2. Guardar sesi\u00f3n tras login exitoso:</p> <pre><code>when (result) {\n    is LoginResult.Success -&gt; {\n        sessionManager.saveSession(result.username)  // \ud83d\udc48 Nuevo: guardar sesi\u00f3n\n        _uiState.update { /* ... */ }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#19-actualizar-loginscreen-para-pasar-context","title":"1.9. Actualizar LoginScreen para pasar Context","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/screens/LoginScreen.kt</code></p> <p>Necesitamos pasar el <code>Context</code> al ViewModel:</p> <pre><code>package com.pmdm.mygamestore.presentation.ui.screens\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.LoginViewModel\n\n@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(\n        factory = LoginViewModelFactory(LocalContext.current)  // \ud83d\udc48 Pasar Context\n    ),\n    onLoginSuccess: () -&gt; Unit = {}\n) {\n    // ... resto del c\u00f3digo sin cambios\n}\n</code></pre> <p>Crear ViewModelFactory:</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/LoginViewModelFactory.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\n\n/**\n * Factory para crear LoginViewModel con Context\n */\nclass LoginViewModelFactory(\n    private val context: Context\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(LoginViewModel::class.java)) {\n            return LoginViewModel(context) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre> <p>Context.applicationContext</p> <p>Es importante usar <code>context.applicationContext</code> dentro del ViewModel para evitar memory leaks:</p> <pre><code>class SessionManagerImpl(context: Context) : SessionManager {\n    private val appContext = context.applicationContext  // \u2705 Usa application context\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#191-solucion-de-problemas-comunes","title":"1.9.1 Soluci\u00f3n de problemas comunes","text":"<p>Problema 1: \"Cannot access DataStore\"</p> <pre><code>java.lang.IllegalStateException: Cannot access DataStore before it is initialized\n</code></pre> <p>Soluci\u00f3n: Aseg\u00farate de que la extensi\u00f3n <code>dataStorePreferences</code> est\u00e9 importada correctamente:</p> <pre><code>import com.pmdm.mygamestore.data.local.dataStorePreferences\n</code></pre> <p>Problema 2: \"Type mismatch\" con Flow</p> <pre><code>Type mismatch: inferred type is Flow&lt;Boolean&gt; but Boolean was expected\n</code></pre> <p>Soluci\u00f3n: Usa <code>collectAsState()</code> en Compose o <code>collect</code> en coroutines:</p> <pre><code>// \u2705 En Composable\nval isLoggedIn by viewModel.isUserLoggedIn().collectAsState(initial = false)\n\n// \u2705 En ViewModel\nviewModelScope.launch {\n    sessionManager.isUserLoggedIn().collect { isLoggedIn -&gt;\n        // usar valor\n    }\n}\n</code></pre> <p>Problema 3: Memory Leak con Context</p> <pre><code>LeakCanary: LoginViewModel has leaked\n</code></pre> <p>Soluci\u00f3n: Usa <code>applicationContext</code>:</p> <pre><code>class SessionManagerImpl(context: Context) : SessionManager {\n    private val dataStore = context.applicationContext.dataStorePreferences\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#2-integrar-navegacion-en-el-flujo-del-login","title":"2. Integrar Navegaci\u00f3n en el Flujo del Login","text":"<p>Para integra la navegaci\u00f3n en el flujo del login, vamos a utilizar la pantalla <code>SplashScreen</code> como punto de entrada de la aplicaci\u00f3n. En esta pantalla, vamos a verificar si el usuario tiene sesi\u00f3n activa y, en funci\u00f3n de eso, vamos a redirigirlo a la pantalla de login o a la pantalla principal.</p> <p>Experiencia de usuario profesional</p> <p>Una pantalla Splash es fundamental en aplicaciones profesionales por varias razones.</p> <ol> <li>oculta el tiempo de inicializaci\u00f3n: mientras la app verifica la sesi\u00f3n del usuario, carga configuraciones iniciales o conecta con servicios, el Splash muestra una interfaz atractiva en lugar de una pantalla en blanco. </li> <li>refuerza la identidad de marca: es la primera impresi\u00f3n que el usuario tiene de tu app, mostrando el logo y estableciendo la identidad visual. Tercero, mejora la percepci\u00f3n de velocidad: aunque la app tarde 1-2 segundos en inicializar, una animaci\u00f3n del logo hace que la espera se sienta intencional y profesional, no como un error o bloqueo. </li> <li>es el punto de decisi\u00f3n de navegaci\u00f3n: permite realizar operaciones as\u00edncronas (como verificar autenticaci\u00f3n) y redirigir al usuario a la pantalla correcta sin mostrar transiciones bruscas o pantallas intermedias. Sin un Splash, el usuario ver\u00eda una pantalla en blanco o cargas abruptas, dando una impresi\u00f3n de app inacabada o de baja calidad.</li> </ol>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#21-crear-splashviewmodel","title":"2.1. Crear SplashViewModel","text":"<p>El <code>SplashScreen</code> ahora necesita verificar si hay sesi\u00f3n activa. Creamos un ViewModel para manejar esta l\u00f3gica:</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/SplashViewModel.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.pmdm.mygamestore.data.repository.SessionManager\nimport com.pmdm.mygamestore.data.repository.SessionManagerImpl\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.stateIn\n\n/**\n * ViewModel para la pantalla Splash\n * \n * Verifica si el usuario tiene sesi\u00f3n activa para decidir la navegaci\u00f3n inicial\n * \n * @param context Contexto para crear SessionManager\n * @param sessionManager Manager para verificar la sesi\u00f3n del usuario\n */\nclass SplashViewModel(\n    context: Context,\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel() {\n\n    /**\n     * Estado que indica si el usuario est\u00e1 logueado\n     * \n     * Flow convertido a StateFlow para:\n     * - Tener un valor inicial (false)\n     * - Compartir el mismo Flow entre m\u00faltiples observadores\n     * - Mantener el \u00faltimo valor emitido\n     */\n    val isUserLoggedIn: StateFlow&lt;Boolean&gt; = sessionManager.isUserLoggedIn()\n        .stateIn(\n            scope = viewModelScope,\n            started = SharingStarted.WhileSubscribed(5000),\n            initialValue = false\n        )\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#que-es-statein","title":"\u00bfQu\u00e9 es <code>.stateIn()</code>?","text":"<p>Flow vs StateFlow</p> <pre><code>// Flow: Emite valores solo cuando hay observadores\nfun isUserLoggedIn(): Flow&lt;Boolean&gt;\n\n// StateFlow: Mantiene siempre el \u00faltimo valor\nval isUserLoggedIn: StateFlow&lt;Boolean&gt;\n</code></pre> <p>Par\u00e1metros de <code>stateIn()</code>:</p> scopestartedinitialValue <p></p><pre><code>scope = viewModelScope\n</code></pre> Define el alcance de vida del StateFlow. Se cancela cuando el ViewModel es destruido.<p></p> <p></p><pre><code>started = SharingStarted.WhileSubscribed(5000)\n</code></pre> Estrategia de inicio:<p></p> <ul> <li><code>WhileSubscribed(5000)</code>: Mantiene activo el Flow mientras haya suscriptores</li> <li><code>5000ms</code>: Espera 5 segundos despu\u00e9s de que el \u00faltimo suscriptor se desconecte antes de cancelar</li> <li>Optimizaci\u00f3n: Evita recrear el Flow si el usuario rota la pantalla r\u00e1pidamente</li> </ul> <p></p><pre><code>initialValue = false\n</code></pre> Valor inicial mientras se obtiene el primer valor real de DataStore.<p></p> <p>M\u00e1s sobre SharingStarted</p> <ul> <li><code>Eagerly</code>: Inicia inmediatamente y nunca se detiene</li> <li><code>Lazily</code>: Inicia con el primer suscriptor y nunca se detiene</li> <li><code>WhileSubscribed(timeout)</code>: Inicia/detiene seg\u00fan suscriptores (\u2b50 recomendado)</li> </ul>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#22-modificar-splashscreen","title":"2.2. Modificar SplashScreen","text":"<p>Actualizamos el <code>SplashScreen</code> para verificar la sesi\u00f3n y navegar en consecuencia:</p> <p>Ubicaci\u00f3n: <code>presentation/ui/screens/SplashScreen.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.ui.screens\n\nimport androidx.compose.foundation.Image\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.size\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.painterResource\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.pmdm.mygamestore.R\nimport com.pmdm.mygamestore.presentation.viewmodel.SplashViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.SplashViewModelFactory\nimport kotlinx.coroutines.delay\n\n/**\n * Pantalla Splash que verifica la sesi\u00f3n del usuario\n * \n * @param viewModel ViewModel que gestiona la l\u00f3gica de verificaci\u00f3n de sesi\u00f3n\n * @param onNavigateToLogin Callback para navegar a Login\n * @param onNavigateToHome Callback para navegar a Home\n */\n@Composable\nfun SplashScreen(\n    viewModel: SplashViewModel = viewModel(\n        factory = SplashViewModelFactory(LocalContext.current)\n    ),\n    onNavigateToLogin: () -&gt; Unit = {},\n    onNavigateToHome: () -&gt; Unit = {}\n) {\n    // Observar el estado de sesi\u00f3n\n    val isLoggedIn by viewModel.isUserLoggedIn.collectAsState()\n\n    // Verificar sesi\u00f3n despu\u00e9s del delay\n    LaunchedEffect(Unit) {\n        delay(2000)  // Mostrar logo durante 2 segundos\n\n        // Decidir navegaci\u00f3n seg\u00fan estado de sesi\u00f3n\n        if (isLoggedIn) {\n            onNavigateToHome()  // Usuario ya est\u00e1 logueado\n        } else {\n            onNavigateToLogin()  // Usuario necesita autenticarse\n        }\n    }\n\n    // UI del Splash Screen\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Image(\n            painter = painterResource(id = R.drawable.ic_launcher_foreground),\n            contentDescription = \"Logo de la aplicaci\u00f3n\",\n            modifier = Modifier.size(200.dp)\n        )\n    }\n}\n</code></pre> <p>Crear SplashViewModelFactory:</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/SplashViewModelFactory.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\n\n/**\n * Factory para crear SplashViewModel con Context\n */\nclass SplashViewModelFactory(\n    private val context: Context\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(SplashViewModel::class.java)) {\n            return SplashViewModel(context) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#23-actualizar-navgraph","title":"2.3. Actualizar NavGraph","text":"<p>Actualizamos la configuraci\u00f3n de navegaci\u00f3n para conectar todo:</p> <p>Ubicaci\u00f3n: <code>presentation/ui/navigation/NavGraph.kt</code></p> <pre><code>@Composable\nfun AppNavigation() {\n    val backStack = rememberNavBackStack(AppRoutes.Splash)\n\n    CompositionLocalProvider(LocalNavStack provides backStack) {\n        NavDisplay(\n            backStack = backStack,\n            onBack = { backStack.removeLastOrNull() },\n            entryProvider = entryProvider {\n\n                // \ud83d\ude80 Pantalla Splash (inicial)\n                entry(AppRoutes.Splash) {\n                    val navStack = LocalNavStack.current\n\n                    SplashScreen(\n                        onNavigateToLogin = {\n                            navStack.clear()\n                            navStack.add(AppRoutes.Login)\n                        },\n                        onNavigateToHome = {\n                            navStack.clear()\n                            navStack.add(AppRoutes.Home)\n                        }\n                    )\n                }\n\n                // \ud83d\udd10 Pantalla Login\n                entry(AppRoutes.Login) {\n                    val navStack = LocalNavStack.current\n\n                    LoginScreen(\n                        onLoginSuccess = {\n                            navStack.clear()\n                            navStack.add(AppRoutes.Home)\n                        }\n                    )\n                }\n\n                // \ud83c\udfe0 Pantalla Home\n                entry(AppRoutes.Home) {\n                    HomeScreen()\n                }\n\n                // ... otras pantallas\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#24-flujo-completo-con-diagrama","title":"2.4. Flujo completo con diagrama","text":"<p>Caso de uso: Usuario abre la aplicaci\u00f3n</p> <pre><code>sequenceDiagram\n    participant U as Usuario\n    participant SS as SplashScreen\n    participant VM as SplashViewModel\n    participant SM as SessionManager\n    participant DS as DataStore\n    participant NG as NavGraph\n    participant LS as LoginScreen\n    participant HS as HomeScreen\n\n    U-&gt;&gt;SS: Abre la app\n    SS-&gt;&gt;VM: Solicita estado de sesi\u00f3n\n    VM-&gt;&gt;SM: isUserLoggedIn()\n    SM-&gt;&gt;DS: Lee IS_LOGGED_IN\n    DS--&gt;&gt;SM: Flow&lt;Boolean&gt;\n    SM--&gt;&gt;VM: Flow&lt;Boolean&gt;\n    VM--&gt;&gt;SS: StateFlow (isLoggedIn)\n\n    SS-&gt;&gt;SS: delay(2000ms)\n    Note over SS: Muestra logo\n\n    alt Usuario con sesi\u00f3n activa\n        DS--&gt;&gt;SS: isLoggedIn = true\n        SS-&gt;&gt;NG: onNavigateToHome()\n        NG-&gt;&gt;NG: navStack.clear()\n        NG-&gt;&gt;NG: navStack.add(Home)\n        NG-&gt;&gt;HS: Navega a HomeScreen\n        Note over HS: \u2705 Usuario en Home\n    else Usuario sin sesi\u00f3n\n        DS--&gt;&gt;SS: isLoggedIn = false\n        SS-&gt;&gt;NG: onNavigateToLogin()\n        NG-&gt;&gt;NG: navStack.clear()\n        NG-&gt;&gt;NG: navStack.add(Login)\n        NG-&gt;&gt;LS: Navega a LoginScreen\n        Note over LS: \ud83d\udd10 Usuario debe autenticarse\n    end</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#25-comparacion-antesdespues","title":"2.5. Comparaci\u00f3n antes/despu\u00e9s","text":"\u274c Antes (sin persistencia)\u2705 Despu\u00e9s (con persistencia) <pre><code>// Usuario siempre ve Login al abrir la app\n@Composable\nfun SplashScreen(onNavigate: () -&gt; Unit) {\n    LaunchedEffect(Unit) {\n        delay(2000)\n        onNavigate()  // Siempre va a Login\n    }\n}\n</code></pre> <p>Flujo: </p><pre><code>1. Abre app \u2192 SplashScreen\n2. Espera 2s \u2192 LoginScreen\n3. Usuario ingresa credenciales \u2192 HomeScreen\n4. Cierra app\n5. Abre app \u2192 SplashScreen\n6. Espera 2s \u2192 LoginScreen \u274c (debe autenticarse de nuevo)\n</code></pre><p></p> <pre><code>@Composable\nfun SplashScreen(\n    viewModel: SplashViewModel,\n    onNavigateToLogin: () -&gt; Unit,\n    onNavigateToHome: () -&gt; Unit\n) {\n    val isLoggedIn by viewModel.isUserLoggedIn.collectAsState()\n\n    LaunchedEffect(Unit) {\n        delay(2000)\n        if (isLoggedIn) {\n            onNavigateToHome()  // Va directo a Home\n        } else {\n            onNavigateToLogin()\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#26-comprobacion-manual","title":"2.6. Comprobaci\u00f3n manual","text":"<p>Escenario 1: Primera vez (sin sesi\u00f3n)</p> <ol> <li>\u2705 Desinstalar la app (para limpiar datos)</li> <li>\u2705 Instalar y abrir la app</li> <li>\u2705 Ver SplashScreen durante 2 segundos</li> <li>\u2705 Navegar autom\u00e1ticamente a LoginScreen</li> <li>\u2705 Ingresar credenciales v\u00e1lidas (admin / 1234)</li> <li>\u2705 Navegar a HomeScreen</li> </ol> <p>Escenario 2: Usuario con sesi\u00f3n activa</p> <ol> <li>\u2705 (Continuar del escenario 1)</li> <li>\u2705 Cerrar completamente la app (no solo minimizar)</li> <li>\u2705 Volver a abrir la app</li> <li>\u2705 Ver SplashScreen durante 2 segundos</li> <li>\u2705 Navegar directo a HomeScreen (sin pasar por Login)</li> <li>\u2705 Presionar \"Atr\u00e1s\" \u2192 Sale de la app (no vuelve a Login)</li> </ol> <p>Escenario 3: Verificar persistencia</p> <ol> <li>\u2705 Con la app cerrada, abrir \"Configuraci\u00f3n\" del dispositivo</li> <li>\u2705 Ir a \"Apps\" \u2192 \"MyGameStore\" \u2192 \"Almacenamiento\"</li> <li>\u2705 NO borrar datos</li> <li>\u2705 Volver a abrir la app</li> <li>\u2705 Verificar que va directo a Home (sesi\u00f3n persiste)</li> </ol> <p>Escenario 4: Borrar sesi\u00f3n manualmente</p> <ol> <li>\u2705 Con la app cerrada, ir a \"Configuraci\u00f3n\" \u2192 \"Apps\" \u2192 \"MyGameStore\"</li> <li>\u2705 Tocar \"Borrar datos\" o \"Limpiar almacenamiento\"</li> <li>\u2705 Abrir la app</li> <li>\u2705 Verificar que va a LoginScreen (sesi\u00f3n eliminada)</li> </ol>"},{"location":"temas/proyectos/GameVault/03-Preferences.html#27-solucion-de-problemas-posibles","title":"2.7. Soluci\u00f3n de problemas posibles","text":"<p>Problema 1: La app siempre va a Login (no persiste)</p> <p>Posibles causas:</p> <ol> <li> <p>No se est\u00e1 guardando la sesi\u00f3n: </p><pre><code>// \u274c Falta llamar a saveSession\nwhen (result) {\n    is LoginResult.Success -&gt; {\n        // sessionManager.saveSession(result.username)  // Olvidado\n        _uiState.update { it.copy(isLoginSuccessful = true) }\n    }\n}\n</code></pre><p></p> </li> <li> <p>El Flow no se est\u00e1 observando correctamente: </p><pre><code>// \u274c No se usa collectAsState\nval isLoggedIn = viewModel.isUserLoggedIn  // Flow, no Boolean\n\n// \u2705 Correcto\nval isLoggedIn by viewModel.isUserLoggedIn.collectAsState()\n</code></pre><p></p> </li> </ol> <p>Problema 2: La app siempre va a Home (no puede hacer logout)</p> <p>Causa: No hay forma de limpiar la sesi\u00f3n.</p> <p>Soluci\u00f3n: (para debugging):**</p> <pre><code>// En HomeScreen, agregar un bot\u00f3n temporal\nButton(onClick = {\n    viewModelScope.launch {\n        sessionManager.clearSession()\n        // Navegar a Login\n    }\n}) {\n    Text(\"DEBUG: Clear Session\")\n}\n</code></pre> <p>Problema 3: Crash al abrir la app</p> <pre><code>java.lang.IllegalStateException: ViewModelProvider.Factory is required\n</code></pre> <p>Soluci\u00f3n: Aseg\u00farate de pasar el Factory:</p> <pre><code>// \u274c Sin factory (crash si ViewModel tiene par\u00e1metros)\nviewModel: SplashViewModel = viewModel()\n\n// \u2705 Con factory\nviewModel: SplashViewModel = viewModel(\n    factory = SplashViewModelFactory(LocalContext.current)\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html","title":"4. Registro y logout","text":""},{"location":"temas/proyectos/GameVault/04-Register-logout.html#4-pantalla-de-registro-y-logout-de-usuario","title":"4. Pantalla de Registro y Logout de usuario","text":"<p>En esta 4\u00aa parte del proyecto, vamos a crear la pantalla de registro de un nuevo usuario, integrarla en el flujo de navegaci\u00f3n y crear la funcionalidad de logout.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#resumen","title":"Resumen","text":"<ol> <li>Crear pantalla de registro con funcionalidad completa</li> <li>Integrar registro en el flujo de navegaci\u00f3n</li> <li>Crear funcionalidad de logout</li> </ol> <p>Objetivo de esta sesi\u00f3n</p> <p>Implementar el sistema completo de registro de usuarios, integrarlo en el flujo de navegaci\u00f3n y agregar funcionalidad de cierre de sesi\u00f3n para completar el ciclo de autenticaci\u00f3n de la aplicaci\u00f3n.</p>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#1-crear-pantalla-de-registro","title":"1. Crear Pantalla de Registro","text":""},{"location":"temas/proyectos/GameVault/04-Register-logout.html#11-introduccion","title":"1.1. Introducci\u00f3n","text":"<p>La pantalla de Registro es similar a la de Login, pero incluye campos adicionales para crear una nueva cuenta de usuario. Reutilizaremos los mismos patrones y componentes que ya conocemos: ViewModel, Repository, UiState y componentes reutilizables.</p> <p>Diferencias principales con Login:</p> <ul> <li>\u2705 Campos adicionales: Email y Confirmaci\u00f3n de contrase\u00f1a</li> <li>\u2705 Validaciones m\u00e1s complejas</li> <li>\u2705 Verificaci\u00f3n de usuario \u00fanico</li> <li>\u2705 Guardar usuario en la \"base de datos\" local</li> </ul>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#12-crear-registerresult","title":"1.2. Crear RegisterResult","text":"<p>Similar a <code>LoginResult</code>, creamos una sealed class para representar los resultados del registro:</p> <p>ubicaci\u00f3n: <code>data/repository/Result.kt</code>. Agrega esta clase dentro de este fichero.</p> <pre><code>package com.pmdm.mygamestore.data.repository\n\n/**\n * \ud83c\udfaf Sealed class que representa los posibles resultados de un registro\n */\nsealed class RegisterResult {\n    /**\n     * Registro exitoso\n     * @param username Nombre del usuario registrado\n     */\n    data class Success(val username: String) : RegisterResult()\n\n    /**\n     * Registro fallido\n     * @param message Mensaje describiendo el error\n     */\n    data class Error(val message: String) : RegisterResult()\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#13-extender-authrepository","title":"1.3. Extender AuthRepository","text":"<p>Agregamos el m\u00e9todo <code>register</code> a la interfaz y su implementaci\u00f3n:</p> <p>ubicaci\u00f3n: <code>data/repository/AuthRepository.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.repository\n\ninterface AuthRepository {\n    suspend fun login(username: String, password: String): LoginResult\n\n    /**\n     * Registra un nuevo usuario\n     * \n     * @param username Nombre de usuario\n     * @param email Email del usuario\n     * @param password Contrase\u00f1a\n     * @return RegisterResult indicando \u00e9xito o error\n     */\n    suspend fun register(\n        username: String, \n        email: String, \n        password: String\n    ): RegisterResult\n}\n</code></pre> <p>ubicaci\u00f3n: <code>data/repository/AuthRepositoryImpl.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.repository\n\nimport kotlinx.coroutines.delay\n\nclass AuthRepositoryImpl : AuthRepository {\n\n    // Usuarios v\u00e1lidos para login\n    private val validUsers = mutableMapOf(\n        \"admin\" to \"1234\",\n        \"user\" to \"password\"\n    )\n\n    // Base de datos simulada de usuarios registrados\n    private val registeredUsers = mutableMapOf&lt;String, UserData&gt;(\n        \"admin\" to UserData(\"admin\", \"admin@example.com\", \"1234\"),\n        \"user\" to UserData(\"user\", \"user@example.com\", \"password\")\n    )\n\n    override suspend fun login(username: String, password: String): LoginResult {\n        delay(1500)\n\n        return if (validUsers[username] == password) {\n            LoginResult.Success(username = username)\n        } else {\n            LoginResult.Error(message = \"Invalid username or password\")\n        }\n    }\n\n    override suspend fun register(\n        username: String,\n        email: String,\n        password: String\n    ): RegisterResult {\n        delay(1500)\n\n        // Verificar si el usuario ya existe\n        if (registeredUsers.containsKey(username)) {\n            return RegisterResult.Error(\"Username already exists\")\n        }\n\n        // Verificar si el email ya est\u00e1 registrado\n        if (registeredUsers.values.any { it.email == email }) {\n            return RegisterResult.Error(\"Email already registered\")\n        }\n\n        // Registrar nuevo usuario\n        registeredUsers[username] = UserData(username, email, password)\n        validUsers[username] = password\n\n        return RegisterResult.Success(username = username)\n    }\n}\n\n/**\n * Clase de datos para almacenar informaci\u00f3n del usuario\n */\ndata class UserData(\n    val username: String,\n    val email: String,\n    val password: String\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#14-crear-registeruistate","title":"1.4. Crear RegisterUiState","text":"<p>ubicaci\u00f3n: <code>presentation/viewmodel/RegisterVM.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\ndata class RegisterUiState(\n    val username: String = \"\",\n    val email: String = \"\",\n    val password: String = \"\",\n    val confirmPassword: String = \"\",\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null,\n    val isRegisterSuccessful: Boolean = false\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#15-crear-registerviewmodel","title":"1.5. Crear RegisterViewModel","text":"<p>ubicaci\u00f3n: <code>presentation/viewmodel/RegisterVM.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.pmdm.mygamestore.data.repository.SessionManager\nimport com.pmdm.mygamestore.data.repository.SessionManagerImpl\nimport com.pmdm.mygamestore.data.repository.AuthRepository\nimport com.pmdm.mygamestore.data.repository.AuthRepositoryImpl\nimport com.pmdm.mygamestore.data.repository.RegisterResult\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\n\n/**\n * ViewModel para gestionar el estado y la l\u00f3gica de la pantalla de Registro\n */\nclass RegisterViewModel(\n    context: Context,\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(RegisterUiState())\n    val uiState: StateFlow&lt;RegisterUiState&gt; = _uiState.asStateFlow()\n\n    fun onUsernameChange(newUsername: String) {\n        _uiState.update { it.copy(username = newUsername, errorMessage = null) }\n    }\n\n    fun onEmailChange(newEmail: String) {\n        _uiState.update { it.copy(email = newEmail, errorMessage = null) }\n    }\n\n    fun onPasswordChange(newPassword: String) {\n        _uiState.update { it.copy(password = newPassword, errorMessage = null) }\n    }\n\n    fun onConfirmPasswordChange(newConfirmPassword: String) {\n        _uiState.update { it.copy(confirmPassword = newConfirmPassword, errorMessage = null) }\n    }\n\n    /**\n     * Ejecuta el proceso de registro con validaciones\n     */\n    fun onRegisterClick() {\n        val state = _uiState.value\n\n        // Validaci\u00f3n: Username\n        if (state.username.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Username cannot be empty\") }\n            return\n        }\n        if (state.username.length &lt; 3) {\n            _uiState.update { it.copy(errorMessage = \"Username must be at least 3 characters\") }\n            return\n        }\n\n        // Validaci\u00f3n: Email\n        if (state.email.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Email cannot be empty\") }\n            return\n        }\n        if (!state.email.contains(\"@\") || !state.email.contains(\".\")) {\n            _uiState.update { it.copy(errorMessage = \"Invalid email format\") }\n            return\n        }\n\n        // Validaci\u00f3n: Password\n        if (state.password.isBlank()) {\n            _uiState.update { it.copy(errorMessage = \"Password cannot be empty\") }\n            return\n        }\n        if (state.password.length &lt; 6) {\n            _uiState.update { it.copy(errorMessage = \"Password must be at least 6 characters\") }\n            return\n        }\n\n        // Validaci\u00f3n: Confirm Password\n        if (state.password != state.confirmPassword) {\n            _uiState.update { it.copy(errorMessage = \"Passwords do not match\") }\n            return\n        }\n\n        // Proceso de registro\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true, errorMessage = null) }\n\n            val result = authRepository.register(\n                username = state.username,\n                email = state.email,\n                password = state.password\n            )\n\n            when (result) {\n                is RegisterResult.Success -&gt; {\n                    // Guardar sesi\u00f3n autom\u00e1ticamente tras registro\n                    sessionManager.saveSession(result.username)\n\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            isRegisterSuccessful = true\n                        )\n                    }\n                }\n\n                is RegisterResult.Error -&gt; {\n                    _uiState.update {\n                        it.copy(\n                            isLoading = false,\n                            errorMessage = result.message\n                        )\n                    }\n                }\n            }\n        }\n    }\n\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n\n    fun resetRegisterSuccess() {\n        _uiState.update { it.copy(isRegisterSuccessful = false) }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#16-crear-registerviewmodelfactory","title":"1.6. Crear RegisterViewModelFactory","text":"<p>ubicaci\u00f3n: <code>presentation/viewmodel/RegisterViewModelFactory.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\n\nclass RegisterViewModelFactory(\n    private val context: Context\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(RegisterViewModel::class.java)) {\n            return RegisterViewModel(context) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class\")\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#17-crear-registerscreen","title":"1.7. Crear RegisterScreen","text":"<p>ubicaci\u00f3n: <code>presentation/ui/screens/RegisterScreen.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.ui.screens\n\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.navigationBarsPadding\nimport androidx.compose.foundation.layout.offset\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.foundation.rememberScrollState\nimport androidx.compose.foundation.verticalScroll\nimport androidx.compose.material3.CircularProgressIndicator\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.SnackbarHost\nimport androidx.compose.material3.SnackbarHostState\nimport androidx.compose.material3.Text\nimport androidx.compose.material3.TextButton\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.res.stringResource\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.text.input.PasswordVisualTransformation\nimport androidx.compose.ui.unit.dp\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport com.pmdm.mygamestore.R\nimport com.pmdm.mygamestore.presentation.ui.componentes.LabeledTextFieldGS\nimport com.pmdm.mygamestore.presentation.ui.componentes.RoundedButton\nimport com.pmdm.mygamestore.presentation.ui.theme.dimens\nimport com.pmdm.mygamestore.presentation.viewmodel.RegisterViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.RegisterViewModelFactory\n\n@Composable\nfun RegisterScreen(\n    viewModel: RegisterViewModel = viewModel(\n        factory = RegisterViewModelFactory(LocalContext.current)\n    ),\n    onRegisterSuccess: () -&gt; Unit = {},\n    onNavigateToLogin: () -&gt; Unit = {}\n) {\n    val uiState by viewModel.uiState.collectAsState()\n    val snackbarHostState = remember { SnackbarHostState() }\n\n    // Mostrar errores\n    LaunchedEffect(uiState.errorMessage) {\n        uiState.errorMessage?.let { error -&gt;\n            snackbarHostState.showSnackbar(error)\n            viewModel.clearError()\n        }\n    }\n\n    // Navegar tras registro exitoso\n    LaunchedEffect(uiState.isRegisterSuccessful) {\n        if (uiState.isRegisterSuccessful) {\n            onRegisterSuccess()\n            viewModel.resetRegisterSuccess()\n        }\n    }\n\n    Scaffold(\n        snackbarHost = { SnackbarHost(hostState = snackbarHostState) },\n        modifier = Modifier.padding(MaterialTheme.dimens.paddingMedium)\n    ) { innerPadding -&gt;\n\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n        ) {\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .verticalScroll(rememberScrollState())\n                    .navigationBarsPadding(),\n                verticalArrangement = Arrangement.Top,\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n\n                Text(\n                    text = \"Create Account\",\n                    style = MaterialTheme.typography.headlineMedium.copy(fontWeight = FontWeight.SemiBold),\n                    color = MaterialTheme.colorScheme.onBackground\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.extraLarge))\n\n                // Username\n                LabeledTextFieldGS(\n                    label = \"Username\",\n                    value = uiState.username,\n                    onValueChange = viewModel::onUsernameChange,\n                    placeholder = \"Enter your username\",\n                    modifier = Modifier.fillMaxWidth(),\n                    enabled = !uiState.isLoading\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.small))\n\n                // Email\n                LabeledTextFieldGS(\n                    label = \"Email\",\n                    value = uiState.email,\n                    onValueChange = viewModel::onEmailChange,\n                    placeholder = \"Enter your email\",\n                    modifier = Modifier.fillMaxWidth(),\n                    enabled = !uiState.isLoading\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.small))\n\n                // Password\n                LabeledTextFieldGS(\n                    label = \"Password\",\n                    value = uiState.password,\n                    onValueChange = viewModel::onPasswordChange,\n                    placeholder = \"Enter your password\",\n                    modifier = Modifier.fillMaxWidth(),\n                    visualTransformation = PasswordVisualTransformation(),\n                    enabled = !uiState.isLoading\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.small))\n\n                // Confirm Password\n                LabeledTextFieldGS(\n                    label = \"Confirm Password\",\n                    value = uiState.confirmPassword,\n                    onValueChange = viewModel::onConfirmPasswordChange,\n                    placeholder = \"Confirm your password\",\n                    modifier = Modifier.fillMaxWidth(),\n                    visualTransformation = PasswordVisualTransformation(),\n                    enabled = !uiState.isLoading\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.large))\n\n                // Bot\u00f3n Register\n                RoundedButton(\n                    texto = if (uiState.isLoading) \"Creating Account...\" else \"Register\",\n                    modifier = Modifier\n                        .fillMaxWidth()\n                        .height(MaterialTheme.dimens.buttonHeightMedium),\n                    onClick = viewModel::onRegisterClick,\n                    enabled = !uiState.isLoading\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.medium))\n\n                // Link a Login\n                TextButton(onClick = onNavigateToLogin) {\n                    Text(\n                        text = \"Already have an account? Login\",\n                        style = MaterialTheme.typography.bodyMedium,\n                        color = MaterialTheme.colorScheme.primary\n                    )\n                }\n\n                Spacer(modifier = Modifier.weight(1f))\n\n                Text(\n                    text = stringResource(R.string.app_name),\n                    style = MaterialTheme.typography.bodyLarge,\n                    color = MaterialTheme.colorScheme.secondary,\n                    modifier = Modifier.padding(bottom = MaterialTheme.dimens.paddingMedium)\n                )\n            }\n\n            // Loading indicator\n            if (uiState.isLoading) {\n                CircularProgressIndicator(\n                    modifier = Modifier\n                        .align(Alignment.Center)\n                        .offset(y = 100.dp),\n                    color = MaterialTheme.colorScheme.primary\n                )\n            }\n        }\n    }\n}\n</code></pre> Pantalla de registro <p>Scroll para campos m\u00faltiples</p> <p>Usamos <code>verticalScroll(rememberScrollState())</code> para que la pantalla sea desplazable si hay muchos campos y no caben en pantalla.</p>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#2-integrar-registro-en-la-navegacion","title":"2. Integrar Registro en la Navegaci\u00f3n","text":""},{"location":"temas/proyectos/GameVault/04-Register-logout.html#21-actualizar-loginscreen-para-navegar-a-register","title":"2.1. Actualizar LoginScreen para navegar a Register","text":"<p>Modificaci\u00f3n en: <code>presentation/ui/screens/LoginScreen.kt</code></p> <p>Agregar el par\u00e1metro <code>onNavigateToRegister</code>:</p> <pre><code>@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(\n        factory = LoginViewModelFactory(LocalContext.current)\n    ),\n    onLoginSuccess: () -&gt; Unit = {},\n    onNavigateToRegister: () -&gt; Unit = {}  // \ud83d\udc48 Nuevo\n) {\n    // ... c\u00f3digo existente ...\n\n    // Reemplazar el Text \"Register\" por:\n    TextButton(onClick = onNavigateToRegister) {\n        Text(\n            text = \"Don't have an account? Register\",\n            style = MaterialTheme.typography.bodyMedium,\n            color = MaterialTheme.colorScheme.primary\n        )\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#22-actualizar-navgraph","title":"2.2. Actualizar NavGraph","text":"<p>Modificaci\u00f3n en: <code>presentation/ui/navigation/NavGraph.kt</code></p> <pre><code>@Composable\nfun AppNavigation() {\n    val backStack = rememberNavBackStack(AppRoutes.Splash)\n\n    CompositionLocalProvider(LocalNavStack provides backStack) {\n        NavDisplay(\n            backStack = backStack,\n            onBack = { backStack.removeLastOrNull() },\n            entryProvider = entryProvider {\n\n                // ... Splash entry ...\n\n                // Login\n                entry(AppRoutes.Login) {\n                    val navStack = LocalNavStack.current\n                    LoginScreen(\n                        onLoginSuccess = {\n                            navStack.clear()\n                            navStack.add(AppRoutes.Home)\n                        },\n                        onNavigateToRegister = {\n                            navStack.add(AppRoutes.Register)  // \ud83d\udc48 Navegar a Register\n                        }\n                    )\n                }\n\n                // Register\n                entry(AppRoutes.Register) {\n                    val navStack = LocalNavStack.current\n                    RegisterScreen(\n                        onRegisterSuccess = {\n                            navStack.clear()\n                            navStack.add(AppRoutes.Home)  // \ud83d\udc48 Ir a Home tras registro\n                        },\n                        onNavigateToLogin = {\n                            navStack.removeLastOrNull()  \n                            navStack.add(AppRoutes.Login) // \ud83d\udc48 Volver a Login\n                        }\n                    )\n                }\n\n                // ... Home y otras pantallas ...\n            }\n        )\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#23-flujo-de-navegacion-completo","title":"2.3. Flujo de navegaci\u00f3n completo","text":"<pre><code>graph TD\n    A[SplashScreen] --&gt;|No sesi\u00f3n| B[LoginScreen]\n    A --&gt;|Sesi\u00f3n activa| C[HomeScreen]\n    B --&gt;|Click Register| D[RegisterScreen]\n    D --&gt;|Click Login| B\n    B --&gt;|Login exitoso| C\n    D --&gt;|Registro exitoso| C\n    C --&gt;|Logout| B\n\n    style A fill:#ffd93d\n    style B fill:#4d96ff\n    style D fill:#6bcf7f\n    style C fill:#ff6b6b</code></pre> <p>Navegaci\u00f3n:</p> <ul> <li><code>Login \u2192 Register</code>: <code>backStack.add(AppRoutes.Register)</code></li> <li><code>Register \u2192 Login</code>: <code>backStack.removeLastOrNull()</code> (vuelve atr\u00e1s)</li> <li><code>Register \u2192 Home</code>: <code>backStack.clear()</code> + <code>backStack.add(AppRoutes.Home)</code></li> </ul>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#3-cerrar-sesion","title":"3. Cerrar Sesi\u00f3n","text":"<p>Cerrar sesi\u00f3n (Logout) consiste en:</p> <ol> <li>Limpiar los datos de sesi\u00f3n almacenados en DataStore</li> <li>Limpiar el historial de navegaci\u00f3n (backStack)</li> <li>Navegar de vuelta a la pantalla de Login</li> </ol> <p>Esto garantiza que el usuario deba autenticarse nuevamente para acceder a la aplicaci\u00f3n.</p>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#31-metodo-clearsession-en-sessionmanager","title":"3.1. M\u00e9todo clearSession en SessionManager","text":"<p>El m\u00e9todo <code>clearSession()</code> ya existe en nuestra interfaz <code>SessionManager</code>:</p> <pre><code>interface SessionManager {\n    suspend fun saveSession(username: String)\n    fun isUserLoggedIn(): Flow&lt;Boolean&gt;\n    fun getUsername(): Flow&lt;String?&gt;\n    suspend fun clearSession()  // \ud83d\udc48 Ya implementado\n}\n</code></pre> <p>Implementaci\u00f3n en SessionManagerImpl:</p> <pre><code>override suspend fun clearSession() {\n    dataStore.edit { preferences -&gt;\n        preferences.clear()  // Elimina todos los datos\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#33-implementar-logout-en-homescreen","title":"3.3. Implementar Logout en HomeScreen","text":"<p>Solo para probar funcionalidad</p> <p>Agregamos un bot\u00f3n  de logout directamente en <code>HomeScreen</code>. En el futuro, este opci\u00f3n se incluir\u00e1 en el <code>perfil del usuario</code>.</p> <p>Modificaci\u00f3n en: <code>presentation/ui/screens/HomeScreen.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.ui.screens\n\nimport androidx.compose.foundation.layout.Arrangement\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.Spacer\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.height\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.Button\nimport androidx.compose.material3.ButtonDefaults\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.rememberCoroutineScope\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport com.pmdm.mygamestore.data.repository.SessionManagerImpl\nimport com.pmdm.mygamestore.presentation.ui.navigation.AppRoutes\nimport com.pmdm.mygamestore.presentation.ui.navigation.LocalNavStack\nimport com.pmdm.mygamestore.presentation.ui.theme.dimens\nimport kotlinx.coroutines.launch\n\n@Composable\nfun HomeScreen() {\n    val context = LocalContext.current\n    val sessionManager = remember { SessionManagerImpl(context) }\n    val scope = rememberCoroutineScope()\n    val navStack = LocalNavStack.current\n\n    Scaffold { innerPadding -&gt;\n        Box(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(innerPadding)\n        ) {\n            Column(\n                modifier = Modifier\n                    .fillMaxSize()\n                    .padding(MaterialTheme.dimens.paddingMedium),\n                verticalArrangement = Arrangement.Center,\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\n                    text = \"Home Screen\",\n                    style = MaterialTheme.typography.headlineLarge.copy(fontWeight = FontWeight.Bold),\n                    color = MaterialTheme.colorScheme.onBackground\n                )\n\n                Spacer(modifier = Modifier.height(MaterialTheme.dimens.medium))\n\n                Text(\n                    text = \"Welcome to GameVault!\",\n                    style = MaterialTheme.typography.bodyLarge,\n                    color = MaterialTheme.colorScheme.secondary\n                )\n            }\n\n            // Bot\u00f3n de Logout (DEBUG) en la parte inferior\n            Button(\n                onClick = {\n                    scope.launch {\n                        // 1. Limpiar sesi\u00f3n en DataStore\n                        sessionManager.clearSession()\n\n                        // 2. Limpiar historial de navegaci\u00f3n\n                        navStack.clear()\n\n                        // 3. Navegar a Login\n                        navStack.add(AppRoutes.Login)\n                    }\n                },\n                modifier = Modifier\n                    .align(Alignment.BottomCenter)\n                    .fillMaxWidth()\n                    .padding(MaterialTheme.dimens.paddingMedium)\n                    .height(MaterialTheme.dimens.buttonHeightMedium),\n                colors = ButtonDefaults.buttonColors(\n                    containerColor = Color.Red.copy(alpha = 0.7f),\n                    contentColor = Color.White\n                )\n            ) {\n                Text(\n                    text = \"\ud83d\udeaa Logout (DEBUG)\",\n                    style = MaterialTheme.typography.titleMedium.copy(fontWeight = FontWeight.SemiBold)\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#conceptos-nuevos","title":"Conceptos nuevos","text":"<p>1. rememberCoroutineScope()</p> <pre><code>val scope = rememberCoroutineScope()\n</code></pre> <p>Coroutine Scope en Compose</p> <p><code>rememberCoroutineScope()</code> crea un scope de coroutine vinculado al ciclo de vida del Composable. Cuando el Composable se destruye, las coroutines se cancelan autom\u00e1ticamente.</p> <p>Uso: Para ejecutar operaciones <code>suspend</code> desde eventos de UI (clicks, etc.)</p> <p>2. launch { }</p> <pre><code>scope.launch {\n    sessionManager.clearSession()  // suspend function\n}\n</code></pre> <p>Lanza una nueva coroutine dentro del scope. Necesario porque <code>clearSession()</code> es una funci\u00f3n <code>suspend</code>.</p>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#34-flujo-completo-de-logout","title":"3.4. Flujo completo de Logout","text":"<pre><code>sequenceDiagram\n    participant U as Usuario\n    participant HS as HomeScreen\n    participant SM as SessionManager\n    participant DS as DataStore\n    participant NG as NavGraph\n    participant LS as LoginScreen\n\n    U-&gt;&gt;HS: Click \"Logout\"\n    HS-&gt;&gt;SM: clearSession()\n    SM-&gt;&gt;DS: dataStore.edit { clear() }\n    DS--&gt;&gt;SM: Datos eliminados\n    SM--&gt;&gt;HS: Sesi\u00f3n limpiada\n\n    HS-&gt;&gt;NG: navStack.clear()\n    Note over NG: Elimina todo el historial\n\n    HS-&gt;&gt;NG: navStack.add(AppRoutes.Login)\n    NG-&gt;&gt;LS: Navega a LoginScreen\n\n    Note over LS: Usuario debe autenticarse nuevamente</code></pre> <p>Paso a paso:</p> <ol> <li>Usuario hace click en \"Logout\"</li> <li>HomeScreen ejecuta <code>scope.launch { }</code></li> <li>SessionManager limpia DataStore con <code>clearSession()</code></li> <li>NavStack se limpia completamente (<code>clear()</code>)</li> <li>NavStack agrega Login (<code>add(AppRoutes.Login)</code>)</li> <li>Usuario ve LoginScreen</li> </ol>"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#35-comprobacion-manual-del-logout","title":"3.5. Comprobaci\u00f3n manual del Logout","text":"<p>Escenario completo:</p> <ol> <li>\u2705 Abrir la app \u2192 Ver Splash</li> <li>\u2705 Si no hay sesi\u00f3n \u2192 LoginScreen</li> <li>\u2705 Ingresar credenciales v\u00e1lidas (<code>admin</code> / <code>1234</code>)</li> <li>\u2705 Navegar a HomeScreen</li> <li>\u2705 Cerrar la app completamente (no minimizar)</li> <li>\u2705 Abrir la app de nuevo</li> <li>\u2705 Verificar que va directo a HomeScreen (sesi\u00f3n persiste) \u2705</li> <li>\u2705 Click en bot\u00f3n \"Logout\"</li> <li>\u2705 Verificar que navega a LoginScreen</li> <li>\u2705 Verificar que no puede volver atr\u00e1s (presionar bot\u00f3n atr\u00e1s \u2192 sale de la app)</li> <li>\u2705 Cerrar la app</li> <li>\u2705 Abrir la app de nuevo</li> <li>\u2705 Verificar que va a LoginScreen (sesi\u00f3n eliminada) \u2705</li> </ol> <p>Resultado esperado:</p> Acci\u00f3n Resultado Esperado Login exitoso Va a Home Cerrar y abrir app Va a Home (sesi\u00f3n persiste) Click Logout Va a Login Presionar atr\u00e1s en Login Sale de la app Cerrar y abrir app tras logout Va a Login (sin sesi\u00f3n)"},{"location":"temas/proyectos/GameVault/04-Register-logout.html#ciclo-completo-de-autenticacion","title":"Ciclo completo de autenticaci\u00f3n","text":"<pre><code>graph LR\n    A[Splash] --&gt;|No sesi\u00f3n| B[Login]\n    A --&gt;|Sesi\u00f3n activa| E[Home]\n    B --&gt;|Registro| C[Register]\n    C --&gt;|Cuenta creada| D[Login/Home]\n    B --&gt;|Credenciales| E\n    C --&gt;|Credenciales| E\n    E --&gt;|Logout| B\n\n    style A fill:#ffd93d\n    style B fill:#4d96ff\n    style C fill:#6bcf7f\n    style E fill:#ff6b6b</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html","title":"5. HomeScreen","text":""},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#5-implementacion-de-la-paantalla-de-homescreen-con-catalogo-de-juegos","title":"5. Implementaci\u00f3n de la Paantalla de HomeScreen con Cat\u00e1logo de Juegos","text":"<p>En esta 5\u00aa parte del proyecto, vamos a implementar la pantalla de inicio de la aplicaci\u00f3n, que mostrar\u00e1 un cat\u00e1logo de juegos con funcionalidades de b\u00fasqueda, filtrado y navegaci\u00f3n.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#indice","title":"\ud83d\udcd6 \u00cdndice","text":"<ol> <li>Introducci\u00f3n</li> <li>Arquitectura General</li> <li>Fase 1: Capa de Datos - Models y Repository</li> <li>Fase 2: Capa de Dominio - UseCases</li> <li>Fase 3: Capa de Presentaci\u00f3n - ViewModel</li> <li>Fase 4: Componentes UI Reutilizables</li> <li>Fase 5: HomeScreen Completa</li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#introducci\u00f3n","title":"\ud83c\udfaf Introducci\u00f3n","text":"<p>En esta gu\u00eda implementaremos la pantalla principal (HomeScreen) de MyGameStore, transform\u00e1ndola de una pantalla vac\u00eda en un cat\u00e1logo completo y funcional de juegos.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#que-vamos-a-construir","title":"\u00bfQu\u00e9 vamos a construir?","text":"<p>Una pantalla con las siguientes capacidades:</p> <ul> <li>\u2705 B\u00fasqueda en tiempo real: Los usuarios podr\u00e1n buscar juegos por t\u00edtulo o descripci\u00f3n</li> <li>\u2705 Filtrado por categor\u00edas: ACTION, RPG, ADVENTURE, STRATEGY, SPORTS, etc.</li> <li>\u2705 Filtrado por plataformas: PC, PlayStation, Xbox, Nintendo, Mobile</li> <li>\u2705 Filtrado por fecha: \u00daltimos 7 d\u00edas, 30 d\u00edas, 90 d\u00edas</li> <li>\u2705 Filtrado por g\u00e9neros: M\u00faltiples g\u00e9neros por juego</li> <li>\u2705 Navegaci\u00f3n: Click en un juego para ver detalles</li> <li>\u2705 Barra de navegaci\u00f3n inferior: Acceso r\u00e1pido a Home, Library, Profile</li> <li>\u2705 Gesti\u00f3n de estados: Loading, Success, Empty, Error</li> </ul>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#arquitectura-que-seguiremos","title":"Arquitectura que seguiremos","text":"<p>Esta implementaci\u00f3n sigue Clean Architecture con separaci\u00f3n clara en tres capas:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     PRESENTATION LAYER (UI)         \u2502\n\u2502  - HomeScreen (Composables)         \u2502\n\u2502  - HomeViewModel (Estado)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       DOMAIN LAYER (L\u00f3gica)         \u2502\n\u2502  - GameUseCases (Casos de uso)      \u2502\n\u2502  - Game, Platform, Category (Models)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       DATA LAYER (Datos)            \u2502\n\u2502  - GamesRepository (Interfaz)       \u2502\n\u2502  - GamesRepositoryImpl (Mock)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#por-que-clean-architecture","title":"\u00bfPor qu\u00e9 Clean Architecture?","text":"<ul> <li>Separaci\u00f3n de responsabilidades: Cada capa tiene un prop\u00f3sito claro</li> <li>Testeable: F\u00e1cil hacer testing en cada capa</li> <li>Mantenible: Cambios en una capa no afectan a otras</li> <li>Escalable: Preparado para crecer (API real, m\u00e1s funcionalidades)</li> <li>Independiente del framework: La l\u00f3gica de negocio no depende de Android</li> </ul>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#arquitectura-general","title":"\ud83c\udfd7\ufe0f Arquitectura General","text":""},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#diagrama-de-capas","title":"Diagrama de Capas","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            PRESENTATION LAYER                      \u2502\n\u2502                                                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502   HomeScreen     \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2502  HomeViewModel   \u2502    \u2502\n\u2502  \u2502  (Composable)    \u2502      \u2502   (StateFlow)    \u2502    \u2502\n\u2502  \u2502                  \u2502      \u2502                  \u2502    \u2502\n\u2502  \u2502 - SearchBar      \u2502      \u2502 - HomeUiState    \u2502    \u2502\n\u2502  \u2502 - CategoryRow    \u2502      \u2502 - loadGames()    \u2502    \u2502\n\u2502  \u2502 - GameGrid       \u2502      \u2502 - onSearch()     \u2502    \u2502\n\u2502  \u2502 - BottomNavBar   \u2502      \u2502 - onFilter()     \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502                                     \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            DOMAIN LAYER             \u2502              \u2502\n\u2502                                     \u25bc              \u2502\n\u2502                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502                          \u2502   GameUseCases      \u2502   \u2502\n\u2502                          \u2502                     \u2502   \u2502\n\u2502                          \u2502 - getAllGames()     \u2502   \u2502\n\u2502                          \u2502 - searchGames()     \u2502   \u2502\n\u2502                          \u2502 - getByCategory()   \u2502   \u2502\n\u2502                          \u2502 - getByPlatform()   \u2502   \u2502\n\u2502                          \u2502 - getByInterval()   \u2502   \u2502\n\u2502                          \u2502 - getByGenres()     \u2502   \u2502\n\u2502                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                     \u2502              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            DATA LAYER               \u2502              \u2502\n\u2502                                     \u25bc              \u2502\n\u2502                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502                          \u2502  GamesRepository    \u2502   \u2502\n\u2502                          \u2502    (Interface)      \u2502   \u2502\n\u2502                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                     \u2502              \u2502\n\u2502                          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502                          \u2502 GamesRepositoryImpl \u2502   \u2502\n\u2502                          \u2502   (Mock Data)       \u2502   \u2502\n\u2502                          \u2502                     \u2502   \u2502\n\u2502                          \u2502 - mockGames: List   \u2502   \u2502\n\u2502                          \u2502 - getAllGames()     \u2502   \u2502\n\u2502                          \u2502 - searchGames()     \u2502   \u2502\n\u2502                          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#flujo-de-datos","title":"Flujo de Datos","text":"<p>1. Usuario interact\u00faa con la UI (escribe en b\u00fasqueda, click en filtro) </p><pre><code>HomeScreen \u2192 viewModel.onSearchQueryChange(\"witcher\")\n</code></pre><p></p> <p>2. ViewModel procesa el evento y llama al caso de uso </p><pre><code>HomeViewModel \u2192 gameUseCases.searchGames(\"witcher\")\n</code></pre><p></p> <p>3. UseCase ejecuta l\u00f3gica de negocio y llama al repository </p><pre><code>GameUseCases \u2192 gamesRepository.searchGames(\"witcher\")\n</code></pre><p></p> <p>4. Repository obtiene los datos (mock, API, DB) </p><pre><code>GamesRepositoryImpl \u2192 Flow&lt;List&lt;Game&gt;&gt;\n</code></pre><p></p> <p>5. Datos fluyen de vuelta hacia la UI </p><pre><code>Repository \u2192 UseCase \u2192 ViewModel \u2192 UI State \u2192 HomeScreen (recomposici\u00f3n)\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#fase-1-capa-de-datos","title":"FASE 1: Capa de Datos - Models y Repository","text":"<p>La capa de datos es responsable de obtener y gestionar los datos de la aplicaci\u00f3n. En esta fase crearemos:</p> <ol> <li>Modelos de dominio (Game, GameCategory, Platform, DateInterval)</li> <li>Resource y AppError para manejo de estados</li> <li>MockGamesDataSource con datos de prueba</li> <li>Interfaz del Repository</li> <li>Implementaci\u00f3n mock del Repository</li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-11-crear-el-modelo-game","title":"Paso 1.1: Crear el modelo Game","text":"<p>El modelo <code>Game</code> representa un videojuego en nuestro cat\u00e1logo. Es una entidad de dominio, lo que significa que pertenece a la l\u00f3gica de negocio y es independiente de frameworks.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/domain/model/Game.kt</code></p> <pre><code>package com.pmdm.mygamestore.domain.model\n\nimport kotlinx.serialization.Serializable\n\n/**\n *  Modelo de dominio que representa un juego en el cat\u00e1logo\n *\n * CARACTER\u00cdSTICAS:\n * - Inmutable (val): No se puede modificar despu\u00e9s de creaci\u00f3n\n * - Data class: Kotlin genera equals, hashCode, toString, copy autom\u00e1ticamente\n * - Serializable: Puede ser serializado para navegaci\u00f3n con par\u00e1metros\n * - Domain model: Pertenece a la capa de dominio, no a UI ni datos\n *\n * @property id Identificador \u00fanico del juego (usado como key en listas)\n * @property slug Identificador \u00fanico en formato URL-friendly\n * @property title T\u00edtulo del juego\n * @property description Descripci\u00f3n detallada del juego\n * @property imageUrl URL de la imagen de portada (cargada con Coil)\n * @property price Precio en formato decimal (ej: 59.99)\n * @property rating Valoraci\u00f3n de 0.0 a 5.0 (ej: 4.8)\n * @property releaseDate Fecha de lanzamiento en formato ISO (yyyy-MM-dd): \"2024-01-15\"\n * @property category Categor\u00eda principal del juego (ACTION, RPG, etc.)\n * @property platforms Lista de plataformas en las que est\u00e1 disponible\n * @property genres Lista de g\u00e9neros del juego\n * @property stores Lista de tiendas donde est\u00e1 disponible\n * @property tags Lista de etiquetas/tags del juego\n * @property screenshots Lista de capturas de pantalla\n * @property metacritic Puntuaci\u00f3n de Metacritic (0-100)\n * @property playtime Tiempo de juego promedio en horas\n * @property ratingsCount N\u00famero total de valoraciones\n * @property esrbRating Clasificaci\u00f3n ESRB del juego\n */\n@Serializable\ndata class Game(\n    val id: Int,\n    val slug: String? = null,\n    val title: String,\n    val description: String,\n    val imageUrl: String,\n    val price: Double,\n    val rating: Double,\n    val releaseDate: String,\n    val category: GameCategory,\n    val platforms: List&lt;Platform&gt; = emptyList(),\n    val genres: List&lt;Genre&gt; = emptyList(),\n    val stores: List&lt;Store&gt; = emptyList(),\n    val tags: List&lt;Tag&gt; = emptyList(),\n    val screenshots: List&lt;Screenshot&gt; = emptyList(),\n    val metacritic: Int? = null,\n    val playtime: Int? = null,\n    val ratingsCount: Int? = null,\n    val esrbRating: EsrbRating? = null\n)\n</code></pre> <p>Conceptos clave:</p> <p>Data class en Kotlin: </p><pre><code>// Kotlin genera autom\u00e1ticamente:\n// - equals(): compara por contenido\n// - hashCode(): para usar en colecciones\n// - toString(): representaci\u00f3n en String\n// - copy(): crea copias con modificaciones\n\nval game1 = Game(id = 1, title = \"Witcher\", ...)\nval game2 = game1.copy(price = 29.99) // Copia modificando solo el precio\n</code></pre><p></p> <p>@Serializable: - Permite convertir el objeto a/desde JSON o otros formatos - Necesario para navegaci\u00f3n con par\u00e1metros tipo-safe - Usado por la librer\u00eda navigation3</p> <p>Inmutabilidad (val): - Los datos no cambian despu\u00e9s de creaci\u00f3n - Previene bugs por modificaciones accidentales - Ideal para arquitecturas reactivas (StateFlow, Flow)</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-12-crear-enums-para-categorias-plataformas-e-intervalos","title":"Paso 1.2: Crear enums para categor\u00edas, plataformas e intervalos","text":"<p>Los enums nos permiten definir conjuntos cerrados de valores posibles, proporcionando type-safety y evitando errores.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/domain/model/GameEnums.kt</code></p> <pre><code>package com.pmdm.mygamestore.domain.model\n\n/**\n *  Categor\u00edas principales de juegos\n *\n * Representa los g\u00e9neros principales disponibles en el cat\u00e1logo.\n * Usado para filtrar juegos por categor\u00eda.\n */\nenum class GameCategory {\n    ALL,        // Todas las categor\u00edas (sin filtro)\n    ACTION,     // Juegos de acci\u00f3n (God of War, Halo)\n    ADVENTURE,  // Aventuras (Zelda, Uncharted)\n    RPG,        // Role-Playing Games (Witcher, Elden Ring)\n    STRATEGY,   // Estrategia (Civilization, Age of Empires)\n    SPORTS,     // Deportes (FIFA, Forza)\n    SIMULATION, // Simulaci\u00f3n (Stardew Valley, Minecraft)\n    PUZZLE      // Puzzles (Tetris, Portal)\n}\n\n/**\n *  Plataformas de videojuegos\n *\n * Representa las plataformas en las que un juego est\u00e1 disponible.\n * Usado para filtrar juegos por plataforma.\n */\nenum class Platform {\n    ALL,         // Todas las plataformas (sin filtro)\n    PC,          // Windows, Mac, Linux\n    PLAYSTATION, // PS4, PS5\n    XBOX,        // Xbox One, Xbox Series X/S\n    NINTENDO,    // Nintendo Switch\n    MOBILE       // iOS, Android\n}\n\n/**\n *  Intervalos de fechas para filtrar lanzamientos\n *\n * Permite filtrar juegos seg\u00fan cu\u00e1ndo fueron lanzados.\n * \u00datil para secciones como \"Novedades de la semana\" o \"Lanzamientos recientes\".\n */\nenum class DateInterval {\n    ALL_TIME,      // Todos los tiempos (sin filtro de fecha)\n    LAST_WEEK,     // \u00daltimos 7 d\u00edas\n    LAST_30_DAYS,  // \u00daltimo mes\n    LAST_90_DAYS   // \u00daltimos 3 meses\n}\n</code></pre> <p>** \u00bfPor qu\u00e9 usar enums?**</p> <p>Ventajas:</p> <ol> <li> <p>Type-safety: El compilador previene valores inv\u00e1lidos </p><pre><code>// \u2705 Correcto\nval category: GameCategory = GameCategory.RPG\n\n// \u274c Error de compilaci\u00f3n\nval category: GameCategory = \"RPG\" // No compila\n</code></pre><p></p> </li> <li> <p>Exhaustive when: El compilador verifica que manejamos todos los casos </p><pre><code>when (category) {\n    GameCategory.ALL -&gt; // ...\n    GameCategory.ACTION -&gt; // ...\n    GameCategory.RPG -&gt; // ...\n    // Si falta un caso, el compilador avisa\n}\n</code></pre><p></p> </li> <li> <p>Autocomplete: El IDE sugiere valores v\u00e1lidos </p><pre><code>val cat = GameCategory. // IDE muestra: ALL, ACTION, RPG, etc.\n</code></pre><p></p> </li> <li> <p>Refactoring seguro: Renombrar un valor actualiza todo el c\u00f3digo</p> </li> <li> <p>Iterable: Podemos iterar sobre todos los valores </p><pre><code>GameCategory.entries.forEach { category -&gt;\n    // Procesar cada categor\u00eda\n}\n</code></pre><p></p> </li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-13-crear-resource-y-apperror-para-manejo-de-estados","title":"Paso 1.3: Crear Resource y AppError para manejo de estados","text":"<p>Antes de crear el Repository, definimos c\u00f3mo manejaremos estados y errores de forma robusta y type-safe.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/domain/model/Resource.kt</code></p> <pre><code>package com.pmdm.mygamestore.domain.model\n\n/**\n *  Sealed class que representa el estado de una operaci\u00f3n\n *\n * PATR\u00d3N RESOURCE/RESULT:\n * \u2705 Manejo expl\u00edcito de estados (Loading, Success, Error)\n * \u2705 Type-safe: El compilador obliga a manejar todos los casos\n * \u2705 Errores tipados con informaci\u00f3n espec\u00edfica\n * \u2705 Elimina null checks y excepciones no controladas\n *\n * VENTAJAS:\n * - Exhaustive when: El compilador verifica todos los casos\n * - Sin null: Evita NullPointerException\n * - Errores descriptivos: Sabemos qu\u00e9 fall\u00f3 exactamente\n * - UI reactiva: La UI puede reaccionar a cada estado\n *\n * FLUJO T\u00cdPICO:\n * 1. Loading \u2192 Mostrar spinner\n * 2. Success \u2192 Mostrar datos\n * 3. Error \u2192 Mostrar mensaje de error\n *\n * @param T Tipo de dato que contiene en caso de \u00e9xito\n */\nsealed class Resource&lt;out T&gt; {\n\n    /**\n     * \u23f3 Estado: Operaci\u00f3n en progreso\n     *\n     * Se emite al iniciar una operaci\u00f3n as\u00edncrona.\n     * La UI muestra loading indicator.\n     *\n     * Ejemplo:\n     * ```\n     * when (resource) {\n     *     is Resource.Loading -&gt; showLoadingSpinner()\n     * }\n     * ```\n     */\n    data object Loading : Resource&lt;Nothing&gt;()\n\n    /**\n     * \u2705 Estado: Operaci\u00f3n completada exitosamente\n     *\n     * Contiene los datos solicitados.\n     *\n     * @param data Datos obtenidos de la operaci\u00f3n\n     *\n     * Ejemplo:\n     * ```\n     * when (resource) {\n     *     is Resource.Success -&gt; {\n     *         val games = resource.data\n     *         showGames(games)\n     *     }\n     * }\n     * ```\n     */\n    data class Success&lt;T&gt;(val data: T) : Resource&lt;T&gt;()\n\n    /**\n     * \u274c Estado: Operaci\u00f3n fall\u00f3\n     *\n     * Contiene informaci\u00f3n detallada del error.\n     *\n     * @param error Error espec\u00edfico que ocurri\u00f3\n     *\n     * Ejemplo:\n     * ```\n     * when (resource) {\n     *     is Resource.Error -&gt; {\n     *         when (resource.error) {\n     *             is AppError.NetworkError -&gt; showNoInternetMessage()\n     *             is AppError.NotFound -&gt; showNotFoundMessage()\n     *         }\n     *     }\n     * }\n     * ```\n     */\n    data class Error(val error: AppError) : Resource&lt;Nothing&gt;()\n}\n\n/**\n *  Sealed class que representa errores espec\u00edficos de la app\n *\n * Permite manejar diferentes tipos de errores de forma espec\u00edfica:\n * - Errores de red (sin conexi\u00f3n, timeout)\n * - Errores de base de datos (corrupci\u00f3n, falta de espacio)\n * - Errores de negocio (no encontrado, no autorizado)\n * - Errores de validaci\u00f3n\n * - Errores desconocidos\n *\n * VENTAJAS:\n * \u2705 Errores tipados y espec\u00edficos\n * \u2705 La UI puede mostrar mensajes personalizados\n * \u2705 F\u00e1cil logging y analytics\n * \u2705 Manejo exhaustivo con when\n */\nsealed class AppError {\n\n    /**\n     *  Error de red\n     *\n     * Ocurre cuando:\n     * - No hay conexi\u00f3n a Internet\n     * - Timeout de la petici\u00f3n\n     * - Error del servidor (5xx)\n     *\n     * @param message Descripci\u00f3n del error\n     *\n     * Ejemplo de uso:\n     * ```\n     * when (error) {\n     *     is AppError.NetworkError -&gt; {\n     *         showSnackbar(\"Check your internet connection\")\n     *     }\n     * }\n     * ```\n     */\n    data class NetworkError(val message: String) : AppError()\n\n    /**\n     *  Error de base de datos\n     *\n     * Ocurre cuando:\n     * - No se puede acceder a la base de datos\n     * - Datos corruptos\n     * - Falta de espacio en disco\n     *\n     * @param message Descripci\u00f3n del error\n     */\n    data class DatabaseError(val message: String) : AppError()\n\n    /**\n     *  Recurso no encontrado (404)\n     *\n     * Ocurre cuando:\n     * - El juego con ID especificado no existe\n     * - La b\u00fasqueda no tiene resultados\n     * - La categor\u00eda no tiene juegos\n     *\n     * Ejemplo de uso:\n     * ```\n     * when (error) {\n     *     is AppError.NotFound -&gt; {\n     *         showEmptyState(\"No games found\")\n     *     }\n     * }\n     * ```\n     */\n    data object NotFound : AppError()\n\n    /**\n     *  No autorizado (401/403)\n     *\n     * Ocurre cuando:\n     * - El usuario no tiene sesi\u00f3n activa\n     * - El token de autenticaci\u00f3n expir\u00f3\n     * - No tiene permisos para la operaci\u00f3n\n     *\n     * Ejemplo de uso:\n     * ```\n     * when (error) {\n     *     is AppError.Unauthorized -&gt; {\n     *         navigateToLogin()\n     *     }\n     * }\n     * ```\n     */\n    data object Unauthorized : AppError()\n\n    /**\n     * \u26a0\ufe0f Error de validaci\u00f3n\n     *\n     * Ocurre cuando:\n     * - Query de b\u00fasqueda inv\u00e1lido\n     * - Par\u00e1metros fuera de rango\n     * - Formato de datos incorrecto\n     *\n     * @param message Descripci\u00f3n del error de validaci\u00f3n\n     *\n     * Ejemplo de uso:\n     * ```\n     * when (error) {\n     *     is AppError.ValidationError -&gt; {\n     *         showError(error.message)\n     *     }\n     * }\n     * ```\n     */\n    data class ValidationError(val message: String) : AppError()\n\n    /**\n     * \u2753 Error desconocido\n     *\n     * Ocurre cuando:\n     * - Excepci\u00f3n no prevista\n     * - Error sin categor\u00eda espec\u00edfica\n     *\n     * @param message Descripci\u00f3n del error\n     *\n     * Ejemplo de uso:\n     * ```\n     * when (error) {\n     *     is AppError.Unknown -&gt; {\n     *         logError(error.message)\n     *         showGenericError()\n     *     }\n     * }\n     * ```\n     */\n    data class Unknown(val message: String) : AppError()\n}\n</code></pre> <p>Conceptos clave de Resource:</p> <p>1. \u00bfPor qu\u00e9 Resource y no solo T?</p> <pre><code>// \u274c Sin Resource: No sabemos si est\u00e1 cargando, si fall\u00f3, etc.\nfun getAllGames(): Flow&lt;List&lt;Game&gt;&gt;\n\n// \u2705 Con Resource: Estados expl\u00edcitos\nfun getAllGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt;\n</code></pre> <p>2. Pattern matching con when exhaustivo:</p> <pre><code>when (val result = resource) {\n    is Resource.Loading -&gt; {\n        // Mostrar loading\n        showLoadingIndicator()\n    }\n    is Resource.Success -&gt; {\n        val games = result.data\n        // Mostrar juegos\n        displayGames(games)\n    }\n    is Resource.Error -&gt; {\n        when (result.error) {\n            is AppError.NetworkError -&gt; showNoInternetDialog()\n            is AppError.NotFound -&gt; showEmptyState()\n            is AppError.Unknown -&gt; showGenericError()\n            // El compilador obliga a manejar todos los casos\n        }\n    }\n}\n</code></pre> <p>3. Type-safety en errores:</p> <pre><code>// \u274c Sin tipos: ambiguo, dif\u00edcil de manejar\nthrow Exception(\"Network error\")\n\n// \u2705 Con tipos: claro y espec\u00edfico\nAppError.NetworkError(\"No internet connection\")\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-14-crear-mockgamesdatasource","title":"Paso 1.4: Crear MockGamesDataSource","text":"<p>Separamos los datos mock en su propia clase para mantener limpio el repository y facilitar la migraci\u00f3n a API real.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/data/local/MockDataSource.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.local\n\n/**\n * MockDataSource es un objeto que simula una fuente de datos para una aplicaci\u00f3n centrada en videojuegos.\n * Sirve como recurso inicial para proporcionar informaci\u00f3n est\u00e1tica relacionada con g\u00e9neros, plataformas,\n * editores, tiendas, etiquetas y juegos.\n *\n * Datos prove\u00eddos:\n * - `genres`: Lista de g\u00e9neros populares de videojuegos, definidos por un identificador \u00fanico, nombre y slug.\n * - `platforms`: Lista de plataformas disponibles para videojuegos, con su respectivo identificador, nombre y slug.\n * - `publishers`: Lista de editores de videojuegos reconocidos, identificados por un ID, nombre y slug.\n * - `stores`: Lista de tiendas en las que se pueden adquirir juegos o contenido relacionado, con su correspondiente identificador, nombre y slug.\n * - `tags`: Lista de etiquetas (tags) relevantes para clasificar los videojuegos, definidas por ID, nombre y slug.\n * - `games`: Lista de detalles de juegos predefinidos, incluyendo informaci\u00f3n como t\u00edtulo, descripci\u00f3n, precio, calificaci\u00f3n, fecha de lanzamiento,\n *  plataformas soportadas, g\u00e9neros relacionados, tiendas donde est\u00e1n disponibles, etiquetas asociadas, capturas de pantalla, entre otros atributos espec\u00edficos\n * .\n */\nobject MockDataSource {\n\n    /**\n     *  Lista de juegos mock para desarrollo\n     *\n     * En producci\u00f3n real, esto vendr\u00eda de:\n     * - API REST: GET https://api.example.com/games\n     * - Base de datos: Room + SQLite\n     * - Firebase: Firestore collection \"games\"\n     * - Cach\u00e9 h\u00edbrida: Room + Retrofit con pol\u00edtica de cach\u00e9\n     */\n    val games = listOf(\n        // ... contenido\n    )\n\n    val platforms = listOf(\n        Platform(id = 4, name = \"PC\", slug = \"pc\"),\n        Platform(id = 187, name = \"PlayStation 5\", slug = \"playstation5\"),\n        Platform(id = 18, name = \"PlayStation 4\", slug = \"playstation4\"),\n        Platform(id = 1, name = \"PlayStation 3\", slug = \"playstation3\"),\n        Platform(id = 186, name = \"Xbox Series S/X\", slug = \"xbox-series-x\"),\n        Platform(id = 14, name = \"Xbox One\", slug = \"xbox-one\"),\n        Platform(id = 80, name = \"Xbox 360\", slug = \"xbox360\"),\n        Platform(id = 7, name = \"Nintendo Switch\", slug = \"nintendo-switch\"),\n        Platform(id = 3, name = \"iOS\", slug = \"ios\"),\n        Platform(id = 21, name = \"Android\", slug = \"android\")\n    )\n\n    val publishers = listOf(\n        Publisher(id = 354, name = \"Electronic Arts\", slug = \"electronic-arts\"),\n        Publisher(id = 3408, name = \"Ubisoft Entertainment\", slug = \"ubisoft-entertainment\"),\n        Publisher(id = 339, name = \"Bethesda Softworks\", slug = \"bethesda-softworks\"),\n        Publisher(id = 3399, name = \"Rockstar Games\", slug = \"rockstar-games\"),\n        Publisher(id = 33, name = \"Warner Bros. Interactive\", slug = \"warner-bros-interactive\"),\n        Publisher(id = 209, name = \"Sony Interactive Entertainment\", slug = \"sony-interactive-entertainment\"),\n        Publisher(id = 45, name = \"Microsoft Xbox Game Studios\", slug = \"microsoft-xbox-game-studios\"),\n        Publisher(id = 16257, name = \"Nintendo\", slug = \"nintendo\"),\n        Publisher(id = 9191, name = \"Sega\", slug = \"sega-2\"),\n        Publisher(id = 3390, name = \"Square Enix\", slug = \"square-enix\"),\n        Publisher(id = 347, name = \"Capcom\", slug = \"capcom\"),\n        Publisher(id = 345, name = \"Activision Blizzard\", slug = \"activision-blizzard\"),\n        Publisher(id = 25, name = \"2K Games\", slug = \"2k-games\"),\n        Publisher(id = 208, name = \"Bandai Namco Entertainment\", slug = \"bandai-namco-entertainment\"),\n        Publisher(id = 3410, name = \"Deep Silver\", slug = \"deep-silver\")\n    )\n\n    val stores = listOf(\n        Store(id = 1, name = \"Steam\", slug = \"steam\"),\n        Store(id = 3, name = \"PlayStation Store\", slug = \"playstation-store\"),\n        Store(id = 2, name = \"Xbox Store\", slug = \"xbox-store\"),\n        Store(id = 4, name = \"App Store\", slug = \"apple-appstore\"),\n        Store(id = 8, name = \"Google Play\", slug = \"google-play\"),\n        Store(id = 5, name = \"GOG\", slug = \"gog\"),\n        Store(id = 6, name = \"Nintendo Store\", slug = \"nintendo\"),\n        Store(id = 7, name = \"Xbox 360 Store\", slug = \"xbox360\"),\n        Store(id = 9, name = \"itch.io\", slug = \"itch\"),\n        Store(id = 11, name = \"Epic Games\", slug = \"epic-games\")\n    )\n\n    val tags = listOf(\n        Tag(id = 31, name = \"Singleplayer\", slug = \"singleplayer\"),\n        Tag(id = 40836, name = \"Full controller support\", slug = \"full-controller-support\"),\n        Tag(id = 7, name = \"Multiplayer\", slug = \"multiplayer\"),\n        Tag(id = 40847, name = \"Steam Achievements\", slug = \"steam-achievements\"),\n        Tag(id = 13, name = \"Atmospheric\", slug = \"atmospheric\"),\n        Tag(id = 40849, name = \"Steam Cloud\", slug = \"steam-cloud\"),\n        Tag(id = 42, name = \"Great Soundtrack\", slug = \"great-soundtrack\"),\n        Tag(id = 24, name = \"RPG\", slug = \"rpg\"),\n        Tag(id = 18, name = \"Co-op\", slug = \"co-op\"),\n        Tag(id = 118, name = \"Story Rich\", slug = \"story-rich\"),\n        Tag(id = 411, name = \"Cooperative\", slug = \"cooperative\"),\n        Tag(id = 8, name = \"First-Person\", slug = \"first-person\"),\n        Tag(id = 32, name = \"Sci-fi\", slug = \"sci-fi\"),\n        Tag(id = 149, name = \"Third Person\", slug = \"third-person\"),\n        Tag(id = 4, name = \"Funny\", slug = \"funny\"),\n        Tag(id = 37, name = \"Sandbox\", slug = \"sandbox\"),\n        Tag(id = 123, name = \"Comedy\", slug = \"comedy\"),\n        Tag(id = 64, name = \"Fantasy\", slug = \"fantasy\"),\n        Tag(id = 147, name = \"2D\", slug = \"2d\")\n    )\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-15-crear-interfaz-gamesrepository","title":"Paso 1.5: Crear interfaz GamesRepository","text":"<p>El patr\u00f3n Repository abstrae el origen de los datos. Definimos un contrato que cualquier implementaci\u00f3n (mock o real) debe cumplir.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/data/repository/GamesRepository.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.repository\n\n/**\n *  Interfaz que define el contrato del repositorio de juegos\n *\n * PATR\u00d3N REPOSITORY:\n * \u2705 Abstrae la fuente de datos (API, DB, Mock)\n * \u2705 Permite m\u00faltiples implementaciones\n * \u2705 Facilita testing con mocks\n * \u2705 Aplica principio de Inversi\u00f3n de Dependencias (SOLID)\n *\n * IMPLEMENTACIONES:\n * 1. MockGamesRepositoryImpl \u2192 Desarrollo local, filtra en memoria\n * 2. GamesRepositoryImpl \u2192 Producci\u00f3n, filtra en API/backend\n *\n * BENEFICIOS:\n * - Desacoplamiento: UseCases no saben de d\u00f3nde vienen los datos\n * - Testing: F\u00e1cil crear implementaciones de prueba\n * - Flexibilidad: Cambiar de mock a API sin modificar UseCases\n * - Mantenibilidad: Un solo punto de cambio para origen de datos\n *\n * IMPORTANTE - Resource Pattern:\n * Todos los m\u00e9todos devuelven Flow&lt;Resource&lt;T&gt;&gt; para manejar:\n * - Loading: Operaci\u00f3n en progreso\n * - Success: Datos obtenidos correctamente\n * - Error: Algo fall\u00f3 con informaci\u00f3n espec\u00edfica\n */\ninterface GamesRepository {\n    /**\n    * Obtiene todos los juegos disponibles en el cat\u00e1logo\n    */\n    fun getAllGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt;\n\n    /**\n     * Busca juegos combinando m\u00faltiples criterios de filtrado\n     */\n    fun getFilteredGames(\n        query: String = \"\",\n        category: GameCategory = GameCategory.ALL,\n        platform: PlatformEnum = PlatformEnum.ALL,\n        interval: DateInterval = DateInterval.ALL_TIME\n    ): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt;\n\n    /**\n     * Obtiene un juego espec\u00edfico por su ID\n     */\n    suspend fun getGameById(id: Int): Resource&lt;Game&gt;\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-16-implementar-mockgamesrepositoryimpl","title":"Paso 1.6: Implementar MockGamesRepositoryImpl","text":"<p>Esta implementaci\u00f3n simula lo que har\u00eda una API real, pero filtrando datos en memoria. Es para desarrollo sin depender de backend.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/data/repository/MockGamesRepositoryImpl.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.repository\n\n/**\n *  Implementaci\u00f3n MOCK del repositorio de juegos\n *\n * PROP\u00d3SITO:\n * - Desarrollo sin depender de backend/API\n * - Testing con datos controlados\n * - Simular comportamiento de API real\n *\n * CARACTER\u00cdSTICAS:\n * \u2705 Filtra datos en MEMORIA (no en servidor)\n * \u2705 Simula delays de red para testing realista\n * \u2705 Devuelve Resource (Loading \u2192 Success/Error)\n * \u2705 Maneja errores con try-catch\n *\n * IMPORTANTE - Filtros locales:\n * Esta implementaci\u00f3n filtra MockGamesDataSource en el DISPOSITIVO.\n * En una API real, los filtros se ejecutar\u00edan en el BACKEND.\n *\n * Ejemplo de diferencia:\n */\nclass MockGamesRepositoryImpl : GamesRepository {\n    private val dataSource = MockDataSource\n\n    private suspend fun simulateNetworkDelay() {\n        delay(800)\n    }\n\n    override fun getAllGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; = flow {\n        try {\n            emit(Resource.Loading)\n            simulateNetworkDelay()\n            emit(Resource.Success(dataSource.games))\n        } catch (e: Exception) {\n            emit(Resource.Error(AppError.Unknown(e.message ?: \"Unknown error\")))\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    override fun getFilteredGames(\n        query: String,\n        category: GameCategory,\n        platform: PlatformEnum,\n        interval: DateInterval\n    ): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; = flow {\n        try {\n            emit(Resource.Loading)\n            simulateNetworkDelay()\n\n            var filtered = dataSource.games\n\n            // Filtro por Query\n            if (query.isNotBlank()) {\n                filtered = filtered.filter { game -&gt;\n                    game.title.contains(query, ignoreCase = true) ||\n                            game.description.contains(query, ignoreCase = true)\n                }\n            }\n\n            // Filtro por Categor\u00eda\n            if (category != GameCategory.ALL) {\n                filtered = filtered.filter { it.category == category }\n            }\n\n            // Filtro por Plataforma\n            if (platform != PlatformEnum.ALL) {\n                filtered = filtered.filter { game -&gt;\n                    game.platforms.any { p -&gt;\n                        when (platform) {\n                            PlatformEnum.PC -&gt; p.slug.contains(\"pc\", ignoreCase = true)\n                            PlatformEnum.PLAYSTATION -&gt; p.slug.contains(\"playstation\", ignoreCase = true)\n                            PlatformEnum.XBOX -&gt; p.slug.contains(\"xbox\", ignoreCase = true)\n                            PlatformEnum.NINTENDO -&gt; p.slug.contains(\"nintendo\", ignoreCase = true)\n                            PlatformEnum.MOBILE -&gt; p.slug.contains(\"android\", ignoreCase = true) || p.slug.contains(\"ios\", ignoreCase = true)\n                            else -&gt; false\n                        }\n                    }\n                }\n            }\n\n            // Filtro por Intervalo\n            if (interval != DateInterval.ALL_TIME) {\n                val now = LocalDate.now()\n                filtered = filtered.filter {\n                    val gameDate = LocalDate.parse(it.releaseDate, DateTimeFormatter.ISO_DATE)\n                    when (interval) {\n                        DateInterval.LAST_WEEK -&gt; gameDate.isAfter(now.minusWeeks(1))\n                        DateInterval.LAST_30_DAYS -&gt; gameDate.isAfter(now.minusDays(30))\n                        DateInterval.LAST_90_DAYS -&gt; gameDate.isAfter(now.minusDays(90))\n                        else -&gt; true\n                    }\n                }\n            }\n\n            emit(Resource.Success(filtered))\n        } catch (e: Exception) {\n            emit(Resource.Error(AppError.Unknown(e.message ?: \"Error filtering games\")))\n        }\n    }\n\n    override suspend fun getGameById(id: Int): Resource&lt;Game&gt; {\n        return try {\n            simulateNetworkDelay()\n\n            val game = dataSource.games.find { it.id == id }\n\n            if (game != null) {\n                Resource.Success(game)\n            } else {\n                Resource.Error(AppError.NotFound)\n            }\n        } catch (e: Exception) {\n            Resource.Error(AppError.Unknown(e.message ?: \"Error getting game\"))\n        }\n    }\n}\n</code></pre> <p>Conceptos clave del MockRepository:</p> <p>1. Flow builder con try-catch:</p> <pre><code>fun getData(): Flow&lt;Resource&lt;T&gt;&gt; = flow {\n    try {\n        emit(Resource.Loading)\n        // Operaci\u00f3n que puede fallar\n        val data = fetchData()\n        emit(Resource.Success(data))\n    } catch (e: Exception) {\n        emit(Resource.Error(AppError.Unknown(e.message)))\n    }\n}\n</code></pre> <p>2. Patr\u00f3n de emisi\u00f3n est\u00e1ndar:</p> <pre><code>Loading \u2192 (operaci\u00f3n) \u2192 Success/Error\n</code></pre> <p>Siempre en este orden para que la UI pueda reaccionar correctamente.</p> <p>3. Filtrado local vs remoto:</p> <pre><code>// Mock: Filtra TODOS los juegos en memoria\nval filtered = mockGames.filter { condition }\n\n// API (futuro): Servidor filtra y devuelve solo resultados\nval response = api.getGames(filter = \"RPG\") // Solo env\u00eda RPGs\n</code></pre> <p>\u2705 Resumen de la Fase 1</p> <p>Has completado la capa de datos con:</p> <ol> <li>\u2705 Modelo Game con propiedades completas</li> <li>\u2705 Enums (GameCategory, Platform, DateInterval) para type-safety</li> <li>\u2705 Resource para manejar estados (Loading, Success, Error)</li> <li>\u2705 AppError con errores espec\u00edficos y tipados</li> <li>\u2705 MockGamesDataSource con 12 juegos de prueba</li> <li>\u2705 GamesRepository (interfaz) que define el contrato</li> <li>\u2705 MockGamesRepositoryImpl que filtra en memoria</li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#fase-2-capa-de-dominio","title":"FASE 2: Capa de Dominio - UseCases","text":"<p>La capa de dominio contiene la l\u00f3gica de negocio de la aplicaci\u00f3n. Los UseCases son el coraz\u00f3n de esta capa y representan las acciones que un usuario puede realizar.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#que-son-los-usecases","title":"\u00bfQu\u00e9 son los UseCases?","text":"<p>Los UseCases (Casos de Uso) son clases que:</p> <ul> <li>\u2705 Encapsulan l\u00f3gica de negocio espec\u00edfica</li> <li>\u2705 Orquestan llamadas a repositories</li> <li>\u2705 Transforman y procesan datos seg\u00fan reglas de negocio</li> <li>\u2705 Son independientes del framework (Android, iOS, Web)</li> </ul>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#arquitectura-de-nuestros-usecases","title":"Arquitectura de nuestros UseCases","text":"<p>En este proyecto, los UseCases est\u00e1n agrupados por funcionalidad:</p> <pre><code>domain/usecase/\n  \u251c\u2500 GameUseCases.kt      \u2190 Todos los casos de uso de Game\n  \u251c\u2500 LibraryUseCases.kt   \u2190 (Futuro) Casos de uso de Library\n  \u2514\u2500 UserUseCases.kt      \u2190 (Futuro) Casos de uso de User\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#responsabilidades-de-usecases-vs-repository","title":"Responsabilidades de UseCases vs Repository","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         GAMEUSECASES                    \u2502\n\u2502  (L\u00f3gica de negocio + Transformaci\u00f3n)   \u2502\n\u2502                                         \u2502\n\u2502  \u2705 Ordenar por rating                  \u2502\n\u2502  \u2705 Ordenar por relevancia              \u2502\n\u2502  \u2705 Combinar m\u00faltiples filtros          \u2502\n\u2502  \u2705 Aplicar reglas de negocio           \u2502\n\u2502  \u2705 Transformar Resource&lt;T&gt;             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        GAMESREPOSITORY                  \u2502\n\u2502     (Acceso a datos puro)               \u2502\n\u2502                                         \u2502\n\u2502  \u2705 Obtener datos (mock/API)            \u2502\n\u2502  \u2705 Filtrar datos b\u00e1sico                \u2502\n\u2502  \u2705 Emitir Resource states              \u2502\n\u2502  \u274c NO tiene l\u00f3gica de ordenamiento     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-21-crear-clase-gameusecases","title":"Paso 2.1: Crear clase GameUseCases","text":"<p>Esta clase agrupa todos los casos de uso relacionados con juegos. Cada m\u00e9todo representa una acci\u00f3n espec\u00edfica que el usuario puede realizar.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/domain/usecase/GameUseCases.kt</code></p> <pre><code>package com.pmdm.mygamestore.domain.usecase\n\n/**\n *  Casos de uso agrupados para operaciones con juegos\n *\n * PATR\u00d3N USE CASE:\n * - Encapsula l\u00f3gica de negocio espec\u00edfica de la aplicaci\u00f3n\n * - Orquesta llamadas a uno o m\u00e1s repositories\n * - Transforma datos del dominio para casos de uso espec\u00edficos\n * - Es independiente del framework (Android, iOS, Web)\n *\n * ORGANIZACI\u00d3N:\n * \u2705 Una clase por entidad/funcionalidad (GameUseCases, LibraryUseCases, etc.)\n * \u2705 Cada m\u00e9todo es un caso de uso concreto\n * \u2705 NO usamos operator invoke() (llamada directa al m\u00e9todo)\n * \u2705 Preparado para inyecci\u00f3n de dependencias con Koin\n *\n * MANEJO DE RESOURCE:\n * \u2705 Recibe Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; del repository\n * \u2705 Aplica l\u00f3gica solo a Resource.Success\n * \u2705 Propaga Loading y Error sin modificar\n * \u2705 Devuelve Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; al ViewModel\n *\n * @property gamesRepository Repository para acceder a los datos de juegos\n */\nclass GameUseCases(\n    private val gamesRepository: GamesRepository\n) {\n     // ... contenido \n}\n</code></pre> <p>[!TIP]</p> <p>Puedes revisar el contenido en <code>presentation/domain/usercase/GameUseCases.kt</code>.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#conceptos-clave-de-los-usecases","title":"Conceptos clave de los UseCases","text":""},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#1-flowmap-para-transformar-resource","title":"1. Flow.map { } para transformar Resource","text":"<pre><code>fun getTopRatedGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; {\n    return repository.getAllGames()\n        .map { resource -&gt;\n            when (resource) {\n                is Resource.Success -&gt; {\n                    // Transformar SOLO los datos de Success\n                    val filtered = resource.data.filter { it.rating &gt;= 4.5 }\n                    Resource.Success(filtered)\n                }\n                is Resource.Loading -&gt; resource // Propagar\n                is Resource.Error -&gt; resource   // Propagar\n            }\n        }\n}\n</code></pre> <p>\u00bfPor qu\u00e9 este patr\u00f3n? - \u2705 La l\u00f3gica solo se aplica a datos exitosos - \u2705 Loading y Error se propagan sin modificar - \u2705 La UI recibe estados correctos</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#2-sortedby-vs-sortedbydescending","title":"2. sortedBy vs sortedByDescending","text":"<pre><code>// Orden ascendente (menor a mayor)\ngames.sortedBy { it.price }\n// Resultado: [$14.99, $19.99, $29.99, $39.99]\n\n// Orden descendente (mayor a menor)\ngames.sortedByDescending { it.rating }\n// Resultado: [5.0, 4.9, 4.8, 4.7]\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#3-filter-para-filtrar-elementos","title":"3. filter para filtrar elementos","text":"<pre><code>// Filtrar juegos con rating &gt;= 4.5\nval topGames = games.filter { it.rating &gt;= 4.5 }\n\n// Filtrar por m\u00faltiples condiciones (AND)\nval filtered = games.filter { \n    it.rating &gt;= 4.0 &amp;&amp; it.price &lt;= 40.0 \n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#4-take-para-limitar-resultados","title":"4. take() para limitar resultados","text":"<pre><code>// Tomar los primeros 5 elementos\nval top5 = games.take(5)\n\n// Tomar los \u00faltimos 3\nval last3 = games.takeLast(3)\n\n// Tomar mientras se cumpla condici\u00f3n\nval expensive = games.takeWhile { it.price &gt; 50.0 }\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#5-diferencia-entre-suspend-fun-y-flow","title":"5. Diferencia entre suspend fun y Flow","text":"<pre><code>// suspend fun: Devuelve UN valor\nsuspend fun getGameById(id: Int): Resource&lt;Game&gt;\n\n// Flow: Puede emitir M\u00daLTIPLES valores en el tiempo\nfun getAllGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt;\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#flujo-completo-de-un-caso-de-uso-con-resource","title":"Flujo completo de un caso de uso con Resource","text":"<pre><code>1. Usuario escribe \"witcher\" en b\u00fasqueda\n   \u2502\n   \u25bc\n2. HomeScreen \u2192 viewModel.onSearchQueryChange(\"witcher\")\n   \u2502\n   \u25bc\n3. HomeViewModel \u2192 gameUseCases.searchGames(\"witcher\")\n   \u2502\n   \u25bc\n4. GameUseCases \u2192 gamesRepository.searchGames(\"witcher\")\n   \u2502                    .map { ordenar por relevancia }\n   \u25bc\n5. MockGamesRepositoryImpl:\n   \u2502  emit(Resource.Loading)          \u2190 UI muestra spinner\n   \u2502  delay(800)                       \u2190 Simula red\n   \u2502  val filtered = mockGames.filter()\n   \u2502  emit(Resource.Success(filtered)) \u2190 UI muestra juegos\n   \u25bc\n6. GameUseCases.map:\n   \u2502  when (Resource.Success) {\n   \u2502    ordenar por relevancia\n   \u2502    devolver Resource.Success(sorted)\n   \u2502  }\n   \u25bc\n7. HomeViewModel.collect:\n   \u2502  when (Resource.Success) {\n   \u2502    _uiState.update { games = result.data }\n   \u2502  }\n   \u25bc\n8. HomeScreen recompone con nuevos datos\n</code></pre> <p>\u2705 Resumen de la Fase 2</p> <p>Se ha completado la capa de dominio con:</p> <ol> <li>\u2705 Clase GameUseCases con 10 casos de uso:</li> <li>\u2705 L\u00f3gica de negocio implementada.</li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#fase-3-capa-de-presentaci\u00f3n","title":"FASE 3: Capa de Presentaci\u00f3n - ViewModel","text":"<p>La capa de presentaci\u00f3n gestiona el estado de la UI y coordina la l\u00f3gica de presentaci\u00f3n. El ViewModel es el componente central que conecta la UI con los casos de uso.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#que-es-un-viewmodel","title":"\u00bfQu\u00e9 es un ViewModel?","text":"<p>El ViewModel en MVVM:</p> <ul> <li>\u2705 Gestiona el estado de la UI (HomeUiState)</li> <li>\u2705 Sobrevive a cambios de configuraci\u00f3n (rotaci\u00f3n de pantalla)</li> <li>\u2705 Coordina casos de uso (GameUseCases)</li> <li>\u2705 Transforma datos del dominio para la UI</li> <li>\u2705 Maneja eventos del usuario (clicks, b\u00fasquedas)</li> <li>\u2705 NO tiene referencias a Views/Composables (evita memory leaks)</li> </ul>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#arquitectura-mvvm","title":"Arquitectura MVVM","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          VIEW (UI)                     \u2502\n\u2502      HomeScreen (Composable)           \u2502\n\u2502                                        \u2502\n\u2502  - Observa uiState                     \u2502\n\u2502  - Renderiza seg\u00fan estado              \u2502\n\u2502  - Emite eventos al ViewModel          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 collectAsState()\n               \u2502 viewModel.onEvent()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         VIEWMODEL                      \u2502\n\u2502        HomeViewModel                   \u2502\n\u2502                                        \u2502\n\u2502  - StateFlow&lt;HomeUiState&gt;              \u2502\n\u2502  - Coordina GameUseCases               \u2502\n\u2502  - Maneja Resource states              \u2502\n\u2502  - Actualiza UI state                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502 gameUseCases.method()\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         USE CASES                      \u2502\n\u2502        GameUseCases                    \u2502\n\u2502                                        \u2502\n\u2502  - L\u00f3gica de negocio                   \u2502\n\u2502  - Transforma datos                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-31-crear-homeuistate","title":"Paso 3.1: Crear HomeUiState","text":"<p>El estado UI es un data class inmutable que representa TODO lo que la UI necesita para renderizarse.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/presentation/viewmodel/HomeViewModel.kt</code></p> <pre><code>package com.pmdm.mygamestore.presentation.viewmodel\n\n/**\n * Clase que modela el estado de la interfaz de usuario para la pantalla principal.\n *\n * Proporciona informaci\u00f3n sobre los juegos cargados, el estado de la carga,\n * mensajes de error y el estado actual de la b\u00fasqueda y los filtros aplicados.\n *\n * Propiedades:\n * - `games`: Lista de juegos disponibles en la interfaz.\n * - `isLoading`: Indica si el contenido est\u00e1 en proceso de ser cargado.\n * - `errorMessage`: Mensaje de error devuelto en caso de fallo.\n * - `username`: Nombre del usuario actualmente autenticado.\n *\n * Opciones de b\u00fasqueda y filtros:\n * - `isSearchMode`: Indica si el modo de b\u00fasqueda est\u00e1 activado.\n * - `isFilterVisible`: Indica si el panel de filtros est\u00e1 visible.\n * - `searchQuery`: Texto de b\u00fasqueda introducido por el usuario.\n * - `selectedCategory`: Categor\u00eda seleccionada para filtrar juegos.\n * - `selectedPlatform`: Plataforma seleccionada para filtrar los juegos.\n * - `selectedInterval`: Intervalo de fechas seleccionado para filtrar juegos.\n */\ndata class HomeUiState(\n    val games: List&lt;Game&gt; = emptyList(),\n    val isLoading: Boolean = false,\n    val errorMessage: String? = null,\n    val username: String? = null,\n\n    // B\u00fasqueda y Filtros\n    val isSearchMode: Boolean = false,\n    val isFilterVisible: Boolean = false,\n    val searchQuery: String = \"\",\n    val selectedCategory: GameCategory = GameCategory.ALL,\n    val selectedPlatform: PlatformEnum = PlatformEnum.ALL,\n    val selectedInterval: DateInterval = DateInterval.ALL_TIME,\n)\n</code></pre> <p>Conceptos del Estado UI:</p> <p>1. \u00bfPor qu\u00e9 data class? </p><pre><code>// data class genera autom\u00e1ticamente:\nval state1 = HomeUiState(games = listOf())\nval state2 = state1.copy(isLoading = true) // \u2705 Copia con cambios\n\n// equals(): compara por contenido\nstate1 == state2 // false (isLoading es diferente)\n\n// toString(): para debugging\nprintln(state1) // HomeUiState(games=[], isLoading=false, ...)\n</code></pre><p></p> <p>2. Single Source of Truth: </p><pre><code>// \u274c MAL: Estado disperso\nvar games: List&lt;Game&gt; = emptyList()\nvar isLoading = false\nvar error: String? = null\n// Dif\u00edcil de sincronizar\n\n// \u2705 BIEN: Estado centralizado\nval uiState = HomeUiState(\n    games = emptyList(),\n    isLoading = false,\n    errorMessage = null\n)\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-32-crear-homeviewmodel","title":"Paso 3.2: Crear HomeViewModel","text":"<p>El ViewModel coordina toda la l\u00f3gica de la pantalla Home.</p> <pre><code>/**\n * ViewModel para gestionar el estado de la pantalla principal, espec\u00edficamente para cargar,\n * filtrar y gestionar una lista de juegos, as\u00ed como tambi\u00e9n administrar elementos relacionados\n * con la sesi\u00f3n del usuario.\n *\n * Este ViewModel encapsula la l\u00f3gica de negocio necesaria para interactuar con los datos de juegos,\n * incluidos filtros, modos de b\u00fasqueda y control de errores. Adem\u00e1s, interact\u00faa con un gestor de sesi\u00f3n\n * para manejar datos del usuario como el nombre de usuario.\n *\n * Principales responsabilidades:\n * - Gestionar el estado inmutable y mutable de la vista utilizando `StateFlow`.\n * - Cargar los juegos aplicando diferentes tipos de filtros, b\u00fasqueda y criterios temporales.\n * - Soportar funcionalidades de gesti\u00f3n, incluyendo modos de b\u00fasqueda, visibilidad de filtros y limpieza de errores.\n * - Administrar estados de carga y manejo de errores, proporcionando mensajes de error descriptivos basados en diferentes fallos.\n *\n * Dependencias internas utilizadas:\n * - `GamesRepository`: Para obtener la lista de juegos y aplicar filtros sobre estos.\n * - `GameUseCases`: Un conjunto de casos de uso relacionados con juegos.\n * - `SessionManager`: Para gestionar informaci\u00f3n de la sesi\u00f3n de usuario, como el nombre de usuario.\n *\n * M\u00e9todos principales:\n * - `loadGames`: Carga y filtra juegos seg\u00fan los criterios actuales.\n * - `onSearchQueryChange`: Actualiza la query de b\u00fasqueda y recarga los juegos.\n * - `toggleSearchMode`: Activa o desactiva el modo de b\u00fasqueda y ajusta otros estados con base en esta acci\u00f3n.\n * - `toggleFilterVisibility`: Muestra u oculta el panel de filtros.\n * - `onCategorySelected`, `onPlatformSelected`, `onIntervalSelected`: Aplica filtros espec\u00edficos y recarga los juegos.\n * - `refreshGames`: Recarga la lista de juegos, \u00fatil para acciones como pull-to-refresh.\n * - `clearError`: Limpia cualquier mensaje de error activo.\n * - `clearAllFilters`: Reinicia todos los filtros a sus valores por defecto y recarga los juegos.\n *\n * Esta clase promueve la separaci\u00f3n de responsabilidades y coordina entre la capa de datos\n * (repositorios y casos de uso) y la capa de presentaci\u00f3n (UI).\n */\nclass HomeViewModel(\n    context: Context\n) : ViewModel() {\n\n    //  Dependencias instanciadas directamente (temporal, antes de Koin)\n    private val gamesRepository: GamesRepository = MockGamesRepositoryImpl()\n    private val gameUseCases = GameUseCases(gamesRepository)\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n\n    //  Estado privado mutable\n    private val _uiState = MutableStateFlow(HomeUiState())\n\n    //  Estado p\u00fablico inmutable\n    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()\n\n    init {\n        loadUsername()\n        loadGames()\n    }\n\n    private fun loadUsername() {\n        viewModelScope.launch {\n            sessionManager.getUsername()\n                .catch { exception -&gt;\n                    println(\"Error loading username: ${exception.message}\")\n                }\n                .collect { username -&gt;\n                    _uiState.update { it.copy(username = username) }\n                }\n        }\n    }\n\n    fun loadGames() {\n        viewModelScope.launch {\n            val currentState = _uiState.value\n\n            val gamesFlow = gameUseCases.getFilteredGames(\n                query = currentState.searchQuery,\n                category = currentState.selectedCategory,\n                platform = currentState.selectedPlatform,\n                interval = currentState.selectedInterval\n            )\n\n            gamesFlow.collect { resource -&gt;\n                when (resource) {\n                    is Resource.Loading -&gt; {\n                        _uiState.update {\n                            it.copy(\n                                isLoading = true,\n                                errorMessage = null\n                            )\n                        }\n                    }\n\n                    is Resource.Success -&gt; {\n                        _uiState.update {\n                            it.copy(\n                                games = resource.data,\n                                isLoading = false,\n                                errorMessage = null\n                            )\n                        }\n                    }\n\n                    is Resource.Error -&gt; {\n                        val errorMsg = when (resource.error) {\n                            is AppError.NetworkError -&gt;\n                                \"No internet connection. Please check your network.\"\n                            is AppError.NotFound -&gt;\n                                \"No games found.\"\n                            is AppError.DatabaseError -&gt;\n                                \"Database error. Please try again.\"\n                            is AppError.Unauthorized -&gt;\n                                \"You need to login to access this content.\"\n                            is AppError.ValidationError -&gt;\n                                resource.error.message\n                            is AppError.Unknown -&gt;\n                                resource.error.message\n                        }\n\n                        _uiState.update {\n                            it.copy(\n                                isLoading = false,\n                                errorMessage = errorMsg\n                            )\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    fun onSearchQueryChange(query: String) {\n        _uiState.update { it.copy(searchQuery = query) }\n        loadGames()\n    }\n\n    fun toggleSearchMode() {\n        _uiState.update {\n            val newSearchMode = !it.isSearchMode\n            it.copy(\n                isSearchMode = newSearchMode,\n                // Si abrimos b\u00fasqueda, cerramos filtros\n                isFilterVisible = if (newSearchMode) false else it.isFilterVisible,\n                // Si cerramos la b\u00fasqueda, limpiamos la query\n                searchQuery = if (!newSearchMode) \"\" else it.searchQuery\n            )\n        }\n        // Si acabamos de limpiar la b\u00fasqueda al cerrar el modo, recargamos juegos\n        if (!_uiState.value.isSearchMode) {\n            loadGames()\n        }\n    }\n\n    fun toggleFilterVisibility() {\n        _uiState.update {\n            it.copy(isFilterVisible = !it.isFilterVisible)\n        }\n    }\n\n    fun onCategorySelected(category: GameCategory) {\n        _uiState.update {\n            it.copy(selectedCategory = category)\n        }\n        loadGames()\n    }\n\n    fun onPlatformSelected(platform: PlatformEnum) {\n        _uiState.update {\n            it.copy(selectedPlatform = platform)\n        }\n        loadGames()\n    }\n\n    fun onIntervalSelected(interval: DateInterval) {\n        _uiState.update {\n            it.copy(selectedInterval = interval)\n        }\n        loadGames()\n    }\n\n    fun refreshGames() {\n        loadGames()\n    }\n\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n\n    fun clearAllFilters() {\n        _uiState.update {\n            it.copy(\n                searchQuery = \"\",\n                selectedCategory = GameCategory.ALL,\n                selectedPlatform = PlatformEnum.ALL,\n                selectedInterval = DateInterval.ALL_TIME\n            )\n        }\n        loadGames()\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#paso-33-crear-homeviewmodelfactory","title":"Paso 3.3: Crear HomeViewModelFactory","text":"<p>El Factory es necesario porque HomeViewModel necesita Context, que no se puede pasar directamente.</p> <pre><code>/**\n *  Factory para crear HomeViewModel\n *\n * PROP\u00d3SITO:\n * - ViewModel necesita Context para SessionManager\n * - ViewModelProvider.Factory permite pasar par\u00e1metros al constructor\n*\n* @param context Contexto de Android\n */\nclass HomeViewModelFactory(\n    private val context: Context\n) : ViewModelProvider.Factory {\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        if (modelClass.isAssignableFrom(HomeViewModel::class.java)) {\n            return HomeViewModel(context) as T\n        }\n        throw IllegalArgumentException(\"Unknown ViewModel class: ${modelClass.name}\")\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#conceptos-clave-del-viewmodel","title":"Conceptos clave del ViewModel","text":""},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#1-stateflow-vs-mutablestateflow","title":"1. StateFlow vs MutableStateFlow","text":"<pre><code>// Privado: Solo el ViewModel puede modificar\nprivate val _uiState = MutableStateFlow(HomeUiState())\n\n// P\u00fablico: La UI solo puede observar (read-only)\nval uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()\n</code></pre> <p>\u00bfPor qu\u00e9 este patr\u00f3n? - \u2705 Encapsulaci\u00f3n: La UI no puede modificar el estado - \u2705 Unidirectional Data Flow: Solo el ViewModel actualiza - \u2705 Previene bugs: Cambios solo desde un lugar</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#2-update-vs-value","title":"2. update { } vs value =","text":"<pre><code>// \u274c Menos seguro en concurrencia\n_uiState.value = _uiState.value.copy(isLoading = true)\n\n// \u2705 Thread-safe, at\u00f3mico\n_uiState.update { it.copy(isLoading = true) }\n</code></pre> <p>update() garantiza que: - Las actualizaciones son at\u00f3micas - No se pierde ning\u00fan cambio en concurrencia - Sintaxis m\u00e1s limpia</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#3-viewmodelscope","title":"3. viewModelScope","text":"<pre><code>// \u2705 Se cancela autom\u00e1ticamente cuando ViewModel se destruye\nviewModelScope.launch {\n    // Operaciones as\u00edncronas\n}\n\n// \u274c No uses GlobalScope (no se cancela nunca)\nGlobalScope.launch { ... }\n</code></pre> <p>Ventajas de viewModelScope: - Vinculado al ciclo de vida del ViewModel - Se cancela autom\u00e1ticamente en onCleared() - Previene memory leaks</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#4-flowcollect-vs-flowcollectlatest","title":"4. Flow.collect vs Flow.collectLatest","text":"<pre><code>// collect: Procesa cada emisi\u00f3n completa\nflow.collect { value -&gt;\n    // Se ejecuta para cada valor\n}\n\n// collectLatest: Cancela emisi\u00f3n anterior si llega una nueva\nflow.collectLatest { value -&gt;\n    // Solo procesa el valor m\u00e1s reciente\n    // \u00datil para b\u00fasquedas en tiempo real\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#5-catch-operator-para-manejo-de-errores","title":"5. catch operator para manejo de errores","text":"<pre><code>flow\n    .catch { exception -&gt;\n        // Maneja errores en el Flow\n        emit(defaultValue)\n    }\n    .collect { value -&gt;\n        // Procesar valor\n    }\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#flujo-completo-de-datos-con-resource","title":"Flujo completo de datos con Resource","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Usuario escribe \"zelda\" en b\u00fasqueda         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  2. HomeScreen llama:                           \u2502\n\u2502     viewModel.onSearchQueryChange(\"zelda\")      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  3. HomeViewModel:                              \u2502\n\u2502     _uiState.update { searchQuery = \"zelda\" }   \u2502\n\u2502     loadGames()                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. loadGames() determina UseCase:              \u2502\n\u2502     gameUseCases.searchGames(\"zelda\")           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  5. GameUseCases:                               \u2502\n\u2502     gamesRepository.searchGames(\"zelda\")        \u2502\n\u2502     .map { ordenar por relevancia }             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  6. MockGamesRepositoryImpl:                    \u2502\n\u2502     emit(Resource.Loading)                      \u2502\n\u2502     delay(800)                                  \u2502\n\u2502     val filtered = mockGames.filter()           \u2502\n\u2502     emit(Resource.Success(filtered))            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  7. GameUseCases.map:                           \u2502\n\u2502     when (Resource.Success) {                   \u2502\n\u2502       ordenar por relevancia                    \u2502\n\u2502       Resource.Success(sorted)                  \u2502\n\u2502     }                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  8. HomeViewModel.collect:                      \u2502\n\u2502     when (resource) {                           \u2502\n\u2502       Loading \u2192 isLoading = true                \u2502\n\u2502       Success \u2192 games = resource.data           \u2502\n\u2502       Error \u2192 errorMessage = ...                \u2502\n\u2502     }                                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  9. HomeScreen recompone:                       \u2502\n\u2502     val uiState by viewModel.uiState            \u2502\n\u2502                    .collectAsState()            \u2502\n\u2502     LazyVerticalGrid(uiState.games)             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>\u2705 Resumen de la Fase 3</p> <p>Has completado la capa de presentaci\u00f3n - ViewModel con:</p> <ol> <li> <p>\u2705 HomeUiState con todos los datos necesarios para la UI:</p> <ul> <li>Lista de juegos</li> <li>Estados de loading y error</li> <li>Username del usuario</li> <li>Filtros activos (b\u00fasqueda, categor\u00eda, plataforma, intervalo)</li> </ul> </li> <li> <p>\u2705 HomeViewModel con funcionalidades completas:</p> <ul> <li>Gesti\u00f3n de estado con StateFlow</li> <li>Coordinaci\u00f3n de GameUseCases</li> <li>Manejo de Resource (Loading, Success, Error)</li> <li>Eventos del usuario (b\u00fasqueda, filtros)</li> <li>Integraci\u00f3n con SessionManager</li> <li>Prioridad de filtros l\u00f3gica</li> </ul> </li> <li> <p>\u2705 HomeViewModelFactory temporal para inyecci\u00f3n de Context</p> </li> <li>\u2705 Manejo robusto de errores con mensajes espec\u00edficos por tipo</li> </ol>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#fase-4-componentes-ui","title":"FASE 4: Componentes UI Reutilizables","text":"<p>Esta fase se centra en crear componentes Compose reutilizables, stateless y bien organizados. Un componente stateless es aquel que no gestiona su propio estado, sino que lo recibe por par\u00e1metros, lo que facilita enormemente su testeo y reutilizaci\u00f3n en diferentes partes de la app.</p> <p>Dependencia de Coil y Material Icons Extended</p> <p>Para esta fase necesitamos dos librer\u00edas fundamentales: 1. Coil: Para cargar las im\u00e1genes de los juegos de forma as\u00edncrona y eficiente. 2. Material Icons Extended: Para acceder a una biblioteca m\u00e1s amplia de iconos (como el de Windows para PC o SearchOff).</p> <p>Ubicaci\u00f3n: <code>app/build.gradle.kts</code> </p><pre><code>dependencies {\n    implementation(\"io.coil-kt:coil-compose:2.5.0\")\n    implementation(\"androidx.compose.material:material-icons-extended:1.7.6\")\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#1-gamecard-la-tarjeta-del-catalogo","title":"1. GameCard: La tarjeta del cat\u00e1logo","text":"<p>Es el componente visual m\u00e1s importante. Debe ser atractivo y mostrar informaci\u00f3n clave de un vistazo sin saturar al usuario.</p> <p>\u00bfQu\u00e9 aprende el alumno aqu\u00ed? - HorizontalPager: Para crear carruseles de im\u00e1genes deslizables. - Mapeo Din\u00e1mico: Traducir datos del modelo (<code>slugs</code>) a elementos visuales (<code>Icons</code>). - Dise\u00f1o Adaptativo: Controlar el desbordamiento de texto con <code>maxLines</code> y <code>Ellipsis</code>.</p> <pre><code>@Composable\nfun GameCard(\n    game: Game,\n    onClick: () -&gt; Unit,\n    modifier: Modifier = Modifier\n) {\n    Card(\n        modifier = modifier\n            .fillMaxWidth()\n            .height(260.dp) // Altura optimizada para el grid\n            .clickable(onClick = onClick),\n        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)\n    ) {\n        Column {\n            // Carrusel de im\u00e1genes (Uso de HorizontalPager)\n            // ... (Ver implementaci\u00f3n completa en el repositorio)\n\n            // Informaci\u00f3n del juego\n            Column(modifier = Modifier.padding(12.dp)) {\n                Row(\n                    modifier = Modifier.fillMaxWidth(),\n                    horizontalArrangement = Arrangement.SpaceBetween\n                ) {\n                    // Iconos de Plataforma (Windows, PS, Xbox...)\n                    PlatformIconsRow(platforms = game.platforms)\n                    // Rating con estrella\n                    // ...\n                }\n                // T\u00edtulo (Limitado a 1 l\u00ednea para mantener simetr\u00eda)\n                Text(text = game.title, maxLines = 1, overflow = TextOverflow.Ellipsis)\n            }\n        }\n    }\n}\n</code></pre> <p>[!TIP] Puedes revisar la implementaci\u00f3n completa del carrusel y el mapeo de iconos en <code>presentation/ui/componentes/GameCard.kt</code>.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#2-filtersystem-gestion-de-filtros-compleja","title":"2. FilterSystem: Gesti\u00f3n de filtros compleja","text":"<p>Para evitar ocupar demasiado espacio, usamos una fila \u00fanica de chips que despliega un panel inferior (ModalBottomSheet).</p> <p>Prop\u00f3sito pedag\u00f3gico: - UX Limpia: No abrumar al usuario con 3 filas de filtros. - Interacci\u00f3n Avanzada: Uso de <code>ModalBottomSheet</code> para selecciones c\u00f3modas. - Feedback Visual: Los chips cambian de color e incluyen un icono de \"check\" cuando est\u00e1n activos.</p> <pre><code>@Composable\nfun FilterSystem(\n    selectedCategory: GameCategory,\n    onCategorySelected: (GameCategory) -&gt; Unit,\n    // ... otros filtros\n) {\n    // Fila horizontal de chips compactos\n    LazyRow(horizontalArrangement = Arrangement.spacedBy(8.dp)) {\n        item {\n            CompactFilterChip(\n                label = \"Categor\u00eda\",\n                isSelected = selectedCategory != GameCategory.ALL,\n                onClick = { /* Abrir BottomSheet */ }\n            )\n        }\n        // ... otros chips\n    }\n\n    // El BottomSheet se encarga de mostrar las opciones sin tapar el cat\u00e1logo\n    if (showSheet) {\n        ModalBottomSheet(onDismissRequest = { showSheet = false }) {\n            // Lista de opciones para elegir\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#3-estados-de-la-interfaz-ux-de-calidad","title":"3. Estados de la Interfaz (UX de calidad)","text":"<p>Una aplicaci\u00f3n profesional siempre informa al usuario de lo que est\u00e1 pasando.</p> <ul> <li>LoadingIndicator: Un spinner centrado para evitar una pantalla blanca durante la carga.</li> <li>ErrorMessage: Incluye un bot\u00f3n de \"Retry\" para que el usuario pueda recuperarse de un fallo de red.</li> <li>EmptyState: Se muestra cuando no hay resultados (ej: al buscar algo que no existe), permitiendo limpiar los filtros con un solo clic.</li> </ul> <pre><code>@Composable\nfun EmptyState(\n    message: String = \"No games found\",\n    onClearFilters: (() -&gt; Unit)? = null\n) {\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        Icon(Icons.Default.SearchOff, modifier = Modifier.size(64.dp))\n        Text(text = message)\n        onClearFilters?.let {\n            BotonGS(texto = \"Clear Filters\", onClick = it)\n        }\n    }\n}\n</code></pre> <p>\u2705 Resumen de la Fase 4</p> <p>Has creado una biblioteca de componentes robustos y educativos:</p> <ul> <li>\u2705 GameCard: Con carrusel interactivo e iconos de plataforma inteligentes.</li> <li>\u2705 FilterSystem: Compacto y basado en Material Design 3 (<code>ModalBottomSheet</code>).</li> <li>\u2705 GameGrid: Organizaci\u00f3n eficiente en 2 columnas.</li> <li>\u2705 Gesti\u00f3n de Estados: Feedback visual completo para Loading, Error y Empty.</li> </ul>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#fase-5-homescreen","title":"FASE 5: HomeScreen Completa","text":"<p>En esta fase final, uniremos todas las piezas que hemos construido: el ViewModel como cerebro de la pantalla, los UseCases como l\u00f3gica de negocio, y la biblioteca de Componentes UI que dise\u00f1amos en la Fase 4.</p> <p>La <code>HomeScreen</code> es el \"orquestador\". Su responsabilidad no es dibujar cada detalle, sino organizar los componentes y pasarles los datos y eventos necesarios.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#1-la-topappbar-dinamica-busqueda-integrada","title":"1. La TopAppBar Din\u00e1mica (B\u00fasqueda integrada)","text":"<p>Una de las caracter\u00edsticas m\u00e1s profesionales de nuestra app es la barra superior que se transforma. En lugar de tener un campo de b\u00fasqueda est\u00e1tico que roba espacio, usamos un icono que activa el modo b\u00fasqueda.</p> <p>Conceptos clave para el alumno: - Estado Visual: Usamos <code>uiState.isSearchMode</code> para decidir qu\u00e9 versi\u00f3n de la <code>TopAppBar</code> mostrar. - Auto-focus: Al abrir la b\u00fasqueda, usamos un <code>FocusRequester</code> para que el teclado aparezca autom\u00e1ticamente.</p> <pre><code>@Composable\nfun HomeScreen() {\n    // ... inicializaci\u00f3n de ViewModel y State\n    val focusRequester = remember { FocusRequester() }\n\n    Scaffold(\n        topBar = {\n            if (uiState.isSearchMode) {\n                // Barra con campo de texto (TextField)\n                SearchTopBar(\n                    query = uiState.searchQuery,\n                    onQueryChange = { viewModel.onSearchQueryChange(it) },\n                    onClose = { viewModel.toggleSearchMode() },\n                    focusRequester = focusRequester\n                )\n            } else {\n                // Barra est\u00e1ndar con t\u00edtulo y botones de acci\u00f3n\n                MainTopBar(\n                    onToggleFilters = { viewModel.toggleFilterVisibility() },\n                    onOpenSearch = { viewModel.toggleSearchMode() }\n                )\n            }\n        },\n        bottomBar = {\n            // Navegaci\u00f3n principal de la app\n            BottomNavigationBar(currentRoute = AppRoutes.Home, onNavigate = { /* ... */ })\n        }\n    ) { innerPadding -&gt;\n        // Contenido...\n    }\n}\n</code></pre> <p>[!TIP] Puedes revisar la implementaci\u00f3n completa de la HomeScreen y el mapeo de iconos en <code>presentation/ui/screens/HomeScreen.kt</code>.</p>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#2-animaciones-de-visibilidad-animatedvisibility","title":"2. Animaciones de Visibilidad (<code>AnimatedVisibility</code>)","text":"<p>Para que la interfaz no sea \"tosca\", los filtros aparecen y desaparecen con una suave animaci\u00f3n de persiana justo debajo de la barra superior.</p> <pre><code>AnimatedVisibility(\n    visible = uiState.isFilterVisible,\n    enter = expandVertically() + fadeIn(),\n    exit = shrinkVertically() + fadeOut()\n) {\n    FilterSystem(\n        selectedCategory = uiState.selectedCategory,\n        // ... pasamos los callbacks del ViewModel\n    )\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#3-el-patron-when-para-la-gestion-de-estados","title":"3. El patr\u00f3n \"When\" para la Gesti\u00f3n de Estados","text":"<p>El coraz\u00f3n del contenido de la pantalla utiliza la potencia de Kotlin para manejar los 4 estados fundamentales de cualquier aplicaci\u00f3n moderna:</p> <ol> <li>Cargando (<code>isLoading</code>): El usuario nunca debe ver una pantalla en blanco.</li> <li>Error (<code>errorMessage</code>): Siempre debemos dar una explicaci\u00f3n y un bot\u00f3n de reintento.</li> <li>Vac\u00edo (<code>isEmpty</code>): Si no hay resultados (ej: una b\u00fasqueda sin \u00e9xito), ayudamos al usuario a limpiar sus filtros.</li> <li>\u00c9xito (<code>Success</code>): Mostramos la cuadr\u00edcula de juegos (<code>GameGrid</code>).</li> </ol> <pre><code>Box(modifier = Modifier.fillMaxSize()) {\n    when {\n        uiState.isLoading -&gt; LoadingIndicator()\n        uiState.errorMessage != null -&gt; ErrorMessage(onRetry = { viewModel.refreshGames() })\n        uiState.games.isEmpty() -&gt; EmptyState(onClearFilters = { viewModel.clearAllFilters() })\n        else -&gt; GameGrid(games = uiState.games, onGameClick = { /* Navegar al detalle */ })\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/05-HomeScreen.html#4-navegacion-e-integracion-global","title":"4. Navegaci\u00f3n e Integraci\u00f3n Global","text":"<p>Finalmente, incluimos el componente <code>BottomNavigationBar</code>. Este componente es vital para la experiencia de usuario (UX), ya que permite saltar entre las secciones principales (Home, Biblioteca, Perfil) desde cualquier lugar.</p> <p>Consejo did\u00e1ctico: F\u00edjate c\u00f3mo la <code>HomeScreen</code> no navega por s\u00ed misma, sino que utiliza el <code>LocalNavStack.current</code> para delegar la navegaci\u00f3n a la infraestructura que definimos en el <code>NavGraph</code>.</p> <p>\u2705 Resumen de la Fase 5</p> <p>\u00a1Enhorabuena! Has construido una pantalla de alta complejidad siguiendo los est\u00e1ndares de la industria:</p> <ul> <li>Modular: Componentes peque\u00f1os y reutilizables.</li> <li>Reactiva: Basada en estados de <code>HomeViewModel</code>.</li> <li>UX Optimizada: B\u00fasqueda integrada, filtros inteligentes y animaciones fluidas.</li> <li>Limpia: Separaci\u00f3n total entre la l\u00f3gica de datos (Repository) y la visual (Compose).</li> </ul> <p>Puedes revisar el c\u00f3digo completo y los detalles de implementaci\u00f3n en el archivo <code>presentation/ui/screens/HomeScreen.kt</code>.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html","title":"6. Detalles de un juego","text":""},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#6-implementacion-de-la-pantalla-de-detalle-detailscreen","title":"6. Implementaci\u00f3n de la Pantalla de Detalle (DetailScreen)","text":"<p>En esta 6\u00aa parte del proyecto, vamos a desarrollar la pantalla de detalle para visualizar la informaci\u00f3n completa de un videojuego. Esta fase es fundamental para aprender a manejar la navegaci\u00f3n con par\u00e1metros, la gesti\u00f3n de estados complejos (Loading, Success, Error) y la creaci\u00f3n de componentes visuales avanzados como carruseles y textos din\u00e1micos.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#indice","title":"\ud83d\udcd6 \u00cdndice","text":"<ol> <li>Introducci\u00f3n</li> <li>Fase 1: Capa de Datos y Dominio (Ampliaci\u00f3n)</li> <li>Fase 2: Capa de Presentaci\u00f3n - ViewModel y Estado</li> <li>Fase 3: Componentes UI de Detalle</li> <li>Fase 4: Pantalla DetailScreen y Navegaci\u00f3n</li> </ol>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#introducci\u00f3n","title":"\ud83c\udfaf Introducci\u00f3n","text":"<p>Hasta ahora, nuestra aplicaci\u00f3n permite listar juegos y filtrarlos. Sin embargo, un cat\u00e1logo no est\u00e1 completo sin una vista detallada donde el usuario pueda profundizar en la informaci\u00f3n de cada t\u00edtulo: descripci\u00f3n, capturas de pantalla, desarrolladores, plataformas y m\u00e1s.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#que-vamos-a-aprender","title":"\u00bfQu\u00e9 vamos a aprender?","text":"<ul> <li>\u2705 Navegaci\u00f3n con Argumentos: C\u00f3mo pasar el ID de un juego de una pantalla a otra.</li> <li>\u2705 ViewModel con Par\u00e1metros: Uso de <code>ViewModelFactory</code> para inyectar datos din\u00e1micos.</li> <li>\u2705 Ciclo de Vida y Claves: Evitar el problema de ver datos \"viejos\" al navegar entre juegos.</li> <li>\u2705 Componentes Avanzados:<ul> <li>HorizontalPager: Para crear carruseles de im\u00e1genes interactivos.</li> <li>FlowRow: Para organizar \"Chips\" de forma adaptativa.</li> <li>ExpandableText: Gesti\u00f3n de layouts para mostrar/ocultar contenido largo.</li> </ul> </li> </ul>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#fase-1-capa-de-datos-y-dominio-ampliaci\u00f3n","title":"\ud83c\udfd7\ufe0f Fase 1: Capa de Datos y Dominio (Ampliaci\u00f3n)","text":"<p>Para que la pantalla de detalle sea visualmente atractiva, necesitamos m\u00e1s informaci\u00f3n de la que usamos en la <code>HomeScreen</code>.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#11-ampliacion-del-modelo-game","title":"1.1. Ampliaci\u00f3n del Modelo Game","text":"<p>Debemos asegurarnos de que nuestra clase <code>Game</code> contenga todos los campos necesarios para el detalle.</p> <p>Ubicaci\u00f3n: <code>domain/model/Game.kt</code></p> <pre><code>@Serializable\ndata class Game(\n    val id: Int,\n    val title: String,\n    val description: String,\n    val imageUrl: String,\n    // ... campos ya existentes (price, rating, releaseDate, etc.) ...\n\n    // Nuevos campos para el detalle\n    val screenshots: List&lt;Screenshot&gt; = emptyList(),\n    val metacritic: Int? = null,\n    val developers: List&lt;Publisher&gt; = emptyList(),\n    val publishers: List&lt;Publisher&gt; = emptyList(),\n    val movies: List&lt;String&gt; = emptyList() // Para el bot\u00f3n de \"Watch Trailer\"\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#12-actualizacion-del-repositorio-y-casos-de-uso","title":"1.2. Actualizaci\u00f3n del Repositorio y Casos de Uso","text":"<p>El repositorio debe ser capaz de buscar un juego espec\u00edfico por su identificador \u00fanico.</p> <p>Interfaz del Repositorio (<code>GamesRepository.kt</code>): </p><pre><code>suspend fun getGameById(id: Int): Resource&lt;Game&gt;\n</code></pre><p></p> <p>Caso de Uso (<code>GameUseCases.kt</code>): Encapsulamos la l\u00f3gica para que el ViewModel no hable directamente con el repositorio.</p> <pre><code>suspend fun getGameById(id: Int): Resource&lt;Game&gt; {\n    return gamesRepository.getGameById(id)\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#fase-2-capa-de-presentaci\u00f3n-viewmodel-y-estado","title":"\ud83c\udfd7\ufe0f Fase 2: Capa de Presentaci\u00f3n - ViewModel y Estado","text":"<p>El <code>DetailViewModel</code> presenta un reto nuevo: necesita el <code>gameId</code> nada m\u00e1s ser creado para cargar los datos correctos.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#21-definicion-del-estado-detailuistate","title":"2.1. Definici\u00f3n del Estado (DetailUiState)","text":"<p>Necesitamos representar tres cosas: el recurso del juego (que puede estar cargando), si es favorito y posibles errores.</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/DetailViewModel.kt</code></p> <pre><code>data class DetailUiState(\n    val gameResource: Resource&lt;Game&gt; = Resource.Loading,\n    val isFavorite: Boolean = false\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#22-el-viewmodel-con-inyeccion-de-parametros","title":"2.2. El ViewModel con Inyecci\u00f3n de Par\u00e1metros","text":"<p>El <code>DetailViewModel</code> presenta un reto nuevo: necesita el <code>gameId</code> nada m\u00e1s ser creado para saber qu\u00e9 juego debe cargar.</p> <p>\u00bfPor qu\u00e9 es esto un problema para Android? Por defecto, el sistema de Android (espec\u00edficamente la clase <code>ViewModelProvider</code>) espera que los ViewModels tengan un constructor vac\u00edo (sin par\u00e1metros). Si intentamos crear un ViewModel que recibe datos en su constructor (como <code>gameId</code> o <code>useCases</code>), Android no sabr\u00e1 de d\u00f3nde sacar esos valores y la aplicaci\u00f3n fallar\u00e1.</p> <p>Para solucionar esto, usaremos una Factor\u00eda (Factory) en el siguiente paso, que actuar\u00e1 como un \"manual de instrucciones\" para que Android sepa c\u00f3mo construir nuestro ViewModel correctamente.</p> <pre><code>class DetailViewModel(\n    private val useCases: GameUseCases,\n    private val gameId: Int\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(DetailUiState())\n    val uiState = _uiState.asStateFlow()\n\n    init {\n        loadGame() // Cargamos el juego al iniciar\n    }\n\n    fun loadGame() {\n        viewModelScope.launch {\n            _uiState.update { it.copy(gameResource = Resource.Loading) }\n            val result = useCases.getGameById(gameId)\n            _uiState.update { it.copy(gameResource = result) }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#23-la-factoria-viewmodelfactory","title":"2.3. La Factor\u00eda (ViewModelFactory)","text":"<p>Para que Compose sepa c\u00f3mo instanciar nuestro ViewModel con el <code>gameId</code>, creamos una clase que implemente <code>ViewModelProvider.Factory</code>.</p> <pre><code>class DetailViewModelFactory(\n    private val useCases: GameUseCases,\n    private val gameId: Int\n) : ViewModelProvider.Factory {\n    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {\n        return DetailViewModel(useCases, gameId) as T\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#fase-3-componentes-ui-de-detalle","title":"\ud83c\udfd7\ufe0f Fase 3: Componentes UI de Detalle","text":"<p>Dada la riqueza visual de esta pantalla y su potencial reutilizaci\u00f3n, vamos a extraer los componentes complejos a la carpeta <code>presentation/ui/componentes</code>. Esto mantendr\u00e1 nuestra pantalla principal limpia y modular.</p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#31-carrusel-de-imagenes-imagecarouselkt","title":"3.1. Carrusel de Im\u00e1genes (<code>ImageCarousel.kt</code>)","text":"<p>Queremos que el usuario pueda deslizar entre la portada y las capturas de pantalla. Este componente se usa tanto en <code>DetailScreen</code> como en <code>GameCard</code>.</p> <pre><code>@Composable\nfun ImageCarousel(\n    images: List&lt;String&gt;,\n    modifier: Modifier = Modifier,\n    height: Dp = 300.dp,\n    showIndicators: Boolean = true\n) {\n    val pagerState = rememberPagerState(pageCount = { images.size })\n\n    Box(modifier = modifier.fillMaxWidth().height(height)) {\n        HorizontalPager(state = pagerState) { page -&gt;\n            AsyncImage(\n                model = images[page],\n                contentScale = ContentScale.Crop,\n                modifier = Modifier.fillMaxSize()\n            )\n        }\n\n        if (showIndicators &amp;&amp; images.size &gt; 1) {\n            PageIndicator(pagerState, images.size, Modifier.align(Alignment.BottomCenter))\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#32-texto-expandible-expandabletextkt","title":"3.2. Texto Expandible (<code>ExpandableText.kt</code>)","text":"<p>La descripci\u00f3n de un juego puede ser muy larga. Queremos mostrar solo 4 l\u00edneas y un bot\u00f3n de \"Show more\".</p> <pre><code>@Composable\nfun ExpandableText(text: String, maxLines: Int = 4) {\n    var expanded by remember { mutableStateOf(false) }\n    var isClickable by remember { mutableStateOf(false) }\n\n    Column(modifier = Modifier.animateContentSize()) {\n        Text(\n            text = text,\n            maxLines = if (expanded) Int.MAX_VALUE else maxLines,\n            onTextLayout = { result -&gt;\n                if (result.hasVisualOverflow || result.lineCount &gt; maxLines) isClickable = true\n            }\n        )\n        if (isClickable) {\n            Text(\n                text = if (expanded) \"Show less\" else \"Show more\",\n                color = MaterialTheme.colorScheme.primary,\n                modifier = Modifier.clickable { expanded = !expanded }\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#33-componentes-de-informacion-detailcomponentskt","title":"3.3. Componentes de Informaci\u00f3n (<code>DetailComponents.kt</code>)","text":"<p>Agrupamos componentes peque\u00f1os como <code>DetailChip</code>, <code>InfoColumn</code> y <code>MetacriticBadge</code> para organizar los metadatos del juego.</p> <pre><code>@Composable\nfun InfoColumn(label: String, value: String = \"\", content: @Composable (() -&gt; Unit)? = null) {\n    Column(modifier = Modifier.width(180.dp)) {\n        Text(text = label, style = MaterialTheme.typography.labelLarge)\n        if (content != null) content() else Text(text = value)\n    }\n}\n\n@Composable\nfun MetacriticBadge(score: Int) {\n    Surface(color = Color(0xFF00CE7A), shape = RoundedCornerShape(4.dp)) {\n        Text(text = score.toString(), color = Color.White)\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#34-layouts-de-chips-chipslayoutskt","title":"3.4. Layouts de Chips (<code>ChipsLayouts.kt</code>)","text":"<p>Para organizar m\u00faltiples etiquetas, usamos <code>TagsFlowRow</code> (varias l\u00edneas) o <code>ChipsPager</code> (una l\u00ednea con scroll).</p> <pre><code>@Composable\nfun TagsFlowRow(items: List&lt;String&gt;) {\n    FlowRow(\n        horizontalArrangement = Arrangement.spacedBy(MaterialTheme.dimens.small),\n        maxLines = 2\n    ) {\n        items.forEach { DetailChip(it) }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#fase-4-pantalla-detailscreen-y-navegaci\u00f3n","title":"\ud83c\udfd7\ufe0f Fase 4: Pantalla DetailScreen y Navegaci\u00f3n","text":""},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#41-configuracion-de-la-ruta","title":"4.1. Configuraci\u00f3n de la Ruta","text":"<p>En nuestro sistema de navegaci\u00f3n, la ruta de detalle ahora requiere un par\u00e1metro.</p> <p>Ubicaci\u00f3n: <code>presentation/ui/navigation/AppRoutes.kt</code> </p><pre><code>@Serializable\ndata class Detail(val gameId: Int) : AppRoutes\n</code></pre><p></p> <p>Y en el <code>NavGraph.kt</code>: </p><pre><code>entry&lt;AppRoutes.Detail&gt; { route -&gt;\n    DetailScreen(\n        gameId = route.gameId,\n        onBack = { navStack.removeLastOrNull() }\n    )\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#42-el-problema-de-la-clave-crucial","title":"4.2. El problema de la \"Clave\" (Crucial)","text":"<p>Error com\u00fan</p> <p>Si navegas del Juego A al Juego B, Compose podr\u00eda reutilizar el mismo ViewModel del Juego A, haciendo que veas los datos incorrectos.</p> <p>Soluci\u00f3n: Pasar una <code>key</code> \u00fanica al obtener el ViewModel.</p> <pre><code>@Composable\nfun DetailScreen(gameId: Int, onBack: () -&gt; Unit) {\n    val viewModel: DetailViewModel = viewModel(\n        // \ud83d\udd11 Esta clave fuerza a crear un nuevo VM si el ID cambia\n        key = \"DetailViewModel_$gameId\", \n        factory = DetailViewModelFactory(GameUseCases(repository), gameId)\n    )\n\n    val uiState by viewModel.uiState.collectAsState()\n\n    // ... Resto del Scaffold con LazyColumn para el contenido ...\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#43-estructura-del-contenido-lazycolumn","title":"4.3. Estructura del Contenido (<code>LazyColumn</code>)","text":"<p>Usamos un <code>LazyColumn</code> para que toda la pantalla sea desplazable, y configuramos la imagen para que sea \"a sangre\" (sin padding lateral), mientras que el texto s\u00ed lo tiene.</p> <pre><code>LazyColumn {\n    item { ImageCarousel(images) }\n    item {\n        Column(modifier = Modifier.padding(MaterialTheme.dimens.medium)) {\n            Text(\n                text = game.title, \n                style = MaterialTheme.typography.headlineMedium.copy(\n                    fontWeight = FontWeight.Bold,\n                    fontSize = 28.sp\n                )\n            )\n            // ... Rating, Developers, Genres ...\n            ExpandableText(game.description)\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#44-ui-limpia-y-profesional","title":"4.4. UI Limpia y Profesional","text":"<p>Para lograr un acabado profesional, hemos realizado dos ajustes finales:</p> <ol> <li>TopAppBar Transparente: Al navegar al detalle, la barra superior es transparente y no tiene t\u00edtulo, permitiendo que la imagen del juego luzca en todo su esplendor.</li> <li>Bot\u00f3n de Favoritos: Un bot\u00f3n flotante junto al t\u00edtulo con estados visuales claros (coraz\u00f3n relleno/vac\u00edo).</li> </ol> <pre><code>IconButton(\n    onClick = onToggleFavorite,\n    modifier = Modifier\n        .size(MaterialTheme.dimens.buttonHeightLarge)\n        .clip(RoundedCornerShape(MaterialTheme.dimens.medium))\n) {\n    Icon(\n        imageVector = if (isFavorite) Icons.Default.Favorite else Icons.Default.FavoriteBorder,\n        contentDescription = \"Favorite\",\n        tint = if (isFavorite) Color.Red else MaterialTheme.colorScheme.onSurfaceVariant\n    )\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/06-DetailScreen.html#resumen-de-la-fase-6","title":"\u2705 Resumen de la Fase 6","text":"<p>\u00a1Felicidades! Has implementado una de las pantallas m\u00e1s complejas de la aplicaci\u00f3n. En esta fase has dominado:</p> <ol> <li>Arquitectura de Datos: C\u00f3mo pedir un recurso espec\u00edfico por su ID.</li> <li>Compose Avanzado: Gesti\u00f3n de estados de texto din\u00e1micos y carruseles.</li> <li>Navegaci\u00f3n Robusta: Uso de argumentos y gesti\u00f3n del ciclo de vida de los ViewModels mediante claves.</li> <li>UI Minimalista: Creaci\u00f3n de una experiencia inmersiva mediante el uso de transparencias y la eliminaci\u00f3n de elementos redundantes como t\u00edtulos de cabecera.</li> <li>Dise\u00f1o Adaptativo con Dimens: Uso de <code>MaterialTheme.dimens</code> para mantener la consistencia visual en diferentes tama\u00f1os de pantalla.</li> <li>UX Pulida: Feedback de carga al usuario y estados de error controlados.</li> </ol> <p>Puedes revisar la implementaci\u00f3n completa en <code>presentation/ui/screens/DetailScreen.kt</code>.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html","title":"7. Persistencia con Room","text":""},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#7-persistencia-local-con-room","title":"7. Persistencia Local con Room","text":"<p>En esta 7\u00aa entrega, transformaremos nuestra aplicaci\u00f3n de una experiencia vol\u00e1til a una persistente. Hasta ahora, si cerr\u00e1bamos la app, perd\u00edamos cualquier cambio (como los favoritos o el historial). Implementaremos Room, la biblioteca oficial de Android para el manejo de bases de datos, permitiendo que el usuario guarde su biblioteca personal, notas y preferencias de forma permanente en su dispositivo.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#indice","title":"\ud83d\udcd6 \u00cdndice","text":"<ol> <li>Nuevas Funcionalidades</li> <li>Introducci\u00f3n a Room y Configuraci\u00f3n</li> <li>El Coraz\u00f3n de Room: Entitys y DAOs</li> <li>Relacionando Datos: Foreign Keys</li> <li>Mapeo de Datos y Conversores</li> <li>Arquitectura H\u00edbrida y Reactividad</li> <li>El Motor de la App: MyGameStoreApp</li> </ol>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#nuevas-funcionalidades","title":"\ud83c\udfaf Nuevas Funcionalidades","text":"<p>Con la integraci\u00f3n de Room, nuestra aplicaci\u00f3n deja de ser una \"demo\" est\u00e1tica para convertirse en una herramienta personalizada. Estas son las capacidades que el alumno aprender\u00e1 a implementar:</p> <ul> <li>Biblioteca Personal: Permite al usuario gestionar su colecci\u00f3n propia de videojuegos de forma persistente. A trav\u00e9s de una tabla dedicada, podremos registrar qu\u00e9 juegos posee el usuario o cu\u00e1les tiene en su lista de deseos, permitiendo que esta informaci\u00f3n sobreviva incluso si el dispositivo se reinicia o la aplicaci\u00f3n se cierra por completo.</li> <li>Sistema de Favoritos: Implementaremos una funcionalidad de \"coraz\u00f3n\" que guarda el estado de preferencia de un juego directamente en la base de datos local. Al contrario que en las versiones anteriores donde el estado se perd\u00eda, ahora utilizaremos consultas SQL para marcar y desmarcar juegos, asegurando que el usuario encuentre siempre sus t\u00edtulos preferidos al volver a la app.</li> <li>Historial Din\u00e1mico: Crearemos un registro autom\u00e1tico que almacena las b\u00fasquedas recientes del usuario y los \u00faltimos juegos visitados. Esta funcionalidad no solo mejora la experiencia de usuario (UX) al permitir accesos r\u00e1pidos, sino que tambi\u00e9n sirve para practicar la gesti\u00f3n de inserciones con l\u00edmites de registros (por ejemplo, guardar solo los \u00faltimos 5 elementos).</li> <li>Notas y Seguimiento: A\u00f1adiremos la capacidad de que el usuario guarde anotaciones personales y estados de progreso para cada juego (Pendiente, Jugando, Completado, Abandonado). Esto permite trabajar con relaciones de datos m\u00e1s complejas y actualizaciones de registros existentes, transformando la app en un verdadero diario de juego personal.</li> </ul>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#introducci\u00f3n-a-room","title":"\ud83c\udfd7\ufe0f Introducci\u00f3n a Room y Configuraci\u00f3n","text":"<p>Room es una capa de abstracci\u00f3n sobre SQLite, el motor de base de datos relacional que viene integrado en Android. Room nos permite trabajar con objetos de Kotlin en lugar de escribir SQL puro de forma manual para cada operaci\u00f3n, proporcionando seguridad en tiempo de compilaci\u00f3n.</p> <p>Documentaci\u00f3n sobre persistencia a datos dentro del m\u00f3dulo:</p> <ul> <li>\u2b50 4.1. Persistencia de datos con Room</li> <li>Documentaci\u00f3n Oficial de Room</li> </ul> <p>Video</p> <p></p> <p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#por-que-room","title":"\u00bfPor qu\u00e9 Room?","text":"<ol> <li>Validaci\u00f3n en compilaci\u00f3n: Si escribes mal una consulta SQL, Room te avisar\u00e1 antes de ejecutar la app.</li> <li>Mapeo de Objetos (ORM): Convierte autom\u00e1ticamente filas de la base de datos en objetos de c\u00f3digo.</li> <li>Soporte para Flow: Permite observar cambios en la base de datos en tiempo real.</li> </ol>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#configuracion-de-dependencias","title":"Configuraci\u00f3n de Dependencias","text":"<p>Para usar Room con las mejores pr\u00e1cticas actuales, utilizaremos KSP (Kotlin Symbol Processing) en lugar del antiguo KAPT, lo que acelera significativamente la compilaci\u00f3n.</p> <p>Ubicaci\u00f3n: <code>gradle/libs.versions.toml</code> </p><pre><code>[versions]\nroom = \"2.6.1\"\nksp = \"2.1.10-1.0.29\"\n\n[libraries]\nandroidx-room-runtime = { group = \"androidx.room\", name = \"room-runtime\", version.ref = \"room\" }\nandroidx-room-ktx = { group = \"androidx.room\", name = \"room-ktx\", version.ref = \"room\" }\nandroidx-room-compiler = { group = \"androidx.room\", name = \"room-compiler\", version.ref = \"room\" }\n\n[plugins]\nksp = { id = \"com.google.devtools.ksp\", version.ref = \"ksp\" }\nroom = { id = \"androidx.room\", version.ref = \"room\" }\n</code></pre><p></p> <p>Ubicaci\u00f3n: <code>app/build.gradle.kts</code> </p><pre><code>plugins {\n    alias(libs.plugins.ksp)\n    alias(libs.plugins.room)\n}\n\ndependencies {\n    implementation(libs.androidx.room.runtime)\n    implementation(libs.androidx.room.ktx)\n    ksp(libs.androidx.room.compiler) // Compilador de Room mediante KSP\n}\n\nroom {\n    schemaDirectory(\"$projectDir/schemas\") // Directorio para exportar el esquema (opcional)\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#entitys-y-daos","title":"\ud83c\udfd7\ufe0f El Coraz\u00f3n de Room: Entitys y DAOs","text":"<p>La persistencia en Room se basa en tres pilares fundamentales: Entities, DAOs y la Database.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#arquitectura-de-room","title":"Arquitectura de Room","text":"<p>Para entender c\u00f3mo interact\u00faan estos componentes, podemos visualizarlo de la siguiente manera:</p> <pre><code>graph TD\n    subgraph \"Capa de Persistencia\"\n        DB[AppDatabase] -- contiene --&gt; DAO[DAOs]\n        DAO -- gestiona --&gt; ENT[Entities]\n        ENT -- mapea a --&gt; SQL[(SQLite Table)]\n        DAO -- realiza consultas SQL a --&gt; SQL\n    end\n\n    Repo[Repository] -- invoca --&gt; DAO\n    VM[ViewModel] -- observa Flow de --&gt; DAO</code></pre>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#1-entities-entidades","title":"1. Entities (Entidades)","text":"<p>Son clases de datos que representan las tablas de nuestra base de datos. Cada propiedad de la clase es una columna en la tabla.</p> <ul> <li>@PrimaryKey: Identificador \u00fanico de la fila.</li> <li>@ForeignKey: Define relaciones entre tablas (ej: una nota pertenece a un usuario).</li> <li>@Index: Optimiza la velocidad de las b\u00fasquedas en columnas espec\u00edficas.</li> </ul>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#ejemplo-libraryentity","title":"Ejemplo: LibraryEntity","text":"<p>Esta entidad gestiona la relaci\u00f3n entre un usuario y sus juegos (favoritos, wishlist).</p> <p>Ubicaci\u00f3n: <code>data/local/entities/LibraryEntity.kt</code> </p><pre><code>@Entity(\n    tableName = \"library\",\n    primaryKeys = [\"username\", \"gameId\"],\n    foreignKeys = [\n        ForeignKey(\n            entity = UserEntity::class,\n            parentColumns = [\"username\"],\n            childColumns = [\"username\"],\n            onDelete = ForeignKey.CASCADE\n        )\n    ],\n    indices = [Index(value = [\"username\"])]\n)\ndata class LibraryEntity(\n    val username: String,\n    val gameId: Int,\n    val addedDate: Long,\n    val status: String // FAVORITE, WISHLIST, OWNED\n)\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#2-daos-data-access-objects","title":"2. DAOs (Data Access Objects)","text":"<p>Son interfaces que definen c\u00f3mo accedemos a los datos. Aqu\u00ed es donde escribimos nuestras consultas: *   <code>@Query</code>: Consultas de lectura personalizadas. *   <code>@Insert</code>, <code>@Update</code>, <code>@Delete</code>: Operaciones b\u00e1sicas de escritura.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#ejemplo-librarydao","title":"Ejemplo: LibraryDao","text":"<p>Define las operaciones para gestionar la biblioteca del usuario.</p> <p>Ubicaci\u00f3n: <code>data/local/dao/LibraryDao.kt</code> </p><pre><code>@Dao\ninterface LibraryDao {\n    @Query(\"SELECT * FROM library WHERE username = :username\")\n    fun getLibraryForUser(username: String): Flow&lt;List&lt;LibraryEntity&gt;&gt;\n\n    @Query(\"SELECT * FROM library WHERE username = :username AND status = :status\")\n    fun getGamesByStatus(username: String, status: String): Flow&lt;List&lt;LibraryEntity&gt;&gt;\n\n    @Insert(onConflict = OnConflictStrategy.REPLACE)\n    suspend fun insertLibraryEntry(entry: LibraryEntity)\n\n    @Query(\"DELETE FROM library WHERE username = :username AND gameId = :gameId\")\n    suspend fun deleteLibraryEntry(username: String, gameId: Int)\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#3-la-base-de-datos-appdatabase","title":"3. La Base de Datos (AppDatabase)","text":"<p>Es el punto de uni\u00f3n de todas las entidades y DAOs.</p> <p>Ubicaci\u00f3n: <code>data/local/AppDatabase.kt</code> </p><pre><code>@Database(\n    entities = [\n        UserEntity::class,\n        LibraryEntity::class,\n        SearchHistoryEntity::class,\n        RecentGameEntity::class,\n        GameNoteEntity::class\n    ],\n    version = 1,\n    exportSchema = false\n)\nabstract class AppDatabase : RoomDatabase() {\n    abstract fun userDao(): UserDao\n    abstract fun libraryDao(): LibraryDao\n    abstract fun searchHistoryDao(): SearchHistoryDao\n    abstract fun recentGameDao(): RecentGameDao\n    abstract fun gameNoteDao(): GameNoteDao\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#diagrama-de-relaciones","title":"Diagrama de Relaciones","text":"<p>A continuaci\u00f3n, vemos c\u00f3mo se relacionan nuestras entidades en el sistema:</p> <pre><code>classDiagram\n    %% Capa de Datos: Entidades de Room\n    class UserEntity {\n        +String username [PK]\n        +String name\n        +String email\n        +String avatarUrl\n        +String bio\n    }\n\n    class LibraryEntity {\n        +String username [PK/FK]\n        +Int gameId [PK]\n        +Long addedDate\n        +String status\n    }\n\n    class GameNoteEntity {\n        +Int gameId [PK]\n        +String username [FK]\n        +String note\n        +String progressStatus\n        +Long lastUpdated\n    }\n\n    class RecentGameEntity {\n        +Int id [PK]\n        +String username [FK]\n        +Int gameId\n        +Long timestamp\n    }\n\n    class SearchHistoryEntity {\n        +Int id [PK]\n        +String username [FK]\n        +String query\n        +Long timestamp\n    }\n\n    %% Capa de Dominio: Modelo de Referencia\n    class Game {\n        +Int id\n        +String title\n        +String description\n        +Double price\n        +GameCategory category\n    }\n\n    %% Relaciones\n    UserEntity \"1\" --o \"0..*\" LibraryEntity : posee\n    UserEntity \"1\" --o \"0..*\" GameNoteEntity : escribe\n    UserEntity \"1\" --o \"0..*\" RecentGameEntity : visualiza\n    UserEntity \"1\" --o \"0..*\" SearchHistoryEntity : busca\n\n    LibraryEntity ..&gt; Game : referencia ID\n    GameNoteEntity ..&gt; Game : referencia ID\n    RecentGameEntity ..&gt; Game : referencia ID\n\n    %% Notas sobre Enums (Referencia Conceptual)\n    note for LibraryEntity \"Status: FAVORITE, WISHLIST, OWNED\"\n    note for GameNoteEntity \"Progress: PENDING, PLAYING, COMPLETED, ABANDONED\"</code></pre>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#relaciones-entidades","title":"\ud83d\udd17 Relacionando Datos: Foreign Keys","text":"<p>En una base de datos relacional, es vital que los datos est\u00e9n conectados. Room utiliza las Foreign Keys (Claves For\u00e1neas) para asegurar la integridad referencial.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#que-es-una-clave-foranea","title":"\u00bfQu\u00e9 es una Clave For\u00e1nea?","text":"<p>Es una columna que establece una conexi\u00f3n entre dos tablas. Por ejemplo, en nuestra tabla <code>library</code>, la columna <code>username</code> es una clave for\u00e1nea que apunta a la tabla <code>users</code>.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#como-implementar-una-relacion-en-room","title":"C\u00f3mo implementar una relaci\u00f3n en Room","text":"<p>Para relacionar dos entidades, usamos el par\u00e1metro <code>foreignKeys</code> dentro de la anotaci\u00f3n <code>@Entity</code>.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#ejemplo-relacion-usuario-biblioteca","title":"Ejemplo: Relaci\u00f3n Usuario -&gt; Biblioteca","text":"<p>Queremos que un registro de la biblioteca solo pueda existir si el usuario asociado existe en la tabla de usuarios.</p> <pre><code>@Entity(\n    tableName = \"library\",\n    primaryKeys = [\"username\", \"gameId\"], // Clave primaria compuesta\n    foreignKeys = [\n        ForeignKey(\n            entity = UserEntity::class,      // Tabla padre\n            parentColumns = [\"username\"],    // Columna en la tabla padre\n            childColumns = [\"username\"],     // Columna en esta tabla (hija)\n            onDelete = ForeignKey.CASCADE    // Si se borra el usuario, se borra su biblioteca\n        )\n    ]\n)\ndata class LibraryEntity(\n    val username: String,\n    val gameId: Int,\n    val addedDate: Long,\n    val status: String\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#tipos-de-relaciones-comunes","title":"Tipos de Relaciones comunes:","text":"<ol> <li>Uno a Muchos (1:N): Un usuario tiene muchos juegos en su biblioteca. Se implementa poniendo el ID del \"padre\" (<code>username</code>) como clave for\u00e1nea en la tabla \"hija\" (<code>library</code>).</li> <li>Muchos a Muchos (N:M): Muchos usuarios pueden tener muchos juegos. Room lo maneja mediante una tabla asociativa (como nuestra tabla <code>library</code>, que asocia un <code>username</code> con un <code>gameId</code>).</li> </ol>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#integridad-referencial-ondelete-cascade","title":"Integridad Referencial: <code>onDelete = CASCADE</code>","text":"<p>Esta es una funcionalidad muy potente. Al configurar <code>CASCADE</code>, le decimos a SQLite: \"Si eliminas este usuario de la base de datos, elimina autom\u00e1ticamente todos sus juegos favoritos, notas y b\u00fasquedas relacionadas\". Esto evita que queden \"datos hu\u00e9rfanos\" en nuestra base de datos.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#mapeo-de-datos","title":"\ud83d\udee1\ufe0f Mapeo de Datos y Conversores","text":"<p>Podr\u00edas preguntarte: \u00bfPor qu\u00e9 no usamos las mismas clases de Room en toda la app? La respuesta es por Arquitectura Limpia (Clean Architecture).</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#1-typeconverters-los-traductores-de-sqlite","title":"1. TypeConverters: Los traductores de SQLite","text":"<p>Room solo entiende tipos b\u00e1sicos (String, Int, Long). Para guardar tipos complejos como Enums o Fechas, necesitamos conversores.</p> <p>Ubicaci\u00f3n: <code>data/local/RoomConverters.kt</code> (Propuesta did\u00e1ctica) </p><pre><code>class RoomConverters {\n    @TypeConverter\n    fun fromLibraryStatus(status: LibraryStatus): String = status.name\n\n    @TypeConverter\n    fun toLibraryStatus(value: String): LibraryStatus = LibraryStatus.valueOf(value)\n}\n</code></pre> Nota: Debes registrar estos conversores en tu clase <code>AppDatabase</code> usando la anotaci\u00f3n <code>@TypeConverters(RoomConverters::class)</code>.<p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#2-mappers-protegiendo-el-dominio","title":"2. Mappers: Protegiendo el Dominio","text":"<p>El Mapper traduce de la Capa de Datos (<code>Entity</code>) a la Capa de Dominio (<code>Game</code>).</p> <p>\u00bfPor qu\u00e9 usarlos? 1.  Desacoplamiento: Si usamos <code>@Entity</code> en la UI, estamos \"contaminando\" la vista con detalles de la base de datos. 2.  Transformaci\u00f3n de Tipos: Traduce de <code>\"FAVORITE\"</code> (String en BD) a <code>LibraryStatus.FAVORITE</code> (Enum en c\u00f3digo). 3.  Seguridad: Asegura que solo los datos necesarios lleguen a la UI.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#typeconverters-vs-mappers","title":"TypeConverters vs Mappers","text":"<ul> <li>TypeConverter: Se encarga de que Room sepa c\u00f3mo guardar un tipo complejo en el disco (ej: Enum -&gt; String). Opera a nivel de persistencia.</li> <li>Mapper: Se encarga de convertir modelos entre capas (ej: Entity -&gt; Domain Model). Opera a nivel de arquitectura.</li> </ul>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#diagrama-de-flujo-de-datos","title":"Diagrama de Flujo de Datos","text":"<p>Para visualizar c\u00f3mo interact\u00faan todos estos componentes, observa el siguiente diagrama de secuencia. Muestra el camino que recorre un dato desde que el usuario interact\u00faa con la pantalla hasta que se guarda o recupera de la base de datos:</p> <pre><code>sequenceDiagram\n    participant UI as UI (Compose Screen)\n    participant VM as ViewModel\n    participant UC as UseCase\n    participant Repo as Repository\n    participant Mapper as Mapper\n    participant Room as Room (DAO)\n    participant TC as TypeConverter\n    participant DB as SQLite (Disco)\n\n    Note over UI, DB: Flujo de Recuperaci\u00f3n de Datos (Observaci\u00f3n)\n\n    UI-&gt;&gt;VM: Observa StateFlow\n    VM-&gt;&gt;UC: Solicita Flow de datos\n    UC-&gt;&gt;Repo: Solicita Resource&lt;Flow&gt;\n    Repo-&gt;&gt;Room: Consulta al DAO\n    Room-&gt;&gt;DB: SELECT * FROM tabla\n    DB--&gt;&gt;TC: Devuelve tipos b\u00e1sicos (String, Int)\n    TC--&gt;&gt;Room: Convierte a tipos complejos (Enums)\n    Room--&gt;&gt;Repo: Devuelve Entity (ej: LibraryEntity)\n    Repo-&gt;&gt;Mapper: Convierte Entity a Domain Model\n    Mapper--&gt;&gt;Repo: Devuelve Domain Model (ej: Game)\n    Repo--&gt;&gt;UC: Devuelve Resource.Success(Game)\n    UC--&gt;&gt;VM: Emite nuevo estado\n    VM--&gt;&gt;UI: Actualiza la pantalla autom\u00e1ticamente</code></pre>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#arquitectura-h\u00edbrida","title":"\u2699\ufe0f Arquitectura H\u00edbrida y Reactividad","text":"<p>Nuestra aplicaci\u00f3n ahora utiliza un Repositorio H\u00edbrido (<code>MockGamesRepositoryImpl</code>). Este act\u00faa como un orquestador que combina dos fuentes de datos: 1.  MockDataSource: Para la informaci\u00f3n est\u00e1tica de los juegos (t\u00edtulo, imagen, etc.). 2.  AppDatabase (Room): Para la informaci\u00f3n din\u00e1mica del usuario (si es favorito, sus notas, etc.).</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#implementacion-en-el-repositorio","title":"Implementaci\u00f3n en el Repositorio","text":"<p>Observa c\u00f3mo el repositorio mezcla los datos de Room con los del Mock:</p> <p>Ubicaci\u00f3n: <code>data/repository/MockGamesRepositoryImpl.kt</code> </p><pre><code>override fun getFavoriteGames(): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; = flow {\n    emit(Resource.Loading)\n    val user = getCurrentUser()\n    // 1. Escuchamos cambios en Room (DAO)\n    db.libraryDao().getGamesByStatus(user, \"FAVORITE\").collect { entities -&gt;\n        // 2. Cruzamos los IDs de Room con los datos del MockDataSource\n        val games = entities.mapNotNull { entity -&gt;\n            dataSource.games.find { it.id == entity.gameId }\n        }\n        // 3. Emitimos el resultado final al UseCase\n        emit(Resource.Success(games))\n    }\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#integracion-en-el-viewmodel","title":"Integraci\u00f3n en el ViewModel","text":"<p>El ViewModel ya no gestiona listas est\u00e1ticas, sino que observa los flujos de datos que vienen de la base de datos.</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/DetailViewModel.kt</code> </p><pre><code>class DetailViewModel(\n    private val useCases: GameUseCases,\n    private val gameId: Int\n) : ViewModel() {\n\n    private val _uiState = MutableStateFlow(DetailUiState())\n    val uiState: StateFlow&lt;DetailUiState&gt; = _uiState.asStateFlow()\n\n    init {\n        loadGame()\n        checkIfFavorite() // Comprueba estado inicial\n        loadNote()        // Carga nota de Room\n    }\n\n    fun toggleFavorite() {\n        viewModelScope.launch {\n            // Actualiza Room y la UI reaccionar\u00e1 sola gracias al Flow\n            useCases.toggleFavorite(gameId)\n            checkIfFavorite()\n        }\n    }\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#el-poder-de-flow-en-room","title":"El poder de Flow en Room","text":"<p>Al definir los m\u00e9todos del DAO devolviendo <code>Flow&lt;List&lt;T&gt;&gt;</code>, Room implementa autom\u00e1ticamente la reactividad. Si el usuario marca un juego como favorito, Room detecta el cambio en el disco y emite autom\u00e1ticamente la nueva lista. La UI se actualiza sola sin que tengamos que pedir los datos de nuevo.</p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#motor-app","title":"\ud83d\ude80 El Motor de la App: MyGameStoreApp","text":"<p>En Android, la clase <code>Application</code> es el punto de entrada global de la aplicaci\u00f3n. Se crea una sola vez cuando se lanza el proceso de la app y vive hasta que este finaliza.</p> <p>Ubicaci\u00f3n: <code>MyGameStoreApp.kt</code> </p><pre><code>class MyGameStoreApp : Application() {\n    companion object {\n        lateinit var database: AppDatabase\n            private set\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        // Inicializaci\u00f3n de la base de datos como Singleton\n        database = Room.databaseBuilder(\n            applicationContext,\n            AppDatabase::class.java,\n            \"mygamestore_db\"\n        ).build()\n    }\n}\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#por-que-es-importante","title":"\u00bfPor qu\u00e9 es importante?","text":"<ol> <li>Patr\u00f3n Singleton: Crear una instancia de base de datos es una operaci\u00f3n \"pesada\". Al hacerlo en la clase <code>Application</code>, aseguramos que solo exista una instancia en toda la vida de la app, evitando fugas de memoria y bloqueos de base de datos.</li> <li>Punto de Acceso Global: Al estar en un <code>companion object</code>, cualquier parte de la app (como los repositorios) puede acceder a la base de datos de forma segura.</li> <li>Configuraci\u00f3n \u00danica: Es el lugar ideal para configurar migraciones de base de datos o inicializar datos por defecto.</li> </ol>"},{"location":"temas/proyectos/GameVault/07-RoomPersistence.html#conclusion","title":"\ud83d\udca1 Conclusi\u00f3n","text":"<p>Con Room, hemos dado el paso definitivo hacia una aplicaci\u00f3n profesional. Ahora los datos del usuario son persistentes, la arquitectura es robusta gracias a los Mappers y la UI es reactiva gracias a Flow. \u00a1MyGameStore ya tiene memoria!</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html","title":"8. Biblioteca y detalles avanzados","text":""},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#8-libraryscreen-y-detalle-avanzado","title":"8. LibraryScreen y Detalle Avanzado","text":"<p>En esta 8\u00aa entrega, daremos el salto final en la experiencia de usuario de nuestra aplicaci\u00f3n. Aprenderemos a dise\u00f1ar la pantalla de Mi Biblioteca (<code>LibraryScreen</code>) integrando filtros din\u00e1micos y acciones avanzadas como el Swipe-to-Action. Adem\u00e1s, profundizaremos en la implementaci\u00f3n t\u00e9cnica de los flujos de persistencia para Favoritos y Lista de Deseos, y c\u00f3mo la arquitectura reactiva permite que la aplicaci\u00f3n se actualice sola.</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#indice","title":"\ud83d\udcd6 \u00cdndice","text":"<ol> <li>El Flujo de Persistencia: Favoritos y Wishlist</li> <li>Dise\u00f1o de LibraryScreen: Tu Colecci\u00f3n Personal</li> <li>Navegaci\u00f3n y LibraryGameCard</li> <li>Interacci\u00f3n Avanzada: Swipe-to-Action y Di\u00e1logos</li> <li>Modificaciones en Componentes Existentes</li> </ol>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#flujo-persistencia","title":"\ud83c\udfd7\ufe0f El Flujo de Persistencia: Favoritos y Wishlist","text":"<p>Una de las partes m\u00e1s importantes de esta entrega es entender c\u00f3mo un click en la UI se convierte en un dato permanente. Hemos implementado dos flujos paralelos pero casi id\u00e9nticos para <code>Favorite</code> y <code>Wishlist</code>.</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#11-de-la-ui-al-repositorio","title":"1.1. De la UI al Repositorio","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/screens/DetailScreen.kt</code></p> <p>Cuando el usuario pulsa el icono del coraz\u00f3n o del marcador en <code>DetailScreen</code>, se desencadena la siguiente cadena:</p> <ol> <li>UI (<code>DetailScreen</code>): Llama a <code>viewModel.toggleFavorite()</code>.</li> <li>ViewModel (<code>DetailViewModel</code>): Ejecuta una corrutina que invoca al Caso de Uso <code>useCases.toggleFavorite(gameId)</code>.</li> <li>Caso de Uso (<code>GameUseCases</code>): Act\u00faa como pasarela hacia el repositorio.</li> <li> <p>Repositorio (<code>MockGamesRepositoryImpl</code>): Contiene la l\u00f3gica de negocio. </p> <ul> <li>Comprueba si el usuario existe en Room (integridad referencial).</li> <li>Si el juego no est\u00e1, lo inserta con el estado correspondiente.</li> <li>Si ya est\u00e1 con ese estado, lo mantiene o elimina (comportamiento de \"toggle\").</li> <li>Si est\u00e1 con otro estado, lo actualiza.</li> </ul> </li> </ol> <pre><code>sequenceDiagram\n    participant UI as DetailScreen\n    participant VM as DetailViewModel\n    participant UC as GameUseCases\n    participant Repo as GamesRepository\n    participant DB as Room (Database)\n\n    UI-&gt;&gt;VM: onToggleFavorite() / onToggleWishlist()\n    VM-&gt;&gt;UC: toggleFavorite(id) / toggleWishlist(id)\n    UC-&gt;&gt;Repo: toggleFavorite(id) / toggleWishlist(id)\n    Repo-&gt;&gt;DB: getUserByUsername(user)\n    DB--&gt;&gt;Repo: UserEntity\n    Note over Repo: L\u00f3gica de Negocio (Insert/Update/Delete)\n    Repo-&gt;&gt;DB: insertLibraryEntry() / deleteLibraryEntry()\n    DB--&gt;&gt;Repo: OK\n    Repo--&gt;&gt;UC: Resource.Success\n    UC--&gt;&gt;VM: Resource.Success</code></pre>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#12-la-magia-de-la-reactividad-flow","title":"1.2. La Magia de la Reactividad (Flow)","text":"<p>Para que el bot\u00f3n cambie de color instant\u00e1neamente, no usamos una variable simple, sino un Flow:</p> <ul> <li>El ViewModel observa <code>useCases.isFavorite(gameId)</code> desde el <code>init</code>.</li> <li>Room emite un nuevo valor cada vez que la tabla <code>library</code> cambia.</li> <li>La UI reacciona autom\u00e1ticamente al nuevo estado del <code>StateFlow</code> en el ViewModel.</li> </ul> <pre><code>sequenceDiagram\n    participant DB as Room (SQLite)\n    participant Repo as GamesRepository\n    participant UC as GameUseCases\n    participant VM as DetailViewModel\n    participant UI as DetailScreen\n\n    Note over DB, UI: Ciclo de Observaci\u00f3n Reactiva\n    DB-&gt;&gt;Repo: Emite cambio en tabla 'library' (Flow)\n    Repo-&gt;&gt;UC: Propaga flujo de datos\n    UC-&gt;&gt;VM: Emite nuevo valor Boolean\n    VM-&gt;&gt;VM: Actualiza _uiState (StateFlow)\n    VM-&gt;&gt;UI: Notifica cambio de estado\n    UI-&gt;&gt;UI: Re-composici\u00f3n (Icono se ilumina)</code></pre>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#diseno-library","title":"\ud83c\udfd7\ufe0f Dise\u00f1o de LibraryScreen: Tu Colecci\u00f3n Personal","text":"<p>La <code>LibraryScreen</code> es el \"hub\" central del usuario. Su implementaci\u00f3n se basa en un filtrado din\u00e1mico sobre los datos de Room.</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#21-implementacion-de-la-pantalla","title":"2.1. Implementaci\u00f3n de la Pantalla","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/screens/LibraryScreen.kt</code></p> <p>La pantalla utiliza un <code>LibraryViewModel</code> que gestiona el estado de los juegos cargados. El coraz\u00f3n de la pantalla es la combinaci\u00f3n de:</p> <ul> <li>Estado de Filtro: Un <code>LibraryStatus</code> que cambia cuando el usuario pulsa los chips superiores.</li> <li>Carga de Datos: El m\u00e9todo <code>loadLibrary()</code> solicita al repositorio los juegos que coinciden con el filtro seleccionado.</li> </ul> <pre><code>// En LibraryViewModel.kt\nfun loadLibrary() {\n    viewModelScope.launch {\n        useCases.getLibraryGames(selectedFilter).collect { resource -&gt;\n            _uiState.update { it.copy(libraryGames = resource) }\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#navegacion-card","title":"\ud83c\udfd7\ufe0f Navegaci\u00f3n y LibraryGameCard","text":"<p>Para que la aplicaci\u00f3n sea fluida, la biblioteca debe permitir volver al detalle de cualquier juego.</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#31-navegacion-desde-la-card","title":"3.1. Navegaci\u00f3n desde la Card","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/screens/LibraryScreen.kt</code></p> <p>Dentro de la <code>LibraryScreen</code>, cada elemento de la lista es una <code>LibraryGameCard</code>. Le pasamos un callback <code>onClick</code> que utiliza nuestro sistema de navegaci\u00f3n:</p> <pre><code>LibraryGameCard(\n    game = game,\n    status = uiState.selectedFilter,\n    onClick = { navStack.add(AppRoutes.Detail(game.id)) }, // Navegaci\u00f3n al detalle\n    onDelete = { gameToDelete = game }\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#32-diseno-de-librarygamecard","title":"3.2. Dise\u00f1o de LibraryGameCard","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/componentes/LibraryCard.kt</code></p> <p>A diferencia de la <code>GameCard</code> de la Home, esta tarjeta es horizontal para aprovechar mejor el espacio:</p> <ul> <li>Fila 1: Iconos de plataformas y un \"Badge\" que indica el estado (ej: \"Deseados\").</li> <li>Fila 2: T\u00edtulo en negrita con truncado de texto.</li> <li>Fila 3: Rating con estrella dorada.</li> <li>Fila 4: G\u00e9neros del juego (GenreChipsRow).</li> <li>Espaciado: Se utiliza <code>Arrangement.SpaceEvenly</code> para que toda la informaci\u00f3n quede perfectamente distribuida verticalmente.</li> </ul>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#swipe-action","title":"\ud83c\udfd7\ufe0f Interacci\u00f3n Avanzada: Swipe-to-Action y Di\u00e1logos","text":"<p>Hemos implementado el gesto de deslizar para eliminar, una de las interacciones m\u00e1s comunes en Android moderno.</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#41-swipe-to-dismissbox","title":"4.1. Swipe-to-DismissBox","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/componentes/LibraryCard.kt</code></p> <p>Utilizamos el componente experimental de Material 3 <code>SwipeToDismissBox</code>. Lo configuramos para que solo permita deslizar de derecha a izquierda (EndToStart).</p>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#42-confirmacion-con-alertdialog","title":"4.2. Confirmaci\u00f3n con AlertDialog","text":"<p>Ubicaci\u00f3n: <code>presentation/ui/screens/LibraryScreen.kt</code></p> <p>Para evitar borrados accidentales, el swipe no borra el dato directamente, sino que activa un estado <code>gameToDelete</code>. Esto dispara un <code>AlertDialog</code>:</p> <ul> <li>Si el usuario confirma, se llama a <code>viewModel.removeFromLibrary()</code>.</li> <li>Si cancela, el estado vuelve a <code>null</code> y la tarjeta recupera su posici\u00f3n.</li> </ul>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#modificaciones","title":"\ud83c\udfd7\ufe0f Modificaciones en Componentes Existentes","text":"<p>Para albergar estas funciones, hemos tenido que \"tocar\" piezas que ya ten\u00edamos:</p> <ol> <li> <p><code>GameUseCases.kt</code>: Se han a\u00f1adido los m\u00e9todos para Wishlist, notas y borrado. Es nuestro punto \u00fanico de acceso a la l\u00f3gica de juegos.</p> <p>Ubicaci\u00f3n: <code>domain/usecase/GameUseCases.kt</code></p> <pre><code>// Nuevos m\u00e9todos en GameUseCases.kt\nsuspend fun toggleWishlist(gameId: Int): Resource&lt;Unit&gt; = gamesRepository.toggleWishlist(gameId)\nfun isInWishlist(gameId: Int): Flow&lt;Boolean&gt; = gamesRepository.isInWishlist(gameId)\nsuspend fun removeFromLibrary(gameId: Int): Resource&lt;Unit&gt; = gamesRepository.removeFromLibrary(gameId)\nsuspend fun saveNoteForGame(gameId: Int, note: String, status: GameProgress) =\n    gamesRepository.saveNoteForGame(gameId, note, status)\n</code></pre> </li> <li> <p><code>DetailViewModel.kt</code>: Ha crecido para observar m\u00faltiples flujos (isFavorite, isInWishlist, note, progress). Ahora es un ViewModel mucho m\u00e1s robusto y reactivo.</p> <p>Ubicaci\u00f3n: <code>presentation/viewmodel/DetailViewModel.kt</code></p> <pre><code>// DetailViewModel.kt: Observaci\u00f3n de m\u00faltiples flujos\ninit {\n    loadGame()\n    observeFavoriteStatus()\n    observeWishlistStatus()\n    loadNoteAndProgress()\n    addToRecent()\n}\n\nprivate fun observeFavoriteStatus() {\n    viewModelScope.launch {\n        useCases.isFavorite(gameId).collect { favorite -&gt;\n            _uiState.update { it.copy(isFavorite = favorite) }\n        }\n    }\n}\n</code></pre> </li> <li> <p><code>AuthRepositoryImpl.kt</code>: Ahora asegura que el usuario se guarde en Room al hacer login. Sin esto, las Claves For\u00e1neas de Room fallar\u00edan por falta de integridad.</p> <p>Ubicaci\u00f3n: <code>data/repository/AuthRepositoryImpl.kt</code></p> <pre><code>// AuthRepositoryImpl.kt: Sincronizaci\u00f3n con Room\noverride suspend fun login(username: String, password: String): LoginResult {\n    // ... validaci\u00f3n ...\n    if (validUsers[username] == password) {\n        val userData = registeredUsers[username]\n        if (userData != null) {\n            db.userDao().insertUser(\n                UserEntity(\n                    username = userData.username,\n                    name = userData.username.replaceFirstChar { it.uppercase() },\n                    email = userData.email\n                )\n            )\n        }\n        return LoginResult.Success(username = username)\n    }\n    // ...\n}\n</code></pre> </li> <li> <p><code>MockGamesRepositoryImpl.kt</code>: Se ha convertido en un repositorio h\u00edbrido que mezcla datos est\u00e1ticos (del Mock) con datos din\u00e1micos (de Room) mediante operaciones de cruce por ID.</p> <p>Ubicaci\u00f3n: <code>data/repository/MockGamesRepositoryImpl.kt</code></p> <pre><code>// MockGamesRepositoryImpl.kt: Repositorio h\u00edbrido\noverride fun getLibraryGames(status: LibraryStatus): Flow&lt;Resource&lt;List&lt;Game&gt;&gt;&gt; = flow {\n    emit(Resource.Loading)\n    val user = getCurrentUser()\n    val flow = if (status == LibraryStatus.ALL) {\n        db.libraryDao().getLibraryForUser(user)\n    } else {\n        db.libraryDao().getGamesByStatus(user, status)\n    }\n\n    flow.collect { entities -&gt;\n        val games = entities.mapNotNull { entity -&gt;\n            dataSource.games.find { it.id == entity.gameId }\n        }\n        emit(Resource.Success(games))\n    }\n}\n</code></pre> </li> </ol>"},{"location":"temas/proyectos/GameVault/08-LibraryAndDetailAdvanced.html#resumen-de-aprendizaje","title":"\ud83c\udfaf Resumen de Aprendizaje","text":"<p>Al finalizar esta parte, el alumno domina:</p> <ol> <li>Flujos Reactivos Completos: Desde la persistencia hasta la actualizaci\u00f3n visual.</li> <li>Arquitectura H\u00edbrida: Mezclar fuentes de datos est\u00e1ticas y din\u00e1micas.</li> <li>Componentes UX Modernos: Swipe, di\u00e1logos de confirmaci\u00f3n y badges de estado.</li> <li>Integridad de Datos: Gesti\u00f3n de Foreign Keys y sincronizaci\u00f3n de usuarios.</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html","title":"9. Inyecci\u00f3n de dependencias con Koin","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#9-inyeccion-de-dependencias-con-koin","title":"9. Inyecci\u00f3n de Dependencias con Koin","text":"<p>En esta 9\u00aa parte del proyecto, refactorizaremos nuestra aplicaci\u00f3n para implementar Inyecci\u00f3n de Dependencias (DI) utilizando Koin. Este cambio arquitect\u00f3nico es fundamental antes de integrar servicios externos como Firebase, ya que nos permitir\u00e1 gestionar las dependencias de forma centralizada, testeable y escalable.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#resumen","title":"Resumen","text":"<ol> <li>Fundamentos: Inversi\u00f3n de Control (IoC) e Inyecci\u00f3n de Dependencias (DI)</li> <li>\u00bfQu\u00e9 es la Inyecci\u00f3n de Dependencias y por qu\u00e9 usarla?</li> <li>Configuraci\u00f3n de Koin en el proyecto</li> <li>Creaci\u00f3n de m\u00f3dulos de Koin</li> <li>Refactorizaci\u00f3n de ViewModels y Repositorios</li> <li>Ventajas y buenas pr\u00e1cticas</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#0-fundamentos-inversion-de-control-ioc-e-inyeccion-de-dependencias-di","title":"0. Fundamentos: Inversi\u00f3n de Control (IoC) e Inyecci\u00f3n de Dependencias (DI)","text":"<p>Antes de implementar cualquier framework de DI, es fundamental comprender los principios arquitect\u00f3nicos que lo sustentan. En esta secci\u00f3n exploraremos conceptos que van m\u00e1s all\u00e1 de Android y son aplicables a cualquier lenguaje de programaci\u00f3n orientado a objetos.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#01-el-problema-de-las-dependencias-hardcoded-a-fuego-en-el-codigo","title":"0.1. El Problema de las Dependencias Hardcoded (a fuego en el c\u00f3digo)","text":"<p>Imagina que est\u00e1s construyendo un coche. En un dise\u00f1o tradicional (sin IoC), cada componente crear\u00eda sus propias piezas:</p> <pre><code>// \u274c Dise\u00f1o acoplado - Ejemplo conceptual\nclass Coche {\n    private val motor = MotorDiesel()      // Crea su propio motor\n    private val ruedas = RuedasMichelin()  // Crea sus propias ruedas\n\n    fun arrancar() {\n        motor.encender()\n    }\n}\n</code></pre> <p>Problemas evidentes:</p> <ol> <li>Acoplamiento r\u00edgido: <code>Coche</code> est\u00e1 \"soldado\" a <code>MotorDiesel</code>. Si quieres un motor el\u00e9ctrico, tienes que modificar la clase <code>Coche</code>.</li> <li>Imposible testear: No puedes probar <code>Coche</code> con un <code>MotorFalso</code> que simule fallos.</li> <li>Reutilizaci\u00f3n nula: No puedes usar el mismo <code>Coche</code> con diferentes motores.</li> <li>Violaci\u00f3n de principios SOLID: Espec\u00edficamente el Principio de Inversi\u00f3n de Dependencias (la \"D\" de SOLID).</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#02-que-es-la-inversion-de-control-ioc","title":"0.2. \u00bfQu\u00e9 es la Inversi\u00f3n de Control (IoC)?","text":"<p>Inversi\u00f3n de Control (IoC) es un principio de dise\u00f1o donde el flujo de control de una aplicaci\u00f3n se invierte: en lugar de que tu c\u00f3digo llame al framework, el framework llama a tu c\u00f3digo.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#analogia-el-restaurante","title":"Analog\u00eda: El Restaurante","text":"<p>Piensa en dos modelos de restaurante:</p> <p>Sin IoC (Control tradicional): </p><pre><code>T\u00fa (el c\u00f3digo) \u2192 Vas a la cocina\n                \u2192 Eliges ingredientes\n                \u2192 Cocinas el plato\n                \u2192 Te lo sirves\n</code></pre><p></p> <p>T\u00fa controlas todo el proceso.</p> <p>Con IoC (Control invertido): </p><pre><code>T\u00fa (el c\u00f3digo) \u2192 Pides el plato al camarero\nFramework      \u2192 Decide c\u00f3mo cocinarlo\n               \u2192 Te lo sirve listo\n</code></pre><p></p> <p>El framework controla el proceso, t\u00fa solo defines qu\u00e9 necesitas.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#implementacion-tecnica","title":"Implementaci\u00f3n t\u00e9cnica","text":"<p>En programaci\u00f3n, IoC se manifiesta en varios patrones:</p> <ol> <li>Template Method Pattern: El framework define el esqueleto del algoritmo.</li> <li>Observer Pattern: Los objetos se registran para ser notificados.</li> <li>Dependency Injection: Las dependencias se \"inyectan\" desde fuera.</li> </ol> <pre><code>// \u2705 Con IoC - Ejemplo conceptual\nclass Coche(\n    private val motor: Motor,      // Recibe el motor desde fuera\n    private val ruedas: Ruedas     // Recibe las ruedas desde fuera\n) {\n    fun arrancar() {\n        motor.encender()\n    }\n}\n\n// Ahora el \"framework\" (o contenedor) controla la creaci\u00f3n:\nval cocheElectrico = Coche(MotorElectrico(), RuedasGoodYear())\nval cocheDiesel = Coche(MotorDiesel(), RuedasMichelin())\n</code></pre> <p>Ventaja clave: <code>Coche</code> ya no controla su construcci\u00f3n, solo define qu\u00e9 necesita.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#03-que-es-la-inyeccion-de-dependencias-di","title":"0.3 . \u00bfQu\u00e9 es la Inyecci\u00f3n de Dependencias (DI)?","text":"<p>Inyecci\u00f3n de Dependencias (DI) es una implementaci\u00f3n espec\u00edfica del principio IoC. Es la t\u00e9cnica de \"pasar\" las dependencias de una clase desde el exterior, en lugar de que la clase las cree internamente.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#los-tres-tipos-de-inyeccion-de-dependencias","title":"Los tres tipos de Inyecci\u00f3n de Dependencias","text":"<p>1. Inyecci\u00f3n por Constructor (Constructor Injection) - \u2b50 Recomendada</p> <pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository,  // \u2190 Inyectada\n    private val sessionManager: SessionManager   // \u2190 Inyectada\n) : ViewModel()\n</code></pre> <p>Ventajas: - \u2705 Dependencias obligatorias (no pueden ser null) - \u2705 Inmutabilidad (<code>val</code>) - \u2705 Facilita testing</p> <p>2. Inyecci\u00f3n por Setter (Setter Injection)</p> <pre><code>class LoginViewModel : ViewModel() {\n    lateinit var authRepository: AuthRepository  // \u2190 Se asigna despu\u00e9s\n\n    fun setAuthRepository(repo: AuthRepository) {\n        this.authRepository = repo\n    }\n}\n</code></pre> <p>Desventajas: - \u26a0\ufe0f Dependencias opcionales (pueden quedar sin inicializar) - \u26a0\ufe0f Mutabilidad - \u274c Poco com\u00fan en Android moderno</p> <p>3. Inyecci\u00f3n por Interfaz (Interface Injection)</p> <pre><code>interface AuthRepositoryInjector {\n    fun inject(repo: AuthRepository)\n}\n\nclass LoginViewModel : ViewModel(), AuthRepositoryInjector {\n    private lateinit var authRepository: AuthRepository\n\n    override fun inject(repo: AuthRepository) {\n        this.authRepository = repo\n    }\n}\n</code></pre> <p>Uso: Muy raro, principalmente en frameworks legacy.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#04-el-principio-de-inversion-de-dependencias-dip","title":"0.4. El Principio de Inversi\u00f3n de Dependencias (DIP)","text":"<p>La Inyecci\u00f3n de Dependencias est\u00e1 estrechamente relacionada con el Principio de Inversi\u00f3n de Dependencias, la \"D\" de SOLID:</p> <p>Principio de Inversi\u00f3n de Dependencias (Robert C. Martin)</p> <p>A. Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel. Ambos deben depender de abstracciones.</p> <p>B. Las abstracciones no deben depender de detalles. Los detalles deben depender de abstracciones.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#aplicado-a-nuestro-proyecto","title":"Aplicado a nuestro proyecto","text":"<p>\u274c Violaci\u00f3n del DIP (C\u00f3digo actual):</p> <pre><code>class LoginViewModel(\n    context: Context,\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),  // \u2190 Depende de implementaci\u00f3n\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel()\n</code></pre> <p>Problema: <code>LoginViewModel</code> (m\u00f3dulo de alto nivel) depende de <code>AuthRepositoryImpl</code> (m\u00f3dulo de bajo nivel concreto).</p> <p>\u2705 Cumplimiento del DIP (Con DI):</p> <pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository,  // \u2190 Depende de abstracci\u00f3n\n    private val sessionManager: SessionManager   // \u2190 Depende de abstracci\u00f3n\n) : ViewModel()\n</code></pre> <p>Soluci\u00f3n: <code>LoginViewModel</code> depende de las interfaces (<code>AuthRepository</code>, <code>SessionManager</code>), no de las implementaciones.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#diagrama-de-dependencias","title":"Diagrama de dependencias","text":"<pre><code>graph TD\n    subgraph \"\u274c Sin DIP\"\n        A1[LoginViewModel&lt;br/&gt;Alto Nivel] --&gt;|depende| B1[AuthRepositoryImpl&lt;br/&gt;Bajo Nivel]\n        B1 --&gt;|depende| C1[AppDatabase&lt;br/&gt;Detalle]\n    end\n\n    subgraph \"\u2705 Con DIP + DI\"\n        A2[LoginViewModel&lt;br/&gt;Alto Nivel] --&gt;|depende| I[AuthRepository&lt;br/&gt;Abstracci\u00f3n]\n        B2[AuthRepositoryImpl&lt;br/&gt;Bajo Nivel] -.-&gt;|implementa| I\n        B2 --&gt;|depende| D[AppDatabase&lt;br/&gt;Detalle]\n    end\n\n    style A1 fill:#ff6b6b\n    style A2 fill:#6bcf7f\n    style I fill:#4d96ff</code></pre> <p>Observa: En el dise\u00f1o correcto, las flechas de dependencia apuntan hacia arriba (hacia las abstracciones), no hacia abajo (hacia los detalles).</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#05-contenedores-de-inyeccion-de-dependencias","title":"0.5. Contenedores de Inyecci\u00f3n de Dependencias","text":"<p>Hasta ahora hemos visto qu\u00e9 es DI, pero no c\u00f3mo gestionarla. Aqu\u00ed es donde entran los Contenedores de DI (tambi\u00e9n llamados IoC Containers).</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#que-es-un-contenedor-de-di","title":"\u00bfQu\u00e9 es un Contenedor de DI?","text":"<p>Un contenedor de DI es un \"almac\u00e9n inteligente\" que:</p> <ol> <li>Registra c\u00f3mo crear cada dependencia (configuraci\u00f3n)</li> <li>Resuelve las dependencias cuando alguien las solicita</li> <li>Gestiona el ciclo de vida (singleton, factory, scoped)</li> <li>Inyecta autom\u00e1ticamente en constructores</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#ejemplo-manual-vs-con-contenedor","title":"Ejemplo manual vs con Contenedor","text":"Sin Contenedor (Manual DI):Con Contenedor (Koin): <pre><code>// En cada Screen, creamos manualmente el \u00e1rbol de dependencias\n@Composable\nfun LoginScreen() {\n    val context = LocalContext.current\n    val database = MyGameStoreApp.database\n    val sessionManager = SessionManagerImpl(context)\n    val authRepository = AuthRepositoryImpl(database)\n    val viewModel = LoginViewModel(authRepository, sessionManager)\n\n    // ... UI ...\n}\n</code></pre> Problemas: <ul> <li>\ud83d\ude13 Repetitivo (cada Screen hace lo mismo)</li> <li>\ud83d\udc1b Propenso a errores (olvidar una dependencia)</li> <li>\ud83d\udd04 Dif\u00edcil cambiar implementaciones</li> </ul> <pre><code>// Configuraci\u00f3n \u00fanica en un m\u00f3dulo\nval appModule = module {\n    single { AppDatabase.getInstance(androidContext()) }\n    single&lt;SessionManager&gt; { SessionManagerImpl(androidContext()) }\n    single&lt;AuthRepository&gt; { AuthRepositoryImpl(get()) }\n    viewModel { LoginViewModel(get(), get()) }\n}\n\n// En la Screen, solo pedimos el ViewModel\n@Composable\nfun LoginScreen() {\n    val viewModel: LoginViewModel = koinViewModel()  // \u00a1Koin resuelve todo!\n\n    // ... UI ...\n}\n</code></pre> <p>Ventajas:</p> <ul> <li>\u2705 Configuraci\u00f3n centralizada</li> <li>\u2705 Resoluci\u00f3n autom\u00e1tica de dependencias</li> <li>\u2705 Gesti\u00f3n de ciclo de vida</li> <li>\u2705 F\u00e1cil cambiar implementaciones</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#06-contenedores-populares-en-el-ecosistema-android","title":"0.6. Contenedores populares en el ecosistema Android","text":"Caracter\u00edstica Koin Hilt Dagger 2 Paradigma Service Locator DI real DI real Compilaci\u00f3n Runtime Compile-time Compile-time Curva aprendizaje \u2b50 Baja \u2b50\u2b50 Media \u2b50\u2b50\u2b50 Alta Configuraci\u00f3n DSL Kotlin Anotaciones Anotaciones Velocidad compilaci\u00f3n R\u00e1pida Media Lenta Detecci\u00f3n de errores Runtime \u26a0\ufe0f Compilaci\u00f3n \u2705 Compilaci\u00f3n \u2705 Ideal para Apps medianas, aprendizaje Apps enterprise con ViewModel Apps enterprise grandes <p>Para este proyecto elegimos Koin porque:</p> <ol> <li>\ud83d\udcda Curva de aprendizaje suave (ideal para estudiantes)</li> <li>\ud83d\ude80 Configuraci\u00f3n r\u00e1pida (en minutos)</li> <li>\ud83c\udfaf DSL Kotlin nativo (m\u00e1s idiom\u00e1tico)</li> <li>\ud83d\udd27 Suficientemente potente para apps reales</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#07-ioc-y-di-en-clean-architecture","title":"0.7. IoC y DI en Clean Architecture","text":"<p>En nuestro proyecto seguimos Clean Architecture, donde la DI juega un papel fundamental para cumplir la Regla de Dependencia:</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#diagrama-de-capas-con-di","title":"Diagrama de capas con DI","text":"<pre><code>graph TB\n    subgraph \"Presentation Layer\"\n        UI[HomeScreen]\n        VM[HomeViewModel]\n    end\n\n    subgraph \"Domain Layer\"\n        UC[GameUseCases]\n        I[AuthRepository Interface]\n    end\n\n    subgraph \"Data Layer\"\n        REPO[AuthRepositoryImpl]\n        DB[AppDatabase]\n    end\n\n    UI --&gt;|observa| VM\n    VM --&gt;|usa| UC\n    UC --&gt;|usa| I\n    REPO -.-&gt;|implementa| I\n    REPO --&gt;|accede| DB\n\n    K[Koin Container]\n    K -.-&gt;|inyecta| VM\n    K -.-&gt;|inyecta| UC\n    K -.-&gt;|inyecta| REPO\n    K -.-&gt;|inyecta| DB\n\n    style UI fill:#4d96ff\n    style VM fill:#6bcf7f\n    style UC fill:#ffd93d\n    style I fill:#ff6b6b\n    style K fill:#a29bfe</code></pre> <p>Observa:</p> <ul> <li>Las flechas s\u00f3lidas (dependencias) siempre apuntan hacia abstracciones</li> <li>Koin (l\u00edneas punteadas) inyecta en todas las capas, sin violar las dependencias</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#08-beneficios-de-ioc-y-di-en-el-mundo-real","title":"0.8. Beneficios de IoC y DI en el Mundo Real","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#1-testing-mas-facil","title":"1. Testing m\u00e1s f\u00e1cil","text":"<pre><code>// Producci\u00f3n: Usa base de datos real\nval productionModule = module {\n    single&lt;AuthRepository&gt; { AuthRepositoryImpl(get()) }\n}\n\n// Testing: Usa mock\nval testModule = module {\n    single&lt;AuthRepository&gt; { FakeAuthRepository() }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#2-multiples-implementaciones-sin-cambiar-codigo","title":"2. M\u00faltiples implementaciones sin cambiar c\u00f3digo","text":"<pre><code>// Desarrollo local\nsingle&lt;AuthRepository&gt; { MockAuthRepositoryImpl() }\n\n// Producci\u00f3n con Firebase\nsingle&lt;AuthRepository&gt; { FirebaseAuthRepositoryImpl() }\n\n// \u00a1LoginViewModel no cambia en absoluto!\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#3-gestion-automatica-de-recursos","title":"3. Gesti\u00f3n autom\u00e1tica de recursos","text":"<pre><code>// Koin asegura una \u00fanica instancia de AppDatabase (singleton)\nsingle { AppDatabase.getInstance(androidContext()) }\n\n// Sin DI, podr\u00edas crear m\u00faltiples instancias accidentalmente \u2192 crash\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#1-como-usar-la-di-en-este-proyecto","title":"1. \u00bfC\u00f3mo usar la DI en este proyecto?","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#11-el-problema-actual","title":"1.1. El problema actual","text":"<p>Actualmente, nuestros ViewModels crean sus propias dependencias de forma manual:</p> <pre><code>// \u274c Acoplamiento directo - C\u00f3digo actual\nclass LoginViewModel(\n    context: Context,\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel()\n</code></pre> <p>Problemas de este enfoque:</p> <ol> <li>Acoplamiento fuerte: El ViewModel \"conoce\" la implementaci\u00f3n concreta (<code>AuthRepositoryImpl</code>)</li> <li>Dif\u00edcil de testear: No podemos inyectar un <code>FakeRepository</code> para pruebas</li> <li>Violaci\u00f3n de principios SOLID: Dependemos de implementaciones, no de abstracciones</li> <li>Dif\u00edcil de mantener: Cambiar la implementaci\u00f3n requiere modificar m\u00faltiples clases</li> <li>Gesti\u00f3n manual del ciclo de vida: Tenemos que crear y destruir instancias manualmente</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#12-la-solucion-inyeccion-de-dependencias","title":"1.2. La soluci\u00f3n: Inyecci\u00f3n de Dependencias","text":"<p>La Inyecci\u00f3n de Dependencias es un patr\u00f3n de dise\u00f1o donde las dependencias de una clase se \"inyectan\" desde el exterior en lugar de crearlas internamente.</p> <pre><code>// \u2705 Con DI - C\u00f3digo objetivo\nclass LoginViewModel(\n    private val authRepository: AuthRepository,  // Se inyecta\n    private val sessionManager: SessionManager   // Se inyecta\n) : ViewModel()\n</code></pre> <p>Ventajas:</p> <ul> <li>\u2705 Desacoplamiento: El ViewModel solo conoce las interfaces</li> <li>\u2705 Testeable: F\u00e1cil inyectar mocks o fakes</li> <li>\u2705 Flexible: Cambiar implementaciones en un solo lugar</li> <li>\u2705 Reutilizable: Las dependencias se comparten entre clases</li> <li>\u2705 Mantenible: C\u00f3digo m\u00e1s limpio y organizado</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#13-por-que-koin","title":"1.3. \u00bfPor qu\u00e9 Koin?","text":"<p>Existen varias librer\u00edas de DI para Android, pero Koin destaca por:</p> Caracter\u00edstica Koin Hilt/Dagger Manual Curva de aprendizaje \u2b50 Baja \u2b50\u2b50\u2b50 Alta \u2b50\u2b50 Media Configuraci\u00f3n \u2b50\u2b50\u2b50 M\u00ednima \u2b50 Compleja \u2b50\u2b50 Media DSL Kotlin \u2705 Nativo \u274c Java \u274c N/A Tiempo de compilaci\u00f3n \u2705 R\u00e1pido \u274c Lento \u2705 R\u00e1pido Detecci\u00f3n de errores \u26a0\ufe0f Runtime \u2705 Compilaci\u00f3n \u26a0\ufe0f Runtime Ideal para Apps medianas Apps enterprise Proyectos peque\u00f1os <p>Para este proyecto, Koin es perfecto porque:</p> <ul> <li>\ud83d\udcda Es f\u00e1cil de aprender para estudiantes</li> <li>\ud83d\ude80 Configuraci\u00f3n r\u00e1pida (minutos, no horas)</li> <li>\ud83c\udfaf Sintaxis Kotlin idiom\u00e1tica (DSL)</li> <li>\ud83d\udd27 Suficientemente potente para apps reales</li> </ul> <p>Recursos adicionales</p> <ul> <li>Documentaci\u00f3n oficial de Koin</li> <li>Koin vs Hilt: Comparativa t\u00e9cnica</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#14-conceptos-clave-de-di","title":"1.4. Conceptos clave de DI","text":"<p>Antes de empezar con la implementaci\u00f3n, es importante entender estos conceptos:</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#modulo-module","title":"M\u00f3dulo (Module)","text":"<p>Es un contenedor l\u00f3gico donde defines c\u00f3mo crear las dependencias.</p> <pre><code>val dataModule = module {\n    single&lt;AuthRepository&gt; { AuthRepositoryImpl() }\n    single&lt;SessionManager&gt; { SessionManagerImpl(androidContext()) }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#scope-ambito","title":"Scope (\u00c1mbito)","text":"<p>Define el ciclo de vida de una dependencia:</p> <ul> <li><code>single</code>: Singleton - Una sola instancia en toda la app</li> <li><code>factory</code>: Nueva instancia cada vez que se solicita</li> <li><code>viewModel</code>: Vinculada al ciclo de vida del ViewModel</li> </ul> <pre><code>module {\n    single { AppDatabase.getInstance(androidContext()) }  // Singleton\n    factory { MyRepository() }                            // Nueva instancia\n    viewModel { HomeViewModel(get()) }                    // Tied to ViewModel lifecycle\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#inyeccion-injection","title":"Inyecci\u00f3n (Injection)","text":"<p>El acto de obtener una dependencia del contenedor de Koin:</p> <pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository  // \u2190 Inyectada por Koin\n) : ViewModel()\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#resolucion-de-dependencias","title":"Resoluci\u00f3n de dependencias","text":"<p>Koin resuelve autom\u00e1ticamente las dependencias transitivas:</p> <pre><code>// LoginViewModel necesita AuthRepository\n// AuthRepository necesita AppDatabase\n// Koin crea AppDatabase \u2192 AuthRepository \u2192 LoginViewModel\nviewModel { LoginViewModel(get()) }  // get() obtiene AuthRepository\nsingle&lt;AuthRepository&gt; { AuthRepositoryImpl(get()) }  // get() obtiene AppDatabase\nsingle { AppDatabase.getInstance(androidContext()) }\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#15-flujo-de-di-con-koin","title":"1.5. Flujo de DI con Koin","text":"<pre><code>graph TD\n    A[App inicia] --&gt; B[Koin.init en Application]\n    B --&gt; C[Registra m\u00f3dulos]\n    C --&gt; D[M\u00f3dulos definen c\u00f3mo crear dependencias]\n\n    E[Screen necesita ViewModel] --&gt; F[Koin busca en m\u00f3dulos]\n    F --&gt; G{\u00bfDependencia existe?}\n    G --&gt;|S\u00ed| H[\u00bfYa fue creada?]\n    H --&gt;|S\u00ed - single| I[Devuelve instancia existente]\n    H --&gt;|No - factory| J[Crea nueva instancia]\n    H --&gt;|No - single| K[Crea y guarda instancia]\n    G --&gt;|No| L[Error: No definition found]\n\n    I --&gt; M[Inyecta en constructor]\n    J --&gt; M\n    K --&gt; M\n\n    style A fill:#ffd93d\n    style B fill:#6bcf7f\n    style C fill:#4d96ff\n    style M fill:#ff6b6b</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#2-configuracion-de-koin-en-el-proyecto","title":"2. Configuraci\u00f3n de Koin en el proyecto","text":"<p>Ahora que entendemos qu\u00e9 es DI y por qu\u00e9 usarla, vamos a configurar Koin en nuestro proyecto paso a paso.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#21-agregar-dependencias","title":"2.1. Agregar dependencias","text":"<p>Primero, a\u00f1adimos las librer\u00edas de Koin al proyecto.</p> <p>Paso 1: Abre <code>gradle/libs.versions.toml</code> y agrega la versi\u00f3n de Koin:</p> <pre><code>[versions]\n# ... otras versiones\nkoin = \"4.0.1\"\n</code></pre> <p>Paso 2: Agrega las librer\u00edas en la secci\u00f3n <code>[libraries]</code>:</p> <pre><code>[libraries]\n# ... otras librer\u00edas\n\n# Koin para Android\nkoin-android = { group = \"io.insert-koin\", name = \"koin-android\", version.ref = \"koin\" }\nkoin-androidx-compose = { group = \"io.insert-koin\", name = \"koin-androidx-compose\", version.ref = \"koin\" }\n</code></pre> <p>Paso 3: Abre <code>app/build.gradle.kts</code> y a\u00f1ade las dependencias:</p> <pre><code>dependencies {\n    // ... dependencias existentes\n\n    // Koin\n    implementation(libs.koin.android)\n    implementation(libs.koin.androidx.compose)\n}\n</code></pre> <p>Paso 4: Sincroniza el proyecto haciendo clic en \"Sync Now\".</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#22-crear-la-clase-application","title":"2.2. Crear la clase Application","text":"<p>Para inicializar Koin, necesitamos una clase que extienda <code>Application</code>. Esta clase se ejecuta antes que cualquier Activity o Screen.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/MyGameStoreApp.kt</code> (ya existe)</p> <pre><code>package com.pmdm.mygamestore\n\nimport android.app.Application\nimport androidx.room.Room\nimport com.pmdm.mygamestore.data.local.AppDatabase\nimport org.koin.android.ext.koin.androidContext\nimport org.koin.android.ext.koin.androidLogger\nimport org.koin.core.context.startKoin\nimport org.koin.core.logger.Level\n\nclass MyGameStoreApp : Application() {\n\n    companion object {\n        lateinit var database: AppDatabase\n            private set\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n\n        // Inicializar Room (ya existente)\n        database = Room.databaseBuilder(\n            applicationContext,\n            AppDatabase::class.java,\n            \"mygamestore_db\"\n        ).build()\n\n        // \ud83c\udd95 Inicializar Koin\n        startKoin {\n            // Logger de Koin para debugging\n            androidLogger(Level.ERROR)\n\n            // Contexto de Android\n            androidContext(this@MyGameStoreApp)\n\n            // M\u00f3dulos de dependencias (los crearemos en el siguiente punto)\n            modules(\n                // dataModule,\n                // domainModule,\n                // presentationModule\n            )\n        }\n    }\n}\n</code></pre> <p>No olvides registrar la clase Application</p> <p>Aseg\u00farate de que tu <code>AndroidManifest.xml</code> tenga registrada esta clase:</p> <pre><code>&lt;application\n        android:name=\".MyGameStoreApp\"\n        ...&gt;\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#23-conceptos-de-la-inicializacion-de-koin","title":"2.3. Conceptos de la inicializaci\u00f3n de Koin","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#startkoin","title":"startKoin { }","text":"<p>Es el punto de entrada de Koin. Se ejecuta una sola vez al iniciar la app.</p> <pre><code>startKoin {\n    androidLogger(Level.DEBUG)  // Logs para debugging\n    androidContext(this@MyApp)  // Contexto de Android\n    modules(myModule1, myModule2)  // M\u00f3dulos con dependencias\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#androidcontext","title":"androidContext()","text":"<p>Proporciona el <code>Context</code> de Android a Koin. Esto permite que las dependencias que necesiten <code>Context</code> puedan obtenerlo:</p> <pre><code>single&lt;SessionManager&gt; { \n    SessionManagerImpl(androidContext())  // \u2190 androidContext() da acceso al Context\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#androidlogger","title":"androidLogger()","text":"<p>Configura el nivel de logs de Koin:</p> <ul> <li><code>Level.DEBUG</code>: Muestra todos los logs (\u00fatil en desarrollo)</li> <li><code>Level.ERROR</code>: Solo errores (recomendado en producci\u00f3n)</li> <li><code>Level.NONE</code>: Sin logs</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#modules","title":"modules()","text":"<p>Lista de m\u00f3dulos donde defines las dependencias. Los veremos en detalle en el siguiente punto.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#24-verificacion-de-la-configuracion","title":"2.4. Verificaci\u00f3n de la configuraci\u00f3n","text":"<p>Para asegurarnos de que Koin est\u00e1 correctamente configurado, podemos crear un m\u00f3dulo de prueba temporal:</p> <p>Ubicaci\u00f3n temporal: <code>MyGameStoreApp.kt</code> (al final del archivo)</p> <pre><code>// \ud83e\uddea M\u00f3dulo de prueba temporal\nprivate val testModule = module {\n    single { \"Koin funciona correctamente!\" }\n}\n\n// En onCreate(), agregar:\nmodules(testModule)\n</code></pre> <p>Para verificar, en cualquier Activity o Composable:</p> <pre><code>@Composable\nfun TestKoinScreen() {\n    val message: String = get()  // Obtenemos el String del m\u00f3dulo\n    Text(text = message)  // Deber\u00eda mostrar \"Koin funciona correctamente!\"\n}\n</code></pre> <p>Si ves el mensaje, Koin est\u00e1 correctamente configurado. Ahora podemos eliminar este m\u00f3dulo de prueba y crear los m\u00f3dulos reales.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#25-comparacion-antes-vs-despues","title":"2.5. Comparaci\u00f3n: Antes vs Despu\u00e9s","text":"<pre><code>graph LR\n    subgraph \"\u2705 Despu\u00e9s (Con Koin)\"\n        A2[LoginScreen] --&gt;|solicita| F[Koin Container]\n        F --&gt;|inyecta| B2[LoginViewModel]\n        F --&gt;|inyecta| C2[AuthRepository]\n        F --&gt;|inyecta| D2[SessionManager]\n        F --&gt;|inyecta| E2[AppDatabase]\n    end\n\n    subgraph \"\u274c Antes (Sin DI)\"\n        A1[LoginScreen] --&gt;|crea| B1[LoginViewModel]\n        B1 --&gt;|crea| C1[AuthRepositoryImpl]\n        B1 --&gt;|crea| D1[SessionManagerImpl]\n        C1 --&gt;|crea| E1[AppDatabase]\n    end\n\n    style A1 fill:#ff6b6b\n    style A2 fill:#6bcf7f\n    style F fill:#4d96ff</code></pre> <p>Ventajas visibles:</p> <ol> <li>Centralizaci\u00f3n: Todo se gestiona desde <code>startKoin { }</code></li> <li>Reutilizaci\u00f3n: <code>AppDatabase</code> se crea una sola vez (singleton)</li> <li>Testeable: Podemos reemplazar m\u00f3dulos con mocks</li> <li>Mantenible: Cambiar implementaciones en un solo lugar</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#3-creacion-de-modulos-de-koin","title":"3. Creaci\u00f3n de m\u00f3dulos de Koin","text":"<p>Los m\u00f3dulos de Koin organizan las dependencias por capas arquitect\u00f3nicas. Cada m\u00f3dulo agrupa las responsabilidades de una capa espec\u00edfica.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#31-organizacion-de-modulos-por-capas","title":"3.1. Organizaci\u00f3n de m\u00f3dulos por capas","text":"<p>Siguiendo Clean Architecture, crearemos tres m\u00f3dulos:</p> <pre><code>di/\n\u251c\u2500 DataModule.kt       \u2192 Capa de Datos (Repositories, Database, SessionManager)\n\u251c\u2500 DomainModule.kt     \u2192 Capa de Dominio (UseCases)\n\u2514\u2500 PresentationModule.kt \u2192 Capa de Presentaci\u00f3n (ViewModels)\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#32-datamodule-capa-de-datos","title":"3.2. DataModule - Capa de Datos","text":"<p>Este m\u00f3dulo gestiona el acceso a datos: repositories, base de datos y managers.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/di/DataModule.kt</code></p> <pre><code>package com.pmdm.mygamestore.di\n\nimport com.pmdm.mygamestore.MyGameStoreApp\nimport com.pmdm.mygamestore.data.repository.*\nimport org.koin.android.ext.koin.androidContext\nimport org.koin.core.module.dsl.singleOf\nimport org.koin.dsl.bind\nimport org.koin.dsl.module\n\nval dataModule = module {\n\n    // Database (Singleton - ya existe en MyGameStoreApp)\n    single { MyGameStoreApp.database }\n\n    // SessionManager (Singleton con binding autom\u00e1tico)\n    singleOf(::SessionManagerImpl) bind SessionManager::class\n\n    // AuthRepository (Singleton con binding autom\u00e1tico)\n    singleOf(::AuthRepositoryImpl) bind AuthRepository::class\n\n    // GamesRepository (Singleton con binding autom\u00e1tico)\n    singleOf(::MockGamesRepositoryImpl) bind GamesRepository::class\n}\n</code></pre> <p>Conceptos clave:</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#singleof-con-bind","title":"singleOf con bind","text":"<p>La sintaxis moderna de Koin 4.x utiliza <code>singleOf</code> con <code>bind</code> para simplificar el c\u00f3digo:</p> <pre><code>// \u274c Sintaxis antigua (verbose)\nsingle&lt;SessionManager&gt; { SessionManagerImpl(androidContext()) }\n\n// \u2705 Sintaxis moderna (concisa)\nsingleOf(::SessionManagerImpl) bind SessionManager::class\n</code></pre> <p>Ventajas:</p> <ul> <li>\u2705 Menos c\u00f3digo boilerplate</li> <li>\u2705 Type-safe (errores en compilaci\u00f3n)</li> <li>\u2705 Constructor injection autom\u00e1tico</li> <li>\u2705 <code>bind</code> asocia la implementaci\u00f3n con la interfaz</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#33-domainmodule-capa-de-dominio","title":"3.3. DomainModule - Capa de Dominio","text":"<p>Este m\u00f3dulo contiene los casos de uso (UseCases) con la l\u00f3gica de negocio.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/di/DomainModule.kt</code></p> <pre><code>package com.pmdm.mygamestore.di\n\nimport com.pmdm.mygamestore.domain.usecase.GameUseCases\nimport org.koin.core.module.dsl.factoryOf\nimport org.koin.dsl.module\n\nval domainModule = module {\n\n    // GameUseCases (Factory - nueva instancia cada vez)\n    factoryOf(::GameUseCases)\n}\n</code></pre> <p>\u00bfPor qu\u00e9 <code>factory</code> en lugar de <code>single</code>?</p> <p>Los UseCases suelen ser stateless (sin estado interno), por lo que no necesitamos compartir instancias:</p> <pre><code>// \u2705 Factory: Nueva instancia cada vez (ligero)\nfactoryOf(::GameUseCases)\n\n// \u274c Single: Compartir instancia (innecesario para UseCases)\nsingleOf(::GameUseCases)\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#34-presentationmodule-capa-de-presentacion","title":"3.4. PresentationModule - Capa de Presentaci\u00f3n","text":"<p>Este m\u00f3dulo gestiona los ViewModels vinculados al ciclo de vida de las pantallas.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/di/PresentationModule.kt</code></p> <pre><code>package com.pmdm.mygamestore.di\n\nimport com.pmdm.mygamestore.presentation.viewmodel.DetailViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.HomeViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.LibraryViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.LoginViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.RegisterViewModel\nimport com.pmdm.mygamestore.presentation.viewmodel.SplashViewModel\nimport org.koin.core.module.dsl.viewModelOf\nimport org.koin.dsl.module\n\nval presentationModule = module {\n\n    // ViewModels con ciclo de vida autom\u00e1tico\n    viewModelOf(::SplashViewModel)\n    viewModelOf(::LoginViewModel)\n    viewModelOf(::RegisterViewModel)\n    viewModelOf(::HomeViewModel)\n    viewModelOf(::DetailViewModel)  // Acepta par\u00e1metros din\u00e1micos\n    viewModelOf(::LibraryViewModel)\n}\n</code></pre> <p>Conceptos clave:</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#viewmodelof","title":"viewModelOf","text":"<p>La funci\u00f3n <code>viewModelOf</code> simplifica la declaraci\u00f3n de ViewModels:</p> <pre><code>// \u274c Sintaxis antigua\nviewModel { HomeViewModel(get(), get()) }\n\n// \u2705 Sintaxis moderna\nviewModelOf(::HomeViewModel)\n</code></pre> <p>Koin resuelve autom\u00e1ticamente los par\u00e1metros del constructor usando <code>get()</code> interno.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#35-registrar-los-modulos-en-mygamestoreapp","title":"3.5. Registrar los m\u00f3dulos en MyGameStoreApp","text":"<p>Ahora conectamos los m\u00f3dulos al inicializar Koin:</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/MyGameStoreApp.kt</code></p> <pre><code>import com.pmdm.mygamestore.di.dataModule\nimport com.pmdm.mygamestore.di.domainModule\nimport com.pmdm.mygamestore.di.presentationModule\n\nclass MyGameStoreApp : Application() {\n\n    override fun onCreate() {\n        super.onCreate()\n\n        // Inicializar Room...\n\n        // Inicializar Koin\n        startKoin {\n            androidLogger(Level.ERROR)\n            androidContext(this@MyGameStoreApp)\n\n            // \ud83d\udc47 M\u00f3dulos organizados por capas\n            modules(\n                dataModule,\n                domainModule,\n                presentationModule\n            )\n        }\n    }\n}\n</code></pre> <p>\u2705 Resumen del Punto 3</p> <p>Has creado los tres m\u00f3dulos fundamentales:</p> <ol> <li>\u2705 DataModule: Repositories, Database, SessionManager</li> <li>\u2705 DomainModule: GameUseCases</li> <li>\u2705 PresentationModule: Todos los ViewModels</li> <li>\u2705 Sintaxis moderna: <code>singleOf</code>, <code>factoryOf</code>, <code>viewModelOf</code></li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#4-refactorizacion-de-viewmodels-y-screens","title":"4. Refactorizaci\u00f3n de ViewModels y Screens","text":"<p>Con los m\u00f3dulos configurados, ahora refactorizamos el c\u00f3digo para usar Koin.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#41-refactorizar-viewmodels","title":"4.1. Refactorizar ViewModels","text":"<p>Los ViewModels ya no crean sus dependencias, solo las declaran en el constructor.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#ejemplo-loginviewmodel","title":"Ejemplo: LoginViewModel","text":"<p>Antes (con valores por defecto): </p><pre><code>class LoginViewModel(\n    context: Context,\n    private val authRepository: AuthRepository = AuthRepositoryImpl(),\n    private val sessionManager: SessionManager = SessionManagerImpl(context)\n) : ViewModel()\n</code></pre><p></p> <p>Despu\u00e9s (solo declaraci\u00f3n): </p><pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository,\n    private val sessionManager: SessionManager\n) : ViewModel()\n</code></pre><p></p> <p>Cambios aplicados:</p> <ul> <li>\u274c Eliminado <code>context: Context</code> (ya no se necesita)</li> <li>\u274c Eliminados valores por defecto (<code>= AuthRepositoryImpl()</code>)</li> <li>\u2705 Solo declaraci\u00f3n de interfaces</li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#42-eliminar-viewmodelfactories","title":"4.2. Eliminar ViewModelFactories","text":"<p>Las factories ya no son necesarias porque Koin gestiona la creaci\u00f3n:</p> <p>Archivos eliminados: </p><pre><code>presentation/viewmodel/\n\u251c\u2500 LoginViewModelFactory.kt       \u274c Eliminado\n\u251c\u2500 RegisterViewModelFactory.kt    \u274c Eliminado\n\u251c\u2500 SplashViewModelFactory.kt      \u274c Eliminado\n\u251c\u2500 HomeViewModelFactory.kt        \u274c Eliminado\n\u251c\u2500 LibraryViewModelFactory.kt     \u274c Eliminado\n\u2514\u2500 DetailViewModelFactory.kt      \u274c Eliminado\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#43-actualizar-screens-para-usar-koinviewmodel","title":"4.3. Actualizar Screens para usar koinViewModel()","text":"<p>Las Screens ahora obtienen los ViewModels directamente desde Koin.</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#ejemplo-loginscreen","title":"Ejemplo: LoginScreen","text":"<p>Antes: </p><pre><code>@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = viewModel(\n        factory = LoginViewModelFactory(LocalContext.current)\n    ),\n    // ...\n)\n</code></pre><p></p> <p>Despu\u00e9s: </p><pre><code>import org.koin.androidx.compose.koinViewModel\n\n@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = koinViewModel(),\n    // ...\n)\n</code></pre><p></p> <p>Cambios:</p> <ul> <li>\u274c Eliminado <code>LocalContext.current</code></li> <li>\u274c Eliminado <code>factory = LoginViewModelFactory(...)</code></li> <li>\u2705 Simplificado a <code>koinViewModel()</code></li> </ul>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#caso-especial-detailviewmodel-con-parametros","title":"Caso especial: DetailViewModel con par\u00e1metros","text":"<p>DetailViewModel necesita <code>gameId</code> din\u00e1mico, que se pasa desde la navegaci\u00f3n:</p> <p>Ubicaci\u00f3n: <code>presentation/ui/screens/DetailScreen.kt</code></p> <pre><code>import org.koin.androidx.compose.koinViewModel\nimport org.koin.core.parameter.parametersOf\n\n@Composable\nfun DetailScreen(\n    gameId: Int,\n    onBack: () -&gt; Unit\n) {\n    // ViewModel con par\u00e1metro din\u00e1mico\n    val viewModel: DetailViewModel = koinViewModel(\n        key = \"DetailViewModel_$gameId\"  // Key \u00fanica para cada juego\n    ) {\n        parametersOf(gameId)  // Pasar gameId como par\u00e1metro\n    }\n\n    // ... resto del c\u00f3digo\n}\n</code></pre> <p>Conceptos clave:</p> <ul> <li><code>key</code>: Fuerza a Koin a crear un nuevo ViewModel si el <code>gameId</code> cambia</li> <li><code>parametersOf(gameId)</code>: Pasa el par\u00e1metro al constructor del ViewModel</li> </ul> <p>\u2705 Resumen del Punto 4</p> <p>Has refactorizado completamente el c\u00f3digo:</p> <ol> <li>\u2705 ViewModels sin valores por defecto</li> <li>\u2705 ViewModelFactories eliminadas (6 archivos)</li> <li>\u2705 Screens usando <code>koinViewModel()</code></li> <li>\u2705 Par\u00e1metros din\u00e1micos con <code>parametersOf()</code></li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#5-ventajas-y-buenas-practicas","title":"5. Ventajas y Buenas Pr\u00e1cticas","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#51-ventajas-alcanzadas","title":"5.1. Ventajas alcanzadas","text":"<p>Con Koin implementado, nuestra aplicaci\u00f3n ahora tiene:</p>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#1-desacoplamiento-total","title":"1. Desacoplamiento total","text":"<pre><code>// ViewModel no sabe QU\u00c9 implementaci\u00f3n usa\nclass LoginViewModel(\n    private val authRepository: AuthRepository  // Interfaz, no implementaci\u00f3n\n)\n\n// Cambiar de Mock a Firebase: Solo editar DataModule\nsingleOf(::FirebaseAuthRepositoryImpl) bind AuthRepository::class\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#2-testing-simplificado","title":"2. Testing simplificado","text":"<pre><code>// M\u00f3dulo de prueba\nval testModule = module {\n    singleOf(::FakeAuthRepository) bind AuthRepository::class\n}\n\n// En test, reemplazar m\u00f3dulos\nstartKoin {\n    modules(testModule)  // Usa fakes en lugar de implementaciones reales\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#3-configuracion-centralizada","title":"3. Configuraci\u00f3n centralizada","text":"<p>Cambiar de entorno (dev, staging, prod) en un solo lugar:</p> <pre><code>val dataModule = module {\n    single&lt;GamesRepository&gt; {\n        if (BuildConfig.DEBUG) {\n            MockGamesRepositoryImpl()  // Mock en desarrollo\n        } else {\n            FirebaseGamesRepositoryImpl()  // Firebase en producci\u00f3n\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#52-buenas-practicas-con-koin","title":"5.2. Buenas Pr\u00e1cticas con Koin","text":""},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#1-organizar-modulos-por-feature-opcional","title":"1. Organizar m\u00f3dulos por feature (opcional)","text":"<p>Para apps grandes, organizar por funcionalidad:</p> <pre><code>// di/features/\n\u251c\u2500 AuthModule.kt      \u2192 Login, Register, Session\n\u251c\u2500 GamesModule.kt     \u2192 Games, Library, Detail\n\u2514\u2500 ProfileModule.kt   \u2192 Profile, Settings\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#2-logs-en-desarrollo","title":"2. Logs en desarrollo","text":"<p>Configurar logs seg\u00fan el entorno:</p> <pre><code>startKoin {\n    androidLogger(\n        if (BuildConfig.DEBUG) Level.DEBUG else Level.ERROR\n    )\n    // ...\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#53-preparacion-para-firebase","title":"5.3. Preparaci\u00f3n para Firebase","text":"<p>Con Koin implementado, integrar Firebase ser\u00e1 trivial:</p> <p>Paso 1: Crear <code>FirebaseAuthRepositoryImpl</code></p> <pre><code>class FirebaseAuthRepositoryImpl(\n    private val auth: FirebaseAuth\n) : AuthRepository {\n    override suspend fun login(username: String, password: String): LoginResult {\n        // Implementaci\u00f3n con Firebase\n    }\n}\n</code></pre> <p>Paso 2: Actualizar <code>DataModule</code></p> <pre><code>val dataModule = module {\n    // Firebase Auth\n    single { Firebase.auth }\n\n    // Cambiar implementaci\u00f3n (\u00a1sin tocar ViewModels!)\n    singleOf(::FirebaseAuthRepositoryImpl) bind AuthRepository::class\n}\n</code></pre> <p>\u00a1Listo! Los ViewModels seguir\u00e1n funcionando sin modificaciones.</p> <p>\u2705 Resumen del Punto 5</p> <ol> <li>\u2705 Desacoplamiento: Cambiar implementaciones sin tocar ViewModels</li> <li>\u2705 Testing: Inyectar fakes f\u00e1cilmente</li> <li>\u2705 Configuraci\u00f3n centralizada: Un solo lugar para cambios</li> <li>\u2705 Preparado para Firebase: Migraci\u00f3n sin dolor</li> </ol>"},{"location":"temas/proyectos/GameVault/09-DI-Koin.html#conclusion-del-capitulo-9","title":"\u2705 Conclusi\u00f3n del Cap\u00edtulo 9","text":"<p>Has completado exitosamente la implementaci\u00f3n de Inyecci\u00f3n de Dependencias con Koin:</p> <ol> <li>\u2705 Configuraci\u00f3n de Koin en el proyecto</li> <li>\u2705 Creaci\u00f3n de m\u00f3dulos organizados por capas</li> <li>\u2705 Refactorizaci\u00f3n completa de ViewModels</li> <li>\u2705 Eliminaci\u00f3n de Factories manuales</li> <li>\u2705 Screens simplificadas con <code>koinViewModel()</code></li> <li>\u2705 Arquitectura preparada para Firebase</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html","title":"10. Autenticaci\u00f3n con Firebase","text":""},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#10-autenticacion-con-firebase","title":"10. Autenticaci\u00f3n con Firebase","text":"<p>En esta 10\u00aa parte del proyecto, integraremos Firebase Authentication en nuestra aplicaci\u00f3n. Gracias a la arquitectura de Inyecci\u00f3n de Dependencias que implementamos en el cap\u00edtulo anterior, este cambio ser\u00e1 transparente para nuestros ViewModels y UI. Aprenderemos a configurar Firebase, implementar autenticaci\u00f3n con email/password y agregar autenticaci\u00f3n con Google como proveedor OAuth.</p> <p>Repositorio de la Aplicaci\u00f3n</p> <p>El c\u00f3digo fuente de la aplicaci\u00f3n se encuentra en el repositorio de GitHub: MyGameStore</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#resumen","title":"Resumen","text":"<ol> <li>Introducci\u00f3n a Firebase</li> <li>Configuraci\u00f3n de Firebase en el proyecto</li> <li>Autenticaci\u00f3n: Conceptos y pr\u00e1ctica</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#1-introduccion-a-firebase","title":"1. Introducci\u00f3n a Firebase","text":""},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#11-que-es-firebase","title":"1.1. \u00bfQu\u00e9 es Firebase?","text":"<p>Firebase es una plataforma BaaS (Backend as a Service) desarrollada por Google que proporciona un conjunto completo de herramientas y servicios para desarrollar aplicaciones m\u00f3viles y web sin necesidad de gestionar infraestructura de servidor.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#analogia-del-restaurante","title":"Analog\u00eda del restaurante","text":"<p>Imagina que est\u00e1s montando un restaurante:</p> <p>Sin Firebase (Backend tradicional): </p><pre><code>T\u00fa debes:\n\u251c\u2500 Comprar y configurar servidores f\u00edsicos\n\u251c\u2500 Instalar y mantener bases de datos\n\u251c\u2500 Configurar sistemas de autenticaci\u00f3n\n\u251c\u2500 Implementar APIs REST\n\u251c\u2500 Gestionar escalabilidad\n\u251c\u2500 Monitorear logs y errores\n\u2514\u2500 Configurar backups y seguridad\n</code></pre><p></p> <p>Con Firebase: </p><pre><code>Firebase proporciona:\n\u251c\u2500 Servidores en la nube (gestionados por Google)\n\u251c\u2500 Base de datos lista para usar\n\u251c\u2500 Sistema de autenticaci\u00f3n completo\n\u251c\u2500 APIs autom\u00e1ticas\n\u251c\u2500 Escalabilidad autom\u00e1tica\n\u251c\u2500 Monitoreo integrado\n\u2514\u2500 Backups autom\u00e1ticos\n</code></pre><p></p> <p>T\u00fa solo te enfocas en cocinar (desarrollar tu app), no en gestionar el local (infraestructura).</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#12-servicios-principales-de-firebase-para-android","title":"1.2. Servicios principales de Firebase para Android","text":"<p>Firebase ofrece m\u00e1s de 20 servicios. Aqu\u00ed est\u00e1n los m\u00e1s relevantes para desarrollo Android:</p> \ud83d\udd10 Servicios Core (Infraestructura)\ud83d\udcca Servicios de Crecimiento\ud83e\uddea Servicios de Calidad <p>1. Firebase Authentication</p> <ul> <li>Sistema completo de gesti\u00f3n de usuarios</li> <li>M\u00faltiples proveedores: Email, Google, Facebook, Twitter, GitHub</li> <li>Gesti\u00f3n de sesiones y tokens JWT</li> <li>Ideal para: Login, registro, recuperaci\u00f3n de contrase\u00f1a</li> </ul> <p>2. Cloud Firestore</p> <ul> <li>Base de datos NoSQL en tiempo real</li> <li>Sincronizaci\u00f3n autom\u00e1tica entre dispositivos</li> <li>Consultas potentes y escalables</li> <li>Ideal para: Datos estructurados (usuarios, posts, productos)</li> </ul> <p>3. Realtime Database</p> <ul> <li>Base de datos NoSQL en tiempo real (versi\u00f3n legacy)</li> <li>Menor funcionalidad que Firestore</li> <li>Sincronizaci\u00f3n ultra-r\u00e1pida</li> <li>Ideal para: Chat en tiempo real, presencia de usuarios</li> </ul> <p>4. Cloud Storage</p> <ul> <li>Almacenamiento de archivos (im\u00e1genes, videos, PDFs)</li> <li>CDN integrado para acceso r\u00e1pido</li> <li>Gesti\u00f3n de permisos por usuario</li> <li>Ideal para: Avatares, fotos de productos, documentos</li> </ul> <p>5. Cloud Messaging (FCM)</p> <ul> <li>Notificaciones push a dispositivos</li> <li>Segmentaci\u00f3n de usuarios</li> <li>Programaci\u00f3n de mensajes</li> <li>Ideal para: Notificaciones de nuevos contenidos, ofertas</li> </ul> <p>6. Analytics - An\u00e1lisis de comportamiento de usuarios - Eventos personalizados - Integraci\u00f3n con Google Ads - Ideal para: Medir conversiones, retenci\u00f3n de usuarios</p> <p>7. Crashlytics - Reportes autom\u00e1ticos de crashes - Stack traces detallados - Priorizaci\u00f3n de errores por impacto - Ideal para: Debugging en producci\u00f3n</p> <p>8. Remote Config - Configuraci\u00f3n din\u00e1mica sin actualizar la app - A/B testing - Personalizaci\u00f3n por segmentos - Ideal para: Feature flags, mensajes promocionales</p> <p>9. Performance Monitoring</p> <ul> <li>M\u00e9tricas de rendimiento de la app</li> <li>Detecci\u00f3n de ANRs (Application Not Responding)</li> <li>Tiempos de carga de pantallas</li> <li>Ideal para: Optimizar velocidad de la app</li> </ul> <p>10. Test Lab - Testing automatizado en dispositivos reales - Ejecuci\u00f3n en la nube - Screenshots autom\u00e1ticos - Ideal para: Testing antes de lanzamientos</p> <p>11. App Distribution - Distribuci\u00f3n de versiones beta - Invitaciones a testers - Feedback integrado - Ideal para: Testing con usuarios reales</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#13-por-que-usar-firebase-authentication","title":"1.3. \u00bfPor qu\u00e9 usar Firebase Authentication?","text":"<p>Firebase Authentication destaca por varias razones clave:</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#1-sin-backend-propio","title":"1. Sin backend propio","text":"<pre><code>graph LR\n    subgraph \"\u274c Backend tradicional\"\n        A1[App Android] --&gt;|API REST| B1[Tu servidor]\n        B1 --&gt;|SQL| C1[Tu BD]\n        B1 --&gt;|Gestionar| D1[Sesiones]\n        B1 --&gt;|Implementar| E1[Seguridad]\n    end\n\n    subgraph \"\u2705 Firebase Auth\"\n        A2[App Android] --&gt;|SDK| F[Firebase]\n        F --&gt;|Autom\u00e1tico| G[Todo gestionado]\n    end\n\n    style A1 fill:#ff6b6b\n    style B1 fill:#ff6b6b\n    style A2 fill:#6bcf7f\n    style F fill:#4d96ff</code></pre> <p>Ahorro de tiempo:</p> <ul> <li>\u274c Sin Firebase: Semanas implementando autenticaci\u00f3n segura</li> <li>\u2705 Con Firebase: Minutos integrando el SDK</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#2-multiples-proveedores-listos-para-usar","title":"2. M\u00faltiples proveedores listos para usar","text":"<p>Firebase soporta m\u00e1s de 10 proveedores de autenticaci\u00f3n:</p> Proveedor Tipo Configuraci\u00f3n Email/Password Tradicional \u2b50 Simple Google OAuth \u2b50 Simple Facebook OAuth \u2b50\u2b50 Media Twitter OAuth \u2b50\u2b50 Media GitHub OAuth \u2b50\u2b50 Media Apple OAuth \u2b50\u2b50\u2b50 Compleja (iOS) Microsoft OAuth \u2b50\u2b50 Media Tel\u00e9fono SMS \u2b50\u2b50 Media An\u00f3nima Temporal \u2b50 Muy simple Personalizada Tokens propios \u2b50\u2b50\u2b50 Avanzada <p>En este proyecto usaremos:</p> <ul> <li>\u2705 Email/Password (autenticaci\u00f3n b\u00e1sica)</li> <li>\u2705 Google (OAuth para mejor UX)</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#3-seguridad-robusta","title":"3. Seguridad robusta","text":"<p>Firebase maneja toda la seguridad por ti:</p> <ul> <li>Tokens JWT: Autenticaci\u00f3n basada en tokens seguros</li> <li>Sesiones persistentes: El usuario sigue logueado tras cerrar la app</li> <li>Renovaci\u00f3n autom\u00e1tica: Tokens se renuevan sin intervenci\u00f3n</li> <li>Protecci\u00f3n contra ataques: Rate limiting, protecci\u00f3n CSRF</li> </ul> <pre><code>// Firebase gestiona autom\u00e1ticamente:\n// - Encriptaci\u00f3n de contrase\u00f1as (bcrypt)\n// - Generaci\u00f3n de tokens JWT\n// - Renovaci\u00f3n de sesiones\n// - Revocaci\u00f3n de tokens\n\n// T\u00fa solo haces:\nfirebaseAuth.signInWithEmailAndPassword(email, password)\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#4-escalabilidad-automatica","title":"4. Escalabilidad autom\u00e1tica","text":"Aspecto Firebase Backend propio Usuarios concurrentes Millones Depende de tu servidor Gesti\u00f3n de carga Autom\u00e1tica Manual (load balancers) Costos iniciales $0 Servidor + BD + DevOps Mantenimiento $0 (tiempo) Horas/semana <p>Plan gratuito de Firebase Auth:</p> <ul> <li>\u2705 Autenticaci\u00f3n ilimitada de usuarios</li> <li>\u2705 10,000 verificaciones de tel\u00e9fono/mes</li> <li>\u2705 Todos los proveedores incluidos</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#5-integracion-con-otros-servicios-de-firebase","title":"5. Integraci\u00f3n con otros servicios de Firebase","text":"<p>Una vez autenticado, el usuario tiene acceso controlado a:</p> <pre><code>// El mismo FirebaseUser se usa en todos los servicios\nval user = FirebaseAuth.getInstance().currentUser\n\n// Firestore: Reglas de seguridad por usuario\nfirestore.collection(\"games\")\n    .whereEqualTo(\"userId\", user.uid)  // Solo sus datos\n\n// Storage: Permisos por usuario\nstorage.reference(\"avatars/${user.uid}/profile.jpg\")\n\n// Realtime Database: Acceso controlado\ndatabase.reference(\"users/${user.uid}\")\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#6-experiencia-de-usuario-mejorada","title":"6. Experiencia de usuario mejorada","text":"<p>Funcionalidades incluidas sin c\u00f3digo adicional:</p> <ul> <li>\ud83d\udd10 Recuperaci\u00f3n de contrase\u00f1a: Email autom\u00e1tico</li> <li>\u2709\ufe0f Verificaci\u00f3n de email: Link de confirmaci\u00f3n</li> <li>\ud83d\udd04 Cambio de contrase\u00f1a: Flujo seguro</li> <li>\ud83d\udeaa Logout en todos los dispositivos: Revocaci\u00f3n de tokens</li> <li>\ud83d\udcf1 Detecci\u00f3n de cuenta existente: Evita duplicados</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#15-arquitectura-de-firebase-authentication","title":"1.5. Arquitectura de Firebase Authentication","text":"<pre><code>graph TB\n    subgraph \"App Android\"\n        A[LoginScreen]\n        B[LoginViewModel]\n        C[FirebaseAuthRepository]\n    end\n\n    subgraph \"Firebase SDK\"\n        D[FirebaseAuth]\n    end\n\n    subgraph \"Firebase Cloud\"\n        E[Authentication Service]\n        F[User Database]\n        G[Token Generator]\n    end\n\n    A --&gt;|Eventos UI| B\n    B --&gt;|Llama| C\n    C --&gt;|SDK| D\n    D --&gt;|HTTPS| E\n    E --&gt;|Valida| F\n    E --&gt;|Genera| G\n    G --&gt;|JWT Token| D\n    D --&gt;|FirebaseUser| C\n    C --&gt;|LoginResult| B\n    B --&gt;|UiState| A\n\n    style A fill:#4d96ff\n    style E fill:#ff6b6b\n    style G fill:#6bcf7f</code></pre> <p>Flujo simplificado:</p> <ol> <li>Usuario ingresa credenciales en la UI</li> <li>ViewModel llama al Repository</li> <li>Repository usa Firebase SDK</li> <li>SDK env\u00eda credenciales a Firebase Cloud (HTTPS)</li> <li>Firebase valida y genera token JWT</li> <li>Token se almacena autom\u00e1ticamente en el dispositivo</li> <li>Repository devuelve <code>LoginResult.Success</code></li> <li>ViewModel actualiza el estado de la UI</li> </ol> <p>Perfecto, contin\u00fao con el Punto 2: Configuraci\u00f3n de Firebase en el proyecto.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#2-configuracion-de-firebase-en-el-proyecto","title":"2. Configuraci\u00f3n de Firebase en el proyecto","text":"<p>En esta secci\u00f3n aprender\u00e1s a conectar tu proyecto Android con Firebase desde cero. El proceso incluye crear el proyecto en Firebase Console, descargar la configuraci\u00f3n y agregar las dependencias necesarias usando el BoM (Bill of Materials).</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#21-requisitos-previos","title":"2.1. Requisitos previos","text":"<p>Antes de empezar, aseg\u00farate de tener:</p> <ul> <li>\u2705 Cuenta de Google (Gmail)</li> <li>\u2705 Proyecto Android funcional en Android Studio</li> <li>\u2705 Package name del proyecto (en nuestro caso: <code>com.pmdm.mygamestore</code>)</li> <li>\u2705 Conexi\u00f3n a Internet para acceder a Firebase Console</li> </ul> <p>Verificar el package name</p> <p>El package name est\u00e1 en <code>app/build.gradle.kts</code>: </p><pre><code>android {\n        namespace = \"com.pmdm.mygamestore\"\n        // ...\n    }\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#22-crear-proyecto-en-firebase-console","title":"2.2. Crear proyecto en Firebase Console","text":""},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-1-acceder-a-firebase-console","title":"Paso 1: Acceder a Firebase Console","text":"<ol> <li>Abre tu navegador y ve a Firebase Console</li> <li>Inicia sesi\u00f3n con tu cuenta de Google</li> <li>Ver\u00e1s el dashboard de Firebase</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-2-crear-nuevo-proyecto","title":"Paso 2: Crear nuevo proyecto","text":"<ol> <li>Haz click en \"Agregar proyecto\" o \"Create a project\"</li> <li>Nombre del proyecto: Escribe el nombre de tu app</li> </ol> <ul> <li>Este nombre es solo para identificar el proyecto en Firebase</li> <li>No tiene que coincidir con el nombre de tu app 3. Click en \"Continuar\"</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-3-configurar-google-analytics-opcional","title":"Paso 3: Configurar Google Analytics (Opcional)","text":"<ol> <li>Firebase preguntar\u00e1 si quieres habilitar Google Analytics</li> <li>Recomendaci\u00f3n para aprendizaje: Desactivar (puedes activarlo despu\u00e9s)</li> <li>Click en \"Crear proyecto\"</li> </ol> <p>Google Analytics</p> <p>Analytics es \u00fatil en producci\u00f3n para medir usuarios, eventos y conversiones. Para desarrollo y aprendizaje, puedes desactivarlo inicialmente.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-4-esperar-a-que-se-cree-el-proyecto","title":"Paso 4: Esperar a que se cree el proyecto","text":"<p>Firebase tardar\u00e1 unos 30-60 segundos en:</p> <ul> <li>Crear la infraestructura</li> <li>Provisionar servicios</li> <li>Configurar reglas de seguridad por defecto</li> </ul> <p>Cuando termine, ver\u00e1s: \"Tu nuevo proyecto est\u00e1 listo\"</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-5-agregar-aplicacion-android","title":"Paso 5: Agregar aplicaci\u00f3n Android","text":"<ol> <li>En el dashboard de Firebase, ver\u00e1s varios \u00edconos: iOS, Android, Web, etc.</li> <li>Click en el \u00edcono de Android </li> <li>Completa el formulario:</li> </ol> <p>a) Package name (Obligatorio): </p><pre><code>com.pmdm.mygamestore\n</code></pre><p></p> <p>\u26a0\ufe0f Importante: Debe coincidir exactamente con el <code>namespace</code> de tu <code>build.gradle.kts</code></p> <p>b) App nickname (Opcional): </p><pre><code>MyGameStore Android\n</code></pre><p></p> <p>Solo para identificar la app si tienes m\u00faltiples (Android, iOS, Web)</p> <p>c) SHA-1 Debug certificate (Opcional por ahora):</p> <ul> <li>D\u00e9jalo vac\u00edo por ahora</li> <li>Lo necesitaremos m\u00e1s adelante para Google Sign-In</li> <li>Explicaremos c\u00f3mo obtenerlo en la secci\u00f3n 3.4</li> </ul> <ol> <li>Click en \"Registrar app\"</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#23-descargar-google-servicesjson","title":"2.3. Descargar google-services.json","text":"<p>Despu\u00e9s de registrar la app, Firebase te mostrar\u00e1 una pantalla con un archivo JSON.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#que-es-google-servicesjson","title":"\u00bfQu\u00e9 es google-services.json?","text":"<p>Es el archivo de configuraci\u00f3n que conecta tu app con Firebase. Contiene:</p> <pre><code>{\n  \"project_info\": {\n    \"project_number\": \"123456789\",\n    \"project_id\": \"mygamestore-abc123\",\n    \"storage_bucket\": \"mygamestore-abc123.appspot.com\"\n  },\n  \"client\": [\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:123456789:android:abc123\",\n        \"android_client_info\": {\n          \"package_name\": \"com.pmdm.mygamestore\"\n        }\n      },\n      \"api_key\": [\n        {\n          \"current_key\": \"AIzaSyXXXXXXXXXXXXXXXXXXXXXXXX\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>Campos importantes:</p> Campo Descripci\u00f3n <code>project_id</code> ID \u00fanico del proyecto Firebase <code>mobilesdk_app_id</code> ID \u00fanico de tu app Android <code>package_name</code> Package de tu app (validaci\u00f3n) <code>api_key</code> Clave de API para comunicarse con Firebase"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#descargar-el-archivo","title":"Descargar el archivo","text":"<ol> <li>Click en \"Descargar google-services.json\"</li> <li>Guarda el archivo (normalmente va a <code>Descargas</code>)</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#ubicar-el-archivo-en-el-proyecto","title":"Ubicar el archivo en el proyecto","text":"<p>Ubicaci\u00f3n cr\u00edtica</p> <p>El archivo DEBE estar en <code>app/google-services.json</code>, NO en la ra\u00edz del proyecto.</p> <p>Estructura correcta: </p><pre><code>MyGameStore/\n\u251c\u2500 app/\n\u2502  \u251c\u2500 src/\n\u2502  \u251c\u2500 build.gradle.kts\n\u2502  \u2514\u2500 google-services.json  \u2190 AQU\u00cd\n\u251c\u2500 gradle/\n\u2514\u2500 build.gradle.kts\n</code></pre><p></p> <p>Pasos en Android Studio:</p> <ol> <li>En el explorador de archivos, ve a la carpeta <code>app</code> de tu proyecto</li> <li>Arrastra el archivo <code>google-services.json</code> desde <code>Descargas</code></li> <li>Su\u00e9ltalo directamente en la carpeta <code>app</code></li> <li>Android Studio detectar\u00e1 el archivo autom\u00e1ticamente</li> </ol> <p>Verificaci\u00f3n:</p> <p>En la vista de proyecto (Project view), deber\u00edas ver: </p><pre><code>app/\n\u251c\u2500 manifests/\n\u251c\u2500 java/\n\u251c\u2500 res/\n\u251c\u2500 build.gradle.kts\n\u2514\u2500 google-services.json  \u2705\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#24-que-es-el-bom-bill-of-materials","title":"2.4. \u00bfQu\u00e9 es el BoM (Bill of Materials)?","text":"<p>El BoM de Firebase es una lista centralizada de versiones compatibles entre s\u00ed. Es como una \"receta\" que garantiza que todas las librer\u00edas de Firebase funcionen correctamente juntas.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#problema-sin-bom","title":"Problema sin BoM","text":"<p>Antes del BoM, ten\u00edas que gestionar versiones manualmente:</p> <pre><code>// \u274c Sin BoM: Riesgo de incompatibilidades\nimplementation(\"com.google.firebase:firebase-auth:21.0.1\")\nimplementation(\"com.google.firebase:firebase-firestore:24.0.0\")  // \u26a0\ufe0f Puede no ser compatible\nimplementation(\"com.google.firebase:firebase-analytics:21.2.0\")  // \u26a0\ufe0f Puede no ser compatible\n</code></pre> <p>Problemas: - \ud83d\ude35 Dif\u00edcil saber qu\u00e9 versiones son compatibles - \ud83d\udc1b Bugs sutiles por incompatibilidades - \u23f0 Tiempo perdido resolviendo conflictos</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#solucion-con-bom","title":"Soluci\u00f3n con BoM","text":"<pre><code>// \u2705 Con BoM: Compatibilidad garantizada\nimplementation(platform(\"com.google.firebase:firebase-bom:33.7.0\"))  // Una versi\u00f3n del BoM\nimplementation(\"com.google.firebase:firebase-auth\")                   // Sin versi\u00f3n\nimplementation(\"com.google.firebase:firebase-firestore\")              // Sin versi\u00f3n\nimplementation(\"com.google.firebase:firebase-analytics\")              // Sin versi\u00f3n\n</code></pre> <p>Ventajas:</p> Ventaja Descripci\u00f3n \u2705 Compatibilidad garantizada Google asegura que todas las versiones funcionan juntas \u2705 Menos c\u00f3digo No repetir versiones en cada librer\u00eda \u2705 Actualizaciones simples Cambiar una sola l\u00ednea (el BoM) actualiza todo \u2705 Menos errores Imposible mezclar versiones incompatibles"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#como-funciona-el-bom","title":"C\u00f3mo funciona el BoM","text":"<p>\u00ba </p><pre><code>graph TD\n    A[firebase-bom:33.7.0] --&gt;|define| B[firebase-auth:22.3.1]\n    A --&gt;|define| C[firebase-firestore:24.10.1]\n    A --&gt;|define| D[firebase-analytics:21.5.1]\n    A --&gt;|define| E[firebase-storage:20.3.0]\n\n    F[Tu app] --&gt;|usa| A\n    F -.-&gt;|obtiene versi\u00f3n de| B\n    F -.-&gt;|obtiene versi\u00f3n de| C\n    F -.-&gt;|obtiene versi\u00f3n de| D\n\n    style A fill:#ff6b6b\n    style F fill:#4d96ff</code></pre><p></p> <p>Cuando declaras el BoM, todas las librer\u00edas de Firebase heredan autom\u00e1ticamente la versi\u00f3n correcta.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#25-configurar-dependencias-con-bom","title":"2.5. Configurar dependencias con BoM","text":"<p>Ahora vamos a agregar Firebase al proyecto usando el BoM.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-1-agregar-versiones-en-libsversionstoml","title":"Paso 1: Agregar versiones en libs.versions.toml","text":"<p>Ubicaci\u00f3n: <code>gradle/libs.versions.toml</code></p> <pre><code>[versions]\n# ... otras versiones\nfirebaseBom = \"33.7.0\"\ngoogleServices = \"4.4.4\"\n</code></pre> <p>\u00bfPor qu\u00e9 estas versiones?</p> <ul> <li><code>firebaseBom</code>: Versi\u00f3n del BoM (contiene todas las librer\u00edas Firebase)</li> <li><code>googleServices</code>: Plugin que procesa <code>google-services.json</code></li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-2-agregar-librerias-en-libsversionstoml","title":"Paso 2: Agregar librer\u00edas en libs.versions.toml","text":"<p>En la secci\u00f3n <code>[libraries]</code>:</p> <pre><code>[libraries]\n# ... otras librer\u00edas\n\n# Firebase BoM (Bill of Materials)\nfirebase-bom = { group = \"com.google.firebase\", name = \"firebase-bom\", version.ref = \"firebaseBom\" }\n\n# Firebase Services (sin versi\u00f3n, controladas por BoM)\nfirebase-auth = { group = \"com.google.firebase\", name = \"firebase-auth\" }\nfirebase-analytics = { group = \"com.google.firebase\", name = \"firebase-analytics\" }\n</code></pre> <p>Observa:</p> <ul> <li><code>firebase-bom</code> S\u00cd tiene <code>version.ref</code> (la versi\u00f3n del BoM)</li> <li><code>firebase-auth</code> y <code>firebase-analytics</code> NO tienen versi\u00f3n (la heredan del BoM)</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-3-agregar-plugin-en-libsversionstoml","title":"Paso 3: Agregar plugin en libs.versions.toml","text":"<p>En la secci\u00f3n <code>[plugins]</code>:</p> <pre><code>[plugins]\n# ... otros plugins\ngoogle-services = { id = \"com.google.gms.google-services\", version.ref = \"googleServices\" }\n</code></pre> <p>Este plugin es necesario para procesar el archivo <code>google-services.json</code>.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-4-aplicar-plugin-en-buildgradlekts-proyecto","title":"Paso 4: Aplicar plugin en build.gradle.kts (proyecto)","text":"<p>Ubicaci\u00f3n: <code>build.gradle.kts</code> (ra\u00edz del proyecto)</p> <pre><code>plugins {\n    alias(libs.plugins.android.application) apply false\n    alias(libs.plugins.kotlin.android) apply false\n    alias(libs.plugins.kotlin.compose) apply false\n    alias(libs.plugins.kotlin.serialization) apply false\n    alias(libs.plugins.ksp) apply false\n    alias(libs.plugins.room) apply false\n\n    // \ud83d\udc47 Agregar plugin de Google Services\n    alias(libs.plugins.google.services) apply false\n}\n</code></pre> <p>\u00bfPor qu\u00e9 <code>apply false</code>?</p> <ul> <li>El plugin se declara aqu\u00ed pero se aplica en el m\u00f3dulo <code>app</code></li> <li>Permite reutilizar la versi\u00f3n en m\u00faltiples m\u00f3dulos</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-5-configurar-buildgradlekts-app","title":"Paso 5: Configurar build.gradle.kts (app)","text":"<p>Ubicaci\u00f3n: <code>app/build.gradle.kts</code></p> <p>a) Aplicar el plugin al inicio:</p> <pre><code>plugins {\n    alias(libs.plugins.android.application)\n    alias(libs.plugins.kotlin.android)\n    alias(libs.plugins.kotlin.compose)\n    alias(libs.plugins.kotlin.serialization)\n    alias(libs.plugins.ksp)\n    alias(libs.plugins.room)\n\n    // \ud83d\udc47 Aplicar plugin de Google Services\n    alias(libs.plugins.google.services)\n}\n</code></pre> <p>b) Agregar dependencias Firebase:</p> <pre><code>dependencies {\n    // ... dependencias existentes\n\n    // Firebase BoM (Bill of Materials)\n    implementation(platform(libs.firebase.bom))\n\n    // Firebase Services (versiones controladas por BoM)\n    implementation(libs.firebase.auth)\n    implementation(libs.firebase.analytics)\n}\n</code></pre> <p>Conceptos clave:</p> <pre><code>// platform() indica que es un BoM\nimplementation(platform(libs.firebase.bom))\n\n// Las siguientes librer\u00edas NO tienen versi\u00f3n expl\u00edcita\nimplementation(libs.firebase.auth)  // Versi\u00f3n viene del BoM\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-6-sincronizar-proyecto","title":"Paso 6: Sincronizar proyecto","text":"<ol> <li>Click en \"Sync Now\" (aparece en la parte superior de Android Studio)</li> <li>Gradle descargar\u00e1 las dependencias de Firebase</li> <li>Espera a que termine (puede tardar 1-2 minutos la primera vez)</li> </ol> <p>Si hay errores de sincronizaci\u00f3n:</p> <pre><code>Error: Failed to resolve: com.google.firebase:firebase-bom:33.7.0\n</code></pre> <p>Soluciones:</p> <ol> <li>Verifica tu conexi\u00f3n a Internet</li> <li>Aseg\u00farate de que <code>google-services.json</code> est\u00e9 en <code>app/</code></li> <li>Revisa que las versiones en <code>libs.versions.toml</code> sean correctas</li> <li>Intenta File \u2192 Invalidate Caches / Restart</li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#26-verificar-la-configuracion","title":"2.6. Verificar la configuraci\u00f3n","text":""},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#prueba-1-verificar-que-firebase-se-inicializa","title":"Prueba 1: Verificar que Firebase se inicializa","text":"<p>Ubicaci\u00f3n: <code>MyGameStoreApp.kt</code></p> <pre><code>import com.google.firebase.Firebase\nimport com.google.firebase.initialize\n\nclass MyGameStoreApp : Application() {\n    override fun onCreate() {\n        super.onCreate()\n\n        // Inicializar Room...\n        // Inicializar Koin...\n\n        // \ud83d\udc47 Verificar Firebase (opcional, se inicializa autom\u00e1ticamente)\n        Firebase.initialize(this)\n        println(\"\u2705 Firebase inicializado correctamente\")\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#prueba-2-verificar-que-firebaseauth-funciona","title":"Prueba 2: Verificar que FirebaseAuth funciona","text":"<p>En cualquier pantalla o ViewModel, agrega temporalmente:</p> <pre><code>import com.google.firebase.auth.FirebaseAuth\n\nclass LoginViewModel(...) : ViewModel() {\n    init {\n        val auth = FirebaseAuth.getInstance()\n        println(\"\u2705 FirebaseAuth disponible: ${auth != null}\")\n        println(\"\ud83d\udce7 Usuario actual: ${auth.currentUser?.email ?: \"No hay usuario\"}\")\n    }\n}\n</code></pre> <p>Ejecuta la app y revisa el Logcat. Deber\u00edas ver:</p> <pre><code>\u2705 Firebase inicializado correctamente\n\u2705 FirebaseAuth disponible: true\n\ud83d\udce7 Usuario actual: No hay usuario\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#27-google-servicesjson-en-profundidad","title":"2.7. google-services.json en profundidad","text":"<p>Ahora que Firebase est\u00e1 configurado, entendamos qu\u00e9 hace realmente este archivo.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#por-que-es-tan-importante","title":"\u00bfPor qu\u00e9 es tan importante?","text":"<p>El archivo <code>google-services.json</code> es el contrato entre tu app y Firebase. Sin \u00e9l:</p> <ul> <li>\u274c Firebase no sabe a qu\u00e9 proyecto pertenece tu app</li> <li>\u274c Las peticiones ser\u00e1n rechazadas (401 Unauthorized)</li> <li>\u274c Analytics no registrar\u00e1 eventos</li> <li>\u274c Authentication no funcionar\u00e1</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#contenido-detallado","title":"Contenido detallado","text":"<pre><code>{\n  \"project_info\": {\n    \"project_number\": \"123456789\",           // ID num\u00e9rico del proyecto\n    \"firebase_url\": \"https://...\",           // URL de Realtime Database\n    \"project_id\": \"mygamestore-abc123\",      // ID legible del proyecto\n    \"storage_bucket\": \"...\"                  // Bucket de Cloud Storage\n  },\n  \"client\": [\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:123:android:abc\",  // ID \u00fanico de esta app\n        \"android_client_info\": {\n          \"package_name\": \"com.pmdm.mygamestore\"  // Package de tu app\n        }\n      },\n      \"oauth_client\": [                      // Para Google Sign-In (lo veremos despu\u00e9s)\n        {\n          \"client_id\": \"...apps.googleusercontent.com\",\n          \"client_type\": 3                   // Tipo: Android\n        }\n      ],\n      \"api_key\": [                           // Clave de API\n        {\n          \"current_key\": \"AIzaSy...\"        // Clave para autenticar peticiones\n        }\n      ],\n      \"services\": {                          // Servicios habilitados\n        \"appinvite_service\": { ... },\n        \"analytics_service\": { ... }\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#que-hace-el-plugin-google-services","title":"\u00bfQu\u00e9 hace el plugin google-services?","text":"<p>Cuando sincronizas Gradle, el plugin:</p> <ol> <li>Lee <code>google-services.json</code></li> <li>Extrae las credenciales</li> <li>Genera archivos auxiliares en <code>app/build/generated/</code></li> <li>Inyecta las credenciales en tu app en tiempo de compilaci\u00f3n</li> </ol> <pre><code>graph LR\n    A[google-services.json] --&gt;|Plugin lee| B[google-services.gradle]\n    B --&gt;|Genera| C[valores XML en generated/]\n    C --&gt;|Se incluyen en| D[APK final]\n    D --&gt;|Firebase SDK lee| E[Credenciales en runtime]\n\n    style A fill:#ffd93d\n    style D fill:#4d96ff</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#seguridad-debo-subir-google-servicesjson-a-git","title":"\u26a0\ufe0f Seguridad: \u00bfDebo subir google-services.json a Git?","text":"<p>Depende del contexto:</p> Escenario Recomendaci\u00f3n Raz\u00f3n Repositorio privado \u2705 S\u00ed Solo tu equipo tiene acceso Repositorio p\u00fablico \u26a0\ufe0f Depende Las API keys est\u00e1n restringidas por dominio Producci\u00f3n con secrets \u274c No Usar CI/CD para inyectar el archivo <p>Para este proyecto educativo:</p> <ul> <li>\u2705 Puedes subirlo (Firebase tiene protecciones)</li> <li>\u26a0\ufe0f Pero es buena pr\u00e1ctica agregarlo a <code>.gitignore</code> para acostumbrarte</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#3-autenticacion-conceptos-y-practica","title":"3. Autenticaci\u00f3n: Conceptos y pr\u00e1ctica","text":"<p>En esta secci\u00f3n implementaremos la autenticaci\u00f3n completa con Firebase, integr\u00e1ndola perfectamente en nuestra arquitectura con Koin. Aprender\u00e1s tanto los conceptos te\u00f3ricos como la implementaci\u00f3n pr\u00e1ctica.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#31-que-es-la-autenticacion","title":"3.1. \u00bfQu\u00e9 es la autenticaci\u00f3n?","text":"<p>La autenticaci\u00f3n es el proceso de verificar la identidad de un usuario. Es la respuesta a la pregunta: \"\u00bfQui\u00e9n eres?\"</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#autenticacion-vs-autorizacion","title":"Autenticaci\u00f3n vs Autorizaci\u00f3n","text":"<p>Estos dos conceptos suelen confundirse, pero son diferentes:</p> Concepto Pregunta Ejemplo Autenticaci\u00f3n \u00bfQui\u00e9n eres? Login con email/password Autorizaci\u00f3n \u00bfQu\u00e9 puedes hacer? \u00bfPuedes eliminar este juego? <pre><code>graph LR\n    A[Usuario] --&gt;|1. Credenciales| B[Autenticaci\u00f3n]\n    B --&gt;|2. Verifica identidad| C{\u00bfV\u00e1lido?}\n    C --&gt;|S\u00ed| D[Token JWT]\n    D --&gt;|3. Con token| E[Autorizaci\u00f3n]\n    E --&gt;|4. Verifica permisos| F{\u00bfPermitido?}\n    F --&gt;|S\u00ed| G[Acci\u00f3n permitida]\n    F --&gt;|No| H[403 Forbidden]\n    C --&gt;|No| I[401 Unauthorized]\n\n    style B fill:#4d96ff\n    style E fill:#6bcf7f</code></pre> <p>Ejemplo en nuestra app:</p> <pre><code>// Autenticaci\u00f3n: \u00bfQui\u00e9n eres?\nval user = firebaseAuth.signInWithEmailAndPassword(email, password)\n\n// Autorizaci\u00f3n: \u00bfQu\u00e9 puedes hacer?\nif (user.uid == game.ownerId) {\n    // Permitir eliminar juego\n} else {\n    // Denegar acci\u00f3n\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#flujo-basico-de-autenticacion","title":"Flujo b\u00e1sico de autenticaci\u00f3n","text":"<pre><code>sequenceDiagram\n    participant U as Usuario\n    participant UI as LoginScreen\n    participant VM as ViewModel\n    participant Repo as Repository\n    participant FB as Firebase Auth\n    participant Cloud as Firebase Cloud\n\n    U-&gt;&gt;UI: Ingresa email y password\n    UI-&gt;&gt;VM: onLoginClick()\n    VM-&gt;&gt;Repo: login(email, password)\n    Repo-&gt;&gt;FB: signInWithEmailAndPassword()\n    FB-&gt;&gt;Cloud: HTTPS POST /auth/login\n    Cloud-&gt;&gt;Cloud: Valida credenciales\n    Cloud-&gt;&gt;Cloud: Genera token JWT\n    Cloud--&gt;&gt;FB: Token + FirebaseUser\n    FB--&gt;&gt;Repo: FirebaseUser\n    Repo--&gt;&gt;VM: LoginResult.Success\n    VM-&gt;&gt;VM: Guarda sesi\u00f3n\n    VM--&gt;&gt;UI: Navega a Home</code></pre>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#tipos-de-autenticacion-en-firebase","title":"Tipos de autenticaci\u00f3n en Firebase","text":"<p>Firebase soporta m\u00faltiples m\u00e9todos de autenticaci\u00f3n:</p> <p>1. Email/Password (Tradicional) </p><pre><code>firebaseAuth.createUserWithEmailAndPassword(email, password)  // Registro\nfirebaseAuth.signInWithEmailAndPassword(email, password)      // Login\n</code></pre><p></p> <p>2. Proveedores OAuth (Google, Facebook, etc.) </p><pre><code>val credential = GoogleAuthProvider.getCredential(idToken, null)\nfirebaseAuth.signInWithCredential(credential)\n</code></pre><p></p> <p>3. Autenticaci\u00f3n an\u00f3nima </p><pre><code>firebaseAuth.signInAnonymously()  // Usuario temporal\n</code></pre><p></p> <p>4. Tel\u00e9fono (SMS) </p><pre><code>PhoneAuthProvider.verifyPhoneNumber(phoneNumber, ...)\n</code></pre><p></p> <p>5. Personalizada (Custom tokens) </p><pre><code>firebaseAuth.signInWithCustomToken(token)\n</code></pre><p></p> <p>En este proyecto implementaremos:</p> <ul> <li>\u2705 Email/Password (autenticaci\u00f3n b\u00e1sica)</li> <li>\u2705 Google Sign-In (mejor UX, m\u00e1s r\u00e1pido)</li> </ul>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#32-autenticacion-con-emailpassword","title":"3.2. Autenticaci\u00f3n con Email/Password","text":"<p>Comenzaremos con la autenticaci\u00f3n tradicional usando email y contrase\u00f1a.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-1-habilitar-emailpassword-en-firebase-console","title":"Paso 1: Habilitar Email/Password en Firebase Console","text":"<ol> <li>Ve a Firebase Console</li> <li>Selecciona tu proyecto</li> <li>En el men\u00fa lateral, click en \"Authentication\"</li> <li>Pesta\u00f1a \"Sign-in method\"</li> <li>Click en \"Email/Password\"</li> <li>Habilitar el primer switch (Email/Password)</li> <li>(Opcional) Deja deshabilitado \"Email link\" por ahora</li> <li>Click en \"Guardar\"</li> </ol> <p>Verificar configuraci\u00f3n</p> <p>Deber\u00edas ver \"Email/Password\" con estado Enabled en la lista de proveedores.</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-2-crear-firebaseauthrepositoryimpl","title":"Paso 2: Crear FirebaseAuthRepositoryImpl","text":"<p>Ahora crearemos la implementaci\u00f3n del repositorio que usa Firebase en lugar del mock.</p> <p>Ubicaci\u00f3n: <code>data/repository/FirebaseAuthRepositoryImpl.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.repository\n\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.auth.FirebaseAuthInvalidCredentialsException\nimport com.google.firebase.auth.FirebaseAuthInvalidUserException\nimport com.google.firebase.auth.FirebaseAuthUserCollisionException\nimport com.google.firebase.auth.FirebaseAuthWeakPasswordException\nimport com.pmdm.mygamestore.MyGameStoreApp\nimport com.pmdm.mygamestore.data.local.entities.UserEntity\nimport kotlinx.coroutines.tasks.await\n\n/**\n * Implementaci\u00f3n del repositorio de autenticaci\u00f3n usando Firebase\n * \n * Esta clase encapsula todas las operaciones de autenticaci\u00f3n con Firebase,\n * convirtiendo las respuestas de Firebase en nuestros tipos de dominio\n * (LoginResult, RegisterResult).\n * \n * Ventajas de esta implementaci\u00f3n:\n * - Manejo robusto de errores de Firebase\n * - Sincronizaci\u00f3n con Room para persistencia local\n * - Conversi\u00f3n autom\u00e1tica de FirebaseUser a nuestros modelos\n * - Compatible con la interfaz AuthRepository (DI)\n */\nclass FirebaseAuthRepositoryImpl(\n    private val firebaseAuth: FirebaseAuth\n) : AuthRepository {\n\n    /**\n     * Inicia sesi\u00f3n con email y contrase\u00f1a usando Firebase\n     * \n     * @param username En este caso, usamos el email como username\n     * @param password Contrase\u00f1a del usuario\n     * @return LoginResult.Success si las credenciales son correctas,\n     *         LoginResult.Error con mensaje espec\u00edfico en caso contrario\n     */\n    override suspend fun login(username: String, password: String): LoginResult {\n        return try {\n            // Intentar login en Firebase\n            val result = firebaseAuth.signInWithEmailAndPassword(username, password).await()\n\n            // Verificar que el usuario existe\n            val firebaseUser = result.user\n            if (firebaseUser != null) {\n                // Sincronizar usuario en Room para acceso offline\n                syncUserToRoom(firebaseUser.uid, firebaseUser.email ?: username)\n\n                LoginResult.Success(username = firebaseUser.email ?: username)\n            } else {\n                LoginResult.Error(\"Authentication failed: User is null\")\n            }\n\n        } catch (e: FirebaseAuthInvalidUserException) {\n            // Usuario no existe\n            LoginResult.Error(\"No account found with this email\")\n        } catch (e: FirebaseAuthInvalidCredentialsException) {\n            // Contrase\u00f1a incorrecta\n            LoginResult.Error(\"Invalid password\")\n        } catch (e: Exception) {\n            // Otros errores (red, etc.)\n            LoginResult.Error(\"Login failed: ${e.message}\")\n        }\n    }\n\n    /**\n     * Registra un nuevo usuario con email y contrase\u00f1a\n     * \n     * @param username Email del usuario\n     * @param email Email del usuario (mismo que username en este caso)\n     * @param password Contrase\u00f1a del usuario\n     * @return RegisterResult.Success si el registro es exitoso,\n     *         RegisterResult.Error con mensaje espec\u00edfico en caso contrario\n     */\n    override suspend fun register(\n        username: String,\n        email: String,\n        password: String\n    ): RegisterResult {\n        return try {\n            // Crear usuario en Firebase\n            val result = firebaseAuth.createUserWithEmailAndPassword(email, password).await()\n\n            val firebaseUser = result.user\n            if (firebaseUser != null) {\n                // Sincronizar en Room\n                syncUserToRoom(firebaseUser.uid, email)\n\n                // (Opcional) Enviar email de verificaci\u00f3n\n                firebaseUser.sendEmailVerification().await()\n\n                RegisterResult.Success(username = email)\n            } else {\n                RegisterResult.Error(\"Registration failed: User is null\")\n            }\n\n        } catch (e: FirebaseAuthWeakPasswordException) {\n            // Contrase\u00f1a d\u00e9bil (menos de 6 caracteres)\n            RegisterResult.Error(\"Password should be at least 6 characters\")\n        } catch (e: FirebaseAuthInvalidCredentialsException) {\n            // Email inv\u00e1lido\n            RegisterResult.Error(\"Invalid email format\")\n        } catch (e: FirebaseAuthUserCollisionException) {\n            // Email ya registrado\n            RegisterResult.Error(\"An account already exists with this email\")\n        } catch (e: Exception) {\n            RegisterResult.Error(\"Registration failed: ${e.message}\")\n        }\n    }\n\n    /**\n     * Sincroniza el usuario de Firebase con Room\n     * \n     * Esto permite:\n     * - Acceso offline a informaci\u00f3n b\u00e1sica del usuario\n     * - Relaciones con otras entidades (Library, Notes, etc.)\n     * - Consistencia entre Firebase Auth y nuestra base de datos local\n     * \n     * @param userId UID de Firebase\n     * @param email Email del usuario\n     */\n    private suspend fun syncUserToRoom(userId: String, email: String) {\n        try {\n            val userEntity = UserEntity(\n                username = email,  // Usamos email como username\n                name = email.substringBefore(\"@\"),  // Nombre por defecto\n                email = email,\n                avatarUrl = null,\n                bio = null\n            )\n\n            MyGameStoreApp.database.userDao().insertUser(userEntity)\n        } catch (e: Exception) {\n            // Log error pero no fallar el login\n            println(\"\u26a0\ufe0f Error syncing user to Room: ${e.message}\")\n        }\n    }\n}\n</code></pre> <p>Conceptos clave del c\u00f3digo:</p> <ol> <li> <p>suspend fun + await() </p><pre><code>// Firebase devuelve Tasks (as\u00edncronas)\nval task: Task&lt;AuthResult&gt; = firebaseAuth.signInWithEmailAndPassword(email, password)\n\n// await() convierte Task en suspend function\nval result: AuthResult = task.await()\n</code></pre><p></p> </li> <li> <p>Manejo espec\u00edfico de excepciones de Firebase </p><pre><code>catch (e: FirebaseAuthInvalidUserException) {\n    // Usuario no existe\n}\ncatch (e: FirebaseAuthInvalidCredentialsException) {\n    // Contrase\u00f1a incorrecta o email inv\u00e1lido\n}\ncatch (e: FirebaseAuthWeakPasswordException) {\n    // Contrase\u00f1a d\u00e9bil (&lt; 6 caracteres)\n}\n</code></pre><p></p> </li> <li> <p>Sincronizaci\u00f3n con Room </p><pre><code>// Guardar usuario en Room para:\n// - Acceso offline\n// - Relaciones con otras entidades (Foreign Keys)\nMyGameStoreApp.database.userDao().insertUser(userEntity)\n</code></pre><p></p> </li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-3-actualizar-datamodule-con-firebase","title":"Paso 3: Actualizar DataModule con Firebase","text":"<p>Ahora configuramos Koin para usar Firebase en lugar del mock.</p> <p>Ubicaci\u00f3n: <code>di/DataModule.kt</code></p> <pre><code>package com.pmdm.mygamestore.di\n\nimport com.google.firebase.auth.FirebaseAuth\nimport com.pmdm.mygamestore.MyGameStoreApp\nimport com.pmdm.mygamestore.data.local.SessionManager\nimport com.pmdm.mygamestore.data.local.SessionManagerImpl\nimport com.pmdm.mygamestore.data.repository.AuthRepository\nimport com.pmdm.mygamestore.data.repository.FirebaseAuthRepositoryImpl  // \ud83d\udc48 Import nuevo\nimport com.pmdm.mygamestore.data.repository.GamesRepository\nimport com.pmdm.mygamestore.data.repository.MockGamesRepositoryImpl\nimport org.koin.core.module.dsl.singleOf\nimport org.koin.dsl.bind\nimport org.koin.dsl.module\n\nval dataModule = module {\n\n    // Database (Singleton)\n    single { MyGameStoreApp.database }\n\n    // \ud83c\udd95 Firebase Auth (Singleton)\n    single { FirebaseAuth.getInstance() }\n\n    // SessionManager (Singleton)\n    singleOf(::SessionManagerImpl) bind SessionManager::class\n\n    // \ud83d\udd04 AuthRepository: Cambiar de Mock a Firebase\n    singleOf(::FirebaseAuthRepositoryImpl) bind AuthRepository::class\n\n    // GamesRepository (Mock por ahora)\n    singleOf(::MockGamesRepositoryImpl) bind GamesRepository::class\n}\n</code></pre> <p>\u00a1Observa la magia de la DI!</p> <pre><code>// \u274c Antes (Mock)\nsingleOf(::AuthRepositoryImpl) bind AuthRepository::class\n\n// \u2705 Ahora (Firebase)\nsingleOf(::FirebaseAuthRepositoryImpl) bind AuthRepository::class\n</code></pre> <p>\u00bfQu\u00e9 cambi\u00f3 en la app?</p> <ul> <li>\u2705 LoginViewModel: Sin cambios</li> <li>\u2705 RegisterViewModel: Sin cambios</li> <li>\u2705 LoginScreen: Sin cambios</li> <li>\u2705 RegisterScreen: Sin cambios</li> </ul> <p>Solo cambiamos UNA l\u00ednea y toda la app usa Firebase. \ud83c\udf89</p>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-4-testing-del-flujo-completo","title":"Paso 4: Testing del flujo completo","text":"<p>Ahora vamos a probar que todo funciona.</p> Escenario 1: Registro de nuevo usuarioEscenario 2: Login con usuario existenteEscenario 3: Error - Contrase\u00f1a incorrectaEscenario 4: Error - Usuario no existe <ol> <li>Abre la app</li> <li>Ve a RegisterScreen</li> <li>Ingresa:</li> </ol> <ul> <li>Email: <code>test@example.com</code></li> <li>Password: <code>password123</code></li> <li>Confirm Password: <code>password123</code></li> </ul> <ol> <li>Click en \"Register\"</li> <li>Resultado esperado:</li> </ol> <ul> <li>Loading indicator aparece</li> <li>Se crea el usuario en Firebase</li> <li>Navegas a HomeScreen</li> </ul> <p>Verificar en Firebase Console:</p> <ol> <li>Ve a Authentication \u2192 Users</li> <li>Deber\u00edas ver el usuario <code>test@example.com</code></li> <li>Click en el usuario para ver detalles</li> </ol> <ol> <li>Cierra la app completamente</li> <li>Abre la app de nuevo</li> <li>Ve a LoginScreen</li> <li> <p>Ingresa:</p> <ul> <li>Email: <code>test@example.com</code></li> <li>Password: <code>password123</code></li> </ul> </li> <li> <p>Click en \"Login\"</p> </li> <li> <p>Resultado esperado:</p> <ul> <li>Loading indicator</li> <li>Login exitoso</li> <li>Navegas a HomeScreen</li> </ul> </li> </ol> <ol> <li>Ve a LoginScreen</li> <li> <p>Ingresa:</p> <ul> <li>Email: <code>test@example.com</code></li> <li>Password: <code>wrongpassword</code></li> </ul> </li> <li> <p>Click en \"Login\"</p> </li> <li> <p>Resultado esperado:</p> <ul> <li>Snackbar con mensaje: \"Invalid password\"</li> <li>No navegas</li> <li>Puedes intentar de nuevo</li> </ul> </li> </ol> <ol> <li>LoginScreen</li> <li> <p>Ingresa:</p> <ul> <li>Email: <code>noexiste@example.com</code></li> <li>Password: <code>password123</code></li> </ul> </li> <li> <p>Resultado esperado:</p> <ul> <li>Snackbar: \"No account found with this email\"</li> </ul> </li> </ol>"},{"location":"temas/proyectos/GameVault/10-Auth-firebase.html#paso-5-debugging-comun","title":"Paso 5: Debugging com\u00fan","text":"Problema 1: \"FirebaseAuth has not been initializedProblema 2: \"Email already existsProblema 3: \"Weak password <pre><code>java.lang.IllegalStateException: Default FirebaseApp is not initialized\n</code></pre> Soluci\u00f3n: <ul> <li>Verifica que <code>google-services.json</code> est\u00e9 en <code>app/</code></li> <li>Aseg\u00farate de que el plugin est\u00e1 aplicado en <code>app/build.gradle.kts</code></li> <li>Sync Gradle de nuevo</li> </ul> <p>Si intentas registrar el mismo email dos veces, Firebase rechazar\u00e1 el segundo intento.</p> <p>Soluci\u00f3n:</p> <ol> <li>Ve a Firebase Console \u2192 Authentication \u2192 Users</li> <li>Elimina el usuario</li> <li>Intenta registrar de nuevo</li> </ol> <p>Firebase requiere m\u00ednimo 6 caracteres en la contrase\u00f1a.</p> <p>Soluci\u00f3n:</p> <ul> <li> <p>Actualiza las validaciones en <code>RegisterViewModel</code>:</p> <pre><code>if (state.password.length &lt; 6) {\n    _uiState.update { \n        it.copy(errorMessage = \"Password must be at least 6 characters\") \n    }\n    return\n}\n</code></pre> </li> </ul> <p>\u2705 Resumen de Email/Password</p> <p>Has implementado autenticaci\u00f3n completa con Firebase:</p> <ol> <li>\u2705 Habilitado Email/Password en Firebase Console</li> <li>\u2705 Creado <code>FirebaseAuthRepositoryImpl</code></li> <li>\u2705 Actualizado <code>DataModule</code> con Firebase Auth</li> <li>\u2705 Testing completo del flujo de registro y login</li> <li>\u2705 Manejo robusto de errores de Firebase</li> <li>\u2705 Sincronizaci\u00f3n autom\u00e1tica con Room</li> </ol> <p>Ventajas alcanzadas:</p> <ul> <li>\ud83d\udd12 Autenticaci\u00f3n segura gestionada por Firebase</li> <li>\ud83d\udce6 Sin cambios en ViewModels ni UI (gracias a DI)</li> <li>\ud83e\uddea F\u00e1cil volver al mock para testing</li> <li>\ud83d\udcf1 Persistencia de sesi\u00f3n autom\u00e1tica</li> </ul>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html","title":"11. Autenticaci\u00f3n con Google","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#guia-integracion-de-google-sign-in-con-firebase-en-android","title":"Gu\u00eda:  Integraci\u00f3n de Google Sign-In con Firebase en Android","text":"<p>En esta 11\u00aa parte de la gu\u00eda se implementar\u00e1 la autenticaci\u00f3n con Google Sign-In.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#indice","title":"\ud83d\udcd6 \u00cdndice","text":"<ol> <li>Introducci\u00f3n</li> <li>Paso 1: Configuraci\u00f3n en Firebase Console</li> <li>Paso 2: Configuraci\u00f3n en Google Cloud Console</li> <li>Paso 3: Agregar dependencias de Google Sign-In</li> <li>Paso 4: Crear GoogleSignInManager</li> <li>Paso 5: Extender FirebaseAuthRepositoryImpl</li> <li>Paso 6: Actualizar DataModule con GoogleSignInManager</li> <li>Paso 7: Actualizar LoginViewModel</li> <li>Paso 8: Actualizar LoginScreen con bot\u00f3n de Google</li> <li>Paso 9: Agregar \u00edcono de Google</li> <li>Paso 10: Actualizar HomeViewModel con logout</li> <li>Paso 11: Testing del flujo completo</li> <li>Resumen de archivos</li> <li>Diagrama del flujo completo</li> </ol>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#introducci\u00f3n","title":"\ud83c\udfaf Introducci\u00f3n","text":"<p>La autenticaci\u00f3n es un componente cr\u00edtico en cualquier aplicaci\u00f3n moderna. En esta gu\u00eda implementaremos:</p> <ul> <li>\u2705 Autenticaci\u00f3n con Email/Password: Registro y login tradicional usando Firebase Auth</li> <li>\u2705 Google Sign-In: Inicio de sesi\u00f3n con cuenta de Google (OAuth 2.0)</li> <li>\u2705 Gesti\u00f3n de Sesi\u00f3n: Persistencia del estado de autenticaci\u00f3n</li> <li>\u2705 Manejo de Errores: Mensajes descriptivos para cada tipo de error</li> <li>\u2705 UX Optimizada: Feedback visual claro en cada paso</li> </ul>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#arquitectura-del-sistema-de-autenticacion","title":"Arquitectura del sistema de autenticaci\u00f3n","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           PRESENTATION LAYER                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502 LoginScreen  \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2502 LoginViewModel   \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              DATA LAYER                         \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   GoogleSignInManager                  \u2502     \u2502\n\u2502  \u2502   (Helper para Google OAuth)           \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2502                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n\u2502  \u2502   FirebaseAuthRepositoryImpl           \u2502     \u2502\n\u2502  \u2502   - signInWithGoogle()                 \u2502     \u2502\n\u2502  \u2502   - login(email, password)             \u2502     \u2502\n\u2502  \u2502   - register(email, password)          \u2502     \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-1-configuraci\u00f3n-en-firebase-console","title":"\ud83d\udd27 Paso 1: Configuraci\u00f3n en Firebase Console","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#11-habilitar-google-como-proveedor-de-autenticacion","title":"1.1. Habilitar Google como proveedor de autenticaci\u00f3n","text":"<ol> <li>Accede a Firebase Console</li> <li>Selecciona tu proyecto</li> <li>En el men\u00fa lateral, ve a Authentication \u2192 Sign-in method</li> <li>Haz clic en Google</li> <li>Activa el interruptor Enable</li> <li>Configura el email de soporte del proyecto (tu email de desarrollador)</li> <li>Haz clic en Guardar</li> </ol> <p>Importante</p> <p>Los pasos espec\u00edficos en este punto pueden variar, ya que la interfaz de Firebase cambia con frecuencia. Consulta la documentaci\u00f3n oficial de Firebase para obtener las instrucciones m\u00e1s actualizadas.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-2-configuraci\u00f3n-en-google-cloud-console","title":"\ud83d\udd10 Paso 2: Configuraci\u00f3n en Google Cloud Console","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#21-generar-sha-1-del-certificado-de-debug","title":"2.1. Generar SHA-1 del certificado de debug","text":"<p>El SHA-1 es una huella digital de tu certificado de firma. Google lo usa para verificar que las peticiones provienen de tu app.</p> <p>En Windows:</p> <pre><code>gradlew signingReport\n</code></pre> <p>Busca en la salida:</p> <pre><code>Variant: debug\nConfig: debug\nStore: C:\\Users\\TuUsuario\\.android\\debug.keystore\nAlias: AndroidDebugKey\nSHA1: A1:B2:C3:D4:E5:F6:...\n</code></pre> <p>Copia el valor del SHA1 que aparece en <code>Variant: debug</code>.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#22-agregar-sha-1-a-firebase","title":"2.2. Agregar SHA-1 a Firebase","text":"<ol> <li>Vuelve a Firebase Console \u2192 Project Settings (icono de engranaje)</li> <li>Ve a la pesta\u00f1a General</li> <li>Haz scroll hasta la secci\u00f3n Your apps</li> <li>En tu app Android, haz clic en Add fingerprint</li> <li>Pega el SHA-1 que copiaste</li> <li>Haz clic en Save</li> </ol>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#23-descargar-nuevo-google-servicesjson","title":"2.3. Descargar nuevo google-services.json","text":"<p>Cr\u00edtico</p> <p>Despu\u00e9s de agregar el SHA-1, Firebase genera un nuevo archivo <code>google-services.json</code> con las credenciales OAuth. Debes reemplazar el archivo antiguo.</p> <ol> <li>En la misma pantalla de Project Settings, haz clic en el bot\u00f3n Download google-services.json</li> <li>Reemplaza el archivo en <code>app/google-services.json</code></li> <li>Sync el proyecto en Android Studio</li> </ol>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-3-agregar-dependencias-de-google-sign-in","title":"\ud83d\udce6 Paso 3: Agregar dependencias de Google Sign-In","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#31-actualizar-libsversionstoml","title":"3.1. Actualizar libs.versions.toml","text":"<pre><code>[versions]\n# ... otras versiones ...\nplayServicesAuth = \"21.3.0\"\n\n[libraries]\n# ... otras librer\u00edas ...\nplay-services-auth = { group = \"com.google.android.gms\", name = \"play-services-auth\", version.ref = \"playServicesAuth\" }\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#32-actualizar-appbuildgradlekts","title":"3.2. Actualizar app/build.gradle.kts","text":"<pre><code>dependencies {\n    // ... otras dependencias ...\n\n    // Google Sign-In\n    implementation(libs.play.services.auth)\n}\n</code></pre> <p>Sync el proyecto despu\u00e9s de estos cambios.</p> <p>Tienes raz\u00f3n, el <code>default_web_client_id</code> se genera autom\u00e1ticamente en el archivo <code>google-services.json</code> cuando configuras Firebase correctamente. Voy a actualizar solo la secci\u00f3n del Paso 4 de la gu\u00eda para reflejar esto correctamente:</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-4-crear-googlesigninmanager","title":"\ud83d\udee0\ufe0f Paso 4: Crear GoogleSignInManager","text":"<p>Esta clase encapsula toda la l\u00f3gica de Google Sign-In, facilitando su uso y mantenimiento.</p> <p>Ubicaci\u00f3n: <code>app/src/main/java/com/pmdm/mygamestore/data/auth/GoogleSignInManager.kt</code></p> <pre><code>package com.pmdm.mygamestore.data.auth\n\nimport android.content.Context\nimport android.content.Intent\nimport com.google.android.gms.auth.api.signin.GoogleSignIn\nimport com.google.android.gms.auth.api.signin.GoogleSignInClient\nimport com.google.android.gms.auth.api.signin.GoogleSignInOptions\nimport com.google.android.gms.common.api.ApiException\nimport com.google.firebase.auth.AuthCredential\nimport com.google.firebase.auth.GoogleAuthProvider\nimport com.pmdm.mygamestore.R\n\n/**\n * \ud83d\udd10 GoogleSignInManager - Helper para gestionar Google Sign-In\n *\n * RESPONSABILIDADES:\n * - Configurar GoogleSignInClient con el Web Client ID\n * - Proporcionar el Intent para iniciar el flujo OAuth\n * - Convertir GoogleSignInAccount a AuthCredential de Firebase\n * - Manejar errores espec\u00edficos de Google Sign-In\n *\n * VENTAJAS:\n * \u2705 Encapsula la complejidad de Google Sign-In\n * \u2705 Reutilizable en cualquier parte de la app\n * \u2705 Manejo robusto de errores\n * \u2705 F\u00e1cil de testear\n *\n * @param context Contexto de Android\n */\nclass GoogleSignInManager(\n    context: Context\n) {\n\n    /**\n     * Cliente de Google Sign-In configurado con el Web Client ID\n     *\n     * IMPORTANTE - Web Client ID autom\u00e1tico:\n     * \u2705 El ID se obtiene autom\u00e1ticamente de R.string.default_web_client_id\n     * \u2705 Este recurso se genera autom\u00e1ticamente desde google-services.json\n     * \u2705 NO necesitas copiarlo manualmente\n     * \n     * REQUISITOS:\n     * 1. Tener google-services.json actualizado en app/\n     * 2. Haber agregado el SHA-1 en Firebase Console\n     * 3. Haber habilitado Google Sign-In en Firebase Authentication\n     * 4. Haber sincronizado el proyecto despu\u00e9s de agregar google-services.json\n     */\n    private val googleSignInClient: GoogleSignInClient\n\n    init {\n        // Configurar opciones de Google Sign-In\n        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)\n            .requestIdToken(context.getString(R.string.default_web_client_id))\n            .requestEmail()\n            .build()\n\n        googleSignInClient = GoogleSignIn.getClient(context, gso)\n    }\n\n    /**\n     * \ud83d\ude80 Obtiene el Intent para iniciar el flujo de Google Sign-In\n     *\n     * FLUJO:\n     * 1. Usuario hace click en \"Sign in with Google\"\n     * 2. LoginScreen llama a este m\u00e9todo\n     * 3. Se lanza el Intent con el selector de cuentas de Google\n     * 4. Usuario selecciona su cuenta\n     * 5. Google devuelve el resultado a trav\u00e9s de ActivityResult\n     *\n     * @return Intent para lanzar el selector de cuentas\n     */\n    fun getSignInIntent(): Intent {\n        return googleSignInClient.signInIntent\n    }\n\n    /**\n     * \ud83d\udd04 Convierte el resultado de Google Sign-In a credencial de Firebase\n     *\n     * FLUJO:\n     * 1. ActivityResult devuelve un Intent con datos de la cuenta\n     * 2. Extraemos GoogleSignInAccount del Intent\n     * 3. Obtenemos el idToken de la cuenta\n     * 4. Creamos AuthCredential para Firebase\n     *\n     * MANEJO DE ERRORES:\n     * - 12501: Usuario cancel\u00f3 el proceso\n     * - 10: Error de configuraci\u00f3n (SHA-1 o Web Client ID incorrecto)\n     * - 7: Error de red\n     * - Otros: Errores desconocidos\n     *\n     * @param data Intent devuelto por ActivityResult\n     * @return AuthCredential para usar con Firebase Auth (puede ser null si falla)\n     * @throws Exception con mensaje descriptivo si hay error\n     */\n    fun getCredentialFromIntent(data: Intent?): AuthCredential? {\n        return try {\n            // Obtener cuenta de Google desde el Intent\n            val task = GoogleSignIn.getSignedInAccountFromIntent(data)\n            val account = task.getResult(ApiException::class.java)\n\n            // Extraer ID token\n            val idToken = account?.idToken\n\n            if (idToken != null) {\n                // Crear credencial de Firebase con el ID token\n                GoogleAuthProvider.getCredential(idToken, null)\n            } else {\n                println(\"\u26a0\ufe0f Google Sign-In: ID Token is null\")\n                null\n            }\n\n        } catch (e: ApiException) {\n            // Manejar errores espec\u00edficos de Google Sign-In\n            val message = when (e.statusCode) {\n                12501 -&gt; \"Sign-in cancelled by user\"\n                10 -&gt; \"Developer error: Check SHA-1 and Web Client ID in Firebase Console\"\n                7 -&gt; \"Network error. Please check your internet connection\"\n                else -&gt; \"Google Sign-In failed: ${e.statusCode}\"\n            }\n            println(\"\u274c Google Sign-In Error: $message\")\n            throw Exception(message)\n        } catch (e: Exception) {\n            println(\"\u274c Unexpected error in Google Sign-In: ${e.message}\")\n            throw e\n        }\n    }\n\n    /**\n     * \ud83d\udeaa Cierra sesi\u00f3n de Google\n     *\n     * IMPORTANTE:\n     * - Limpia la cuenta de Google en el dispositivo\n     * - Permite al usuario elegir otra cuenta en el pr\u00f3ximo login\n     * - Debe llamarse junto con Firebase signOut()\n     *\n     * CASO DE USO:\n     * - Usuario hace logout desde ProfileScreen\n     * - HomeViewModel llama a este m\u00e9todo adem\u00e1s de sessionManager.clearSession()\n     */\n    suspend fun signOut() {\n        try {\n            googleSignInClient.signOut()\n        } catch (e: Exception) {\n            println(\"\u26a0\ufe0f Error signing out from Google: ${e.message}\")\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#de-donde-viene-default_web_client_id","title":"\ud83d\udcdd \u00bfDe d\u00f3nde viene <code>default_web_client_id</code>?","text":"<p>Generaci\u00f3n Autom\u00e1tica</p> <p>El recurso <code>R.string.default_web_client_id</code> se genera autom\u00e1ticamente cuando:</p> <ol> <li>\u2705 Agregas el archivo <code>google-services.json</code> a la carpeta <code>app/</code></li> <li>\u2705 El plugin de Google Services procesa el archivo</li> <li>\u2705 Se genera un archivo <code>values.xml</code> en <code>build/generated/res/google-services/debug/values/</code></li> </ol> <p>Contenido generado autom\u00e1ticamente: </p><pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n    &lt;resources&gt;\n        &lt;string name=\"default_web_client_id\" translatable=\"false\"&gt;\n            123456789-abc123def456.apps.googleusercontent.com\n        &lt;/string&gt;\n        &lt;!-- ... otros recursos de Firebase ... --&gt;\n    &lt;/resources&gt;\n</code></pre><p></p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#verificacion-del-web-client-id","title":"\u26a0\ufe0f Verificaci\u00f3n del Web Client ID","text":"<p>Si quieres verificar que el <code>default_web_client_id</code> se gener\u00f3 correctamente:</p> <p>Opci\u00f3n 1: En Android Studio</p> <ol> <li>Ve a Build \u2192 Rebuild Project</li> <li>Navega a <code>app/build/generated/res/google-services/debug/values/values.xml</code></li> <li>Busca el recurso <code>default_web_client_id</code></li> </ol> <p>Opci\u00f3n 2: En google-services.json</p> <p>Abre <code>app/google-services.json</code> y busca:</p> <pre><code>{\n  \"client\": [\n    {\n      \"oauth_client\": [\n        {\n          \"client_id\": \"123456789-abc123.apps.googleusercontent.com\",\n          \"client_type\": 3\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>El <code>client_type: 3</code> corresponde al Web Client ID.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#errores-comunes","title":"\ud83d\udd34 Errores comunes","text":"<p>Error 1: <code>R.string.default_web_client_id</code> no se encuentra</p> <pre><code>Unresolved reference: default_web_client_id\n</code></pre> <p>Soluci\u00f3n:</p> <ol> <li>Verifica que <code>google-services.json</code> est\u00e9 en <code>app/</code></li> <li> <p>Verifica que tengas el plugin en <code>app/build.gradle.kts</code>: </p><pre><code>plugins {\n       id(\"com.google.gms.google-services\")\n   }\n</code></pre><p></p> </li> <li> <p>Sync el proyecto</p> </li> <li>Rebuild el proyecto</li> </ol> <p>Error 2: \"Developer error: Check SHA-1\" en runtime</p> <pre><code>ApiException: statusCode=10\n</code></pre> <p>Soluci\u00f3n:</p> <ol> <li>Verifica que agregaste el SHA-1 en Firebase Console</li> <li>Descarga el nuevo <code>google-services.json</code> despu\u00e9s de agregar el SHA-1</li> <li>Reemplaza el archivo y vuelve a hacer Sync</li> </ol> <p>Con esta actualizaci\u00f3n, la gu\u00eda ahora refleja correctamente que NO es necesario copiar manualmente el Web Client ID, ya que Firebase lo gestiona autom\u00e1ticamente a trav\u00e9s del <code>google-services.json</code>.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-5-extender-firebaseauthrepositoryimpl","title":"\ud83d\udd17 Paso 5: Extender FirebaseAuthRepositoryImpl","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#51-agregar-metodo-en-la-interfaz-authrepository","title":"5.1. Agregar m\u00e9todo en la interfaz AuthRepository","text":"<pre><code>interface AuthRepository {\n    suspend fun login(username: String, password: String): Resource&lt;Unit&gt;\n    suspend fun register(username: String, email: String, password: String): Resource&lt;Unit&gt;\n\n    // \ud83c\udd95 Nuevo m\u00e9todo para Google Sign-In\n    suspend fun signInWithGoogle(credential: AuthCredential): Resource&lt;Unit&gt;\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#52-implementar-en-firebaseauthrepositoryimpl","title":"5.2. Implementar en FirebaseAuthRepositoryImpl","text":"<pre><code>/**\n * \ud83d\udd10 Autentica usuario con credencial de Google\n *\n * FLUJO:\n * 1. Recibe AuthCredential de GoogleSignInManager\n * 2. Llama a Firebase signInWithCredential()\n * 3. Obtiene FirebaseUser del resultado\n * 4. Sincroniza con Room (crea/actualiza usuario local)\n * 5. Retorna Resource.Success o Resource.Error\n *\n * VENTAJAS:\n * \u2705 No requiere email/password\n * \u2705 Usuario ya verificado por Google\n * \u2705 Experiencia m\u00e1s r\u00e1pida\n * \u2705 Vinculaci\u00f3n autom\u00e1tica con cuentas existentes\n *\n * @param credential Credencial de Google obtenida del Manager\n * @return Resource.Success si la autenticaci\u00f3n fue exitosa\n */\noverride suspend fun signInWithGoogle(credential: AuthCredential): Resource&lt;Unit&gt; {\n    return try {\n        // Autenticar con Firebase usando la credencial de Google\n        val result = firebaseAuth.signInWithCredential(credential).await()\n        val firebaseUser = result.user\n            ?: return Resource.Error(AppError.Unknown(\"Firebase user is null\"))\n\n        // Obtener datos del usuario\n        val userId = firebaseUser.uid\n        val email = firebaseUser.email\n            ?: return Resource.Error(AppError.ValidationError(\"Email is required\"))\n        val displayName = firebaseUser.displayName ?: email.substringBefore(\"@\")\n\n        // Sincronizar con Room\n        val existingUser = userDao.getUserByEmail(email)\n\n        if (existingUser == null) {\n            // Usuario nuevo: crear en Room\n            val newUser = User(\n                id = userId,\n                username = displayName,\n                email = email,\n                password = \"\" // No almacenamos password para usuarios de Google\n            )\n            userDao.insert(newUser)\n        } else {\n            // Usuario existente: actualizar ID de Firebase si es diferente\n            if (existingUser.id != userId) {\n                userDao.update(existingUser.copy(id = userId))\n            }\n        }\n\n        Resource.Success(Unit)\n\n    } catch (e: FirebaseAuthException) {\n        // Errores espec\u00edficos de Firebase Auth\n        val error = when (e.errorCode) {\n            \"ERROR_ACCOUNT_EXISTS_WITH_DIFFERENT_CREDENTIAL\" -&gt; \n                AppError.ValidationError(\"Account already exists with different sign-in method\")\n            \"ERROR_INVALID_CREDENTIAL\" -&gt; \n                AppError.ValidationError(\"Invalid Google credentials\")\n            else -&gt; AppError.Unknown(e.message ?: \"Google Sign-In failed\")\n        }\n        Resource.Error(error)\n\n    } catch (e: Exception) {\n        Resource.Error(AppError.Unknown(e.message ?: \"Unknown error during Google Sign-In\"))\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-6-actualizar-datamodule-con-googlesigninmanager","title":"\ud83e\udde9 Paso 6: Actualizar DataModule con GoogleSignInManager","text":"<pre><code>val dataModule = module {\n    // ... dependencias existentes ...\n\n    // \ud83c\udd95 Google Sign-In Manager\n    single { GoogleSignInManager(androidContext()) }\n}\n</code></pre> <p>Inyecci\u00f3n Autom\u00e1tica</p> <p>Como usamos <code>viewModelOf(::LoginViewModel)</code> en Koin, el <code>GoogleSignInManager</code> se inyectar\u00e1 autom\u00e1ticamente cuando se cree el <code>LoginViewModel</code>.</p>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-7-actualizar-loginviewmodel","title":"\ud83c\udfa8 Paso 7: Actualizar LoginViewModel","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#71-inyectar-googlesigninmanager","title":"7.1. Inyectar GoogleSignInManager","text":"<pre><code>class LoginViewModel(\n    private val authRepository: AuthRepository,\n    private val sessionManager: SessionManager,\n    private val googleSignInManager: GoogleSignInManager  // \ud83c\udd95 Inyecci\u00f3n\n) : ViewModel() {\n\n    // ... c\u00f3digo existente ...\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#72-agregar-funcion-para-iniciar-google-sign-in","title":"7.2. Agregar funci\u00f3n para iniciar Google Sign-In","text":"<pre><code>/**\n     * \ud83d\ude80 Obtiene el Intent para iniciar Google Sign-In\n     *\n     * CASO DE USO:\n     * - Usuario hace click en bot\u00f3n \"Sign in with Google\"\n     * - LoginScreen llama a este m\u00e9todo\n     * - Se lanza el Intent con ActivityResultLauncher\n     *\n     * @return Intent para el selector de cuentas de Google\n     */\n    fun getGoogleSignInIntent(): Intent {\n        return googleSignInManager.getSignInIntent()\n    }\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#73-agregar-funcion-para-manejar-resultado","title":"7.3. Agregar funci\u00f3n para manejar resultado","text":"<pre><code>/**\n     * \ud83d\udd04 Maneja el resultado de Google Sign-In\n     *\n     * FLUJO:\n     * 1. ActivityResult devuelve el Intent con datos\n     * 2. GoogleSignInManager extrae la credencial\n     * 3. AuthRepository autentica con Firebase\n     * 4. SessionManager guarda la sesi\u00f3n\n     * 5. UI navega a Home\n     *\n     * MANEJO DE ERRORES:\n     * \u2705 Captura excepciones lanzadas por GoogleSignInManager\n     * \u2705 Muestra mensajes descriptivos al usuario\n     * \u2705 Siempre sale del estado isLoading\n     *\n     * @param data Intent devuelto por ActivityResult (puede ser null si se cancel\u00f3)\n     */\n    fun handleGoogleSignInResult(data: Intent?) {\n        viewModelScope.launch {\n            // Iniciar loading y limpiar error previo\n            _uiState.update { \n                it.copy(\n                    isLoading = true, \n                    errorMessage = null\n                ) \n            }\n\n            try {\n                // Obtener credencial de Google\n                val credential = googleSignInManager.getCredentialFromIntent(data)\n\n                // Autenticar con Firebase\n                val result = authRepository.signInWithGoogle(credential)\n\n                when (result) {\n                    is Resource.Success -&gt; {\n                        // Guardar sesi\u00f3n\n                        val username = sessionManager.getUsername().firstOrNull() ?: \"Usuario\"\n                        sessionManager.saveSession(username)\n\n                        // Actualizar UI (navegaci\u00f3n manejada en LoginScreen)\n                        _uiState.update { \n                            it.copy(\n                                isLoading = false,\n                                errorMessage = null\n                            ) \n                        }\n                    }\n\n                    is Resource.Error -&gt; {\n                        // Mostrar error espec\u00edfico\n                        val errorMsg = when (result.error) {\n                            is AppError.ValidationError -&gt; result.error.message\n                            is AppError.NetworkError -&gt; \"No internet connection\"\n                            else -&gt; \"Google Sign-In failed. Please try again\"\n                        }\n\n                        _uiState.update { \n                            it.copy(\n                                isLoading = false,\n                                errorMessage = errorMsg\n                            ) \n                        }\n                    }\n\n                    is Resource.Loading -&gt; {\n                        // No deber\u00eda llegar aqu\u00ed, pero por exhaustividad\n                    }\n                }\n\n            } catch (e: Exception) {\n                // Captura excepciones lanzadas por GoogleSignInManager\n                _uiState.update { \n                    it.copy(\n                        isLoading = false,\n                        errorMessage = e.message ?: \"An unexpected error occurred\"\n                    ) \n                }\n            }\n        }\n    }\n\n    /**\n     * \ud83e\uddf9 Limpia el error cuando el usuario cancela Google Sign-In\n     */\n    fun clearError() {\n        _uiState.update { it.copy(errorMessage = null) }\n    }\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-8-actualizar-loginscreen-con-bot\u00f3n-de-google","title":"\ud83d\uddbc\ufe0f Paso 8: Actualizar LoginScreen con bot\u00f3n de Google","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#81-configurar-activityresultlauncher","title":"8.1. Configurar ActivityResultLauncher","text":"<pre><code>@Composable\nfun LoginScreen(\n    viewModel: LoginViewModel = koinViewModel(),\n    onLoginSuccess: () -&gt; Unit,\n    onNavigateToRegister: () -&gt; Unit\n) {\n    val uiState by viewModel.uiState.collectAsState()\n\n    // \ud83c\udd95 Configurar ActivityResultLauncher para Google Sign-In\n    val googleSignInLauncher = rememberLauncherForActivityResult(\n        contract = ActivityResultContracts.StartActivityForResult()\n    ) { result -&gt;\n        // Verificar que el usuario no cancel\u00f3\n        if (result.resultCode == android.app.Activity.RESULT_OK) {\n            viewModel.handleGoogleSignInResult(result.data)\n        } else {\n            // Usuario cancel\u00f3 o error de sistema\n            viewModel.clearError()\n        }\n    }\n\n    // Navegaci\u00f3n autom\u00e1tica cuando login es exitoso\n    LaunchedEffect(uiState.isLoginSuccess) {\n        if (uiState.isLoginSuccess) {\n            onLoginSuccess()\n        }\n    }\n\n    // ... resto del c\u00f3digo de UI ...\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#82-agregar-boton-de-google-sign-in","title":"8.2. Agregar bot\u00f3n de Google Sign-In","text":"<p>Dentro de tu <code>Column</code> principal, despu\u00e9s de los botones de login tradicional:</p> <pre><code>// Divisor \"OR\"\n    Row(\n        modifier = Modifier\n            .fillMaxWidth()\n            .padding(vertical = MaterialTheme.dimens.medium),\n        verticalAlignment = Alignment.CenterVertically\n    ) {\n        HorizontalDivider(\n            color = MaterialTheme.colorScheme.onSurfaceVariant,\n            modifier = Modifier.weight(1f)\n        )\n        Text(\n            text = \"OR\",\n            modifier = Modifier.padding(horizontal = MaterialTheme.dimens.medium),\n            style = MaterialTheme.typography.bodySmall,\n            color = MaterialTheme.colorScheme.onSurfaceVariant\n        )\n        HorizontalDivider(\n            color = MaterialTheme.colorScheme.onSurfaceVariant,\n            modifier = Modifier.weight(1f)\n        )\n    }\n\n    // \ud83c\udd95 Bot\u00f3n de Google Sign-In\n    OutlinedButton(\n        onClick = {\n            val signInIntent = viewModel.getGoogleSignInIntent()\n            googleSignInLauncher.launch(signInIntent)\n        },\n        modifier = Modifier.fillMaxWidth(),\n        enabled = !uiState.isLoading\n    ) {\n        Icon(\n            painter = painterResource(R.drawable.ic_google),\n            contentDescription = \"Google\",\n            modifier = Modifier.size(20.dp)\n        )\n        Spacer(modifier = Modifier.width(MaterialTheme.dimens.small))\n        Text(\"Sign in with Google\")\n    }\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-9-agregar-\u00edcono-de-google","title":"\ud83c\udfa8 Paso 9: Agregar \u00edcono de Google","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#opcion-a-usar-material-icons-extended-recomendado","title":"Opci\u00f3n A: Usar Material Icons Extended (Recomendado)","text":"<p>Si ya agregaste la dependencia de Material Icons Extended en el Paso 3:</p> <pre><code>Icon(\n    imageVector = Icons.Filled.Login, // o cualquier icono alternativo\n    contentDescription = \"Google\"\n)\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#opcion-b-descargar-icono-oficial-de-google","title":"Opci\u00f3n B: Descargar \u00edcono oficial de Google","text":"<ol> <li>Descarga el \u00edcono oficial desde Google Brand Resources</li> <li>Guarda el archivo en <code>app/src/main/res/drawable/ic_google.xml</code></li> </ol>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-10-actualizar-homeviewmodel-con-logout","title":"\ud83d\udeaa Paso 10: Actualizar HomeViewModel con logout","text":"<p>Para que el logout sea completo, debemos cerrar sesi\u00f3n tanto en Firebase como en Google.</p> <pre><code>class HomeViewModel(\n    private val gameUseCases: GameUseCases,\n    private val sessionManager: SessionManager,\n    private val googleSignInManager: GoogleSignInManager  // \ud83c\udd95 Inyecci\u00f3n\n) : ViewModel() {\n\n    // ... c\u00f3digo existente ...\n\n    /**\n     * \ud83d\udeaa Cierra sesi\u00f3n del usuario\n     *\n     * FLUJO COMPLETO:\n     * 1. Limpiar sesi\u00f3n local (SessionManager)\n     * 2. Cerrar sesi\u00f3n de Google (GoogleSignInManager)\n     * 3. Navegar a LoginScreen\n     *\n     * IMPORTANTE:\n     * \u2705 Limpia tanto Firebase como Google\n     * \u2705 Permite elegir otra cuenta en el pr\u00f3ximo login\n     * \u2705 Sin esto, Google reutiliza la \u00faltima cuenta autom\u00e1ticamente\n     *\n     * @param onSuccess Callback para navegar a LoginScreen\n     */\n    fun logout(onSuccess: () -&gt; Unit) {\n        viewModelScope.launch {\n            // 1. Limpiar sesi\u00f3n local\n            sessionManager.clearSession()\n\n            // 2. Forzar logout de Google\n            googleSignInManager.signOut()\n\n            // 3. Navegar a Login\n            onSuccess()\n        }\n    }\n}\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#paso-11-testing-del-flujo-completo","title":"\u2705 Paso 11: Testing del flujo completo","text":""},{"location":"temas/proyectos/GameVault/11-Auth-google.html#111-escenarios-de-prueba","title":"11.1. Escenarios de prueba","text":"Escenario 1: Login exitoso con GoogleEscenario 2: Cancelar Google Sign-InEscenario 3: Error de configuraci\u00f3n (SHA-1 incorrecto)Escenario 4: Cuenta ya existente con email/passwordEscenario 5: Logout completo <ol> <li>Abre la app y haz clic en \"Sign in with Google\"</li> <li>Se abre el selector de cuentas de Google</li> <li>Selecciona una cuenta</li> <li>Firebase autentica correctamente</li> <li>La app navega a HomeScreen</li> <li>Verifica que el nombre del usuario aparece en la TopAppBar</li> </ol> <ol> <li>Haz clic en \"Sign in with Google\"</li> <li>Presiona el bot\u00f3n \"Atr\u00e1s\" en el selector de cuentas</li> <li>Verifica que la app NO crashea</li> <li>Permaneces en LoginScreen sin mensaje de error</li> </ol> <p>Este escenario solo ocurre si configuraste mal el SHA-1.</p> <ol> <li>Intenta hacer Google Sign-In</li> <li>Si el SHA-1 no coincide, ver\u00e1s un error</li> <li>Mensaje: \"Developer error: Check SHA-1 and Web Client ID configuration\"</li> </ol> <ol> <li>Reg\u00edstrate con email/password: <code>test@gmail.com</code> / <code>password123</code></li> <li>Haz logout</li> <li>Haz clic en \"Sign in with Google\"</li> <li>Selecciona la cuenta <code>test@gmail.com</code></li> <li>Firebase vincula autom\u00e1ticamente las cuentas</li> <li>Ahora puedes iniciar sesi\u00f3n con cualquiera de los dos m\u00e9todos</li> </ol> <ol> <li>Inicia sesi\u00f3n con Google</li> <li>Ve a ProfileScreen (o donde tengas el bot\u00f3n de logout)</li> <li>Haz clic en Logout</li> <li>La app navega a LoginScreen</li> <li>Vuelve a hacer \"Sign in with Google\"</li> <li>Verifica que se muestra el selector de cuentas (no inicia sesi\u00f3n autom\u00e1ticamente)</li> </ol>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#resumen-de-archivos","title":"\ud83d\udcc1 Resumen de archivos","text":"<pre><code>\ud83d\udcc1 Nuevos archivos creados:\n\u251c\u2500 data/auth/GoogleSignInManager.kt          \u2190 Helper para Google OAuth\n\n\ud83d\udcdd Archivos modificados:\n\u251c\u2500 gradle/libs.versions.toml                 \u2190 Versi\u00f3n de play-services-auth\n\u251c\u2500 app/build.gradle.kts                      \u2190 Dependencia de Google Sign-In\n\u251c\u2500 data/repository/AuthRepository.kt         \u2190 M\u00e9todo signInWithGoogle()\n\u251c\u2500 data/repository/FirebaseAuthRepositoryImpl.kt \u2190 Implementaci\u00f3n de Google Sign-In\n\u251c\u2500 di/DataModule.kt                          \u2190 Inyecci\u00f3n de GoogleSignInManager\n\u251c\u2500 presentation/viewmodel/LoginViewModel.kt  \u2190 Funciones de Google Sign-In\n\u251c\u2500 presentation/viewmodel/HomeViewModel.kt   \u2190 Logout completo\n\u251c\u2500 presentation/ui/screens/LoginScreen.kt    \u2190 Bot\u00f3n de Google y ActivityResult\n\u251c\u2500 app/google-services.json                  \u2190 Nuevo archivo con credenciales OAuth\n\n\ud83c\udfa8 Recursos opcionales:\n\u2514\u2500 res/drawable/ic_google.xml                \u2190 \u00cdcono oficial de Google\n</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#diagrama-del-flujo-completo","title":"\ud83d\udd04 Diagrama del flujo completo","text":"<pre><code>sequenceDiagram\n    participant U as Usuario\n    participant LS as LoginScreen\n    participant VM as LoginViewModel\n    participant GSM as GoogleSignInManager\n    participant GP as Google Play Services\n    participant FB as Firebase Auth\n    participant Repo as AuthRepository\n\n    U-&gt;&gt;LS: Click \"Sign in with Google\"\n    LS-&gt;&gt;VM: getGoogleSignInIntent()\n    VM-&gt;&gt;GSM: getSignInIntent()\n    GSM--&gt;&gt;VM: Intent\n    VM--&gt;&gt;LS: Intent\n    LS-&gt;&gt;GP: launch(intent)\n    GP-&gt;&gt;U: Muestra selector de cuentas\n    U-&gt;&gt;GP: Selecciona cuenta\n    GP--&gt;&gt;LS: ActivityResult (con idToken)\n    LS-&gt;&gt;VM: handleGoogleSignInResult(data)\n    VM-&gt;&gt;GSM: getCredentialFromIntent(data)\n    GSM--&gt;&gt;VM: AuthCredential\n    VM-&gt;&gt;Repo: signInWithGoogle(credential)\n    Repo-&gt;&gt;FB: signInWithCredential()\n    FB--&gt;&gt;Repo: FirebaseUser\n    Repo--&gt;&gt;VM: Resource.Success\n    VM-&gt;&gt;VM: Guarda sesi\u00f3n\n    VM--&gt;&gt;LS: Navega a Home</code></pre>"},{"location":"temas/proyectos/GameVault/11-Auth-google.html#conclusion","title":"\ud83c\udf89 Conclusi\u00f3n","text":"<p>\u00a1Enhorabuena! Has implementado un sistema de autenticaci\u00f3n completo y profesional que incluye:</p> <ul> <li>\u2705 Registro y Login con email/password</li> <li>\u2705 Google Sign-In con OAuth 2.0</li> <li>\u2705 Gesti\u00f3n robusta de errores con mensajes descriptivos</li> <li>\u2705 Sincronizaci\u00f3n entre Firebase y Room</li> <li>\u2705 Logout completo que limpia todas las sesiones</li> <li>\u2705 UX optimizada con feedback visual en cada paso</li> </ul>"}]}